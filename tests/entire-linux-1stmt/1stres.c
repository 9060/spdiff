void print_delayacct(struct taskstats *t)
{
	printf("\n\nCPU   %15s%15s%15s%15s\n"
	       "      %15llu%15llu%15llu%15llu\n"
	       "IO    %15s%15s\n"
	       "      %15llu%15llu\n"
	       "SWAP  %15s%15s\n"
	       "      %15llu%15llu\n"
	       "RECLAIM  %12s%15s\n"
	       "      %15llu%15llu\n",
	       "count", "real total", "virtual total", "delay total",
	       (unsigned long long)t->cpu_count,
	       (unsigned long long)t->cpu_run_real_total,
	       (unsigned long long)t->cpu_run_virtual_total,
	       (unsigned long long)t->cpu_delay_total,
	       "count", "delay total",
	       (unsigned long long)t->blkio_count,
	       (unsigned long long)t->blkio_delay_total,
	       "count", "delay total",
	       (unsigned long long)t->swapin_count,
	       (unsigned long long)t->swapin_delay_total,
	       "count", "delay total",
	       (unsigned long long)t->freepages_count,
	       (unsigned long long)t->freepages_delay_total);
}
void task_context_switch_counts(struct taskstats *t)
{
	printf("\n\nTask   %15s%15s\n"
	       "       %15llu%15llu\n",
	       "voluntary", "nonvoluntary",
	       (unsigned long long)t->nvcsw, (unsigned long long)t->nivcsw);
}
void print_cgroupstats(struct cgroupstats *c)
{
	printf("sleeping %llu, blocked %llu, running %llu, stopped %llu, "
		"uninterruptible %llu\n", (unsigned long long)c->nr_sleeping,
		(unsigned long long)c->nr_io_wait,
		(unsigned long long)c->nr_running,
		(unsigned long long)c->nr_stopped,
		(unsigned long long)c->nr_uninterruptible);
}
void print_ioacct(struct taskstats *t)
{
	printf("%s: read=%llu, write=%llu, cancelled_write=%llu\n",
		t->ac_comm,
		(unsigned long long)t->read_bytes,
		(unsigned long long)t->write_bytes,
		(unsigned long long)t->cancelled_write_bytes);
}
void cfag12864b_blit(void)
{
	memcpy(cfag12864b_mem, cfag12864b_buffer, CFAG12864B_SIZE);
}
static inline struct childless *to_childless(struct config_item *item)
{
	return item ? container_of(to_configfs_subsystem(to_config_group(item)), struct childless, subsys) : NULL;
}
static ssize_t childless_storeme_read(struct childless *childless,
				      char *page)
{
	return sprintf(page, "%d\n", childless->storeme);
}
static ssize_t childless_description_read(struct childless *childless,
					  char *page)
{
	return sprintf(page,
"[01-childless]\n"
"\n"
"The childless subsystem is the simplest possible subsystem in\n"
"configfs.  It does not support the creation of child config_items.\n"
"It only has a few attributes.  In fact, it isn't much different\n"
"than a directory in /proc.\n");
}
static inline struct simple_child *to_simple_child(struct config_item *item)
{
	return item ? container_of(item, struct simple_child, item) : NULL;
}
static void simple_child_release(struct config_item *item)
{
	kfree(to_simple_child(item));
}
static inline struct simple_children *to_simple_children(struct config_item *item)
{
	return item ? container_of(to_config_group(item), struct simple_children, group) : NULL;
}
static ssize_t simple_children_attr_show(struct config_item *item,
					 struct configfs_attribute *attr,
					 char *page)
{
	return sprintf(page,
"[02-simple-children]\n"
"\n"
"This subsystem allows the creation of child config_items.  These\n"
"items have only one attribute that is readable and writeable.\n");
}
static void simple_children_release(struct config_item *item)
{
	kfree(to_simple_children(item));
}
static ssize_t group_children_attr_show(struct config_item *item,
					struct configfs_attribute *attr,
					char *page)
{
	return sprintf(page,
"[03-group-children]\n"
"\n"
"This subsystem allows the creation of child config_groups.  These\n"
"groups are like the subsystem simple-children.\n");
}
static inline struct childless *to_childless(struct config_item *item)
{
	return item ? container_of(to_configfs_subsystem(to_config_group(item)), struct childless, subsys) : NULL;
}
static ssize_t childless_storeme_read(struct childless *childless,
				      char *page)
{
	return sprintf(page, "%d\n", childless->storeme);
}
static ssize_t childless_description_read(struct childless *childless,
					  char *page)
{
	return sprintf(page,
"[01-childless]\n"
"\n"
"The childless subsystem is the simplest possible subsystem in\n"
"configfs.  It does not support the creation of child config_items.\n"
"It only has a few attributes.  In fact, it isn't much different\n"
"than a directory in /proc.\n");
}
static inline struct simple_child *to_simple_child(struct config_item *item)
{
	return item ? container_of(item, struct simple_child, item) : NULL;
}
static void simple_child_release(struct config_item *item)
{
	kfree(to_simple_child(item));
}
static inline struct simple_children *to_simple_children(struct config_item *item)
{
	return item ? container_of(to_config_group(item), struct simple_children, group) : NULL;
}
static ssize_t simple_children_attr_show(struct config_item *item,
					 struct configfs_attribute *attr,
					 char *page)
{
	return sprintf(page,
"[02-simple-children]\n"
"\n"
"This subsystem allows the creation of child config_items.  These\n"
"items have only one attribute that is readable and writeable.\n");
}
static void simple_children_release(struct config_item *item)
{
	kfree(to_simple_children(item));
}
static ssize_t group_children_attr_show(struct config_item *item,
					struct configfs_attribute *attr,
					char *page)
{
	return sprintf(page,
"[03-group-children]\n"
"\n"
"This subsystem allows the creation of child config_groups.  These\n"
"groups are like the subsystem simple-children.\n");
}
static int set_if_up(char *ifname, short flags)
{
	return set_if_flags(ifname, flags | IFF_UP);
}
static int set_if_down(char *ifname, short flags)
{
	return set_if_flags(ifname, flags & ~IFF_UP);
}
static inline void
load(unsigned long dst, unsigned long src, unsigned long count)
{
	memcpy((void *)dst, (void *)src, count);
}
static inline void
runkernel(void)
{
	__asm__ __volatile__(
		"bis %0,%0,$27\n\t"
		"jmp ($27)"
		: /* no outputs: it doesn't even return */
		: "r" (START_ADDR));
}
static inline void
runkernel(void)
{
	__asm__ __volatile__(
		"bis %0,%0,$27\n\t"
		"jmp ($27)"
		: /* no outputs: it doesn't even return */
		: "r" (START_ADDR));
}
void *__kmalloc(size_t size, gfp_t flags)
{
	return (void *)NULL;
}
static inline long close(long dev)
{
	return callback_close(dev);
}
static void runkernel(void)
{
	__asm__ __volatile__(
		"bis %1,%1,$30\n\t"
		"bis %0,%0,$26\n\t"
		"ret ($26)"
		: /* no outputs: it doesn't even return */
		: "r" (START_ADDR),
		  "r" (PAGE_SIZE + INIT_STACK));
}
static int __init init_loader_binfmt(void)
{
	return register_binfmt(&loader_format);
}
void __init
cia_init_arch(void)
{
	do_init_arch(0);
}
inline struct io7 *
marvel_next_io7(struct io7 *prev)
{
	return (prev ? prev->next : io7_head);
}
static inline unsigned long
build_conf_addr(struct pci_controller *hose, u8 bus, 
		unsigned int devfn, int where)
{
	return (hose->config_space_base | (bus << 16) | (devfn << 8) | where);
}
int
marvel_cpuid_to_nid(int cpuid)
{
	return cpuid;
}
unsigned long
marvel_node_mem_size(int nid)
{
	return 16UL * 1024 * 1024 * 1024; /* 16GB */
}
static inline volatile unsigned long *
mk_tig_addr(int offset)
{
	return (volatile unsigned long *)(TITAN_TIG_SPACE + (offset << 6));
}
void
titan_kill_arch(int mode)
{
	titan_kill_pachips(TITAN_pachip0, TITAN_pachip1);
}
int wildfire_pa_to_nid(unsigned long pa)
{
	return pa >> 36;
}
int wildfire_cpuid_to_nid(int cpuid)
{
	return cpuid >> 2;
}
unsigned long wildfire_node_mem_start(int nid)
{
	return (unsigned long)nid * (64UL * 1024 * 1024 * 1024);
}
unsigned long wildfire_node_mem_size(int nid)
{
	return 64UL * 1024 * 1024 * 1024;
}
u8 inb(unsigned long port)
{
	return ioread8(ioport_map(port, 1));
}
u16 inw(unsigned long port)
{
	return ioread16(ioport_map(port, 2));
}
u32 inl(unsigned long port)
{
	return ioread32(ioport_map(port, 4));
}
void outb(u8 b, unsigned long port)
{
	iowrite8(b, ioport_map(port, 1));
}
void outw(u16 b, unsigned long port)
{
	iowrite16(b, ioport_map(port, 2));
}
void outl(u32 b, unsigned long port)
{
	iowrite32(b, ioport_map(port, 4));
}
u8 __raw_readb(const volatile void __iomem *addr)
{
	return IO_CONCAT(__IO_PREFIX,readb)(addr);
}
u16 __raw_readw(const volatile void __iomem *addr)
{
	return IO_CONCAT(__IO_PREFIX,readw)(addr);
}
u32 __raw_readl(const volatile void __iomem *addr)
{
	return IO_CONCAT(__IO_PREFIX,readl)(addr);
}
u64 __raw_readq(const volatile void __iomem *addr)
{
	return IO_CONCAT(__IO_PREFIX,readq)(addr);
}
void __raw_writeb(u8 b, volatile void __iomem *addr)
{
	IO_CONCAT(__IO_PREFIX,writeb)(b, addr);
}
void __raw_writew(u16 b, volatile void __iomem *addr)
{
	IO_CONCAT(__IO_PREFIX,writew)(b, addr);
}
void __raw_writel(u32 b, volatile void __iomem *addr)
{
	IO_CONCAT(__IO_PREFIX,writel)(b, addr);
}
void __raw_writeq(u64 b, volatile void __iomem *addr)
{
	IO_CONCAT(__IO_PREFIX,writeq)(b, addr);
}
void insb(unsigned long port, void *dst, unsigned long count)
{
	ioread8_rep(ioport_map(port, 1), dst, count);
}
void insw(unsigned long port, void *dst, unsigned long count)
{
	ioread16_rep(ioport_map(port, 2), dst, count);
}
void insl(unsigned long port, void *dst, unsigned long count)
{
	ioread32_rep(ioport_map(port, 4), dst, count);
}
void outsb(unsigned long port, const void *src, unsigned long count)
{
	iowrite8_rep(ioport_map(port, 1), src, count);
}
void outsw(unsigned long port, const void *src, unsigned long count)
{
	iowrite16_rep(ioport_map(port, 2), src, count);
}
void outsl(unsigned long port, const void *src, unsigned long count)
{
	iowrite32_rep(ioport_map(port, 4), src, count);
}
void __iomem *ioport_map(unsigned long port, unsigned int size)
{
	return IO_CONCAT(__IO_PREFIX,ioportmap) (port);
}
static unsigned int rtc_startup(unsigned int irq) { return 0; }
static inline void
__i8259a_disable_irq(unsigned int irq)
{
	i8259_update_irq_hw(irq, cached_irq_mask |= 1 << irq);
}
static inline void
pyxis_enable_irq(unsigned int irq)
{
	pyxis_update_irq_hw(cached_irq_mask |= 1UL << (irq - 16));
}
static void
pyxis_disable_irq(unsigned int irq)
{
	pyxis_update_irq_hw(cached_irq_mask &= ~(1UL << (irq - 16)));
}
void
module_free(struct module *mod, void *module_region)
{
	vfree(module_region);
}
int
module_finalize(const Elf_Ehdr *hdr, const Elf_Shdr *sechdrs,
		struct module *me)
{
	return 0;
}
static inline long
get_tv32(struct timeval *o, struct timeval32 __user *i)
{
	return (!access_ok(VERIFY_READ, i, sizeof(*i)) ||
		(__get_user(o->tv_sec, &i->tv_sec) |
		 __get_user(o->tv_usec, &i->tv_usec)));
}
static inline long
put_tv32(struct timeval32 __user *o, struct timeval *i)
{
	return (!access_ok(VERIFY_WRITE, o, sizeof(*o)) ||
		(__put_user(i->tv_sec, &o->tv_sec) |
		 __put_user(i->tv_usec, &o->tv_usec)));
}
static inline long
get_it32(struct itimerval *o, struct itimerval32 __user *i)
{
	return (!access_ok(VERIFY_READ, i, sizeof(*i)) ||
		(__get_user(o->it_interval.tv_sec, &i->it_interval.tv_sec) |
		 __get_user(o->it_interval.tv_usec, &i->it_interval.tv_usec) |
		 __get_user(o->it_value.tv_sec, &i->it_value.tv_sec) |
		 __get_user(o->it_value.tv_usec, &i->it_value.tv_usec)));
}
static inline long
put_it32(struct itimerval32 __user *o, struct itimerval *i)
{
	return (!access_ok(VERIFY_WRITE, o, sizeof(*o)) ||
		(__put_user(i->it_interval.tv_sec, &o->it_interval.tv_sec) |
		 __put_user(i->it_interval.tv_usec, &o->it_interval.tv_usec) |
		 __put_user(i->it_value.tv_sec, &o->it_value.tv_sec) |
		 __put_user(i->it_value.tv_usec, &o->it_value.tv_usec)));
}
asmlinkage long
sys_pciconfig_read(unsigned long bus, unsigned long dfn,
		   unsigned long off, unsigned long len, void *buf)
{
	if (!capable(CAP_SYS_ADMIN))
		return -EPERM;
	else
		return -ENODEV;
}

asmlinkage long
sys_pciconfig_write(unsigned long bus, unsigned long dfn,
		    unsigned long off, unsigned long len, void *buf)
{
	if (!capable(CAP_SYS_ADMIN))
		return -EPERM;
	else
		return -ENODEV;
}
void *
__pci_alloc_consistent(struct pci_dev *pdev, size_t size,
		       dma_addr_t *dma_addrp, gfp_t gfp)
{
	return NULL;
}
int
pci_map_sg(struct pci_dev *pdev, struct scatterlist *sg, int nents,
	   int direction)
{
	return 0;
}
int
pci_dma_supported(struct pci_dev *hwdev, dma_addr_t mask)
{
	return 0;
}
void __iomem *pci_iomap(struct pci_dev *dev, int bar, unsigned long maxlen)
{
	return NULL;
}
static void __init
quirk_isa_bridge(struct pci_dev *dev)
{
	dev->class = PCI_CLASS_BRIDGE_ISA << 8;
}
char * __devinit
pcibios_setup(char *str)
{
	return str;
}
void __init
pcibios_update_irq(struct pci_dev *dev, int irq)
{
	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq);
}
int
pcibios_enable_device(struct pci_dev *dev, int mask)
{
	return pci_enable_resources(dev, mask);
}
static inline unsigned long
mk_iommu_pte(unsigned long paddr)
{
	return (paddr >> (PAGE_SHIFT-1)) | 1;
}
struct pci_iommu_arena * __init
iommu_arena_new(struct pci_controller *hose, dma_addr_t base,
		unsigned long window_size, unsigned long align)
{
	return iommu_arena_new_node(0, hose, base, window_size, align);
}
void
pci_unmap_page(struct pci_dev *pdev, dma_addr_t dma_addr,
	       size_t size, int direction)
{
	pci_unmap_single(pdev, dma_addr, size, direction);
}
void
machine_restart(char *restart_cmd)
{
	common_shutdown(LINUX_REBOOT_CMD_RESTART, restart_cmd);
}
void
machine_halt(void)
{
	common_shutdown(LINUX_REBOOT_CMD_HALT, NULL);
}
void
machine_power_off(void)
{
	common_shutdown(LINUX_REBOOT_CMD_POWER_OFF, NULL);
}
void
show_regs(struct pt_regs *regs)
{
	dik_show_regs(regs, NULL);
}
int
alpha_vfork(struct pt_regs *regs)
{
	return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, rdusp(),
		       regs, 0, NULL, NULL);
}
void ptrace_disable(struct task_struct *child)
{ 
	ptrace_cancel_bpt(child);
}
static void *
c_start(struct seq_file *f, loff_t *pos)
{
	return *pos ? NULL : (char *)hwrpb + hwrpb->processor_offset;
}
static void *
c_next(struct seq_file *f, void *v, loff_t *pos)
{
	return NULL;
}
asmlinkage int
sys_sigaltstack(const stack_t __user *uss, stack_t __user *uoss)
{
	return do_sigaltstack(uss, uoss, rdusp());
}
static void __init SMCRunState(unsigned long baseAddr)
{
	outb(CONFIG_OFF_KEY, baseAddr);
}
int
setup_profiling_timer(unsigned int multiplier)
{
	return -EINVAL;
}
void arch_send_call_function_ipi(cpumask_t mask)
{
	send_ipi_message(mask, IPI_CALL_FUNC);
}
void arch_send_call_function_single_ipi(int cpu)
{
	send_ipi_message(cpumask_of_cpu(cpu), IPI_CALL_FUNC_SINGLE);
}
static void
ipi_imb(void *ignored)
{
	imb();
}
static void
ipi_flush_tlb_all(void *ignored)
{
	tbia();
}
void
flush_tlb_range(struct vm_area_struct *vma, unsigned long start, unsigned long end)
{
	flush_tlb_mm(vma->vm_mm);
}
static int
srmcons_write_room(struct tty_struct *tty)
{
	return 512;
}
static int
srmcons_chars_in_buffer(struct tty_struct *tty)
{
	return 0;
}
static int
srm_console_setup(struct console *co, char *options)
{
	return 0;
}
static inline void
alcor_enable_irq(unsigned int irq)
{
	alcor_update_irq_hw(cached_irq_mask |= 1UL << (irq - 16));
}
static void
alcor_disable_irq(unsigned int irq)
{
	alcor_update_irq_hw(cached_irq_mask &= ~(1UL << (irq - 16)));
}
static inline void
cabriolet_enable_irq(unsigned int irq)
{
	cabriolet_update_irq_hw(irq, cached_irq_mask &= ~(1UL << irq));
}
static void
cabriolet_disable_irq(unsigned int irq)
{
	cabriolet_update_irq_hw(irq, cached_irq_mask |= 1UL << irq);
}
static void __init
cabriolet_init_irq(void)
{
	common_init_irq(srm_device_interrupt);
}
static void __init
pc164_init_irq(void)
{
	common_init_irq(pc164_srm_device_interrupt);
}
static void
dp264_device_interrupt(unsigned long vector)
{
	printk("dp264_device_interrupt: NOT IMPLEMENTED YET!! \n");
}
static inline void
eb64p_update_irq_hw(unsigned int irq, unsigned long mask)
{
	outb(mask >> (irq >= 24 ? 24 : 16), (irq >= 24 ? 0x27 : 0x26));
}
static inline void
eb64p_enable_irq(unsigned int irq)
{
	eb64p_update_irq_hw(irq, cached_irq_mask &= ~(1 << irq));
}
static void
eb64p_disable_irq(unsigned int irq)
{
	eb64p_update_irq_hw(irq, cached_irq_mask |= 1 << irq);
}
static void
jensen_machine_check (u64 vector, u64 la)
{
	printk(KERN_CRIT "Machine check\n");
}
static void
marvel_irq_noop(unsigned int irq) 
{ 
	return; 
}
static unsigned int
marvel_irq_noop_return(unsigned int irq) 
{ 
	return 0; 
}
static void __init
marvel_init_rtc(void)
{
	init_rtc_irq();
}
static inline void
mikasa_update_irq_hw(int mask)
{
	outw(mask, 0x536);
}
static inline void
mikasa_enable_irq(unsigned int irq)
{
	mikasa_update_irq_hw(cached_irq_mask |= 1 << (irq - 16));
}
static void
mikasa_disable_irq(unsigned int irq)
{
	mikasa_update_irq_hw(cached_irq_mask &= ~(1 << (irq - 16)));
}
static void
noritake_enable_irq(unsigned int irq)
{
	noritake_update_irq_hw(irq, cached_irq_mask |= 1 << (irq - 16));
}
static void
noritake_disable_irq(unsigned int irq)
{
	noritake_update_irq_hw(irq, cached_irq_mask &= ~(1 << (irq - 16)));
}
static void
ruffian_kill_arch (int mode)
{
	cia_kill_arch(mode);
}
static inline void
rx164_enable_irq(unsigned int irq)
{
	rx164_update_irq_hw(cached_irq_mask |= 1UL << (irq - 16));
}
static void
rx164_disable_irq(unsigned int irq)
{
	rx164_update_irq_hw(cached_irq_mask &= ~(1UL << (irq - 16)));
}
static void __init
sable_lynx_init_pci(void)
{
	common_init_pci();
}
void
sio_kill_arch(int mode)
{
 	pci_bus_write_config_dword(pci_isa_hose->bus, PCI_DEVFN(7, 0), 0x60,
				   saved_config.orig_route_tab);
}
static void
titan_device_interrupt(unsigned long vector)
{
	printk("titan_device_interrupt: NOT IMPLEMENTED YET!! \n");
}
static irqreturn_t
titan_intr_nop(int irq, void *dev_id)
{
       return IRQ_HANDLED;
}
unsigned int common_get_rtc_time(struct rtc_time *time)
{
	return __get_rtc_time(time);
}
int common_set_rtc_time(struct rtc_time *time)
{
	return __set_rtc_time(time);
}
void dump_stack(void)
{
	show_stack(NULL, NULL);
}
static long dummy_emul(void) { return 0; }
static inline unsigned long
s_reg_to_mem (unsigned long s_reg)
{
	return ((s_reg >> 62) << 30) | ((s_reg << 5) >> 34);
}
__sum16 csum_tcpudp_magic(__be32 saddr, __be32 daddr,
				   unsigned short len,
				   unsigned short proto,
				   __wsum sum)
{
	return (__force __sum16)~from64to16(
		(__force u64)saddr + (__force u64)daddr +
		(__force u64)sum + ((len + proto) << 8));
}
__sum16 ip_fast_csum(const void *iph, unsigned int ihl)
{
	return (__force __sum16)~do_csum(iph,ihl*4);
}
__sum16 ip_compute_csum(const void *buff, int len)
{
	return (__force __sum16)~from64to16(do_csum(buff,len));
}
static void
op_axp_shutdown(void)
{
	perf_irq = save_perf_irq;
}
static void
op_axp_cpu_start(void *dummy)
{
	wrperfmon(1, reg.enable);
}
static inline void
op_axp_cpu_stop(void *dummy)
{
	wrperfmon(0, -1);
}
static void
ev5_reg_setup(struct op_register_config *reg,
	      struct op_counter_config *ctr,
	      struct op_system_config *sys)
{
	common_reg_setup(reg, ctr, sys, 19, 22);
}
static void
pca56_reg_setup(struct op_register_config *reg,
	        struct op_counter_config *ctr,
	        struct op_system_config *sys)
{
	common_reg_setup(reg, ctr, sys, 8, 11);
}
static void
ev5_handle_interrupt(unsigned long which, struct pt_regs *regs,
		     struct op_counter_config *ctr)
{
	oprofile_add_sample(regs, which);
}
static void
ev6_reset_ctr(struct op_register_config *reg, unsigned long ctr)
{
	wrperfmon(6, reg->reset_values | (1 << ctr));
}
static void
ev6_handle_interrupt(unsigned long which, struct pt_regs *regs,
		     struct op_counter_config *ctr)
{
	oprofile_add_sample(regs, which);
}
static void
ev67_reset_ctr(struct op_register_config *reg, unsigned long ctr)
{
	wrperfmon(6, reg->reset_values | (1 << ctr));
}
void clk_put(struct clk *clk)
{
	__clk_put(clk);
}
unsigned long icst307_khz(const struct icst307_params *p, struct icst307_vco vco)
{
	return p->ref * 2 * (vco.v + 8) / ((vco.r + 2) * s2div[vco.s]);
}
unsigned long icst525_khz(const struct icst525_params *p, struct icst525_vco vco)
{
	return p->ref * 2 * (vco.v + 8) / ((vco.r + 2) * s2div[vco.s]);
}
struct pci_bus * __init it8152_pci_scan_bus(int nr, struct pci_sys_data *sys)
{
	return pci_scan_bus(nr, &it8152_ops, sys);
}
static inline struct locomo *locomo_chip_driver(struct locomo_dev *ldev)
{
	return (struct locomo *)dev_get_drvdata(ldev->dev.parent);
}
void locomo_driver_unregister(struct locomo_driver *driver)
{
	driver_unregister(&driver->drv);
}
int dma_needs_bounce(struct device *dev, dma_addr_t addr, size_t size)
{
	return ((machine_is_assabet() || machine_is_pfs168()) &&
		(addr >= 0xc8000000 || (addr + size) >= 0xc8000000));
}
static inline struct sa1111 *sa1111_chip_driver(struct sa1111_dev *sadev)
{
	return (struct sa1111 *)dev_get_drvdata(sadev->dev.parent);
}
void sa1111_driver_unregister(struct sa1111_driver *driver)
{
	driver_unregister(&driver->drv);
}
static int __init scoop_init(void)
{
	return platform_driver_register(&scoop_driver);
}
void sharpsl_battery_kick(void)
{
	schedule_delayed_work(&sharpsl_bat, msecs_to_jiffies(125));
}
static void sharpsl_average_clear(void)
{
	sharpsl_ad_index = 0;
}
static ssize_t battery_percentage_show(struct device *dev, struct device_attribute *attr, char *buf)
{
	return sprintf(buf, "%d\n",sharpsl_pm.battstat.mainbat_percent);
}
static ssize_t battery_voltage_show(struct device *dev, struct device_attribute *attr, char *buf)
{
	return sprintf(buf, "%d\n",sharpsl_pm.battstat.mainbat_voltage);
}
static int __devinit sharpsl_pm_init(void)
{
	return platform_driver_register(&sharpsl_pm_driver);
}
static void sharpsl_pm_exit(void)
{
 	platform_driver_unregister(&sharpsl_pm_driver);
}
static void *ixp2000_uengine_csr_area(int uengine)
{
	return ((void *)IXP_UENGINE_CSR_VIRT_BASE) + (uengine << 10);
}
static int make_even_parity(u32 x)
{
	return hweight32(x) & 1;
}
int __init via82c505_setup(int nr, struct pci_sys_data *sys)
{
	return (nr == 0);
}
static int __init arthur_init(void)
{
	return register_exec_domain(&arthur_exec_domain);
}
static void __exit arthur_exit(void)
{
	unregister_exec_domain(&arthur_exec_domain);
}
void __init save_atags(const struct tag *tags)
{
	memcpy(atags_copy, tags, sizeof(atags_copy));
}
static void __devinit pci_fixup_dec21142(struct pci_dev *dev)
{
	pci_write_config_dword(dev, 0x40, 0x80000000);
}
static inline int pdev_bad_for_parity(struct pci_dev *dev)
{
	return ((dev->vendor == PCI_VENDOR_ID_INTERG &&
		 (dev->device == PCI_DEVICE_ID_INTERG_2000 ||
		  dev->device == PCI_DEVICE_ID_INTERG_2010)) ||
		(dev->vendor == PCI_VENDOR_ID_ITE &&
		 dev->device == PCI_DEVICE_ID_ITE_8152));
}
static int crunch_enabled(u32 devcfg)
{
	return !!(devcfg & EP93XX_SYSCON_DEVICE_CONFIG_CRUNCH_ENABLE);
}
static void isa_disable_dma(dmach_t channel, dma_t *dma)
{
	outb(channel | 4, isa_dma_port[channel][ISA_DMA_MASK]);
}
int dma_channel_active(dmach_t channel)
{
	return dma_chan[channel].active;
}
void set_dma_page(dmach_t channel, char pagenr)
{
	printk(KERN_ERR "dma%d: trying to set_dma_page\n", channel);
}
static inline unsigned short ecard_getu16(unsigned char *v)
{
	return v[0] | v[1] << 8;
}
static inline signed long ecard_gets24(unsigned char *v)
{
	return v[0] | v[1] << 8 | v[2] << 16 | ((v[2] & 0x80) ? 0xff000000 : 0);
}
static inline ecard_t *slot_to_ecard(unsigned int slot)
{
	return slot < MAX_ECARDS ? slot_to_expcard[slot] : NULL;
}
static int ecard_def_irq_pending(ecard_t *ec)
{
	return !ec->irqmask || readb(ec->irqaddr) & ec->irqmask;
}
static void ecard_def_fiq_enable(ecard_t *ec, int fiqnr)
{
	panic("ecard_def_fiq_enable called - impossible");
}
static void ecard_def_fiq_disable(ecard_t *ec, int fiqnr)
{
	panic("ecard_def_fiq_disable called - impossible");
}
static int ecard_def_fiq_pending(ecard_t *ec)
{
	return !ec->fiqmask || readb(ec->fiqaddr) & ec->fiqmask;
}
static int ecard_devices_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, ecard_devices_proc_show, NULL);
}
void ecard_remove_driver(struct ecard_driver *drv)
{
	driver_unregister(&drv->drv);
}
static int ecard_bus_init(void)
{
	return bus_register(&ecard_bus_type);
}
void enable_fiq(int fiq)
{
	enable_irq(fiq + FIQ_START);
}
void disable_fiq(int fiq)
{
	disable_irq(fiq + FIQ_START);
}
void __init init_FIQ(void)
{
	no_fiq_insn = *(unsigned long *)0xffff001c;
}
unsigned char *ftrace_nop_replace(void)
{
	return (char *)&NOP;
}
static void __kprobes simulate_mov_ipsp(struct kprobe *p, struct pt_regs *regs)
{
	regs->uregs[12] = regs->uregs[13];
}
static enum kprobe_insn __kprobes
space_cccc_01xx(kprobe_opcode_t insn, struct arch_specific_insn *asi)
{
	return prep_emulate_ldr_str(insn, asi);
}
void __init arm_kprobe_decode_init(void)
{
	find_str_pc_offset();
}
static void __kprobes set_current_kprobe(struct kprobe *p)
{
	__get_cpu_var(current_kprobe) = p;
}
int __kprobes kprobe_exceptions_notify(struct notifier_block *self,
				       unsigned long val, void *data)
{
	return NOTIFY_DONE;
}
int __kprobes arch_trampoline_kprobe(struct kprobe *p)
{
	return 0;
}
int machine_kexec_prepare(struct kimage *image)
{
	return 0;
}
void *module_alloc(unsigned long size)
{
	return size == 0 ? NULL : vmalloc(size);
}
void module_free(struct module *module, void *region)
{
	vfree(region);
}
int module_frob_arch_sections(Elf_Ehdr *hdr,
			      Elf_Shdr *sechdrs,
			      char *secstrings,
			      struct module *mod)
{
	return 0;
}
int
module_finalize(const Elf32_Ehdr *hdr, const Elf_Shdr *sechdrs,
		struct module *module)
{
	return 0;
}
void disable_hlt(void)
{
	hlt_counter++;
}
void enable_hlt(void)
{
	hlt_counter--;
}
void machine_restart(char * __unused)
{
	arm_pm_restart(reboot_mode);
}
static inline long get_user_reg(struct task_struct *task, int offset)
{
	return task_pt_regs(task)->uregs[offset];
}
void ptrace_disable(struct task_struct *child)
{
	single_step_disable(child);
}
static int ptrace_getfpregs(struct task_struct *tsk, void __user *ufp)
{
	return copy_to_user(ufp, &task_thread_info(tsk)->fpstate,
			    sizeof(struct user_fp)) ? -EFAULT : 0;
}
static int __init parse_tag_mem32(const struct tag *tag)
{
	return arm_add_memory(tag->u.mem.start, tag->u.mem.size);
}
static void *c_start(struct seq_file *m, loff_t *pos)
{
	return *pos < 1 ? (void *)1 : NULL;
}
void arch_send_call_function_ipi(cpumask_t mask)
{
	send_ipi_message(mask, IPI_CALL_FUNC);
}
void arch_send_call_function_single_ipi(int cpu)
{
	send_ipi_message(cpumask_of_cpu(cpu), IPI_CALL_FUNC_SINGLE);
}
void smp_send_reschedule(int cpu)
{
	send_ipi_message(cpumask_of_cpu(cpu), IPI_RESCHEDULE);
}
void smp_timer_broadcast(cpumask_t mask)
{
	send_ipi_message(mask, IPI_TIMER);
}
int setup_profiling_timer(unsigned int multiplier)
{
	return -EINVAL;
}
static inline void ipi_flush_tlb_all(void *ignored)
{
	local_flush_tlb_all();
}
void flush_tlb_all(void)
{
	on_each_cpu(ipi_flush_tlb_all, NULL, 1);
}
void save_stack_trace(struct stack_trace *trace)
{
	save_stack_trace_tsk(current, trace);
}
asmlinkage int sys_fork(struct pt_regs *regs)
{
	return do_fork(SIGCHLD, regs->ARM_sp, regs, 0, NULL, NULL);
}
asmlinkage int sys_vfork(struct pt_regs *regs)
{
	return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, regs->ARM_sp, regs, 0, NULL, NULL);
}
asmlinkage long sys_arm_fadvise64_64(int fd, int advice,
				     loff_t offset, loff_t len)
{
	return sys_fadvise64_64(fd, offset, len, advice);
}
asmlinkage long sys_oabi_semop(int semid, struct oabi_sembuf __user *tsops,
			       unsigned nsops)
{
	return sys_oabi_semtimedop(semid, tsops, nsops, NULL);
}
static inline void teehbr_write(unsigned long v)
{
	asm("mcr	p14, 6, %0, c1, c0, 0\n" : : "r" (v));
}
static unsigned long dummy_gettimeoffset(void)
{
	return 0;
}
void save_time_delta(struct timespec *delta, struct timespec *rtc)
{
	set_normalized_timespec(delta,
				xtime.tv_sec - rtc->tv_sec,
				xtime.tv_nsec - rtc->tv_nsec);
}
void dump_stack(void)
{
	dump_backtrace(NULL, NULL);
}
void __pte_error(const char *file, int line, unsigned long val)
{
	printk("%s:%d: bad pte %08lx.\n", file, line, val);
}
void __pmd_error(const char *file, int line, unsigned long val)
{
	printk("%s:%d: bad pmd %08lx.\n", file, line, val);
}
void __pgd_error(const char *file, int line, unsigned long val)
{
	printk("%s:%d: bad pgd %08lx.\n", file, line, val);
}
void __init trap_init(void)
{
	return;
}
static inline void dsp_save_state(u32 *state)
{
	__asm__ __volatile__ (
		"mrrc	p0, 0, %0, %1, c0\n"
		: "=r" (state[0]), "=r" (state[1]));
}
static inline void dsp_load_state(u32 *state)
{
	__asm__ __volatile__ (
		"mcrr	p0, 0, %0, %1, c0\n"
		: : "r" (state[0]), "r" (state[1]));
}
static void aaed2000_clcd_disable(struct clcd_fb *fb)
{
	AAED_EXT_GPIO &= ~AAED_EGPIO_LCD_PWR_EN;
}
static void aaed2000_clcd_enable(struct clcd_fb *fb)
{
	AAED_EXT_GPIO |= AAED_EGPIO_LCD_PWR_EN;
}
static void __init aaed2000_init_irq(void)
{
	aaec2000_init_irq();
}
static void __init aaed2000_init(void)
{
	aaec2000_set_clcd_plat_data(&clcd_info);
}
void __init aaec2000_map_io(void)
{
	iotable_init(standard_io_desc, ARRAY_SIZE(standard_io_desc));
}
static void aaec2000_int_ack(unsigned int irq)
{
	IRQ_INTSR = 1 << irq;
}
static void aaec2000_int_mask(unsigned int irq)
{
	IRQ_INTENC |= (1 << irq);
}
static void aaec2000_int_unmask(unsigned int irq)
{
	IRQ_INTENS |= (1 << irq);
}
static int aaec2000_clcd_mmap(struct clcd_fb *fb, struct vm_area_struct *vma)
{
	return dma_mmap_writecombine(&fb->dev->dev, vma,
			fb->fb.screen_base,
			fb->fb.fix.smem_start,
			fb->fb.fix.smem_len);
}
static void aaec2000_clcd_remove(struct clcd_fb *fb)
{
	dma_free_writecombine(&fb->dev->dev, fb->fb.fix.smem_len,
			fb->fb.screen_base, fb->fb.fix.smem_start);
}
int clk_set_rate(struct clk *clk, unsigned long rate)
{
	return 0;
}
int clk_enable(struct clk *clk)
{
	return 0;
}
struct clk *clk_get(struct device *dev, const char *id)
{
	return dev && strcmp(dev_name(dev), "mb:16") == 0 ? NULL : ERR_PTR(-ENOENT);
}
static void at91cap9_reset(void)
{
	at91_sys_write(AT91_RSTC_CR, AT91_RSTC_KEY | AT91_RSTC_PROCRST | AT91_RSTC_PERRST);
}
static void at91cap9_poweroff(void)
{
	at91_sys_write(AT91_SHDW_CR, AT91_SHDW_KEY | AT91_SHDW_SHDW);
}
static void __init at91_add_device_rtt(void)
{
	platform_device_register(&at91cap9_rtt_device);
}
static void __init at91_add_device_watchdog(void)
{
	platform_device_register(&at91cap9_wdt_device);
}
static void __init at91_add_device_rtc(void)
{
	platform_device_register(&at91rm9200_rtc_device);
}
static void __init at91_add_device_watchdog(void)
{
	platform_device_register(&at91rm9200_wdt_device);
}
static cycle_t read_clk32k(void)
{
	return read_CRTR();
}
static void at91sam9260_reset(void)
{
	at91_sys_write(AT91_RSTC_CR, AT91_RSTC_KEY | AT91_RSTC_PROCRST | AT91_RSTC_PERRST);
}
static void at91sam9260_poweroff(void)
{
	at91_sys_write(AT91_SHDW_CR, AT91_SHDW_KEY | AT91_SHDW_SHDW);
}
static void __init at91_add_device_rtt(void)
{
	platform_device_register(&at91sam9260_rtt_device);
}
static void __init at91_add_device_watchdog(void)
{
	platform_device_register(&at91sam9260_wdt_device);
}
static void at91sam9261_reset(void)
{
	at91_sys_write(AT91_RSTC_CR, AT91_RSTC_KEY | AT91_RSTC_PROCRST | AT91_RSTC_PERRST);
}
static void at91sam9261_poweroff(void)
{
	at91_sys_write(AT91_SHDW_CR, AT91_SHDW_KEY | AT91_SHDW_SHDW);
}
static void __init at91_add_device_rtt(void)
{
	platform_device_register(&at91sam9261_rtt_device);
}
static void __init at91_add_device_watchdog(void)
{
	platform_device_register(&at91sam9261_wdt_device);
}
static void at91sam9263_reset(void)
{
	at91_sys_write(AT91_RSTC_CR, AT91_RSTC_KEY | AT91_RSTC_PROCRST | AT91_RSTC_PERRST);
}
static void at91sam9263_poweroff(void)
{
	at91_sys_write(AT91_SHDW_CR, AT91_SHDW_KEY | AT91_SHDW_SHDW);
}
static void __init at91_add_device_watchdog(void)
{
	platform_device_register(&at91sam9263_wdt_device);
}
static void at91sam926x_pit_suspend(void)
{
	at91_sys_write(AT91_PIT_MR, 0);
}
static void at91sam9rl_reset(void)
{
	at91_sys_write(AT91_RSTC_CR, AT91_RSTC_KEY | AT91_RSTC_PROCRST | AT91_RSTC_PERRST);
}
static void at91sam9rl_poweroff(void)
{
	at91_sys_write(AT91_SHDW_CR, AT91_SHDW_KEY | AT91_SHDW_SHDW);
}
static void __init at91_add_device_rtc(void)
{
	platform_device_register(&at91sam9rl_rtc_device);
}
static void __init at91_add_device_rtt(void)
{
	platform_device_register(&at91sam9rl_rtt_device);
}
static void __init at91_add_device_watchdog(void)
{
	platform_device_register(&at91sam9rl_wdt_device);
}
int clk_enable(struct clk *clk)
{
	return 0;
}
unsigned long clk_get_rate(struct clk *clk)
{
	return AT91X40_MASTER_CLOCK;
}
struct clk *clk_get(struct device *dev, const char *id)
{
	return NULL;
}
void __init at91x40_initialize(unsigned long main_clock)
{
	at91_extern_irq = (1 << AT91X40_ID_IRQ0) | (1 << AT91X40_ID_IRQ1)
			| (1 << AT91X40_ID_IRQ2);
}
static unsigned long at91x40_gettimeoffset(void)
{
	return (at91_sys_read(AT91_TC + AT91_TC_CLK1BASE + AT91_TC_CV) * 1000000 / (AT91X40_MASTER_CLOCK / 128));
}
static void __init onearm_init_irq(void)
{
	at91rm9200_init_interrupts(NULL);
}
static void __init afeb9260_init_irq(void)
{
	at91sam9260_init_interrupts(NULL);
}
static void __init cam60_init_irq(void)
{
	at91sam9260_init_interrupts(NULL);
}
static void __init cap9adk_init_irq(void)
{
	at91cap9_init_interrupts(NULL);
}
static int ads7843_pendown_state(void)
{
	return !at91_get_gpio_value(AT91_PIN_PC4);	/* Touchscreen PENIRQ */
}
static void __init carmeva_init_irq(void)
{
	at91rm9200_init_interrupts(NULL);
}
static void __init csb337_init_irq(void)
{
	at91rm9200_init_interrupts(NULL);
}
static void __init csb637_init_irq(void)
{
	at91rm9200_init_interrupts(NULL);
}
static void __init dk_init_irq(void)
{
	at91rm9200_init_interrupts(NULL);
}
static void __init at91eb01_map_io(void)
{
	at91x40_initialize(40000000);
}
static void __init eb9200_init_irq(void)
{
	at91rm9200_init_interrupts(NULL);
}
static void __init ecb_at91init_irq(void)
{
	at91rm9200_init_interrupts(NULL);
}
static void __init ek_init_irq(void)
{
	at91rm9200_init_interrupts(NULL);
}
static void __init kafa_init_irq(void)
{
	at91rm9200_init_interrupts(NULL);
}
static void __init kb9202_init_irq(void)
{
	at91rm9200_init_interrupts(NULL);
}
static void __init neocore926_init_irq(void)
{
	at91sam9263_init_interrupts(NULL);
}
static int ads7843_pendown_state(void)
{
	return !at91_get_gpio_value(AT91_PIN_PA15);	/* Touchscreen PENIRQ */
}
static void at91_lcdc_power_control(int on)
{
	at91_set_gpio_value(AT91_PIN_PA30, on);
}
static void __init picotux200_init_irq(void)
{
	at91rm9200_init_interrupts(NULL);
}
static void __init ek_init_irq(void)
{
	at91sam9260_init_interrupts(NULL);
}
static void __init ek_init_irq(void)
{
	at91sam9260_init_interrupts(NULL);
}
static void __init ek_init_irq(void)
{
	at91sam9260_init_interrupts(NULL);
}
static void __init ek_init_irq(void)
{
	at91sam9261_init_interrupts(NULL);
}
static int ads7843_pendown_state(void)
{
	return !at91_get_gpio_value(AT91_PIN_PC2);	/* Touchscreen PENIRQ */
}
static void __init ek_init_irq(void)
{
	at91sam9263_init_interrupts(NULL);
}
static int ads7843_pendown_state(void)
{
	return !at91_get_gpio_value(AT91_PIN_PA15);	/* Touchscreen PENIRQ */
}
static void at91_lcdc_power_control(int on)
{
	at91_set_gpio_value(AT91_PIN_PA30, on);
}
static void __init ek_init_irq(void)
{
	at91sam9260_init_interrupts(NULL);
}
static void __init ek_init_irq(void)
{
	at91sam9rl_init_interrupts(NULL);
}
static void __init ek_init_irq(void)
{
	at91sam9260_init_interrupts(NULL);
}
static void __init ek_init_irq(void)
{
	at91sam9263_init_interrupts(NULL);
}
static void __init yl9200_init_irq(void)
{
	at91rm9200_init_interrupts(NULL);
}
static int ads7843_pendown_state(void)
{
	return !at91_get_gpio_value(AT91_PIN_PB11);	/* Touchscreen PENIRQ */
}
void __init yl9200_add_device_video(void)
{
	platform_device_register(&yl9200_s1dfb_device);
}
struct clk *clk_get_parent(struct clk *clk)
{
	return clk->parent;
}
static int at91_clk_open(struct inode *inode, struct file *file)
{
	return single_open(file, at91_clk_show, NULL);
}
static u32 __init at91_usb_rate(struct clk *pll, u32 freq, u32 reg)
{
	if (pll == &pllb && (reg & AT91_PMC_USB96M))
		return freq / 2;
	else
		return freq;
}
static void at91_aic_mask_irq(unsigned int irq)
{
	at91_sys_write(AT91_AIC_IDCR, 1 << irq);
}
static void at91_aic_unmask_irq(unsigned int irq)
{
	at91_sys_write(AT91_AIC_IECR, 1 << irq);
}
static inline void at91_led_on(unsigned int led)
{
	at91_set_gpio_value(led, 0);
}
static inline void at91_led_off(unsigned int led)
{
	at91_set_gpio_value(led, 1);
}
int at91_suspend_entering_slow_clock(void)
{
	return (target_state == PM_SUSPEND_MEM);
}
static void at91_pm_end(void)
{
	target_state = PM_SUSPEND_ON;
}
void __init clps711x_map_io(void)
{
	iotable_init(clps711x_io_desc, ARRAY_SIZE(clps711x_io_desc));
}
static void __init
davinci_evm_map_io(void)
{
	davinci_map_common_io();
}
static void *davinci_ck_start(struct seq_file *m, loff_t *pos)
{
	return *pos < 1 ? (void *)1 : NULL;
}
static int davinci_ck_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &davinci_ck_op);
}
static struct gpio_controller *__iomem __init gpio2controller(unsigned gpio)
{
	return __gpio_to_controller(gpio);
}
void __init davinci_init_common_hw(void)
{
	davinci_clk_init();
}
static inline unsigned int davinci_irq_readl(int offset)
{
	return davinci_readl(DAVINCI_ARM_INTC_BASE + offset);
}
static inline void davinci_irq_writel(unsigned long value, int offset)
{
	davinci_writel(value, DAVINCI_ARM_INTC_BASE + offset);
}
static inline u32 timer32_read(struct timer_s *t)
{
	return davinci_readl(t->tim_reg);
}
static irqreturn_t freerun_interrupt(int irq, void *dev_id)
{
	return IRQ_HANDLED;
}
static void ebsa110_mask_irq(unsigned int irq)
{
	__raw_writeb(1 << irq, IRQ_MCLR);
}
static void ebsa110_unmask_irq(unsigned int irq)
{
	__raw_writeb(1 << irq, IRQ_MSET);
}
static void __init ebsa110_map_io(void)
{
	iotable_init(ebsa110_io_desc, ARRAY_SIZE(ebsa110_io_desc));
}
static int __init ebsa110_init(void)
{
	return platform_add_devices(ebsa110_devices, ARRAY_SIZE(ebsa110_devices));
}
void __outl(u32 val, unsigned int port)
{
	BUG();
}
unsigned long clk_get_rate(struct clk *clk)
{
	return clk->rate;
}
void __init ep93xx_map_io(void)
{
	iotable_init(ep93xx_io_desc, ARRAY_SIZE(ep93xx_io_desc));
}
void ep93xx_gpio_int_mask(unsigned line)
{
	gpio_int_unmasked[line >> 3] &= ~(1 << (line & 7));
}
static void __init micro9_init(void)
{
	ep93xx_register_eth(&micro9_eth_data, 1);
}
static void __init micro9h_init(void)
{
	platform_device_register(&micro9h_flash);
}
static void __init early_fclk(char **arg)
{
	mem_fclk_21285 = simple_strtoul(*arg, arg, 0);
}
static void fb_mask_irq(unsigned int irq)
{
	*CSR_IRQ_DISABLE = fb_irq_mask[_DC21285_INR(irq)];
}
static void fb_unmask_irq(unsigned int irq)
{
	*CSR_IRQ_ENABLE = fb_irq_mask[_DC21285_INR(irq)];
}
struct pci_bus * __init dc21285_scan_bus(int nr, struct pci_sys_data *sys)
{
	return pci_scan_bus(0, &dc21285_ops, sys);
}
void __init dc21285_postinit(void)
{
	register_isa_ports(DC21285_PCI_MEM, DC21285_PCI_IO, 0);
}
static inline void wb977_close(void)
{
	outb(0xaa, 0x370);
}
unsigned int nw_gpio_read(void)
{
	return inb(GP1_IO_BASE) | inb(GP2_IO_BASE) << 8;
}
unsigned long h720x_gettimeoffset(void)
{
	return (CPU_REG (TIMER_VIRT, TM0_COUNT) * tick_usec) / LATCH;
}
static void mask_global_irq (unsigned int irq )
{
	CPU_REG (IRQC_VIRT, IRQC_IER) &= ~(1 << irq);
}
static void unmask_global_irq (unsigned int irq )
{
	CPU_REG (IRQC_VIRT, IRQC_IER) |= (1 << irq);
}
void __init h720x_map_io(void)
{
	iotable_init(h720x_io_desc,ARRAY_SIZE(h720x_io_desc));
}
static unsigned long imx_get_mcu_clk(void)
{
	return imx_decode_pll(MPCTL0, CLK32 * 512);
}
static unsigned long imx_get_perclk1(void)
{
	return imx_get_system_clk() / (((PCDR) & 0xf)+1);
}
static unsigned long imx_get_perclk2(void)
{
	return imx_get_system_clk() / (((PCDR>>4) & 0xf)+1);
}
static unsigned long imx_get_perclk3(void)
{
	return imx_get_system_clk() / (((PCDR>>16) & 0x7f)+1);
}
static unsigned long imx_get_hclk(void)
{
	return imx_get_system_clk() / (((CSCR>>10) & 0xf)+1);
}
int clk_enable(struct clk *clk)
{
	return 0;
}
unsigned long clk_get_rate(struct clk *clk)
{
	return clk->get_rate();
}
static void imx_set_async_mode(void)
{
	adjust_cr(CR_920T_CLOCK_MODE, CR_920T_ASYNC_MODE);
}
static void imx_set_fastbus_mode(void)
{
	adjust_cr(CR_920T_CLOCK_MODE, CR_920T_FASTBUS_MODE);
}
void __imx_gpio_set_value(unsigned gpio, int value)
{
	imx_gpio_set_value_inline(gpio, value);
}
int imx_gpio_to_irq(unsigned gpio)
{
	return IRQ_GPIOA(0) + gpio;
}
void __init imx_set_mmc_info(struct imxmmc_platform_data *info)
{
	imx_mmc_device.dev.platform_data = info;
}
void __init set_imx_fb_info(struct imx_fb_platform_data *hard_imx_fb_info)
{
	memcpy(&imx_fb_info,hard_imx_fb_info,sizeof(struct imx_fb_platform_data));
}
void __init
imx_map_io(void)
{
	iotable_init(imx_io_desc, ARRAY_SIZE(imx_io_desc));
}
static int __init imx_init(void)
{
	return platform_add_devices(devices, ARRAY_SIZE(devices));
}
static void
imx_mask_irq(unsigned int irq)
{
	__raw_writel(irq, IMX_AITC_INTDISNUM);
}
static void
imx_unmask_irq(unsigned int irq)
{
	__raw_writel(irq, IMX_AITC_INTENNUM);
}
static int mx1ads_mmc_card_present(struct device *dev)
{
	return (SSR(1) & (1 << 20) ? 0 : 1);
}
static void __init
mx1ads_map_io(void)
{
	imx_map_io();
}
cycle_t imx_get_cycles(void)
{
	return IMX_TCN(TIMER_BASE);
}
int clk_enable(struct clk *clk)
{
	return 0;
}
unsigned long clk_get_rate(struct clk *clk)
{
	return clk->rate;
}
static int __init integrator_cpu_init(void)
{
	return cpufreq_register_driver(&integrator_driver);
}
static void __exit integrator_cpu_exit(void)
{
	cpufreq_unregister_driver(&integrator_driver);
}
static void impd1fb_clcd_disable(struct clcd_fb *fb)
{
	impd1_tweak_control(fb->dev->dev.parent, IMPD1_CTRL_DISP_MASK, 0);
}
static void impd1fb_clcd_enable(struct clcd_fb *fb)
{
	impd1_tweak_control(fb->dev->dev.parent, IMPD1_CTRL_DISP_MASK,
			fb->panel->connector | IMPD1_CTRL_DISP_ENABLE);
}
static int __init impd1_init(void)
{
	return lm_driver_register(&impd1_driver);
}
static void __exit impd1_exit(void)
{
	lm_driver_unregister(&impd1_driver);
}
static void __init ap_map_io(void)
{
	iotable_init(ap_io_desc, ARRAY_SIZE(ap_io_desc));
}
static void sc_mask_irq(unsigned int irq)
{
	writel(1 << irq, VA_IC_BASE + IRQ_ENABLE_CLEAR);
}
static void sc_unmask_irq(unsigned int irq)
{
	writel(1 << irq, VA_IC_BASE + IRQ_ENABLE_SET);
}
static void __init ap_init_timer(void)
{
	integrator_time_init(1000000 * TICKS_PER_uSEC / HZ, 0);
}
static void __init intcp_map_io(void)
{
	iotable_init(intcp_io_desc, ARRAY_SIZE(intcp_io_desc));
}
static int cp_clcd_mmap(struct clcd_fb *fb, struct vm_area_struct *vma)
{
	return dma_mmap_writecombine(&fb->dev->dev, vma,
				     fb->fb.screen_base,
				     fb->fb.fix.smem_start,
				     fb->fb.fix.smem_len);
}
static void cp_clcd_remove(struct clcd_fb *fb)
{
	dma_free_writecombine(&fb->dev->dev, fb->fb.fix.smem_len,
			      fb->fb.screen_base, fb->fb.fix.smem_start);
}
static void __init intcp_timer_init(void)
{
	integrator_time_init(1000000 / HZ, TIMER_CTRL_IE);
}
static int lm_match(struct device *dev, struct device_driver *drv)
{
	return 1;
}
static int __init lm_init(void)
{
	return bus_register(&lm_bustype);
}
void lm_driver_unregister(struct lm_driver *drv)
{
	driver_unregister(&drv->drv);
}
struct pci_bus *pci_v3_scan_bus(int nr, struct pci_sys_data *sys)
{
	return pci_scan_bus(sys->busnr, &pci_v3_ops, sys);
}
static void write_intctl_0(u32 val)
{
	asm volatile("mcr p6, 0, %0, c0, c4, 0"::"r" (val));
}
static void write_intctl_1(u32 val)
{
	asm volatile("mcr p6, 0, %0, c1, c4, 0"::"r" (val));
}
static void write_intctl_2(u32 val)
{
	asm volatile("mcr p6, 0, %0, c2, c4, 0"::"r" (val));
}
static void write_intctl_3(u32 val)
{
	asm volatile("mcr p6, 0, %0, c3, c4, 0"::"r" (val));
}
static void write_intstr_0(u32 val)
{
	asm volatile("mcr p6, 0, %0, c0, c5, 0"::"r" (val));
}
static void write_intstr_1(u32 val)
{
	asm volatile("mcr p6, 0, %0, c1, c5, 0"::"r" (val));
}
static void write_intstr_2(u32 val)
{
	asm volatile("mcr p6, 0, %0, c2, c5, 0"::"r" (val));
}
static void write_intstr_3(u32 val)
{
	asm volatile("mcr p6, 0, %0, c3, c5, 0"::"r" (val));
}
static void write_intbase(u32 val)
{
	asm volatile("mcr p6, 0, %0, c0, c2, 0"::"r" (val));
}
static void write_intsize(u32 val)
{
	asm volatile("mcr p6, 0, %0, c2, c2, 0"::"r" (val));
}
static void
iop13xx_irq_mask0 (unsigned int irq)
{
	write_intctl_0(read_intctl_0() & ~(1 << (irq - 0)));
}
static void
iop13xx_irq_mask1 (unsigned int irq)
{
	write_intctl_1(read_intctl_1() & ~(1 << (irq - 32)));
}
static void
iop13xx_irq_mask2 (unsigned int irq)
{
	write_intctl_2(read_intctl_2() & ~(1 << (irq - 64)));
}
static void
iop13xx_irq_mask3 (unsigned int irq)
{
	write_intctl_3(read_intctl_3() & ~(1 << (irq - 96)));
}
static void
iop13xx_irq_unmask0(unsigned int irq)
{
	write_intctl_0(read_intctl_0() | (1 << (irq - 0)));
}
static void
iop13xx_irq_unmask1(unsigned int irq)
{
	write_intctl_1(read_intctl_1() | (1 << (irq - 32)));
}
static void
iop13xx_irq_unmask2(unsigned int irq)
{
	write_intctl_2(read_intctl_2() | (1 << (irq - 64)));
}
static void
iop13xx_irq_unmask3(unsigned int irq)
{
	write_intctl_3(read_intctl_3() | (1 << (irq - 96)));
}
static void write_imipr_0(u32 val)
{
	asm volatile("mcr p6, 0, %0, c8, c1, 0"::"r" (val));
}
static void write_imipr_1(u32 val)
{
	asm volatile("mcr p6, 0, %0, c9, c1, 0"::"r" (val));
}
static void write_imipr_2(u32 val)
{
	asm volatile("mcr p6, 0, %0, c10, c1, 0"::"r" (val));
}
static void write_imipr_3(u32 val)
{
	asm volatile("mcr p6, 0, %0, c11, c1, 0"::"r" (val));
}
void __init iop13xx_msi_init(void)
{
	set_irq_chained_handler(IRQ_IOP13XX_INBD_MSI, iop13xx_msi_handler);
}
void arch_teardown_msi_irq(unsigned int irq)
{
	destroy_irq(irq);
}
static void iop13xx_msi_nop(unsigned int irq)
{
	return;
}
u16 iop13xx_dev_id(void)
{
	if (__raw_readl(IOP13XX_ESSR0) & IOP13XX_INTERFACE_SEL_PCIX)
		return __raw_readw(IOP13XX_ATUE_DID);
	else
		return __raw_readw(IOP13XX_ATUX_DID);
}
void __init iop13xx_map_io(void)
{
	iotable_init(iop13xx_std_desc, ARRAY_SIZE(iop13xx_std_desc));
}
static void __init em7210_timer_init(void)
{
	iop_init_time(200000000);
}
static void __init glantank_timer_init(void)
{
	iop_init_time(200000000);
}
static int is_80219(void)
{
	return !!((read_cpuid_id() & 0xffffffe0) == 0x69052e20);
}
static int is_ep80219(void)
{
	if (machine_is_ep80219() || force_ep80219)
		return 1;
	else
		return 0;
}
static void __init iq80321_timer_init(void)
{
	iop_init_time(200000000);
}
static void intctl_write(u32 val)
{
	asm volatile("mcr p6, 0, %0, c0, c0, 0" : : "r" (val));
}
static void intstr_write(u32 val)
{
	asm volatile("mcr p6, 0, %0, c4, c0, 0" : : "r" (val));
}
static void __init n2100_timer_init(void)
{
	iop_init_time(198000000);
}
static void intctl0_write(u32 val)
{
	asm volatile("mcr p6, 0, %0, c0, c0, 0" : : "r" (val));
}
static void intctl1_write(u32 val)
{
	asm volatile("mcr p6, 0, %0, c1, c0, 0" : : "r" (val));
}
static void intstr0_write(u32 val)
{
	asm volatile("mcr p6, 0, %0, c2, c0, 0" : : "r" (val));
}
static void intstr1_write(u32 val)
{
	asm volatile("mcr p6, 0, %0, c3, c0, 0" : : "r" (val));
}
static void intbase_write(u32 val)
{
	asm volatile("mcr p6, 0, %0, c12, c0, 0" : : "r" (val));
}
static void intsize_write(u32 val)
{
	asm volatile("mcr p6, 0, %0, c13, c0, 0" : : "r" (val));
}
void __init ixp2000_uart_init(void)
{
	platform_device_register(&ixp2000_serial_device);
}
static void ixp2000_GPIO_irq_mask(unsigned int irq)
{
	ixp2000_reg_wrb(IXP2000_GPIO_INCR, (1 << (irq - IRQ_IXP2000_GPIO0)));
}
static void ixp2000_GPIO_irq_unmask(unsigned int irq)
{
	ixp2000_reg_write(IXP2000_GPIO_INSR, (1 << (irq - IRQ_IXP2000_GPIO0)));
}
static void ixp2000_err_irq_mask(unsigned int irq)
{
	ixp2000_reg_write(IXP2000_IRQ_ERR_ENABLE_CLR,
			(1 << (irq - IRQ_IXP2000_DRAM0_MIN_ERR)));
}
static void ixp2000_err_irq_unmask(unsigned int irq)
{
	ixp2000_reg_write(IXP2000_IRQ_ERR_ENABLE_SET,
			(1 << (irq - IRQ_IXP2000_DRAM0_MIN_ERR)));
}
static void ixp2000_irq_mask(unsigned int irq)
{
	ixp2000_reg_wrb(IXP2000_IRQ_ENABLE_CLR, (1 << irq));
}
static void ixp2000_irq_unmask(unsigned int irq)
{
	ixp2000_reg_write(IXP2000_IRQ_ENABLE_SET, (1 << irq));
}
static void __init enp2611_timer_init(void)
{
	ixp2000_init_time(50 * 1000 * 1000);
}
static struct pci_bus * __init enp2611_pci_scan_bus(int nr,
						struct pci_sys_data *sys)
{
	return pci_scan_bus(sys->busnr, &enp2611_pci_ops, sys);
}
void __init ixdp2400_init_irq(void)
{
	ixdp2x00_init_irq(IXDP2400_CPLD_INT_STAT, IXDP2400_CPLD_INT_MASK, IXDP2400_NR_IRQS);
}
static void __init ixdp2800_timer_init(void)
{
	ixp2000_init_time(50000000);
}
static void __init ixdp2800_slave_disable_pci_master(void)
{
	*IXP2000_PCI_CMDSTAT &= ~(PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY);
}
void __init ixdp2800_init_irq(void)
{
	ixdp2x00_init_irq(IXDP2800_CPLD_INT_STAT, IXDP2800_CPLD_INT_MASK, IXDP2800_NR_IRQS);
}
static void ixdp2x01_irq_mask(unsigned int irq)
{
	ixp2000_reg_wrb(IXDP2X01_INT_MASK_SET_REG,
				IXP2000_BOARD_IRQ_MASK(irq));
}
static void ixdp2x01_irq_unmask(unsigned int irq)
{
	ixp2000_reg_write(IXDP2X01_INT_MASK_CLR_REG,
				IXP2000_BOARD_IRQ_MASK(irq));
}
struct pci_bus *ixp2000_pci_scan_bus(int nr, struct pci_sys_data *sysdata)
{
	return pci_scan_bus(sysdata->busnr, &ixp2000_pci_ops, sysdata);
}
void __init ixp23xx_map_io(void)
{
	iotable_init(ixp23xx_io_desc, ARRAY_SIZE(ixp23xx_io_desc));
}
static void ixp23xx_pci_irq_mask(unsigned int irq)
{
	*IXP23XX_PCI_XSCALE_INT_ENABLE &= ~(1 << (IRQ_IXP23XX_INTA + 27 - irq));
}
static void ixp23xx_pci_irq_unmask(unsigned int irq)
{
	*IXP23XX_PCI_XSCALE_INT_ENABLE |= (1 << (IRQ_IXP23XX_INTA + 27 - irq));
}
static void ixdp2351_inta_mask(unsigned int irq)
{
	*IXDP2351_CPLD_INTA_MASK_SET_REG = IXDP2351_INTA_IRQ_MASK(irq);
}
static void ixdp2351_inta_unmask(unsigned int irq)
{
	*IXDP2351_CPLD_INTA_MASK_CLR_REG = IXDP2351_INTA_IRQ_MASK(irq);
}
static void ixdp2351_intb_mask(unsigned int irq)
{
	*IXDP2351_CPLD_INTB_MASK_SET_REG = IXDP2351_INTB_IRQ_MASK(irq);
}
static void ixdp2351_intb_unmask(unsigned int irq)
{
	*IXDP2351_CPLD_INTB_MASK_CLR_REG = IXDP2351_INTB_IRQ_MASK(irq);
}
struct pci_bus *ixp23xx_pci_scan_bus(int nr, struct pci_sys_data *sysdata)
{
	return pci_scan_bus(sysdata->busnr, &ixp23xx_pci_ops, sysdata);
}
void __init ixp23xx_pci_slave_init(void)
{
	ixp23xx_pci_common_init();
}
int dma_needs_bounce(struct device *dev, dma_addr_t dma_addr, size_t size)
{
	return (dev->bus == &pci_bus_type ) && ((dma_addr + size) >= SZ_64M);
}
struct pci_bus *ixp4xx_scan_bus(int nr, struct pci_sys_data *sys)
{
	return pci_scan_bus(sys->busnr, &ixp4xx_ops, sys);
}
void __init ixp4xx_map_io(void)
{
  	iotable_init(ixp4xx_io_desc, ARRAY_SIZE(ixp4xx_io_desc));
}
void __init ixp4xx_set_udc_info(struct pxa2xx_udc_mach_info *info)
{
	memcpy(&ixp4xx_udc_info, info, sizeof *info);
}
cycle_t ixp4xx_get_cycles(void)
{
	return *IXP4XX_OSTS;
}
static int __init coyote_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
{
	if (slot == COYOTE_PCI_SLOT0_DEVID)
		return IRQ_COYOTE_PCI_SLOT0;
	else if (slot == COYOTE_PCI_SLOT1_DEVID)
		return IRQ_COYOTE_PCI_SLOT1;
	else return -1;
}
static int __init gateway7001_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
{
	if (slot == 1)
		return IRQ_IXP4XX_GPIO11;
	else if (slot == 2)
		return IRQ_IXP4XX_GPIO10;
	else return -1;
}
static int __init ixdpg425_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
{
	if (slot == 12 || slot == 13)
		return IRQ_IXP4XX_GPIO7;
	else if (slot == 14)
		return IRQ_IXP4XX_GPIO6;
	else return -1;
}
int npe_running(struct npe *npe)
{
	return (__raw_readl(&npe->regs->exec_status_cmd) & STAT_RUN) != 0;
}
void npe_release(struct npe *npe)
{
	module_put(THIS_MODULE);
}
static int __init wg302v2_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
{
	if (slot == 1)
		return IRQ_IXP4XX_GPIO8;
	else if (slot == 2)
		return IRQ_IXP4XX_GPIO9;
	else return -1;
}
void __init kirkwood_setup_sram_win(u32 base, u32 size)
{
	setup_cpu_win(win_alloc_count++, base, size, 0x03, 0x00, -1);
}
void __init kirkwood_map_io(void)
{
	iotable_init(kirkwood_io_desc, ARRAY_SIZE(kirkwood_io_desc));
}
void __init kirkwood_ehci_init(void)
{
	platform_device_register(&kirkwood_ehci);
}
void __init kirkwood_rtc_init(void)
{
	platform_device_register_simple("rtc-mv", -1, &kirkwood_rtc_resource, 1);
}
void __init kirkwood_spi_init()
{
	platform_device_register(&kirkwood_spi);
}
void __init kirkwood_uart0_init(void)
{
	platform_device_register(&kirkwood_uart0);
}
void __init kirkwood_uart1_init(void)
{
	platform_device_register(&kirkwood_uart1);
}
static int __init kirkwood_pcie_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
{
	return IRQ_KIRKWOOD_PCIE;
}
void __init kirkwood_pcie_init(void)
{
	pci_common_init(&kirkwood_pci);
}
static int micrel_pci_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
{
	return KS8695_IRQ_EXTERN0;
}
void __init ks8695_add_device_wan(void)
{
	platform_device_register(&ks8695_wan_device);
}
void __init ks8695_add_device_lan(void)
{
	platform_device_register(&ks8695_lan_device);
}
void __init ks8696_add_device_hpna(void)
{
	platform_device_register(&ks8695_hpna_device);
}
static void __init ks8695_add_device_watchdog(void)
{
	platform_device_register(&ks8695_wdt_device);
}
static int ks8695_gpio_open(struct inode *inode, struct file *file)
{
	return single_open(file, ks8695_gpio_show, NULL);
}
static void ks8695_irq_ack(unsigned int irqno)
{
	__raw_writel((1 << irqno), KS8695_IRQ_VA + KS8695_INTST);
}
static inline void ks8695_led_on(unsigned int led)
{
	gpio_set_value(led, 0);
}
static inline void ks8695_led_off(unsigned int led)
{
	gpio_set_value(led, 1);
}
static struct pci_bus* __init ks8695_pci_scan_bus(int nr, struct pci_sys_data *sys)
{
	return pci_scan_bus(sys->busnr, &ks8695_pci_ops, sys);
}
static inline unsigned int size_mask(unsigned long size)
{
	return (~size) + 1;
}
static void l7200_mask_irq(unsigned int irq)
{
	IRQ_ENABLECLEAR = 1 << irq;
}
static void l7200_unmask_irq(unsigned int irq)
{
	IRQ_ENABLE = 1 << irq;
}
static void __init l7200_map_io(void)
{
	iotable_init(l7200_io_desc, ARRAY_SIZE(l7200_io_desc));
}
void __init kev7a400_map_io(void)
{
	iotable_init (kev7a400_io_desc, ARRAY_SIZE (kev7a400_io_desc));
}
static void kev7a400_ack_cpld_irq (u32 irq)
{
	CPLD_CL_INT = 1 << (irq - IRQ_KEV7A400_CPLD);
}
void __init
lpd7a40x_map_io(void)
{
	iotable_init (lpd7a40x_io_desc, ARRAY_SIZE (lpd7a40x_io_desc));
}
static int lh7a40x_clcd_mmap (struct clcd_fb *fb, struct vm_area_struct *vma)
{
	return dma_mmap_writecombine(&fb->dev->dev, vma,
				     fb->fb.screen_base,
				     fb->fb.fix.smem_start,
				     fb->fb.fix.smem_len);
}
static void lh7a40x_clcd_remove (struct clcd_fb *fb)
{
	dma_free_writecombine (&fb->dev->dev, fb->fb.fix.smem_len,
			       fb->fb.screen_base, fb->fb.fix.smem_start);
}
unsigned int cpufreq_get (unsigned int cpu) /* in kHz */
{
	return fclkfreq_get ()/1000;
}
struct clk *clk_get (struct device *dev, const char *id)
{
	return dev && strcmp(dev_name(dev), "cldc-lh7a40x") == 0
		 ? NULL : ERR_PTR(-ENOENT);
}
int clk_enable (struct clk *clk)
{
	return 0;
}
unsigned long clk_get_rate (struct clk *clk)
{
	return 0;
}
long clk_round_rate (struct clk *clk, unsigned long rate)
{
	return rate;
}
int clk_set_rate (struct clk *clk, unsigned long rate)
{
	return -EIO;
}
static void
lh7a400_ack_cpld_irq (u32 irq)
{
	CPLD_CL_INT = 1 << (irq - IRQ_KEV7A400_CPLD);
}
static void lh7a400_mask_irq (u32 irq)
{
	INTC_INTENC = (1 << irq);
}
static void lh7a400_unmask_irq (u32 irq)
{
	INTC_INTENS = (1 << irq);
}
static void lh7a404_vic1_mask_irq (u32 irq)
{
	VIC1_INTENCLR = (1 << irq);
}
static void lh7a404_vic1_unmask_irq (u32 irq)
{
	VIC1_INTEN = (1 << irq);
}
static void lh7a404_vic2_mask_irq (u32 irq)
{
	VIC2_INTENCLR = (1 << (irq - 32));
}
static void lh7a404_vic2_unmask_irq (u32 irq)
{
	VIC2_INTEN = (1 << (irq - 32));
}
static void ssp_acquire (void)
{
	spin_lock (&ssp_lock);
}
static int ssp_read (void)
{
	return execute_spi_command (0, 0, ssp_configuration.frame_size_read);
}
static int ssp_write_read (u16 data)
{
	return execute_spi_command (data, ssp_configuration.frame_size_write,
				    ssp_configuration.frame_size_read);
}
void __init loki_setup_dev_boot_win(u32 base, u32 size)
{
	setup_cpu_win(4, base, size, TARGET_DEV_BUS, ATTR_DEV_BOOT, -1);
}
void __init loki_map_io(void)
{
	iotable_init(loki_io_desc, ARRAY_SIZE(loki_io_desc));
}
void __init loki_uart0_init(void)
{
	platform_device_register(&loki_uart0);
}
void __init loki_uart1_init(void)
{
	platform_device_register(&loki_uart1);
}
static void loki_timer_init(void)
{
	orion_time_init(IRQ_LOKI_BRIDGE, LOKI_TCLK);
}
void __init loki_init_irq(void)
{
	orion_irq_init(0, (void __iomem *)(IRQ_VIRT_BASE + IRQ_MASK_OFF));
}
static void __init halibut_init_irq(void)
{
	msm_init_irq();
}
static void __init halibut_init(void)
{
	platform_add_devices(devices, ARRAY_SIZE(devices));
}
static inline int pc_clk_enable(unsigned id)
{
	return msm_proc_comm(PCOM_CLKCTL_RPC_ENABLE, &id, NULL);
}
static inline void pc_clk_disable(unsigned id)
{
	msm_proc_comm(PCOM_CLKCTL_RPC_DISABLE, &id, NULL);
}
static inline int pc_clk_set_rate(unsigned id, unsigned rate)
{
	return msm_proc_comm(PCOM_CLKCTL_RPC_SET_RATE, &id, &rate);
}
static inline int pc_clk_set_min_rate(unsigned id, unsigned rate)
{
	return msm_proc_comm(PCOM_CLKCTL_RPC_MIN_RATE, &id, &rate);
}
static inline int pc_clk_set_max_rate(unsigned id, unsigned rate)
{
	return msm_proc_comm(PCOM_CLKCTL_RPC_MAX_RATE, &id, &rate);
}
static inline int pc_clk_set_flags(unsigned id, unsigned flags)
{
	return msm_proc_comm(PCOM_CLKCTL_RPC_SET_FLAGS, &id, &flags);
}
static inline unsigned pc_clk_get_rate(unsigned id)
{
	if (msm_proc_comm(PCOM_CLKCTL_RPC_RATE, &id, NULL))
		return 0;
	else
		return id;
}
static inline unsigned pc_clk_is_enabled(unsigned id)
{
	if (msm_proc_comm(PCOM_CLKCTL_RPC_ENABLED, &id, NULL))
		return 0;
	else
		return id;
}
unsigned long clk_get_rate(struct clk *clk)
{
	return pc_clk_get_rate(clk->id);
}
int clk_set_parent(struct clk *clk, struct clk *parent)
{
	return -ENOSYS;
}
struct clk *clk_get_parent(struct clk *clk)
{
	return ERR_PTR(-ENOSYS);
}
void msm_dmov_stop_cmd(unsigned id, struct msm_dmov_cmd *cmd, int graceful)
{
	writel((graceful << 31), DMOV_FLUSH0(id));
}
static int msm_irq_set_wake(unsigned int irq, unsigned int on)
{
	return -EINVAL;
}
static inline void notify_other_proc_comm(void)
{
	writel(1, MSM_A2M_INT(6));
}
static cycle_t msm_gpt_read(void)
{
	return readl(MSM_GPT_BASE + TIMER_COUNT_VAL);
}
static cycle_t msm_dgt_read(void)
{
	return readl(MSM_DGT_BASE + TIMER_COUNT_VAL) >> MSM_DGT_SHIFT;
}
static int vreg_debug_get(void *data, u64 *val)
{
	return -ENOSYS;
}
static void __init __iomem *win_cfg_base(int win)
{
	return (void __iomem *)((win < 8) ? WIN0_OFF(win) : WIN8_OFF(win));
}
void __init mv78xx0_setup_pcie_io_win(int window, u32 base, u32 size,
				      int maj, int min)
{
	setup_cpu_win(window, base, size, TARGET_PCIE(maj),
		      ATTR_PCIE_IO(min), -1);
}
void __init mv78xx0_setup_pcie_mem_win(int window, u32 base, u32 size,
				       int maj, int min)
{
	setup_cpu_win(window, base, size, TARGET_PCIE(maj),
		      ATTR_PCIE_MEM(min), -1);
}
void __init mv78xx0_ehci0_init(void)
{
	platform_device_register(&mv78xx0_ehci0);
}
void __init mv78xx0_ehci1_init(void)
{
	platform_device_register(&mv78xx0_ehci1);
}
void __init mv78xx0_ehci2_init(void)
{
	platform_device_register(&mv78xx0_ehci2);
}
void __init mv78xx0_uart0_init(void)
{
	platform_device_register(&mv78xx0_uart0);
}
void __init mv78xx0_uart1_init(void)
{
	platform_device_register(&mv78xx0_uart1);
}
void __init mv78xx0_uart2_init(void)
{
	platform_device_register(&mv78xx0_uart2);
}
void __init mv78xx0_uart3_init(void)
{
	platform_device_register(&mv78xx0_uart3);
}
static void mv78xx0_timer_init(void)
{
	orion_time_init(IRQ_MV78XX0_TIMER_1, get_tclk());
}
static int __init is_l2_writethrough(void)
{
	return !!(readl(CPU_CONTROL) & L2_WRITETHROUGH);
}
static unsigned long _clk_parent_round_rate(struct clk *clk, unsigned long rate)
{
	return clk->parent->round_rate(clk->parent, rate);
}
static int _clk_parent_set_rate(struct clk *clk, unsigned long rate)
{
	return clk->parent->set_rate(clk->parent, rate);
}
static unsigned long clk16m_get_rate(struct clk *clk)
{
	return 16000000;
}
static unsigned long clk32_get_rate(struct clk *clk)
{
	return clk32_rate;
}
static unsigned long clk32_premult_get_rate(struct clk *clk)
{
	return clk_get_rate(clk->parent) * 512;
}
static unsigned long system_clk_get_rate(struct clk *clk)
{
	return mx1_decode_pll(__raw_readl(CCM_SPCTL0),
			      clk_get_rate(clk->parent));
}
static unsigned long mcu_clk_get_rate(struct clk *clk)
{
	return mx1_decode_pll(__raw_readl(CCM_MPCTL0),
			      clk_get_rate(clk->parent));
}
static unsigned long hclk_get_rate(struct clk *clk)
{
	return clk_get_rate(clk->parent) / (((__raw_readl(CCM_CSCR) &
			CCM_CSCR_BCLK_MASK) >> CCM_CSCR_BCLK_OFFSET) + 1);
}
static unsigned long hclk_round_rate(struct clk *clk, unsigned long rate)
{
	return _clk_simple_round_rate(clk, rate, 16);
}
static unsigned long clk48m_get_rate(struct clk *clk)
{
	return clk_get_rate(clk->parent) / (((__raw_readl(CCM_CSCR) &
			CCM_CSCR_USB_MASK) >> CCM_CSCR_USB_OFFSET) + 1);
}
static unsigned long clk48m_round_rate(struct clk *clk, unsigned long rate)
{
	return _clk_simple_round_rate(clk, rate, 8);
}
static unsigned long perclk1_get_rate(struct clk *clk)
{
	return clk_get_rate(clk->parent) / (((__raw_readl(CCM_PCDR) &
			CCM_PCDR_PCLK1_MASK) >> CCM_PCDR_PCLK1_OFFSET) + 1);
}
static unsigned long perclk1_round_rate(struct clk *clk, unsigned long rate)
{
	return _clk_simple_round_rate(clk, rate, 16);
}
static unsigned long perclk2_get_rate(struct clk *clk)
{
	return clk_get_rate(clk->parent) / (((__raw_readl(CCM_PCDR) &
			CCM_PCDR_PCLK2_MASK) >> CCM_PCDR_PCLK2_OFFSET) + 1);
}
static unsigned long perclk2_round_rate(struct clk *clk, unsigned long rate)
{
	return _clk_simple_round_rate(clk, rate, 16);
}
static unsigned long perclk3_get_rate(struct clk *clk)
{
	return clk_get_rate(clk->parent) / (((__raw_readl(CCM_PCDR) &
			CCM_PCDR_PCLK3_MASK) >> CCM_PCDR_PCLK3_OFFSET) + 1);
}
static unsigned long perclk3_round_rate(struct clk *clk, unsigned long rate)
{
	return _clk_simple_round_rate(clk, rate, 128);
}
int __init mxc_register_gpios(void)
{
	return mxc_gpio_init(imx_gpio_ports, ARRAY_SIZE(imx_gpio_ports));
}
void __init mxc_map_io(void)
{
	iotable_init(imx_io_desc, ARRAY_SIZE(imx_io_desc));
}
static int uart1_mxc_init(struct platform_device *pdev)
{
	return mxc_gpio_setup_multiple_pins(mxc_uart1_pins,
			ARRAY_SIZE(mxc_uart1_pins), "UART1");
}
static int uart2_mxc_init(struct platform_device *pdev)
{
	return mxc_gpio_setup_multiple_pins(mxc_uart2_pins,
			ARRAY_SIZE(mxc_uart2_pins), "UART2");
}
static void _clk_dma_disable(struct clk *clk)
{
	_clk_pccr01_disable(CCM_PCCR0_DMA_MASK, CCM_PCCR1_HCLK_DMA_MASK);
}
static void _clk_rtic_disable(struct clk *clk)
{
	_clk_pccr01_disable(CCM_PCCR0_RTIC_MASK, CCM_PCCR1_HCLK_RTIC_MASK);
}
static void _clk_emma_disable(struct clk *clk)
{
	_clk_pccr01_disable(CCM_PCCR0_EMMA_MASK, CCM_PCCR1_HCLK_EMMA_MASK);
}
static void _clk_slcdc_disable(struct clk *clk)
{
	_clk_pccr01_disable(CCM_PCCR0_SLCDC_MASK, CCM_PCCR1_HCLK_SLCDC_MASK);
}
static void _clk_fec_disable(struct clk *clk)
{
	_clk_pccr01_disable(CCM_PCCR0_FEC_MASK, CCM_PCCR1_HCLK_FEC_MASK);
}
static void _clk_sahara2_disable(struct clk *clk)
{
	_clk_pccr01_disable(CCM_PCCR0_SAHARA_MASK, CCM_PCCR1_HCLK_SAHARA_MASK);
}
static void _clk_mstick1_disable(struct clk *clk)
{
	_clk_pccr10_disable(CCM_PCCR1_MSHC_BAUD_MASK, CCM_PCCR0_MSHC_MASK);
}
static unsigned long _clk_parent_round_rate(struct clk *clk, unsigned long rate)
{
	return clk->parent->round_rate(clk->parent, rate);
}
static int _clk_parent_set_rate(struct clk *clk, unsigned long rate)
{
	return clk->parent->set_rate(clk->parent, rate);
}
static unsigned long get_high_reference_clock_rate(struct clk *clk)
{
	return external_high_reference;
}
static unsigned long get_low_reference_clock_rate(struct clk *clk)
{
	return external_low_reference;
}
void __init change_external_low_reference(unsigned long new_ref)
{
	external_low_reference = new_ref;
}
unsigned long __init clk_early_get_timer_rate(void)
{
	return clk_get_rate(&per_clk[0]);
}
int __init mxc_register_gpios(void)
{
	return mxc_gpio_init(imx_gpio_ports, ARRAY_SIZE(imx_gpio_ports));
}
void __init mxc_map_io(void)
{
	iotable_init(mxc_io_desc, ARRAY_SIZE(mxc_io_desc));
}
static int uart_mxc_port0_init(struct platform_device *pdev)
{
	return mxc_gpio_setup_multiple_pins(mxc_uart0_pins,
			ARRAY_SIZE(mxc_uart0_pins), "UART0");
}
static int uart_mxc_port1_init(struct platform_device *pdev)
{
	return mxc_gpio_setup_multiple_pins(mxc_uart1_pins,
			ARRAY_SIZE(mxc_uart1_pins), "UART1");
}
static int uart_mxc_port2_init(struct platform_device *pdev)
{
	return mxc_gpio_setup_multiple_pins(mxc_uart2_pins,
			ARRAY_SIZE(mxc_uart2_pins), "UART2");
}
static int uart_mxc_port3_init(struct platform_device *pdev)
{
	return mxc_gpio_setup_multiple_pins(mxc_uart3_pins,
			ARRAY_SIZE(mxc_uart3_pins), "UART3");
}
static int uart_mxc_port3_exit(struct platform_device *pdev)
{
	mxc_gpio_release_multiple_pins(mxc_uart3_pins,
			ARRAY_SIZE(mxc_uart3_pins));
}
static int uart_mxc_port4_init(struct platform_device *pdev)
{
	return mxc_gpio_setup_multiple_pins(mxc_uart4_pins,
			ARRAY_SIZE(mxc_uart4_pins), "UART4");
}
static int uart_mxc_port5_init(struct platform_device *pdev)
{
	return mxc_gpio_setup_multiple_pins(mxc_uart5_pins,
			ARRAY_SIZE(mxc_uart5_pins), "UART5");
}
static void gpio_fec_active(void)
{
	mxc_gpio_setup_multiple_pins(mxc_fec_pins,
			ARRAY_SIZE(mxc_fec_pins), "FEC");
}
static void gpio_fec_inactive(void)
{
	mxc_gpio_release_multiple_pins(mxc_fec_pins,
			ARRAY_SIZE(mxc_fec_pins));
}
static int uart_mxc_port0_init(struct platform_device *pdev)
{
	return mxc_gpio_setup_multiple_pins(mxc_uart0_pins,
			ARRAY_SIZE(mxc_uart0_pins), "UART0");
}
static int uart_mxc_port1_init(struct platform_device *pdev)
{
	return mxc_gpio_setup_multiple_pins(mxc_uart1_pins,
			ARRAY_SIZE(mxc_uart1_pins), "UART1");
}
static int uart_mxc_port2_init(struct platform_device *pdev)
{
	return mxc_gpio_setup_multiple_pins(mxc_uart2_pins,
			ARRAY_SIZE(mxc_uart2_pins), "UART2");
}
static void gpio_fec_active(void)
{
	mxc_gpio_setup_multiple_pins(mxc_fec_pins,
			ARRAY_SIZE(mxc_fec_pins), "FEC");
}
static void gpio_fec_inactive(void)
{
	mxc_gpio_release_multiple_pins(mxc_fec_pins,
			ARRAY_SIZE(mxc_fec_pins));
}
void arch_idle(void)
{
	cpu_do_idle();
}
static unsigned long _clk_mbx_get_rate(struct clk *clk)
{
	return clk_get_rate(clk->parent) / 2;
}
static unsigned long clk_ckih_get_rate(struct clk *clk)
{
	return ckih_rate;
}
static unsigned long clk_ckil_get_rate(struct clk *clk)
{
	return CKIL_CLK_FREQ;
}
int __init mxc_register_gpios(void)
{
	return mxc_gpio_init(imx_gpio_ports, ARRAY_SIZE(imx_gpio_ports));
}
void __init mxc_map_io(void)
{
	iotable_init(mxc_io_desc, ARRAY_SIZE(mxc_io_desc));
}
static int __init mxc_init_extuart(void)
{
	return platform_device_register(&serial_device);
}
static inline int mxc_init_extuart(void)
{
	return 0;
}
static void __init mxc_board_init(void)
{
	mxc_init_imx_uart();
}
int netx_clcd_mmap(struct clcd_fb *fb, struct vm_area_struct *vma)
{
	return dma_mmap_writecombine(&fb->dev->dev, vma,
				     fb->fb.screen_base,
				     fb->fb.fix.smem_start,
				     fb->fb.fix.smem_len);
}
void netx_clcd_remove(struct clcd_fb *fb)
{
	dma_free_writecombine(&fb->dev->dev, fb->fb.fix.smem_len,
			      fb->fb.screen_base, fb->fb.fix.smem_start);
}
int clk_set_rate(struct clk *clk, unsigned long rate)
{
	return 0;
}
int clk_enable(struct clk *clk)
{
	return 0;
}
struct clk *clk_get(struct device *dev, const char *id)
{
	return dev && strcmp(dev_name(dev), "fb") == 0 ? NULL : ERR_PTR(-ENOENT);
}
void __init netx_map_io(void)
{
	iotable_init(netx_io_desc, ARRAY_SIZE(netx_io_desc));
}
static int __init netx_init(void)
{
	return platform_add_devices(devices, ARRAY_SIZE(devices));
}
static void __init nxdkn_init(void)
{
	platform_add_devices(devices, ARRAY_SIZE(devices));
}
cycle_t netx_get_cycles(void)
{
	return readl(NETX_GPIO_COUNTER_CURRENT(TIMER_CLOCKSOURCE));
}
int xc_running(struct xc *x)
{
	return (readl(x->xmac_base + NETX_XMAC_RPU_HOLD_PC_OFS) & RPU_HOLD_PC)
	    || (readl(x->xmac_base + NETX_XMAC_TPU_HOLD_PC_OFS) & TPU_HOLD_PC)
	    || (readl(x->xpec_base + NETX_XPEC_XPU_HOLD_PC_OFS) & XPU_HOLD_PC) ?
		0 : 1;
}
void __init board_a9m9750dev_map_io(void)
{
	iotable_init(board_a9m9750dev_io_desc,
		     ARRAY_SIZE(board_a9m9750dev_io_desc));
}
static int clk_debugfs_open(struct inode *inode, struct file *file)
{
	return single_open(file, clk_debugfs_show, NULL);
}
static inline int ns9360_valid_gpio(unsigned gpio)
{
	return gpio <= 72;
}
static inline void __iomem *ns9360_gpio_get_gconfaddr(unsigned gpio)
{
	if (gpio < 56)
		return BBU_GCONFb1(gpio / 8);
	else
		return BBU_GCONFb2((gpio - 56) / 8);
}
static inline void __iomem *ns9360_gpio_get_gctrladdr(unsigned gpio)
{
	if (gpio < 32)
		return BBU_GCTRL1;
	else if (gpio < 64)
		return BBU_GCTRL2;
	else
		return BBU_GCTRL3;
}
static inline void __iomem *ns9360_gpio_get_gstataddr(unsigned gpio)
{
	if (gpio < 32)
		return BBU_GSTAT1;
	else if (gpio < 64)
		return BBU_GSTAT2;
	else
		return BBU_GSTAT3;
}
static void ns9xxx_ack_irq(unsigned int irq)
{
	__raw_writel(0, SYS_ISRADDR);
}
void __init ns9360_map_io(void)
{
	iotable_init(ns9360_io_desc, ARRAY_SIZE(ns9360_io_desc));
}
static cycle_t ns9360_clocksource_read(void)
{
	return __raw_readl(SYS_TR(TIMER_CLOCKSOURCE));
}
static void __init ams_delta_map_io(void)
{
	omap1_map_common_io();
}
static int nand_dev_ready(struct omap_nand_platform_data *data)
{
	return gpio_get_value(P2_NAND_RB_GPIO_PIN);
}
static void __init omap_generic_map_io(void)
{
	omap1_map_common_io();
}
static void mmc_shutdown(struct device *dev)
{
	gpio_free(H2_TPS_GPIO_MMC_PWR_EN);
}
static void __init h2_map_io(void)
{
	omap1_map_common_io();
}
static int nand_dev_ready(struct omap_nand_platform_data *data)
{
	return gpio_get_value(H3_NAND_RB_GPIO_PIN);
}
static void __init h3_map_io(void)
{
	omap1_map_common_io();
}
static int innovator_get_pendown_state(void)
{
	return !(fpga_read(OMAP1510_FPGA_TOUCHSCREEN) & (1 << 5));
}
static int ads7846_get_pendown_state(void)
{
	return !gpio_get_value(ADS7846_PENDOWN_GPIO);
}
static int nokia770_mmc_get_cover_state(struct device *dev, int slot)
{
	return gpio_get_value(NOKIA770_GPIO_MMC_SWITCH);
}
static void __init omap_nokia770_map_io(void)
{
	omap1_map_common_io();
}
static int mistral_get_pendown_state(void)
{
	return !gpio_get_value(4);
}
static irqreturn_t
osk_mistral_wake_interrupt(int irq, void *ignored)
{
	return IRQ_HANDLED;
}
static void __init osk_map_io(void)
{
	omap1_map_common_io();
}
static void __init omap_palmte_map_io(void)
{
	omap1_map_common_io();
}
static int palmtt_get_pendown_state(void)
{
	return !gpio_get_value(6);
}
static void __init omap_palmtt_map_io(void)
{
	omap1_map_common_io();
}
static int
palmz71_get_pendown_state(void)
{
	return !gpio_get_value(PALMZ71_PENIRQ_GPIO);
}
static void __init
omap_palmz71_map_io(void)
{
	omap1_map_common_io();
}
static int nand_dev_ready(struct omap_nand_platform_data *data)
{
	return gpio_get_value(P2_NAND_RB_GPIO_PIN);
}
int sx1_getkeylight(u8 * keylight)
{
	return sx1_i2c_read_byte(SOFIA_I2C_ADDR, SOFIA_KEYLIGHT_REG, keylight);
}
int sx1_getbacklight (u8 * backlight)
{
	return sx1_i2c_read_byte(SOFIA_I2C_ADDR, SOFIA_BACKLIGHT_REG,
				 backlight);
}
static void __init omap_sx1_map_io(void)
{
	omap1_map_common_io();
}
static int __init ext_uart_init(void)
{
	return platform_device_register(&serial_device);
}
static void __init voiceblue_map_io(void)
{
	omap1_map_common_io();
}
static void omap1_watchdog_recalc(struct clk * clk)
{
	clk->rate = clk->parent->rate / 14;
}
static long omap1_round_ext_clk_rate(struct clk * clk, unsigned long rate)
{
	return 96000000 / calc_ext_dsor(rate);
}
static void omap_init_rtc(void)
{
	(void) platform_device_register(&omap_rtc_device);
}
static inline void omap_init_mbox(void)
{
	platform_device_register(&mbox_device);
}
static inline void omap_init_sti(void)
{
	platform_device_register(&sti_device);
}
static inline u32 get_fpga_unmasked_irqs(void)
{
	return
		((__raw_readb(OMAP1510_FPGA_ISR_LO) &
		  __raw_readb(OMAP1510_FPGA_IMR_LO))) |
		((__raw_readb(OMAP1510_FPGA_ISR_HI) &
		  __raw_readb(OMAP1510_FPGA_IMR_HI)) << 8) |
		((__raw_readb(INNOVATOR_FPGA_ISR2) &
		  __raw_readb(INNOVATOR_FPGA_IMR2)) << 16);
}
unsigned int omap_rev(void)
{
	return omap_revision;
}
static inline unsigned int irq_bank_readl(int bank, int offset)
{
	return omap_readl(irq_banks[bank].base_reg + offset);
}
static inline void irq_bank_writel(unsigned long value, int bank, int offset)
{
	omap_writel(value, irq_banks[bank].base_reg + offset);
}
static inline int mbox_read_reg(size_t ofs)
{
	return __raw_readw(mbox_base + ofs);
}
static inline void mbox_write_reg(u32 val, size_t ofs)
{
	__raw_writew(val, mbox_base + ofs);
}
static int omap1_mbox_fifo_empty(struct omap_mbox *mbox)
{
	return 0;
}
static int __init omap1_mbox_init(void)
{
	return platform_driver_register(&omap1_mbox_driver);
}
static void __exit omap1_mbox_exit(void)
{
	platform_driver_unregister(&omap1_mbox_driver);
}
static ssize_t idle_show(struct kobject *kobj, struct kobj_attribute *attr,
			 char *buf)
{
	return sprintf(buf, "%hu\n", enable_dyn_sleep);
}
static void omap_pm_finish(void)
{
	pm_idle = saved_idle;
}
static irqreturn_t omap_wakeup_interrupt(int irq, void *dev)
{
	return IRQ_HANDLED;
}
static irqreturn_t omap_serial_wake_interrupt(int irq, void *dev_id)
{
	return IRQ_HANDLED;
}
static int __init omap_init(void)
{
	return platform_device_register(&serial_device);
}
static cycle_t mpu_read(void)
{
	return ~omap_mpu_timer_read(1);
}
static inline void omap_32k_timer_write(int val, int reg)
{
	omap_writew(val, OMAP1_32K_TIMER_BASE + reg);
}
static inline unsigned long omap_32k_timer_read(int reg)
{
	return omap_readl(OMAP1_32K_TIMER_BASE + reg) & 0xffffff;
}
static inline void omap_32k_timer_stop(void)
{
	omap_32k_timer_write(0x0, OMAP1_32K_TIMER_CR);
}
static inline unsigned long omap_32k_sync_timer_read(void)
{
	return omap_readl(TIMER_32K_SYNCHRONIZED);
}
static u32 get_sysboot_value(void)
{
	return (omap_ctrl_readl(OMAP24XX_CONTROL_STATUS) &
		(OMAP2_SYSBOOT_5_MASK | OMAP2_SYSBOOT_4_MASK |
		 OMAP2_SYSBOOT_3_MASK | OMAP2_SYSBOOT_2_MASK |
		 OMAP2_SYSBOOT_1_MASK | OMAP2_SYSBOOT_0_MASK));
}
static int ads7846_get_pendown_state(void)
{
	return !gpio_get_value(OMAP3_PANDORA_TS_GPIO);
}
static void omap2_table_mpu_recalc(struct clk *clk)
{
	clk->rate = curr_prcm_set->mpu_speed;
}
void __init omap2_set_globals_control(struct omap_globals *omap2_globals)
{
	omap2_ctrl_base = omap2_globals->ctrl;
}

void __iomem *omap_ctrl_base_get(void)
{
	return omap2_ctrl_base;
}

u8 omap_ctrl_readb(u16 offset)
{
	return __raw_readb(OMAP_CTRL_REGADDR(offset));
}

u16 omap_ctrl_readw(u16 offset)
{
	return __raw_readw(OMAP_CTRL_REGADDR(offset));
}

u32 omap_ctrl_readl(u16 offset)
{
	return __raw_readl(OMAP_CTRL_REGADDR(offset));
}

void omap_ctrl_writeb(u8 val, u16 offset)
{
	__raw_writeb(val, OMAP_CTRL_REGADDR(offset));
}

void omap_ctrl_writew(u16 val, u16 offset)
{
	__raw_writew(val, OMAP_CTRL_REGADDR(offset));
}

void omap_ctrl_writel(u32 val, u16 offset)
{
	__raw_writel(val, OMAP_CTRL_REGADDR(offset));
}
static inline void omap_init_sti(void)
{
	platform_device_register(&sti_device);
}
static void omap_init_sha1_md5(void)
{
	platform_device_register(&sha1_md5_device);
}
static inline void omap_hdq_init(void)
{
	(void) platform_device_register(&omap_hdq_dev);
}
static void gpmc_write_reg(int idx, u32 val)
{
	__raw_writel(val, gpmc_base + idx);
}
static u32 gpmc_read_reg(int idx)
{
	return __raw_readl(gpmc_base + idx);
}
unsigned int gpmc_ticks_to_ns(unsigned int ticks)
{
	return ticks * gpmc_get_fclk_period() / 1000;
}
unsigned int omap_rev(void)
{
	return omap_revision;
}
int omap_chip_is(struct omap_chip_id oci)
{
	return (oci.oc & omap_chip.oc) ? 1 : 0;
}
static void intc_bank_write_reg(u32 val, struct omap_irq_bank *bank, u16 reg)
{
	__raw_writel(val, bank->base_reg + reg);
}
static u32 intc_bank_read_reg(struct omap_irq_bank *bank, u16 reg)
{
	return __raw_readl(bank->base_reg + reg);
}
static void omap_ack_irq(unsigned int irq)
{
	intc_bank_write_reg(0x1, &irq_banks[0], INTC_CONTROL);
}
static inline unsigned int mbox_read_reg(size_t ofs)
{
	return __raw_readl(mbox_base + ofs);
}
static inline void mbox_write_reg(u32 val, size_t ofs)
{
	__raw_writel(val, mbox_base + ofs);
}
static int __init omap2_mbox_init(void)
{
	return platform_driver_register(&omap2_mbox_driver);
}
static void __exit omap2_mbox_exit(void)
{
	platform_driver_unregister(&omap2_mbox_driver);
}
u32 omap2_memory_get_slow_dll_ctrl(void)
{
	return mem_timings.slow_dll_ctrl;
}
u32 omap2_memory_get_fast_dll_ctrl(void)
{
	return mem_timings.fast_dll_ctrl;
}
u32 omap2_memory_get_type(void)
{
	return mem_timings.m_type;
}
static int omap2_pm_suspend(void)
{
	return 0;
}
static void omap2_pm_finish(void)
{
	pm_idle = saved_idle;
}
int __init omap2_pm_init(void)
{
	return 0;
}
bool pwrdm_has_hdwr_sar(struct powerdomain *pwrdm)
{
	return (pwrdm && pwrdm->flags & PWRDM_HAS_HDWR_SAR) ? 1 : 0;
}
u32 omap_prcm_get_reset_sources(void)
{
	return prm_read_mod_reg(WKUP_MOD, RM_RSTST) & 0x7f;
}
u32 prm_read_mod_reg(s16 module, u16 idx)
{
	return __omap_prcm_read(prm_base, module, idx);
}
void prm_write_mod_reg(u32 val, s16 module, u16 idx)
{
	__omap_prcm_write(val, prm_base, module, idx);
}
u32 cm_read_mod_reg(s16 module, u16 idx)
{
	return __omap_prcm_read(cm_base, module, idx);
}
void cm_write_mod_reg(u32 val, s16 module, u16 idx)
{
	__omap_prcm_write(val, cm_base, module, idx);
}
static int __init omap_init(void)
{
	return platform_device_register(&serial_device);
}
static cycle_t clocksource_read_cycles(void)
{
	return (cycle_t)omap_dm_timer_read_counter(gpt_clocksource);
}
void __init orion5x_setup_dev_boot_win(u32 base, u32 size)
{
	setup_cpu_win(win_alloc_count++, base, size,
		      TARGET_DEV_BUS, ATTR_DEV_BOOT, -1);
}
void __init orion5x_setup_dev0_win(u32 base, u32 size)
{
	setup_cpu_win(win_alloc_count++, base, size,
		      TARGET_DEV_BUS, ATTR_DEV_CS0, -1);
}
void __init orion5x_setup_dev1_win(u32 base, u32 size)
{
	setup_cpu_win(win_alloc_count++, base, size,
		      TARGET_DEV_BUS, ATTR_DEV_CS1, -1);
}
void __init orion5x_setup_dev2_win(u32 base, u32 size)
{
	setup_cpu_win(win_alloc_count++, base, size,
		      TARGET_DEV_BUS, ATTR_DEV_CS2, -1);
}
void __init orion5x_setup_pcie_wa_win(u32 base, u32 size)
{
	setup_cpu_win(win_alloc_count++, base, size,
		      TARGET_PCIE, ATTR_PCIE_WA, -1);
}
void __init orion5x_map_io(void)
{
	iotable_init(orion5x_io_desc, ARRAY_SIZE(orion5x_io_desc));
}
void __init orion5x_ehci0_init(void)
{
	platform_device_register(&orion5x_ehci0);
}
void __init orion5x_ehci1_init(void)
{
	platform_device_register(&orion5x_ehci1);
}
void __init orion5x_i2c_init(void)
{
	platform_device_register(&orion5x_i2c);
}
void __init orion5x_spi_init()
{
	platform_device_register(&orion5x_spi);
}
void __init orion5x_uart0_init(void)
{
	platform_device_register(&orion5x_uart0);
}
void __init orion5x_uart1_init(void)
{
	platform_device_register(&orion5x_uart1);
}
static void lsmini_power_off(void)
{
	arch_reset(0);
}
void __init orion5x_pci_disable(void)
{
	orion5x_pci_disabled = 1;
}
void __init orion5x_pci_set_cardbus_mode(void)
{
	orion5x_pci_cardbus_mode = 1;
}
static int __init ts78xx_rtc_init(void)
{
	return 0;
}
static inline void clock_lock(void)
{
	local_irq_disable();
}
static inline void clock_unlock(void)
{
	local_irq_enable();
}
static u32 per_clk_round_rate(struct clk *clk, u32 rate)
{
	return CLK_RATE_13MHZ;
}
static u32 on_off_round_rate(struct clk *clk, u32 rate)
{
	return (rate ? 1 : 0);
}
static u32 pll5_round_rate(struct clk *clk, u32 rate)
{
	return (rate ? CLK_RATE_48MHZ : 0);
}
static u32 ck_13MHz_round_rate(struct clk *clk, u32 rate)
{
	return (rate ? CLK_RATE_13MHZ : 0);
}
static int pll1_set_rate(struct clk *clk, u32 rate)
{
	return 0;
}
void __init pnx4008_map_io(void)
{
	iotable_init(pnx4008_io_desc, ARRAY_SIZE(pnx4008_io_desc));
}
static inline void pnx4008_dma_lock(void)
{
	spin_lock_irq(&dma_lock);
}
static inline void pnx4008_dma_unlock(void)
{
	spin_unlock_irq(&dma_lock);
}
static inline void gpio_lock(void)
{
	local_irq_disable();
}
static inline void gpio_unlock(void)
{
	local_irq_enable();
}
static u32 calculate_input_freq(struct platform_device *pdev)
{
	return HCLK_MHZ;
}
void __init pnx4008_register_i2c_devices(void)
{
	platform_add_devices(devices, ARRAY_SIZE(devices));
}
static void pnx4008_mask_irq(unsigned int irq)
{
	__raw_writel(__raw_readl(INTC_ER(irq)) & ~INTC_BIT(irq), INTC_ER(irq));	/* mask interrupt */
}
static void pnx4008_unmask_irq(unsigned int irq)
{
	__raw_writel(__raw_readl(INTC_ER(irq)) | INTC_BIT(irq), INTC_ER(irq));	/* unmask interrupt */
}
static int pnx4008_pm_valid(suspend_state_t state)
{
	return (state == PM_SUSPEND_STANDBY) ||
	       (state == PM_SUSPEND_MEM);
}
void pnx4008_timer_resume(void)
{
	__raw_writel(timclk_ctrl_reg_save, TIMCLK_CTRL_REG);	/* enable timers */
}
static int am200_get_panel_type(void)
{
	return panel_type;
}
static void am200_set_rst(struct metronomefb_par *par, int state)
{
	gpio_set_value(RST_GPIO_PIN, state);
}
static void am200_set_stdby(struct metronomefb_par *par, int state)
{
	gpio_set_value(STDBY_GPIO_PIN, state);
}
static int am200_wait_event(struct metronomefb_par *par)
{
	return wait_event_timeout(par->waitq, gpio_get_value(RDY_GPIO_PIN), HZ);
}
static int am200_wait_event_intr(struct metronomefb_par *par)
{
	return wait_event_interruptible_timeout(par->waitq,
					gpio_get_value(RDY_GPIO_PIN), HZ);
}
static int am300_init_board(struct broadsheetfb_par *par)
{
	return am300_init_gpio_regs(par);
}
static int am300_get_panel_type(void)
{
	return panel_type;
}
void clk_cken_enable(struct clk *clk)
{
	CKEN |= 1 << clk->cken;
}
void clk_cken_disable(struct clk *clk)
{
	CKEN &= ~(1 << clk->cken);
}
static void __init cmx255_init_nor(void)
{
	platform_device_register(&cmx255_nor);
}
static void __init cmx255_init_nand(void)
{
	platform_device_register(&cmx255_nand);
}
static void __init cmx270_init_rtc(void)
{
	platform_device_register(&cmx270_rtc_device);
}
static void __init cmx270_init_2700G(void)
{
	platform_device_register(&cmx270_2700G);
}
static void __init cmx270_init_ohci(void)
{
	pxa_set_ohci_info(&cmx270_ohci_platform_data);
}
static void __init cmx270_init_mmc(void)
{
	pxa_set_mci_info(&cmx270_mci_platform_data);
}
static void __init cmx2xx_init_touchscreen(void)
{
	platform_device_register(&cmx2xx_ts_device);
}
static void __init cmx2xx_init_display(void)
{
	set_pxa_fb_info(cmx2xx_display);
}
static int __init cmx2xx_pm_init(void) { return 0; }
static void __init cmx2xx_init_ac97(void)
{
	pxa_set_ac97_info(NULL);
}
static void __init cmx2xx_map_io(void)
{
	pxa_map_io();
}
static void __init cm_x300_init_dm9000(void)
{
	platform_device_register(&dm9000_device);
}
static void __init cm_x300_init_lcd(void)
{
	set_pxa_fb_info(&cm_x300_lcd);
}
static void __init cm_x300_init_nand(void)
{
	pxa3xx_set_nand_info(&cm_x300_nand_info);
}
static int cm_x300_mci_init(struct device *dev,
			    irq_handler_t cm_x300_detect_int,
			    void *data)
{
	return 0;
}
static int cm_x300_mci2_ro(struct device *dev)
{
	return gpio_get_value(GPIO85_MMC2_WP);
}
static void __init cm_x300_init_ohci(void)
{
	pxa_set_ohci_info(&cm_x300_ohci_platform_data);
}
static void __init cm_x300_init_leds(void)
{
	platform_device_register(&cm_x300_led_device);
}
static int corgi_mci_get_ro(struct device *dev)
{
	return gpio_get_value(CORGI_GPIO_nSD_WP);
}
static void corgi_irda_shutdown(struct device *dev)
{
	gpio_free(CORGI_GPIO_IR_ON);
}
static void corgi_ads7846_cs(u32 command)
{
	gpio_set_value(CORGI_GPIO_ADS7846_CS, !(command == PXA2XX_CS_ASSERT));
}
static void corgi_lcdcon_cs(u32 command)
{
	gpio_set_value(CORGI_GPIO_LCDCON_CS, !(command == PXA2XX_CS_ASSERT));
}
static void corgi_max1111_cs(u32 command)
{
	gpio_set_value(CORGI_GPIO_MAX1111_CS, !(command == PXA2XX_CS_ASSERT));
}
static void lcdtg_i2c_wait_ack(u8 base)
{
	lcdtg_i2c_send_bit(base);
}
static unsigned long corgi_charger_wakeup(void)
{
	return ~GPLR0 & ( GPIO_bit(CORGI_GPIO_AC_IN) | GPIO_bit(CORGI_GPIO_KEY_INT) | GPIO_bit(CORGI_GPIO_WAKEUP) );
}
static void corgipm_exit(void)
{
	platform_device_unregister(corgipm_device);
}
void corgi_ssp_ads7846_put(ulong data)
{
	ssp_write_word(&corgi_ssp_dev,data);
}
void corgi_ssp_lcdtg_send(u8 adrs, u8 data)
{
	corgi_ssp_dac_put(((adrs & 0x07) << 5) | (data & 0x1f));
}
void corgi_ssp_blduty_set(int duty)
{
	corgi_ssp_lcdtg_send(0x02,duty);
}
void __init corgi_ssp_set_machinfo(struct corgissp_machinfo *machinfo)
{
	ssp_machinfo = machinfo;
}
int __init corgi_ssp_init(void)
{
	return platform_driver_register(&corgissp_driver);
}
static unsigned int pxa_cpufreq_get(unsigned int cpu)
{
	return get_clk_frequency_khz(0);
}
static void __exit pxa_cpu_exit(void)
{
	cpufreq_unregister_driver(&pxa_cpufreq_driver);
}
static int pxa3xx_cpufreq_verify(struct cpufreq_policy *policy)
{
	return cpufreq_frequency_table_verify(policy, pxa3xx_freqs_table);
}
static unsigned int pxa3xx_cpufreq_get(unsigned int cpu)
{
	return get_clk_frequency_khz(0);
}
static void __exit cpufreq_exit(void)
{
	cpufreq_unregister_driver(&pxa3xx_cpufreq_driver);
}
void __init pxa_set_mci_info(struct pxamci_platform_data *info)
{
	pxa_register_device(&pxa_device_mci, info);
}
void __init pxa_set_udc_info(struct pxa2xx_udc_mach_info *info)
{
	memcpy(&pxa_udc_info, info, sizeof *info);
}
void __init set_pxa_fb_info(struct pxafb_mach_info *info)
{
	pxa_register_device(&pxa_device_fb, info);
}
void __init set_pxa_fb_parent(struct device *parent_dev)
{
	pxa_device_fb.dev.parent = parent_dev;
}
void __init pxa_set_i2c_info(struct i2c_pxa_platform_data *info)
{
	pxa_register_device(&pxa_device_i2c, info);
}
void __init pxa_set_ficp_info(struct pxaficp_platform_data *info)
{
	pxa_register_device(&pxa_device_ficp, info);
}
void __init pxa_set_ac97_info(pxa2xx_audio_ops_t *ops)
{
	pxa_register_device(&pxa_device_ac97, ops);
}
void __init pxa_set_keypad_info(struct pxa27x_keypad_platform_data *info)
{
	pxa_register_device(&pxa27x_device_keypad, info);
}
void __init pxa_set_ohci_info(struct pxaohci_platform_data *info)
{
	pxa_register_device(&pxa27x_device_ohci, info);
}
void __init pxa_set_camera_info(struct pxacamera_platform_data *info)
{
	pxa_register_device(&pxa27x_device_camera, info);
}
void __init pxa3xx_set_mci2_info(struct pxamci_platform_data *info)
{
	pxa_register_device(&pxa3xx_device_mci2, info);
}
void __init pxa3xx_set_mci3_info(struct pxamci_platform_data *info)
{
	pxa_register_device(&pxa3xx_device_mci3, info);
}
void __init pxa3xx_set_nand_info(struct pxa3xx_nand_platform_data *info)
{
	pxa_register_device(&pxa3xx_device_nand, info);
}
static void __init em_x270_init_rtc(void)
{
	platform_device_register(&em_x270_rtc);
}
static inline void nand_cs_on(void)
{
	gpio_set_value(GPIO11_NAND_CS, 0);
}
static void __init em_x270_init_nor(void)
{
	platform_device_register(&em_x270_physmap_flash);
}
static void __init em_x270_init_ohci(void)
{
	pxa_set_ohci_info(&em_x270_ohci_platform_data);
}
static int em_x270_mci_get_ro(struct device *dev)
{
	return gpio_get_value(GPIO95_MMC_WP);
}
static void __init em_x270_init_lcd(void)
{
	set_pxa_fb_info(&em_x270_lcd);
}
static void __init em_x270_init_ac97(void)
{
	pxa_set_ac97_info(NULL);
}
static void __init em_x270_init_gpio_keys(void)
{
	platform_device_register(&em_x270_gpio_keys);
}
static void em_x270_battery_low(void)
{
	apm_queue_event(APM_LOW_BATTERY);
}
static void em_x270_battery_critical(void)
{
	apm_queue_event(APM_CRITICAL_SUSPEND);
}
void eseries_register_clks(void)
{
	clks_register(eseries_clkregs, ARRAY_SIZE(eseries_clkregs));
}
unsigned int get_clk_frequency_khz(int info)
{
	if (cpu_is_pxa25x())
		return pxa25x_get_clk_frequency_khz(info);
	else if (cpu_is_pxa27x())
		return pxa27x_get_clk_frequency_khz(info);
	else
		return pxa3xx_get_clk_frequency_khz(info);
}
unsigned int get_memclk_frequency_10khz(void)
{
	if (cpu_is_pxa25x())
		return pxa25x_get_memclk_frequency_10khz();
	else if (cpu_is_pxa27x())
		return pxa27x_get_memclk_frequency_10khz();
	else
		return pxa3xx_get_memclk_frequency_10khz();
}
static inline void __iomem *gpio_chip_base(struct gpio_chip *c)
{
	return container_of(c, struct pxa_gpio_chip, chip)->regbase;
}
static inline struct pxa_gpio_chip *gpio_to_chip(unsigned gpio)
{
	return &pxa_gpio_chips[gpio_to_bank(gpio)];
}
static int pxa_gpio_get(struct gpio_chip *chip, unsigned offset)
{
	return __raw_readl(gpio_chip_base(chip) + GPLR_OFFSET) & (1 << offset);
}
static void pxa_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
{
	__raw_writel(1 << offset, gpio_chip_base(chip) +
				(value ? GPSR_OFFSET : GPCR_OFFSET));
}
static int __init pxa_gpio_init(void)
{
	return sysdev_class_register(&pxa_gpio_sysclass);
}
static void __init gumstix_mmc_init(void)
{
	pxa_set_mci_info(&gumstix_mci_platform_data);
}
static void __init gumstix_mmc_init(void)
{
	pr_debug("Gumstix mmc disabled\n");
}
static void __init gumstix_udc_init(void)
{
	pxa_set_udc_info(&gumstix_udc_info);
}
static void gumstix_udc_init(void)
{
	pr_debug("Gumstix udc is disabled\n");
}
static void gumstix_bluetooth_init(void)
{
	pr_debug("Gumstix Bluetooth is disabled\n");
}
int __attribute__((weak)) am200_init(void)
{
	return 0;
}
int __attribute__((weak)) am300_init(void)
{
	return 0;
}
static int imote2_mci_get_ro(struct device *dev)
{
	return 0;
}
 static void spi1control(u32 command)
{
	gpio_set_value(24, command & PXA2XX_CS_ASSERT ? 0 : 1);
}

static void spi3control(u32 command)
{
	gpio_set_value(39, command & PXA2XX_CS_ASSERT ? 0 : 1);
}
static void pxa_mask_irq(unsigned int irq)
{
	_ICMR(irq) &= ~(1 << IRQ_BIT(irq));
}
static void pxa_unmask_irq(unsigned int irq)
{
	_ICMR(irq) |= 1 << IRQ_BIT(irq);
}
static void pxa_ack_low_gpio(unsigned int irq)
{
	GEDR0 = (1 << (irq - IRQ_GPIO0));
}
static void pxa_mask_low_gpio(unsigned int irq)
{
	ICMR &= ~(1 << (irq - PXA_IRQ(0)));
}
static void pxa_unmask_low_gpio(unsigned int irq)
{
	ICMR |= 1 << (irq - PXA_IRQ(0));
}
static int __init pxa_irq_init(void)
{
	return sysdev_class_register(&pxa_irq_sysclass);
}
static void littleton_init_lcd(void)
{
	set_pxa_fb_info(&littleton_lcd_info);
}
static void littleton_tdo24m_cs(u32 cmd)
{
	gpio_set_value(LITTLETON_GPIO_LCD_CS, !(cmd == PXA2XX_CS_ASSERT));
}
static void __init littleton_init_keypad(void)
{
	pxa_set_keypad_info(&littleton_keypad_info);
}
static void __init littleton_init_nand(void)
{
	pxa3xx_set_nand_info(&littleton_nand_info);
}
void lubbock_set_hexled(uint32_t value)
{
	LUB_HEXLED = value;
}
static int lubbock_udc_is_connected(void)
{
	return (LUB_MISC_RD & (1 << 9)) == 0;
}
static int lubbock_ads7846_pendown_state(void)
{
	return 0;
}
static int lubbock_mci_get_ro(struct device *dev)
{
	return (LUB_MISC_RD & (1 << 2)) != 0;
}
static int magician_is_ac_online(void)
{
	return gpio_get_value(EGPIO_MAGICIAN_CABLE_STATE_AC);
}
static int magician_is_usb_online(void)
{
	return gpio_get_value(EGPIO_MAGICIAN_CABLE_STATE_USB);
}
static int magician_mci_get_ro(struct device *dev)
{
	return (!gpio_get_value(EGPIO_MAGICIAN_nSD_READONLY));
}
static void magician_set_vpp(struct map_info *map, int vpp)
{
	gpio_set_value(EGPIO_MAGICIAN_FLASH_VPP, vpp);
}
static void mst_audio_resume(void *priv)
{
	MST_MSCWR2 &= mst_audio_suspend_mask | ~MST_MSCWR2_AC97_SPKROFF;
}
static void mainstone_mci_exit(struct device *dev, void *data)
{
	free_irq(MAINSTONE_MMC_IRQ, data);
}
static void __init mainstone_init_keypad(void)
{
	pxa_set_keypad_info(&mainstone_keypad_info);
}
static void mioa701_lcd_power(int on, struct fb_var_screeninfo *si)
{
	gpio_set_value(GPIO87_LCD_POWER, on);
}
static int is_usb_connected(void)
{
	return !gpio_get_value(GPIO13_nUSB_DETECT);
}
static void udc_exit(void)
{
	mio_gpio_free(ARRAY_AND_SIZE(udc_gpios));
}
static int mci_get_ro(struct device *dev)
{
	return gpio_get_value(GPIO78_SDIO_RO);
}
static int is_ac_connected(void)
{
	return gpio_get_value(GPIO96_AC_DETECT);
}
static void mioa701_set_charge(int flags)
{
	gpio_set_value(GPIO9_CHARGE_EN, (flags == PDA_POWER_CHARGE_USB));
}
static int palmld_mci_get_ro(struct device *dev)
{
	return gpio_get_value(GPIO_NR_PALMLD_SD_READONLY);
}
static void palmld_irda_shutdown(struct device *dev)
{
	gpio_free(GPIO_NR_PALMLD_IR_DISABLE);
}
static int palmld_is_ac_online(void)
{
	return gpio_get_value(GPIO_NR_PALMLD_POWER_DETECT);
}
static int palmld_is_usb_online(void)
{
	return !gpio_get_value(GPIO_NR_PALMLD_USB_DETECT_N);
}
static int palmt5_mci_get_ro(struct device *dev)
{
	return gpio_get_value(GPIO_NR_PALMT5_SD_READONLY);
}
static void palmt5_irda_shutdown(struct device *dev)
{
	gpio_free(GPIO_NR_PALMT5_IR_DISABLE);
}
static int palmt5_is_ac_online(void)
{
	return gpio_get_value(GPIO_NR_PALMT5_POWER_DETECT);
}
static void power_supply_exit(struct device *dev)
{
	gpio_free(GPIO_NR_PALMT5_POWER_DETECT);
}
static int palmtx_mci_get_ro(struct device *dev)
{
	return gpio_get_value(GPIO_NR_PALMTX_SD_READONLY);
}
static void palmtx_irda_shutdown(struct device *dev)
{
	gpio_free(GPIO_NR_PALMTX_IR_DISABLE);
}
static int palmtx_is_ac_online(void)
{
	return gpio_get_value(GPIO_NR_PALMTX_POWER_DETECT);
}
static void power_supply_exit(struct device *dev)
{
	gpio_free(GPIO_NR_PALMTX_POWER_DETECT);
}
static int palmz72_mci_ro(struct device *dev)
{
	return gpio_get_value(GPIO_NR_PALMZ72_SD_RO);
}
static void palmz72_irda_shutdown(struct device *dev)
{
	gpio_free(GPIO_NR_PALMZ72_IR_DISABLE);
}
static int palmz72_is_ac_online(void)
{
	return gpio_get_value(GPIO_NR_PALMZ72_POWER_DETECT);
}
static int palmz72_is_usb_online(void)
{
	return !gpio_get_value(GPIO_NR_PALMZ72_USB_DETECT_N);
}
static void pcm990_mci_exit(struct device *dev, void *data)
{
	free_irq(PCM027_MMCDET_IRQ, data);
}
unsigned long sleep_phys_sp(void *sp)
{
	return virt_to_phys(sp);
}
static void ads7846_cs(u32 command)
{
	gpio_set_value(POODLE_GPIO_TP_CS, !(command == PXA2XX_CS_ASSERT));
}
static int poodle_mci_get_ro(struct device *dev)
{
	return !!gpio_get_value(POODLE_GPIO_nSD_WP);
}
static void poodle_irda_shutdown(struct device *dev)
{
	gpio_free(POODLE_GPIO_IR_ON);
}
static void poodle_poweroff(void)
{
	arm_machine_restart('h');
}
static void poodle_restart(char mode)
{
	arm_machine_restart('h');
}
unsigned int pxa25x_get_memclk_frequency_10khz(void)
{
	return L_clk_mult[(CCCR >> 0) & 0x1f] * BASE_CLK / 10000;
}
static unsigned long clk_pxa25x_lcd_getrate(struct clk *clk)
{
	return pxa25x_get_memclk_frequency_10khz() * 10000;
}
static void clk_gpio12_enable(struct clk *clk)
{
	pxa2xx_mfp_config(gpio12_config_32k, 1);
}
static void clk_gpio12_disable(struct clk *clk)
{
	pxa2xx_mfp_config(gpio12_config_gpio, 1);
}
static void clk_gpio11_enable(struct clk *clk)
{
	pxa2xx_mfp_config(gpio11_config_3m6, 1);
}
static void clk_gpio11_disable(struct clk *clk)
{
	pxa2xx_mfp_config(gpio11_config_gpio, 1);
}
static void pxa25x_cpu_pm_finish(void)
{
	PSPR = 0;
}
static void __init pxa25x_init_pm(void)
{
	pxa_cpu_pm_fns = &pxa25x_cpu_pm_fns;
}
static unsigned long clk_pxa27x_lcd_getrate(struct clk *clk)
{
	return pxa27x_get_lcdclk_frequency_10khz() * 10000;
}
static int pxa27x_cpu_pm_valid(suspend_state_t state)
{
	return state == PM_SUSPEND_MEM || state == PM_SUSPEND_STANDBY;
}
static void pxa27x_cpu_pm_finish(void)
{
	PSPR = 0;
}
static void __init pxa27x_init_pm(void)
{
	pxa_cpu_pm_fns = &pxa27x_cpu_pm_fns;
}
void pxa2xx_clear_reset_status(unsigned int mask)
{
	RCSR = mask;
}
void pxa3xx_clear_reset_status(unsigned int mask)
{
	ARSR = mask;
}
static void clk_pout_enable(struct clk *clk)
{
	OSCC |= OSCC_PEN;
}
static void clk_pout_disable(struct clk *clk)
{
	OSCC &= ~OSCC_PEN;
}
static int pxa3xx_cpu_pm_valid(suspend_state_t state)
{
	return state == PM_SUSPEND_MEM || state == PM_SUSPEND_STANDBY;
}
void __init pxa3xx_set_i2c_power_info(struct i2c_pxa_platform_data *info)
{
	pxa_register_device(&pxa3xx_device_i2c_power, info);
}
static void __init saar_init_lcd(void)
{
	set_pxa_fb_info(&saar_lcd_info);
}
static void spitz_ads7846_cs(u32 command)
{
	gpio_set_value(SPITZ_GPIO_ADS7846_CS, !(command == PXA2XX_CS_ASSERT));
}
static void spitz_lcdcon_cs(u32 command)
{
	gpio_set_value(SPITZ_GPIO_LCDCON_CS, !(command == PXA2XX_CS_ASSERT));
}
static void spitz_max1111_cs(u32 command)
{
	gpio_set_value(SPITZ_GPIO_MAX1111_CS, !(command == PXA2XX_CS_ASSERT));
}
static int spitz_mci_get_ro(struct device *dev)
{
	return gpio_get_value(SPITZ_GPIO_nSD_WP);
}
static void spitz_irda_shutdown(struct device *dev)
{
	gpio_free(SPITZ_GPIO_IR_ON);
}
static void spitz_poweroff(void)
{
	arm_machine_restart('g');
}
static void spitz_measure_temp(int on)
{
	gpio_set_value(SPITZ_GPIO_ADC_TEMP_ON, on);
}
static void spitz_discharge(int on)
{
	gpio_set_value(SPITZ_GPIO_JK_A, on);
}
static void spitz_discharge1(int on)
{
	gpio_set_value(SPITZ_GPIO_LED_GREEN, on);
}
static unsigned long spitz_charger_wakeup(void)
{
	return (~GPLR0 & GPIO_bit(SPITZ_GPIO_KEY_INT)) | (GPLR0 & GPIO_bit(SPITZ_GPIO_SYNC));
}
static void spitzpm_exit(void)
{
 	platform_device_unregister(spitzpm_device);
}
static int __devinit pxa25x_ssp_probe(struct platform_device *pdev)
{
	return ssp_probe(pdev, PXA25x_SSP);
}
static int __devinit pxa25x_nssp_probe(struct platform_device *pdev)
{
	return ssp_probe(pdev, PXA25x_NSSP);
}
static int __devinit pxa27x_ssp_probe(struct platform_device *pdev)
{
	return ssp_probe(pdev, PXA27x_SSP);
}
static void __init tavorevb_init_keypad(void)
{
	pxa_set_keypad_info(&tavorevb_keypad_info);
}
static cycle_t pxa_read_oscr(void)
{
	return OSCR;
}
static int __init tosa_bt_init(void)
{
	return platform_driver_register(&tosa_bt_driver);
}
static void __exit tosa_bt_exit(void)
{
	platform_driver_unregister(&tosa_bt_driver);
}
static int tosa_mci_get_ro(struct device *dev)
{
	return gpio_get_value(TOSA_GPIO_SD_WP);
}
static void tosa_power_exit(struct device *dev)
{
	gpio_free(TOSA_GPIO_AC_IN);
}
static int tosa_power_ac_online(void)
{
	return gpio_get_value(TOSA_GPIO_AC_IN) == 0;
}
static void tosa_tc6393xb_teardown(struct platform_device *dev)
{
	gpio_free(TOSA_GPIO_CARD_VCC_ON);
}
static void tosa_poweroff(void)
{
	arm_machine_restart('g');
}
static void trizeps4_mci_exit(struct device *dev, void *data)
{
	free_irq(TRIZEPS4_MMC_IRQ, data);
}
static inline int viper_irq_to_bitmask(unsigned int irq)
{
	return viper_isa_irq_map[irq - PXA_ISA_IRQ(0)];
}
static inline int viper_bit_to_irq(int bit)
{
	return viper_isa_irqs[bit] + PXA_ISA_IRQ(0);
}
static void viper_mask_irq(unsigned int irq)
{
	viper_irq_enabled_mask &= ~(viper_irq_to_bitmask(irq));
}
static void viper_unmask_irq(unsigned int irq)
{
	viper_irq_enabled_mask |= viper_irq_to_bitmask(irq);
}
static inline unsigned long viper_irq_pending(void)
{
	return (VIPER_HI_IRQ_STATUS << 8 | VIPER_LO_IRQ_STATUS) &
			viper_irq_enabled_mask;
}
static void isp116x_delay(struct device *dev, int delay)
{
	ndelay(delay);
}
static void __init zylonite_init_keypad(void)
{
	pxa_set_keypad_info(&zylonite_keypad_info);
}
static void __init zylonite_init_nand(void)
{
	pxa3xx_set_nand_info(&zylonite_nand_info);
}
static void __init zylonite_init_ohci(void)
{
	pxa_set_ohci_info(&zylonite_ohci_info);
}
int clk_enable(struct clk *clk)
{
	return 0;
}
unsigned long clk_get_rate(struct clk *clk)
{
	return clk->rate;
}
static int __init realview_i2c_init(void)
{
	return i2c_register_board_info(0, realview_i2c_board_info,
				       ARRAY_SIZE(realview_i2c_board_info));
}
static int realview_clcd_mmap(struct clcd_fb *fb, struct vm_area_struct *vma)
{
	return dma_mmap_writecombine(&fb->dev->dev, vma,
				     fb->fb.screen_base,
				     fb->fb.fix.smem_start,
				     fb->fb.fix.smem_len);
}
static void realview_clcd_remove(struct clcd_fb *fb)
{
	dma_free_writecombine(&fb->dev->dev, fb->fb.fix.smem_len,
			      fb->fb.screen_base, fb->fb.fix.smem_start);
}
static cycle_t realview_get_cycles(void)
{
	return ~readl(timer3_va_base + TIMER_VALUE);
}
int platform_cpu_kill(unsigned int cpu)
{
	return wait_for_completion_timeout(&cpu_killed, 5000);
}
int mach_cpu_disable(unsigned int cpu)
{
	return cpu == 0 ? -EPERM : 0;
}
void __cpuexit local_timer_stop(void)
{
	__raw_writel(0, twd_base + TWD_TIMER_CONTROL);
}
static void __iomem *scu_base_addr(void)
{
	if (machine_is_realview_eb_mp())
		return __io_address(REALVIEW_EB11MP_SCU_BASE);
	else if (machine_is_realview_pb11mp())
		return __io_address(REALVIEW_TC11MP_SCU_BASE);
	else
		return (void __iomem *)0;
}
static void __init realview_pb1176_map_io(void)
{
	iotable_init(realview_pb1176_io_desc, ARRAY_SIZE(realview_pb1176_io_desc));
}
static void __init realview_pb11mp_map_io(void)
{
	iotable_init(realview_pb11mp_io_desc, ARRAY_SIZE(realview_pb11mp_io_desc));
}
static void __init realview_pba8_map_io(void)
{
	iotable_init(realview_pba8_io_desc, ARRAY_SIZE(realview_pba8_io_desc));
}
static int iomd_request_dma(dmach_t channel, dma_t *dma)
{
	return request_irq(dma->dma_irq, iomd_dma_handle,
			   IRQF_DISABLED, dma->device_id, dma);
}
static void iomd_free_dma(dmach_t channel, dma_t *dma)
{
	free_irq(dma->dma_irq, dma);
}
static int __init rpc_init(void)
{
	return platform_add_devices(devs, ARRAY_SIZE(devs));
}
static void s3c2410_dma_select(struct s3c2410_dma_chan *chan,
			       struct s3c24xx_dma_map *map)
{
	chan->dcon = map->channels[chan->number] & ~DMA_CH_VALID;
}
static int __init s3c2410_dma_drvinit(void)
{
	return sysdev_driver_register(&s3c2410_sysclass, &s3c2410_dma_driver);
}
static int __init s3c2442_dma_drvinit(void)
{
	return sysdev_driver_register(&s3c2442_sysclass, &s3c2442_dma_driver);
}
static ssize_t h1940bt_show(struct device *dev, struct device_attribute *attr, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%d\n", state);
}
static int __init h1940bt_init(void)
{
	return platform_driver_register(&h1940bt_driver);
}
static void __exit h1940bt_exit(void)
{
	platform_driver_unregister(&h1940bt_driver);
}
static int s3c2410_irq_add(struct sys_device *sysdev)
{
	return 0;
}
static int s3c2410_irq_init(void)
{
	return sysdev_driver_register(&s3c2410_sysclass, &s3c2410_irq_driver);
}
static irqreturn_t
amlm5900_wake_interrupt(int irq, void *ignored)
{
	return IRQ_HANDLED;
}
static void __init h1940_init_irq(void)
{
	s3c24xx_init_irq();
}
static void __init n30_init_irq(void)
{
	s3c24xx_init_irq();
}
static int __init s3c2410_pm_drvinit(void)
{
	return sysdev_driver_register(&s3c2410_sysclass, &s3c2410_pm_driver);
}
static int __init s3c2440_pm_drvinit(void)
{
	return sysdev_driver_register(&s3c2440_sysclass, &s3c2440_pm_driver);
}
static int __init s3c2442_pm_drvinit(void)
{
	return sysdev_driver_register(&s3c2442_sysclass, &s3c2442_pm_driver);
}
void __init s3c2410_init_uarts(struct s3c2410_uartcfg *cfg, int no)
{
	s3c24xx_init_uartdevs("s3c2410-uart", s3c2410_uart_resources, cfg, no);
}
void __init s3c2410_map_io(void)
{
	iotable_init(s3c2410_iodesc, ARRAY_SIZE(s3c2410_iodesc));
}
static int __init s3c2410_core_init(void)
{
	return sysdev_class_register(&s3c2410_sysclass);
}
static void s3c2412_dma_select(struct s3c2410_dma_chan *chan,
			       struct s3c24xx_dma_map *map)
{
	s3c2412_dma_direction(chan, map, chan->source);
}
static int __init s3c2412_dma_init(void)
{
	return sysdev_driver_register(&s3c2412_sysclass, &s3c2412_dma_driver);
}
static void s3c2412_irq_cfsdi_mask(unsigned int irqno)
{
	s3c_irqsub_mask(irqno, INTMSK_CFSDI, SUBMSK_CFSDI);
}
static void s3c2412_irq_cfsdi_unmask(unsigned int irqno)
{
	s3c_irqsub_unmask(irqno, INTMSK_CFSDI);
}
static void s3c2412_irq_cfsdi_ack(unsigned int irqno)
{
	s3c_irqsub_maskack(irqno, INTMSK_CFSDI, SUBMSK_CFSDI);
}
static int s3c2412_irq_init(void)
{
	return sysdev_driver_register(&s3c2412_sysclass, &s3c2412_irq_driver);
}
static void jive_lcd_spi_chipselect(struct s3c2410_spigpio_info *spi, int cs)
{
	s3c2410_gpio_setpin(S3C2410_GPB7, cs ? 0 : 1);
}
static void jive_wm8750_chipselect(struct s3c2410_spigpio_info *spi, int cs)
{
	s3c2410_gpio_setpin(S3C2410_GPH10, cs ? 0 : 1);
}
static __init int s3c2412_pm_init(void)
{
	return sysdev_driver_register(&s3c2412_sysclass, &s3c2412_pm_driver);
}
static inline void s3c2412_init_gpio2(void)
{
	s3c24xx_va_gpio2 = S3C24XX_VA_GPIO + 0x10;
}
static int __init s3c2412_core_init(void)
{
	return sysdev_class_register(&s3c2412_sysclass);
}
static __init int s3c24xx_clk_driver(void)
{
	return sysdev_driver_register(&s3c2440_sysclass, &s3c2440_clk_driver);
}
static void s3c2440_dma_select(struct s3c2410_dma_chan *chan,
			       struct s3c24xx_dma_map *map)
{
	chan->dcon = map->channels[chan->number] & ~DMA_CH_VALID;
}
static int __init s3c2440_dma_init(void)
{
	return sysdev_driver_register(&s3c2440_sysclass, &s3c2440_dma_driver);
}
static void
s3c_irq_wdtac97_mask(unsigned int irqno)
{
	s3c_irqsub_mask(irqno, INTMSK_WDT, 3<<13);
}
static void
s3c_irq_wdtac97_unmask(unsigned int irqno)
{
	s3c_irqsub_unmask(irqno, INTMSK_WDT);
}
static void
s3c_irq_wdtac97_ack(unsigned int irqno)
{
	s3c_irqsub_maskack(irqno, INTMSK_WDT, 3<<13);
}
static int s3c2440_irq_init(void)
{
	return sysdev_driver_register(&s3c2440_sysclass, &s3c2440_irq_driver);
}
static void __init rx3715_init_irq(void)
{
	s3c24xx_init_irq();
}
static __init int s3c2442_clk_init(void)
{
	return sysdev_driver_register(&s3c2442_sysclass, &s3c2442_clk_driver);
}
static unsigned long s3c2443_roundrate_clksrc4(struct clk *clk,
					       unsigned long rate)
{
	return s3c2443_roundrate_clksrc(clk, rate, 4);
}
static unsigned long s3c2443_roundrate_clksrc16(struct clk *clk,
						unsigned long rate)
{
	return s3c2443_roundrate_clksrc(clk, rate, 16);
}
static unsigned long s3c2443_roundrate_clksrc256(struct clk *clk,
						 unsigned long rate)
{
	return s3c2443_roundrate_clksrc(clk, rate, 256);
}
static int s3c2443_enable_hsmmc(struct clk *clk, int enable)
{
	return s3c2443_setparent_hsmmc(clk, clk->parent);
}
static void s3c2443_dma_select(struct s3c2410_dma_chan *chan,
			       struct s3c24xx_dma_map *map)
{
	writel(map->channels[0] | S3C2443_DMAREQSEL_HW,
	       chan->regs + S3C2443_DMA_DMAREQSEL);
}
static int __init s3c2443_dma_init(void)
{
	return sysdev_driver_register(&s3c2443_sysclass, &s3c2443_dma_driver);
}
static void s3c2443_irq_demux_wdtac97(unsigned int irq, struct irq_desc *desc)
{
	s3c2443_irq_demux(IRQ_S3C2443_WDT, 4);
}
static void s3c2443_irq_wdtac97_mask(unsigned int irqno)
{
	s3c_irqsub_mask(irqno, INTMSK_WDTAC97, SUBMSK_WDTAC97);
}
static void s3c2443_irq_wdtac97_unmask(unsigned int irqno)
{
	s3c_irqsub_unmask(irqno, INTMSK_WDTAC97);
}
static void s3c2443_irq_wdtac97_ack(unsigned int irqno)
{
	s3c_irqsub_maskack(irqno, INTMSK_WDTAC97, SUBMSK_WDTAC97);
}
static void s3c2443_irq_demux_lcd(unsigned int irq, struct irq_desc *desc)
{
	s3c2443_irq_demux(IRQ_S3C2443_LCD1, 4);
}
static void s3c2443_irq_lcd_mask(unsigned int irqno)
{
	s3c_irqsub_mask(irqno, INTMSK_LCD, SUBMSK_LCD);
}
static void s3c2443_irq_lcd_unmask(unsigned int irqno)
{
	s3c_irqsub_unmask(irqno, INTMSK_LCD);
}
static void s3c2443_irq_lcd_ack(unsigned int irqno)
{
	s3c_irqsub_maskack(irqno, INTMSK_LCD, SUBMSK_LCD);
}
static void s3c2443_irq_demux_dma(unsigned int irq, struct irq_desc *desc)
{
	s3c2443_irq_demux(IRQ_S3C2443_DMA0, 6);
}
static void s3c2443_irq_dma_mask(unsigned int irqno)
{
	s3c_irqsub_mask(irqno, INTMSK_DMA, SUBMSK_DMA);
}
static void s3c2443_irq_dma_unmask(unsigned int irqno)
{
	s3c_irqsub_unmask(irqno, INTMSK_DMA);
}
static void s3c2443_irq_dma_ack(unsigned int irqno)
{
	s3c_irqsub_maskack(irqno, INTMSK_DMA, SUBMSK_DMA);
}
static void s3c2443_irq_demux_uart3(unsigned int irq, struct irq_desc *desc)
{
	s3c2443_irq_demux(IRQ_S3C2443_UART3, 3);
}
static void s3c2443_irq_uart3_mask(unsigned int irqno)
{
	s3c_irqsub_mask(irqno, INTMSK_UART3, SUBMSK_UART3);
}
static void s3c2443_irq_uart3_unmask(unsigned int irqno)
{
	s3c_irqsub_unmask(irqno, INTMSK_UART3);
}
static void s3c2443_irq_uart3_ack(unsigned int irqno)
{
	s3c_irqsub_maskack(irqno, INTMSK_UART3, SUBMSK_UART3);
}
static void s3c2443_irq_demux_cam(unsigned int irq, struct irq_desc *desc)
{
	s3c2443_irq_demux(IRQ_S3C2440_CAM_C, 4);
}
static void s3c2443_irq_cam_mask(unsigned int irqno)
{
	s3c_irqsub_mask(irqno, INTMSK_CAM, SUBMSK_CAM);
}
static void s3c2443_irq_cam_unmask(unsigned int irqno)
{
	s3c_irqsub_unmask(irqno, INTMSK_CAM);
}
static void s3c2443_irq_cam_ack(unsigned int irqno)
{
	s3c_irqsub_maskack(irqno, INTMSK_CAM, SUBMSK_CAM);
}
static int __init s3c2443_irq_init(void)
{
	return sysdev_driver_register(&s3c2443_sysclass, &s3c2443_irq_driver);
}
static void s3c2443_hard_reset(void)
{
	__raw_writel(S3C2443_SWRST_RESET, S3C2443_SWRST);
}
void __init s3c2443_init_uarts(struct s3c2410_uartcfg *cfg, int no)
{
	s3c24xx_init_uartdevs("s3c2440-uart", s3c2410_uart_resources, cfg, no);
}
void __init s3c2443_map_io(void)
{
	iotable_init(s3c2443_iodesc, ARRAY_SIZE(s3c2443_iodesc));
}
static int __init s3c2443_core_init(void)
{
	return sysdev_class_register(&s3c2443_sysclass);
}
void __init s3c6410_init_irq(void)
{
	s3c64xx_init_irq(~0 & ~(1 << 7), ~0);
}
static int __init s3c6410_core_init(void)
{
	return sysdev_class_register(&s3c6410_sysclass);
}
unsigned long clk_get_rate(struct clk *clk)
{
	return 3686400;
}
static int collie_uart_probe(struct locomo_dev *dev)
{
	return 0;
}
static int collie_uart_remove(struct locomo_dev *dev)
{
	return 0;
}
static int __init collie_uart_init(void) {
	return locomo_driver_register(&collie_uart_driver);
}
static int collie_should_wakeup(unsigned int resume_on_alarm)
{
	return 0;
}
static unsigned long collie_charger_wakeup(void)
{
	return 0;
}
static int __init sa1100_dram_init(void)
{
	if (cpu_is_sa1100())
		return cpufreq_register_driver(&sa1100_driver);
	else
		return -ENODEV;
}
static inline u_int ns_to_cycles(u_int ns, u_int khz)
{
	return (ns * khz + 999999) / 1000000;
}
unsigned int cpufreq_get(unsigned int cpu)
{
	return cclk_frequency_100khz[PPCR & 0xf] * 100;
}
void sa11x0_set_mcp_data(struct mcp_plat_data *data)
{
	sa11x0mcp_device.dev.platform_data = data;
}
void sa11x0_set_irda_data(struct irda_platform_data *irda)
{
	sa11x0ir_device.dev.platform_data = irda;
}
void __init sa1100_map_io(void)
{
	iotable_init(standard_io_desc, ARRAY_SIZE(standard_io_desc));
}
static int sa1100_gpio_get(struct gpio_chip *chip, unsigned offset)
{
	return GPLR & GPIO_GPIO(offset);
}
void __init sa1100_init_gpio(void)
{
	gpiochip_add(&sa1100_gpio_chip);
}
static void h3xxx_set_vpp(int vpp)
{
	assign_h3600_egpio(IPAQ_EGPIO_VPP_ON, vpp);
}
static void h3xxx_lcd_power(int enable)
{
	assign_h3600_egpio(IPAQ_EGPIO_LCD_POWER, enable);
}
static unsigned long h3100_read_egpio(void)
{
	return h3100_egpio;
}
static unsigned long h3600_read_egpio(void)
{
	return h3600_egpio;
}
static unsigned long h3800_read_egpio(void)
{
	return H3800_ASIC1_GPIO_OUT | (H3800_ASIC2_GPIOPIOD << 16);
}
static void __init hackkit_init(void)
{
	sa11x0_set_flash_data(&hackkit_flash_data, &hackkit_flash_resource, 1);
}
static void sa1100_low_gpio_ack(unsigned int irq)
{
	GEDR = (1 << irq);
}
static void sa1100_low_gpio_mask(unsigned int irq)
{
	ICMR &= ~(1 << irq);
}
static void sa1100_low_gpio_unmask(unsigned int irq)
{
	ICMR |= 1 << irq;
}
static void sa1100_mask_irq(unsigned int irq)
{
	ICMR &= ~(1 << irq);
}
static void sa1100_unmask_irq(unsigned int irq)
{
	ICMR |= (1 << irq);
}
static void __init jornada720_mach_init(void)
{
	sa11x0_set_flash_data(&jornada720_flash_data, &jornada720_flash_resource, 1);
}
 u8 inline jornada_ssp_reverse(u8 byte)
{
	return
		((0x80 & byte) >> 7) |
		((0x40 & byte) >> 5) |
		((0x20 & byte) >> 3) |
		((0x10 & byte) >> 1) |
		((0x08 & byte) << 1) |
		((0x04 & byte) << 3) |
		((0x02 & byte) << 5) |
		((0x01 & byte) << 7);
}
static int __init jornada_ssp_init(void)
{
	return platform_driver_register(&jornadassp_driver);
}
static void __init lart_init(void)
{
	sa11x0_set_mcp_data(&lart_mcp_data);
}
void __init neponset_map_io(void)
{
	iotable_init(neponset_io_desc, ARRAY_SIZE(neponset_io_desc));
}
unsigned long sleep_phys_sp(void *sp)
{
	return virt_to_phys(sp);
}
long get_cs3_shadow(void)
{
	return cs3_shadow;
}
void set_cs3(long value)
{
	*(CS3BUSTYPE *)(CS3_BASE) = cs3_shadow = value;
}
void ssp_enable(void)
{
	Ser4SSCR0 |= SSCR0_SSE;
}
void ssp_disable(void)
{
	Ser4SSCR0 &= ~SSCR0_SSE;
}
static cycle_t sa1100_read_oscr(void)
{
	return OSCR;
}
static void __init shark_map_io(void)
{
	iotable_init(shark_io_desc, ARRAY_SIZE(shark_io_desc));
}
void __init arch_dma_init(dma_t *dma)
{
	isa_init_dma(dma);
}
static int __init shark_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
{
	if (dev->bus->number == 0)
		if (dev->devfn == 0) return 255;
		else return 11;
	else return 255;
}
int clk_enable(struct clk *clk)
{
	return 0;
}
unsigned long clk_get_rate(struct clk *clk)
{
	return clk->rate;
}
void __init versatile_map_io(void)
{
	iotable_init(versatile_io_desc, ARRAY_SIZE(versatile_io_desc));
}
static int __init versatile_i2c_init(void)
{
	return i2c_register_board_info(0, versatile_i2c_board_info,
				       ARRAY_SIZE(versatile_i2c_board_info));
}
static int versatile_clcd_mmap(struct clcd_fb *fb, struct vm_area_struct *vma)
{
	return dma_mmap_writecombine(&fb->dev->dev, vma,
				     fb->fb.screen_base,
				     fb->fb.fix.smem_start,
				     fb->fb.fix.smem_len);
}
static void versatile_clcd_remove(struct clcd_fb *fb)
{
	dma_free_writecombine(&fb->dev->dev, fb->fb.fix.smem_len,
			      fb->fb.screen_base, fb->fb.fix.smem_start);
}
static cycle_t versatile_get_cycles(void)
{
	return ~readl(TIMER3_VA_BASE + TIMER_VALUE);
}
struct pci_bus *pci_versatile_scan_bus(int nr, struct pci_sys_data *sys)
{
	return pci_scan_bus(sys->busnr, &pci_versatile_ops, sys);
}
static void w90x900_irq_mask(unsigned int irq)
{
	__raw_writel(1 << irq, REG_AIC_MDCR);
}
static void w90x900_irq_ack(unsigned int irq)
{
	__raw_writel(0x01, REG_AIC_EOSCR);
}
static void __init w90p910evb_init(void)
{
	platform_add_devices(w90p910evb_dev, ARRAY_SIZE(w90p910evb_dev));
}
static unsigned long w90x900_gettimeoffset(void)
{
	return 0;
}
static int __init w90p910_init_cpu(void)
{
	return 0;
}
static int __init w90x900_arch_init(void)
{
	return w90p910_init_cpu();
}
static inline void l2_clean_pa(unsigned long addr)
{
	__asm__("mcr p15, 1, %0, c15, c9, 3" : : "r" (addr));
}
static inline void l2_clean_pa_range(unsigned long start, unsigned long end)
{
	l2_clean_mva_range(__phys_to_virt(start), __phys_to_virt(end));
}
static inline void l2_clean_inv_pa(unsigned long addr)
{
	__asm__("mcr p15, 1, %0, c15, c10, 3" : : "r" (addr));
}
static inline void l2_inv_pa(unsigned long addr)
{
	__asm__("mcr p15, 1, %0, c15, c11, 3" : : "r" (addr));
}
static inline void l2_inv_pa_range(unsigned long start, unsigned long end)
{
	l2_inv_mva_range(__phys_to_virt(start), __phys_to_virt(end));
}
static inline void write_extra_features(u32 u)
{
	__asm__("mcr p15, 1, %0, c15, c1, 0" : : "r" (u));
}
static inline void cache_sync(void)
{
	sync_writel(0, L2X0_CACHE_SYNC, 1);
}
static inline void xsc3_l2_clean_mva(unsigned long addr)
{
	__asm__("mcr p15, 1, %0, c7, c11, 1" : : "r" (addr));
}
static inline void xsc3_l2_clean_pa(unsigned long addr)
{
	xsc3_l2_clean_mva(__phys_to_virt(addr));
}
static inline void xsc3_l2_inv_mva(unsigned long addr)
{
	__asm__("mcr p15, 1, %0, c7, c7, 1" : : "r" (addr));
}
static inline void xsc3_l2_inv_pa(unsigned long addr)
{
	xsc3_l2_inv_mva(__phys_to_virt(addr));
}
void __init_new_context(struct task_struct *tsk, struct mm_struct *mm)
{
	mm->context.id = 0;
}
static void __attribute__((naked))
feroceon_copy_user_page(void *kto, const void *kfrom)
{
	asm("\
	stmfd	sp!, {r4-r9, lr}		\n\
	mov	ip, %0				\n\
1:	mov	lr, r1				\n\
	ldmia	r1!, {r2 - r9}			\n\
	pld	[lr, #32]			\n\
	pld	[lr, #64]			\n\
	pld	[lr, #96]			\n\
	pld	[lr, #128]			\n\
	pld	[lr, #160]			\n\
	pld	[lr, #192]			\n\
	pld	[lr, #224]			\n\
	stmia	r0, {r2 - r9}			\n\
	ldmia	r1!, {r2 - r9}			\n\
	mcr	p15, 0, r0, c7, c14, 1		@ clean and invalidate D line\n\
	add	r0, r0, #32			\n\
	stmia	r0, {r2 - r9}			\n\
	ldmia	r1!, {r2 - r9}			\n\
	mcr	p15, 0, r0, c7, c14, 1		@ clean and invalidate D line\n\
	add	r0, r0, #32			\n\
	stmia	r0, {r2 - r9}			\n\
	ldmia	r1!, {r2 - r9}			\n\
	mcr	p15, 0, r0, c7, c14, 1		@ clean and invalidate D line\n\
	add	r0, r0, #32			\n\
	stmia	r0, {r2 - r9}			\n\
	ldmia	r1!, {r2 - r9}			\n\
	mcr	p15, 0, r0, c7, c14, 1		@ clean and invalidate D line\n\
	add	r0, r0, #32			\n\
	stmia	r0, {r2 - r9}			\n\
	ldmia	r1!, {r2 - r9}			\n\
	mcr	p15, 0, r0, c7, c14, 1		@ clean and invalidate D line\n\
	add	r0, r0, #32			\n\
	stmia	r0, {r2 - r9}			\n\
	ldmia	r1!, {r2 - r9}			\n\
	mcr	p15, 0, r0, c7, c14, 1		@ clean and invalidate D line\n\
	add	r0, r0, #32			\n\
	stmia	r0, {r2 - r9}			\n\
	ldmia	r1!, {r2 - r9}			\n\
	mcr	p15, 0, r0, c7, c14, 1		@ clean and invalidate D line\n\
	add	r0, r0, #32			\n\
	stmia	r0, {r2 - r9}			\n\
	subs	ip, ip, #(32 * 8)		\n\
	mcr	p15, 0, r0, c7, c14, 1		@ clean and invalidate D line\n\
	add	r0, r0, #32			\n\
	bne	1b				\n\
	mcr	p15, 0, ip, c7, c10, 4		@ drain WB\n\
	ldmfd	sp!, {r4-r9, pc}"
	:
	: "I" (PAGE_SIZE));
}
static void __attribute__((naked))
v3_copy_user_page(void *kto, const void *kfrom)
{
	asm("\n\
	stmfd	sp!, {r4, lr}			@	2\n\
	mov	r2, %2				@	1\n\
	ldmia	%0!, {r3, r4, ip, lr}		@	4+1\n\
1:	stmia	%1!, {r3, r4, ip, lr}		@	4\n\
	ldmia	%0!, {r3, r4, ip, lr}		@	4+1\n\
	stmia	%1!, {r3, r4, ip, lr}		@	4\n\
	ldmia	%0!, {r3, r4, ip, lr}		@	4+1\n\
	stmia	%1!, {r3, r4, ip, lr}		@	4\n\
	ldmia	%0!, {r3, r4, ip, lr}		@	4\n\
	subs	r2, r2, #1			@	1\n\
	stmia	%1!, {r3, r4, ip, lr}		@	4\n\
	ldmneia	%0!, {r3, r4, ip, lr}		@	4\n\
	bne	1b				@	1\n\
	ldmfd	sp!, {r4, pc}			@	3"
	:
	: "r" (kfrom), "r" (kto), "I" (PAGE_SIZE / 64));
}
static void __attribute__((naked))
mc_copy_user_page(void *from, void *to)
{
	asm volatile(
	"stmfd	sp!, {r4, lr}			@ 2\n\
	mov	r4, %2				@ 1\n\
	ldmia	%0!, {r2, r3, ip, lr}		@ 4\n\
1:	mcr	p15, 0, %1, c7, c6, 1		@ 1   invalidate D line\n\
	stmia	%1!, {r2, r3, ip, lr}		@ 4\n\
	ldmia	%0!, {r2, r3, ip, lr}		@ 4+1\n\
	stmia	%1!, {r2, r3, ip, lr}		@ 4\n\
	ldmia	%0!, {r2, r3, ip, lr}		@ 4\n\
	mcr	p15, 0, %1, c7, c6, 1		@ 1   invalidate D line\n\
	stmia	%1!, {r2, r3, ip, lr}		@ 4\n\
	ldmia	%0!, {r2, r3, ip, lr}		@ 4\n\
	subs	r4, r4, #1			@ 1\n\
	stmia	%1!, {r2, r3, ip, lr}		@ 4\n\
	ldmneia	%0!, {r2, r3, ip, lr}		@ 4\n\
	bne	1b				@ 1\n\
	ldmfd	sp!, {r4, pc}			@ 3"
	:
	: "r" (from), "r" (to), "I" (PAGE_SIZE / 64));
}
static void __attribute__((naked))
v4wb_copy_user_page(void *kto, const void *kfrom)
{
	asm("\
	stmfd	sp!, {r4, lr}			@ 2\n\
	mov	r2, %0				@ 1\n\
	ldmia	r1!, {r3, r4, ip, lr}		@ 4\n\
1:	mcr	p15, 0, r0, c7, c6, 1		@ 1   invalidate D line\n\
	stmia	r0!, {r3, r4, ip, lr}		@ 4\n\
	ldmia	r1!, {r3, r4, ip, lr}		@ 4+1\n\
	stmia	r0!, {r3, r4, ip, lr}		@ 4\n\
	ldmia	r1!, {r3, r4, ip, lr}		@ 4\n\
	mcr	p15, 0, r0, c7, c6, 1		@ 1   invalidate D line\n\
	stmia	r0!, {r3, r4, ip, lr}		@ 4\n\
	ldmia	r1!, {r3, r4, ip, lr}		@ 4\n\
	subs	r2, r2, #1			@ 1\n\
	stmia	r0!, {r3, r4, ip, lr}		@ 4\n\
	ldmneia	r1!, {r3, r4, ip, lr}		@ 4\n\
	bne	1b				@ 1\n\
	mcr	p15, 0, r1, c7, c10, 4		@ 1   drain WB\n\
	ldmfd	 sp!, {r4, pc}			@ 3"
	:
	: "I" (PAGE_SIZE / 64));
}
static void __attribute__((naked))
v4wt_copy_user_page(void *kto, const void *kfrom)
{
	asm("\
	stmfd	sp!, {r4, lr}			@ 2\n\
	mov	r2, %0				@ 1\n\
	ldmia	r1!, {r3, r4, ip, lr}		@ 4\n\
1:	stmia	r0!, {r3, r4, ip, lr}		@ 4\n\
	ldmia	r1!, {r3, r4, ip, lr}		@ 4+1\n\
	stmia	r0!, {r3, r4, ip, lr}		@ 4\n\
	ldmia	r1!, {r3, r4, ip, lr}		@ 4\n\
	stmia	r0!, {r3, r4, ip, lr}		@ 4\n\
	ldmia	r1!, {r3, r4, ip, lr}		@ 4\n\
	subs	r2, r2, #1			@ 1\n\
	stmia	r0!, {r3, r4, ip, lr}		@ 4\n\
	ldmneia	r1!, {r3, r4, ip, lr}		@ 4\n\
	bne	1b				@ 1\n\
	mcr	p15, 0, r2, c7, c7, 0		@ flush ID cache\n\
	ldmfd	sp!, {r4, pc}			@ 3"
	:
	: "I" (PAGE_SIZE / 64));
}
static void discard_old_kernel_data(void *kto)
{
	__asm__("mcrr	p15, 0, %1, %0, c6	@ 0xec401f06"
	   :
	   : "r" (kto),
	     "r" ((unsigned long)kto + PAGE_SIZE - L1_CACHE_BYTES)
	   : "cc");
}
static void __attribute__((naked))
xsc3_mc_copy_user_page(void *kto, const void *kfrom)
{
	asm("\
	stmfd	sp!, {r4, r5, lr}		\n\
	mov	lr, %0				\n\
						\n\
	pld	[r1, #0]			\n\
	pld	[r1, #32]			\n\
1:	pld	[r1, #64]			\n\
	pld	[r1, #96]			\n\
						\n\
2:	ldrd	r2, [r1], #8			\n\
	mov	ip, r0				\n\
	ldrd	r4, [r1], #8			\n\
	mcr	p15, 0, ip, c7, c6, 1		@ invalidate\n\
	strd	r2, [r0], #8			\n\
	ldrd	r2, [r1], #8			\n\
	strd	r4, [r0], #8			\n\
	ldrd	r4, [r1], #8			\n\
	strd	r2, [r0], #8			\n\
	strd	r4, [r0], #8			\n\
	ldrd	r2, [r1], #8			\n\
	mov	ip, r0				\n\
	ldrd	r4, [r1], #8			\n\
	mcr	p15, 0, ip, c7, c6, 1		@ invalidate\n\
	strd	r2, [r0], #8			\n\
	ldrd	r2, [r1], #8			\n\
	subs	lr, lr, #1			\n\
	strd	r4, [r0], #8			\n\
	ldrd	r4, [r1], #8			\n\
	strd	r2, [r0], #8			\n\
	strd	r4, [r0], #8			\n\
	bgt	1b				\n\
	beq	2b				\n\
						\n\
	ldmfd	sp!, {r4, r5, pc}"
	:
	: "I" (PAGE_SIZE / 64 - 1));
}
static void __attribute__((naked))
mc_copy_user_page(void *from, void *to)
{
	asm volatile(
	"stmfd	sp!, {r4, r5, lr}		\n\
	mov	lr, %2				\n\
	pld	[r0, #0]			\n\
	pld	[r0, #32]			\n\
	pld	[r1, #0]			\n\
	pld	[r1, #32]			\n\
1:	pld	[r0, #64]			\n\
	pld	[r0, #96]			\n\
	pld	[r1, #64]			\n\
	pld	[r1, #96]			\n\
2:	ldrd	r2, [r0], #8			\n\
	ldrd	r4, [r0], #8			\n\
	mov	ip, r1				\n\
	strd	r2, [r1], #8			\n\
	ldrd	r2, [r0], #8			\n\
	strd	r4, [r1], #8			\n\
	ldrd	r4, [r0], #8			\n\
	strd	r2, [r1], #8			\n\
	strd	r4, [r1], #8			\n\
	mcr	p15, 0, ip, c7, c10, 1		@ clean D line\n\
	ldrd	r2, [r0], #8			\n\
	mcr	p15, 0, ip, c7, c6, 1		@ invalidate D line\n\
	ldrd	r4, [r0], #8			\n\
	mov	ip, r1				\n\
	strd	r2, [r1], #8			\n\
	ldrd	r2, [r0], #8			\n\
	strd	r4, [r1], #8			\n\
	ldrd	r4, [r0], #8			\n\
	strd	r2, [r1], #8			\n\
	strd	r4, [r1], #8			\n\
	mcr	p15, 0, ip, c7, c10, 1		@ clean D line\n\
	subs	lr, lr, #1			\n\
	mcr	p15, 0, ip, c7, c6, 1		@ invalidate D line\n\
	bgt	1b				\n\
	beq	2b				\n\
	ldmfd	sp!, {r4, r5, pc}		"
	:
	: "r" (from), "r" (to), "I" (PAGE_SIZE / 64 - 1));
}
void *
dma_alloc_writecombine(struct device *dev, size_t size, dma_addr_t *handle, gfp_t gfp)
{
	return __dma_alloc(dev, size, handle, gfp,
			   pgprot_writecombine(pgprot_kernel));
}
static inline int notify_page_fault(struct pt_regs *regs, unsigned int fsr)
{
	return 0;
}
static int
do_bad(unsigned long addr, unsigned int fsr, struct pt_regs *regs)
{
	return 1;
}
asmlinkage void __exception
do_PrefetchAbort(unsigned long addr, struct pt_regs *regs)
{
	do_translation_fault(addr, 0, regs);
}
void __iomem *ioport_map(unsigned long port, unsigned int nr)
{
	return __io(port);
}
int valid_mmap_phys_addr_range(unsigned long pfn, size_t size)
{
	return !(pfn + (size >> PAGE_SHIFT) > 0x00100000);
}
const struct mem_type *get_mem_type(unsigned int type)
{
	return type < ARRAY_SIZE(mem_types) ? &mem_types[type] : NULL;
}
void __init paging_init(struct machine_desc *mdesc)
{
	bootmem_init();
}
void flush_dcache_page(struct page *page)
{
	__cpuc_flush_dcache_page(page_address(page));
}
void __iomem *__arm_ioremap(unsigned long phys_addr, size_t size,
			    unsigned int mtype)
{
	return (void __iomem *)phys_addr;
}
static float64 float64_rsf(struct roundingData *roundData, float64 rFn, float64 rFm)
{
	return float64_sub(roundData, rFm, rFn);
}
static float64 float64_rdv(struct roundingData *roundData, float64 rFn, float64 rFm)
{
	return float64_div(roundData, rFm, rFn);
}
static float64 float64_mvf(struct roundingData *roundData,float64 rFm)
{
	return rFm;
}
static floatx80 floatx80_rsf(struct roundingData *roundData, floatx80 rFn, floatx80 rFm)
{
	return floatx80_sub(roundData, rFm, rFn);
}
static floatx80 floatx80_rdv(struct roundingData *roundData, floatx80 rFn, floatx80 rFm)
{
	return floatx80_div(roundData, rFm, rFn);
}
static floatx80 floatx80_mvf(struct roundingData *roundData, floatx80 rFm)
{
	return rFm;
}
unsigned int checkCondition(const unsigned int opcode, const unsigned int ccodes)
{
	return (aCC[opcode >> 28] >> (ccodes >> 28)) & 1;
}
static float32 float32_rsf(struct roundingData *roundData, float32 rFn, float32 rFm)
{
	return float32_sub(roundData, rFm, rFn);
}
static float32 float32_rdv(struct roundingData *roundData, float32 rFn, float32 rFm)
{
	return float32_div(roundData, rFm, rFn);
}
static float32 float32_mvf(struct roundingData *roundData, float32 rFm)
{
	return rFm;
}
static float32 float32_mnf(struct roundingData *roundData, float32 rFm)
{
	return rFm ^ 0x80000000;
}
static float32 float32_abs(struct roundingData *roundData, float32 rFm)
{
	return rFm & 0x7fffffff;
}
static inline void scu_reset_counter(struct eventmonitor __iomem *emc, unsigned int n)
{
	writel(-(u32)counter_config[SCU_COUNTER(n)].count, &emc->MC[n]);
}
static int armv6_detect_pmu(void)
{
	return 0;
}
static inline void armv7_start_pmnc(void)
{
	armv7_pmnc_write(armv7_pmnc_read() | PMNC_E);
}
static inline void armv7_stop_pmnc(void)
{
	armv7_pmnc_write(armv7_pmnc_read() & ~PMNC_E);
}
static int armv7_detect_pmnc(void)
{
	return 0;
}
void __init iop_init_cp6_handler(void)
{
	register_undef_hook(&cp6_hook);
}
int gpio_line_get(int line)
{
	return !!(*IOP3XX_GPID & (1 << line));
}
static int iop3xx_gpio_get_value(struct gpio_chip *chip, unsigned gpio)
{
	return gpio_line_get(gpio);
}
static void iop3xx_gpio_set_value(struct gpio_chip *chip, unsigned gpio, int value)
{
	gpio_line_set(gpio, value);
}
static int __init iop3xx_gpio_setup(void)
{
	return gpiochip_add(&iop3xx_chip);
}
struct pci_bus *iop3xx_pci_scan_bus(int nr, struct pci_sys_data *sys)
{
	return pci_scan_bus(sys->busnr, &iop3xx_ops, sys);
}
int iop3xx_get_init_atu(void) {
	if (init_atu != IOP3XX_INIT_ATU_DEFAULT)
		return init_atu;
	else
		return IOP3XX_INIT_ATU_DISABLE;
}
void __init iop3xx_map_io(void)
{
	iotable_init(iop3xx_std_desc, ARRAY_SIZE(iop3xx_std_desc));
}
unsigned long get_iop_tick_rate(void)
{
	return iop_tick_rate;
}
static int imx_dma_hw_chain(struct imx_dma_channel *imxdma)
{
	if (cpu_is_mx27())
		return imxdma->hw_chaining;
	else
		return 0;
}
void imx_dma_config_burstlen(int channel, unsigned int burstlen)
{
	__raw_writel(burstlen, DMA_BASE + DMA_BLR(channel));
}
static void _clear_gpio_irqstatus(struct mxc_gpio_port *port, u32 index)
{
	__raw_writel(1 << index, port->base + GPIO_ISR);
}
static void mxc_mask_irq(unsigned int irq)
{
	__raw_writel(irq, AVIC_INTDISNUM);
}
static void mxc_unmask_irq(unsigned int irq)
{
	__raw_writel(irq, AVIC_INTENNUM);
}
static cycle_t mxc_get_cycles(void)
{
	return __raw_readl(TIMER_BASE + MXC_TCN);
}
const void *__omap_get_config(u16 tag, size_t len, int nr)
{
        return get_config(tag, len, nr, NULL);
}
const void *omap_get_var_config(u16 tag, size_t *len)
{
        return get_config(tag, NO_LENGTH_CHECK, 0, len);
}
static cycle_t omap_32k_read(void)
{
	return omap_readl(TIMER_32K_SYNCHRONIZED);
}
unsigned long long omap_32k_ticks_to_nsecs(unsigned long ticks_32k)
{
	return cyc2ns(&clocksource_32k, ticks_32k);
}
unsigned long long sched_clock(void)
{
	return omap_32k_ticks_to_nsecs(omap_32k_read());
}
static int __init omap_cpufreq_init(void)
{
	return cpufreq_register_driver(&omap_driver);
}
static void omap_init_uwire(void)
{
	(void) platform_device_register(&omap_uwire_device);
}
static void omap_init_rng(void)
{
	(void) platform_device_register(&omap_rng_device);
}
int omap_dma_in_1510_mode(void)
{
	return enable_1510_mode;
}
void omap_enable_dma_irq(int lch, u16 bits)
{
	dma_chan[lch].enabled_irqs |= bits;
}
void omap_disable_dma_irq(int lch, u16 bits)
{
	dma_chan[lch].enabled_irqs &= ~bits;
}
int omap_get_dma_active_status(int lch)
{
	return (dma_read(CCR(lch)) & OMAP_DMA_CCR_EN) != 0;
}
void omap_set_lcd_dma_src_port(int port)
{
	lcd_dma.src_port = port;
}
void omap_set_lcd_dma_ext_controller(int external)
{
	lcd_dma.ext_ctrl = external;
}
void omap_set_lcd_dma_single_transfer(int single)
{
	lcd_dma.single_transfer = single;
}
int omap_dm_timer_get_irq(struct omap_dm_timer *timer)
{
	return timer->irq;
}
struct clk *omap_dm_timer_get_fclk(struct omap_dm_timer *timer)
{
	return timer->fclk;
}
void omap_dm_timer_trigger(struct omap_dm_timer *timer)
{
	omap_dm_timer_write_reg(timer, OMAP_TIMER_TRIGGER_REG, 0);
}
void omap_dm_timer_write_status(struct omap_dm_timer *timer, unsigned int value)
{
	omap_dm_timer_write_reg(timer, OMAP_TIMER_STAT_REG, value);
}
void omap_dm_timer_write_counter(struct omap_dm_timer *timer, unsigned int value)
{
	omap_dm_timer_write_reg(timer, OMAP_TIMER_COUNTER_REG, value);
}
static inline int ranges_overlap(unsigned long start1, unsigned long size1,
				 unsigned long start2, unsigned long size2)
{
	return (start1 >= start2 && start1 < start2 + size2) ||
	       (start2 >= start1 && start2 < start1 + size1);
}
static inline int range_included(unsigned long start1, unsigned long size1,
				 unsigned long start2, unsigned long size2)
{
	return start1 >= start2 && start1 + size1 <= start2 + size2;
}
void omapfb_set_ctrl_platform_data(void *data)
{
	omapfb_config.ctrl_platform_data = data;
}
unsigned long omapfb_reserve_sram(unsigned long sram_pstart,
				  unsigned long sram_vstart,
				  unsigned long sram_size,
				  unsigned long start_avail,
				  unsigned long size_avail)
{
	return 0;
}
static inline void _clear_gpio_irqstatus(struct gpio_bank *bank, int gpio)
{
	_clear_gpio_irqbank(bank, 1 << get_gpio_index(gpio));
}
static inline void _set_gpio_irqenable(struct gpio_bank *bank, int gpio, int enable)
{
	_enable_gpio_irqbank(bank, 1 << get_gpio_index(gpio), enable);
}
static int gpio_get(struct gpio_chip *chip, unsigned offset)
{
	return __omap_get_gpio_datain(chip->base + offset);
}
int __init omap_gpio_init(void)
{
	if (!initialized)
		return _omap_gpio_init();
	else
		return 0;
}
static int dbg_gpio_open(struct inode *inode, struct file *file)
{
	return single_open(file, dbg_gpio_show, &inode->i_private);
}
static inline mbox_msg_t mbox_fifo_read(struct omap_mbox *mbox)
{
	return mbox->ops->fifo_read(mbox);
}
static inline void mbox_fifo_write(struct omap_mbox *mbox, mbox_msg_t msg)
{
	mbox->ops->fifo_write(mbox, msg);
}
static inline int mbox_fifo_empty(struct omap_mbox *mbox)
{
	return mbox->ops->fifo_empty(mbox);
}
static inline int mbox_fifo_full(struct omap_mbox *mbox)
{
	return mbox->ops->fifo_full(mbox);
}
static inline void enable_mbox_irq(struct omap_mbox *mbox, omap_mbox_irq_t irq)
{
	mbox->ops->enable_irq(mbox, irq);
}
static inline void disable_mbox_irq(struct omap_mbox *mbox, omap_mbox_irq_t irq)
{
	mbox->ops->disable_irq(mbox, irq);
}
static inline int is_mbox_irq(struct omap_mbox *mbox, omap_mbox_irq_t irq)
{
	return mbox->ops->is_irq(mbox, irq);
}
void omap_mbox_init_seq(struct omap_mbox *mbox)
{
	mbox_seq_init(mbox);
}
static ssize_t mbox_show(struct class *class, char *buf)
{
	return sprintf(buf, "mbox");
}
void omap_mbox_put(struct omap_mbox *mbox)
{
	omap_mbox_fini(mbox);
}
int omap_mcbsp_read(void __iomem *io_base, u16 reg)
{
	if (cpu_class_is_omap1() || cpu_is_omap2420())
		return __raw_readw(io_base + reg);
	else
		return __raw_readl(io_base + reg);
}
int __init omap_mcbsp_init(void)
{
	return platform_driver_register(&omap_mcbsp_driver);
}
static void omap_sram_error(void)
{
	panic("Uninitialized SRAM function\n");
}
static inline int omap242x_sram_init(void)
{
	return 0;
}
static inline int omap243x_sram_init(void)
{
	return 0;
}
static inline int omap34xx_sram_init(void)
{
	return 0;
}
u32 __init orion_pcie_dev_id(void __iomem *base)
{
	return readl(base + PCIE_DEV_ID_OFF) >> 16;
}
u32 __init orion_pcie_rev(void __iomem *base)
{
	return readl(base + PCIE_DEV_REV_OFF) & 0xff;
}
int orion_pcie_link_up(void __iomem *base)
{
	return !(readl(base + PCIE_STAT_OFF) & PCIE_STAT_LINK_DOWN);
}
int __init orion_pcie_x4_mode(void __iomem *base)
{
	return !(readl(base + PCIE_CTRL_OFF) & PCIE_CTRL_X1_MODE);
}
static cycle_t orion_clksrc_read(void)
{
	return 0xffffffff - readl(TIMER0_VAL);
}
static int clk_null_enable(struct clk *clk, int enable)
{
	return 0;
}
void clk_put(struct clk *clk)
{
	module_put(clk->owner);
}
struct clk *clk_get_parent(struct clk *clk)
{
	return clk->parent;
}
static inline struct pwm_tdiv_clk *to_tdiv(struct clk *clk)
{
	return container_of(clk, struct pwm_tdiv_clk, clk);
}
static unsigned long clk_pwm_tdiv_bits(struct pwm_tdiv_clk *divclk)
{
	return pwm_tdiv_div_bits(divclk->divisor);
}
static inline struct clk *s3c24xx_pwmclk_tclk(unsigned int id)
{
	return (id >= 2) ? &clk_timer_tclk[1] : &clk_timer_tclk[0];
}
static inline struct clk *s3c24xx_pwmclk_tdiv(unsigned int id)
{
	return &clk_timer_tdiv[id].clk;
}
static void s3c_adc_dbgshow(struct adc_device *adc)
{
	adc_dbg(adc, "CON=%08x, TSC=%08x, DLY=%08x\n",
		readl(adc->regs + S3C2410_ADCCON),
		readl(adc->regs + S3C2410_ADCTSC),
		readl(adc->regs + S3C2410_ADCDLY));
}
void s3c_adc_release(struct s3c_adc_client *client)
{
	kfree(client);
}
static unsigned long s3c24xx_read_idcode_v5(void)
{
	return __raw_readl(S3C2412_GSTATUS1);
}
static unsigned long s3c24xx_read_idcode_v4(void)
{
	return __raw_readl(S3C2410_GSTATUS1);
}
static void
dmadbg_dumpregs(const char *fname, int line, struct s3c2410_dma_chan *chan,
		 struct s3c2410_dma_regstate *regs)
{
	printk(KERN_DEBUG "dma%d: %s:%d: DCSRC=%08lx, DISRC=%08lx, DSTAT=%08lx DMT=%02lx, DCON=%08lx\n",
	       chan->number, fname, line,
	       regs->dcsrc, regs->disrc, regs->dstat, regs->dmsktrig,
	       regs->dcon);
}
static struct s3c2410_dma_chan *lookup_dma_channel(unsigned int channel)
{
	if (channel & DMACH_LOW_LEVEL)
		return &s3c2410_chans[channel & ~DMACH_LOW_LEVEL];
	else
		return dma_chan_map[channel];
}
static struct s3c2410_dma_chan *to_dma_chan(struct sys_device *dev)
{
	return container_of(dev, struct s3c2410_dma_chan, dev);
}
static void s3c2410_dma_cache_ctor(void *p)
{
	memset(p, 0, sizeof(struct s3c2410_dma_buf));
}
int __init s3c2410_dma_init(void)
{
	return s3c24xx_dma_init(4, IRQ_DMA0, 0x40);
}
static inline int is_channel_valid(unsigned int channel)
{
	return (channel & DMA_CH_VALID);
}
static int s3c24xx_dma_check_entry(struct s3c24xx_dma_map *map, int ch)
{
	return 0;
}
static int s3c24xx_gpiolib_banka_input(struct gpio_chip *chip, unsigned offset)
{
	return -EINVAL;
}
static int s3c24xx_gpiolib_bankg_toirq(struct gpio_chip *chip, unsigned offset)
{
	return IRQ_EINT8 + offset;
}
static void
s3c_irq_uart0_mask(unsigned int irqno)
{
	s3c_irqsub_mask(irqno, INTMSK_UART0, 7);
}
static void
s3c_irq_uart0_unmask(unsigned int irqno)
{
	s3c_irqsub_unmask(irqno, INTMSK_UART0);
}
static void
s3c_irq_uart0_ack(unsigned int irqno)
{
	s3c_irqsub_maskack(irqno, INTMSK_UART0, 7);
}
static void
s3c_irq_uart1_mask(unsigned int irqno)
{
	s3c_irqsub_mask(irqno, INTMSK_UART1, 7 << 3);
}
static void
s3c_irq_uart1_unmask(unsigned int irqno)
{
	s3c_irqsub_unmask(irqno, INTMSK_UART1);
}
static void
s3c_irq_uart1_ack(unsigned int irqno)
{
	s3c_irqsub_maskack(irqno, INTMSK_UART1, 7 << 3);
}
static void
s3c_irq_uart2_mask(unsigned int irqno)
{
	s3c_irqsub_mask(irqno, INTMSK_UART2, 7 << 6);
}
static void
s3c_irq_uart2_unmask(unsigned int irqno)
{
	s3c_irqsub_unmask(irqno, INTMSK_UART2);
}
static void
s3c_irq_uart2_ack(unsigned int irqno)
{
	s3c_irqsub_maskack(irqno, INTMSK_UART2, 7 << 6);
}
static void
s3c_irq_adc_mask(unsigned int irqno)
{
	s3c_irqsub_mask(irqno, INTMSK_ADCPARENT, 3 << 9);
}
static void
s3c_irq_adc_unmask(unsigned int irqno)
{
	s3c_irqsub_unmask(irqno, INTMSK_ADCPARENT);
}
static void
s3c_irq_adc_ack(unsigned int irqno)
{
	s3c_irqsub_ack(irqno, INTMSK_ADCPARENT, 3 << 9);
}
static void s3c2410_pm_run_sysram(run_fn_t fn, u32 *arg)
{
	s3c2410_pm_run_res(&iomem_resource, fn, arg);
}
static inline int is_sfn(unsigned long con)
{
	return (con == 2 || con == 3);
}
static inline int is_in(unsigned long con)
{
	return con == 0;
}
static inline int is_out(unsigned long con)
{
	return con == 1;
}
static inline int pwm_is_tdiv(struct pwm_device *pwm)
{
	return clk_get_parent(pwm->clk) == pwm->clk_div;
}
static int s3c2440_clk_init(void)
{
	return sysdev_driver_register(&s3c2440_sysclass, &s3c2440_clk_driver);
}
static int s3c2442_clk_init(void)
{
	return sysdev_driver_register(&s3c2442_sysclass, &s3c2442_clk_driver);
}
static void
s3c_irq_cam_mask(unsigned int irqno)
{
	s3c_irqsub_mask(irqno, INTMSK_CAM, 3<<11);
}
static void
s3c_irq_cam_unmask(unsigned int irqno)
{
	s3c_irqsub_unmask(irqno, INTMSK_CAM);
}
static void
s3c_irq_cam_ack(unsigned int irqno)
{
	s3c_irqsub_maskack(irqno, INTMSK_CAM, 3<<11);
}
static int s3c2440_irq_init(void)
{
	return sysdev_driver_register(&s3c2440_sysclass, &s3c2440_irq_driver);
}
static int s3c2442_irq_init(void)
{
	return sysdev_driver_register(&s3c2442_sysclass, &s3c2442_irq_driver);
}
void __init s3c244x_init_uarts(struct s3c2410_uartcfg *cfg, int no)
{
	s3c24xx_init_uartdevs("s3c2440-uart", s3c2410_uart_resources, cfg, no);
}
static int __init s3c2440_core_init(void)
{
	return sysdev_class_register(&s3c2440_sysclass);
}
static int __init s3c2442_core_init(void)
{
	return sysdev_class_register(&s3c2442_sysclass);
}
static int s3c64xx_pclk_ctrl(struct clk *clk, int enable)
{
	return s3c64xx_gate(S3C_PCLK_GATE, clk, enable);
}
static int s3c64xx_hclk_ctrl(struct clk *clk, int enable)
{
	return s3c64xx_gate(S3C_HCLK_GATE, clk, enable);
}
int s3c64xx_sclk_ctrl(struct clk *clk, int enable)
{
	return s3c64xx_gate(S3C_SCLK_GATE, clk, enable);
}
static inline void s3c_irq_eint_ack(unsigned int irq)
{
	__raw_writel(eint_irq_to_bit(irq), S3C64XX_EINT0PEND);
}
static void s3c_irq_demux_eint0_3(unsigned int irq, struct irq_desc *desc)
{
	s3c_irq_demux_eint(0, 3);
}
static void s3c_irq_demux_eint4_11(unsigned int irq, struct irq_desc *desc)
{
	s3c_irq_demux_eint(4, 11);
}
static void s3c_irq_demux_eint12_19(unsigned int irq, struct irq_desc *desc)
{
	s3c_irq_demux_eint(12, 19);
}
static void s3c_irq_demux_eint20_27(unsigned int irq, struct irq_desc *desc)
{
	s3c_irq_demux_eint(20, 27);
}
static void s3c_irq_demux_timer(unsigned int base_irq, unsigned int sub_irq)
{
	generic_handle_irq(sub_irq);
}
static void s3c_irq_demux_timer0(unsigned int irq, struct irq_desc *desc)
{
	s3c_irq_demux_timer(irq, IRQ_TIMER0);
}
static void s3c_irq_demux_timer1(unsigned int irq, struct irq_desc *desc)
{
	s3c_irq_demux_timer(irq, IRQ_TIMER1);
}
static void s3c_irq_demux_timer2(unsigned int irq, struct irq_desc *desc)
{
	s3c_irq_demux_timer(irq, IRQ_TIMER2);
}
static void s3c_irq_demux_timer3(unsigned int irq, struct irq_desc *desc)
{
	s3c_irq_demux_timer(irq, IRQ_TIMER3);
}
static void s3c_irq_demux_timer4(unsigned int irq, struct irq_desc *desc)
{
	s3c_irq_demux_timer(irq, IRQ_TIMER4);
}
static inline unsigned int s3c_irq_uart_bit(unsigned int irq)
{
	return irq & 3;
}
static inline struct clksrc_clk *to_clksrc(struct clk *clk)
{
	return container_of(clk, struct clksrc_clk, clk);
}
void __init s3c6400_common_init_uarts(struct s3c2410_uartcfg *cfg, int no)
{
	s3c24xx_init_uartdevs("s3c6400-uart", s3c64xx_uart_resources, cfg, no);
}
static void vfp_double_dump(const char *str, struct vfp_double *d)
{
	pr_debug("VFP: %s: sign=%d exponent=%d significand=%016llx\n",
		 str, d->sign != 0, d->exponent, d->significand);
}
static u32 vfp_double_fcmp(int dd, int unused, int dm, u32 fpscr)
{
	return vfp_compare(dd, 0, dm, fpscr);
}
static u32 vfp_double_fcmpe(int dd, int unused, int dm, u32 fpscr)
{
	return vfp_compare(dd, 1, dm, fpscr);
}
static u32 vfp_double_fcmpz(int dd, int unused, int dm, u32 fpscr)
{
	return vfp_compare(dd, 0, VFP_REG_ZERO, fpscr);
}
static u32 vfp_double_fcmpez(int dd, int unused, int dm, u32 fpscr)
{
	return vfp_compare(dd, 1, VFP_REG_ZERO, fpscr);
}
static u32 vfp_double_ftouiz(int sd, int unused, int dm, u32 fpscr)
{
	return vfp_double_ftoui(sd, unused, dm, FPSCR_ROUND_TOZERO);
}
static u32 vfp_double_ftosiz(int dd, int unused, int dm, u32 fpscr)
{
	return vfp_double_ftosi(dd, unused, dm, FPSCR_ROUND_TOZERO);
}
static u32 vfp_double_fmac(int dd, int dn, int dm, u32 fpscr)
{
	return vfp_double_multiply_accumulate(dd, dn, dm, fpscr, 0, "fmac");
}
static u32 vfp_double_fnmac(int dd, int dn, int dm, u32 fpscr)
{
	return vfp_double_multiply_accumulate(dd, dn, dm, fpscr, NEG_MULTIPLY, "fnmac");
}
static u32 vfp_double_fmsc(int dd, int dn, int dm, u32 fpscr)
{
	return vfp_double_multiply_accumulate(dd, dn, dm, fpscr, NEG_SUBTRACT, "fmsc");
}
static u32 vfp_double_fnmsc(int dd, int dn, int dm, u32 fpscr)
{
	return vfp_double_multiply_accumulate(dd, dn, dm, fpscr, NEG_SUBTRACT | NEG_MULTIPLY, "fnmsc");
}
void vfp_sync_state(struct thread_info *thread)
{
	thread->vfpstate.hard.cpu = NR_CPUS;
}
static void vfp_single_dump(const char *str, struct vfp_single *s)
{
	pr_debug("VFP: %s: sign=%d exponent=%d significand=%08x\n",
		 str, s->sign != 0, s->exponent, s->significand);
}
static u32 vfp_single_fcmp(int sd, int unused, s32 m, u32 fpscr)
{
	return vfp_compare(sd, 0, m, fpscr);
}
static u32 vfp_single_fcmpe(int sd, int unused, s32 m, u32 fpscr)
{
	return vfp_compare(sd, 1, m, fpscr);
}
static u32 vfp_single_fcmpz(int sd, int unused, s32 m, u32 fpscr)
{
	return vfp_compare(sd, 0, 0, fpscr);
}
static u32 vfp_single_fcmpez(int sd, int unused, s32 m, u32 fpscr)
{
	return vfp_compare(sd, 1, 0, fpscr);
}
static u32 vfp_single_ftouiz(int sd, int unused, s32 m, u32 fpscr)
{
	return vfp_single_ftoui(sd, unused, m, FPSCR_ROUND_TOZERO);
}
static u32 vfp_single_ftosiz(int sd, int unused, s32 m, u32 fpscr)
{
	return vfp_single_ftosi(sd, unused, m, FPSCR_ROUND_TOZERO);
}
static u32 vfp_single_fmac(int sd, int sn, s32 m, u32 fpscr)
{
	return vfp_single_multiply_accumulate(sd, sn, m, fpscr, 0, "fmac");
}
static u32 vfp_single_fnmac(int sd, int sn, s32 m, u32 fpscr)
{
	return vfp_single_multiply_accumulate(sd, sn, m, fpscr, NEG_MULTIPLY, "fnmac");
}
static u32 vfp_single_fmsc(int sd, int sn, s32 m, u32 fpscr)
{
	return vfp_single_multiply_accumulate(sd, sn, m, fpscr, NEG_SUBTRACT, "fmsc");
}
static u32 vfp_single_fnmsc(int sd, int sn, s32 m, u32 fpscr)
{
	return vfp_single_multiply_accumulate(sd, sn, m, fpscr, NEG_SUBTRACT | NEG_MULTIPLY, "fnmsc");
}
static u32 vfp_single_fsub(int sd, int sn, s32 m, u32 fpscr)
{
	return vfp_single_fadd(sd, sn, vfp_single_packed_negate(m), fpscr);
}
static int ads7843_get_pendown_state(void)
{
	return !gpio_get_value(GPIO_PIN_PB(3));
}
static void __exit
fram_cleanup_module(void)
{
	misc_deregister(&fram_dev);
}
static void *c_start(struct seq_file *m, loff_t *pos)
{
	return *pos < 1 ? (void *)1 : NULL;
}
void ack_bad_irq(unsigned int irq)
{
	printk("unexpected IRQ %u\n", irq);
}
int __weak nmi_enable(void)
{
	return -ENOSYS;
}
static void __kprobes set_current_kprobe(struct kprobe *p)
{
	__get_cpu_var(current_kprobe) = p;
}
void __kprobes jprobe_return(void)
{
	asm volatile("breakpoint" ::: "memory");
}
int __init arch_init_kprobes(void)
{
	return 0;
}
void module_arch_cleanup(struct module *module)
{
	module_bug_cleanup(module);
}
void machine_halt(void)
{
	asm volatile("sleep 3\n\t"
		     "sub pc, -2");
}
void exit_thread(void)
{
	ocd_disable(current);
}
static inline int valid_stack_ptr(struct thread_info *tinfo, unsigned long p)
{
	return (p > (unsigned long)tinfo)
		&& (p < (unsigned long)tinfo + THREAD_SIZE - 3);
}
void show_stack(struct task_struct *tsk, unsigned long *stack)
{
	show_stack_log_lvl(tsk, (unsigned long)stack, NULL, "");
}
int dump_fpu(struct pt_regs *regs, elf_fpregset_t *fpu)
{
	return 0;
}
asmlinkage int sys_fork(struct pt_regs *regs)
{
	return do_fork(SIGCHLD, regs->sp, regs, 0, NULL, NULL);
}
asmlinkage int sys_vfork(struct pt_regs *regs)
{
	return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, regs->sp, regs,
		       0, NULL, NULL);
}
static struct pt_regs *get_user_regs(struct task_struct *tsk)
{
	return (struct pt_regs *)((unsigned long)task_stack_page(tsk) +
				  THREAD_SIZE - sizeof(struct pt_regs));
}
static int __init parse_tag_clock(struct tag *tag)
{
	return 0;
}
asmlinkage int sys_sigaltstack(const stack_t __user *uss, stack_t __user *uoss,
			       struct pt_regs *regs)
{
	return do_sigaltstack(uss, uoss, regs->sp);
}
static cycle_t read_cycle_count(void)
{
	return (cycle_t)sysreg_read(COUNT);
}
asmlinkage void do_critical_exception(unsigned long ecr, struct pt_regs *regs)
{
	die("Critical exception", regs, SIGKILL);
}
asmlinkage void do_address_exception(unsigned long ecr, struct pt_regs *regs)
{
	_exception(SIGBUS, regs, BUS_ADRALN, regs->pc);
}
asmlinkage void do_fpe(unsigned long ecr, struct pt_regs *regs)
{
	_exception(SIGILL, regs, ILL_COPROC, regs->pc);
}
void __udelay(unsigned long usecs)
{
	__const_udelay(usecs * 0x000010c7); /* 2**32 / 1000000 (rounded up) */
}
void __ndelay(unsigned long nsecs)
{
	__const_udelay(nsecs * 0x00005); /* 2**32 / 1000000000 (rounded up) */
}
static unsigned long osc_get_rate(struct clk *clk)
{
	return at32_board_osc_rates[clk->index];
}
 static unsigned long bus_clk_get_rate(struct clk *clk, unsigned int shift)
{
	return main_clock->get_rate(main_clock) >> shift;
}
static inline void set_ebi_sfr_bits(u32 mask)
{
	hmatrix_sfr_set_bits(HMATRIX_SLAVE_EBI, mask);
}
void __init at32_setup_serial_console(unsigned int usart_id)
{
	atmel_default_console_device = at32_usarts[usart_id];
}
struct clk *clk_get_parent(struct clk *clk)
{
	return clk->parent;
}
static int clk_open(struct inode *inode, struct file *file)
{
	return single_open(file, clk_show, NULL);
}
static int __init at32_cpufreq_init(void)
{
	return cpufreq_register_driver(&at32_driver);
}
static int __init eic_init(void)
{
	return platform_driver_probe(&eic_driver, eic_probe);
}
static inline void __hmatrix_write_reg(unsigned long offset, u32 value)
{
	__raw_writel(value, (void __iomem __force *)(HMATRIX_BASE + offset));
}
static inline u32 __hmatrix_read_reg(unsigned long offset)
{
	return __raw_readl((void __iomem __force *)(HMATRIX_BASE + offset));
}
static int __init hsmc_init(void)
{
	return platform_driver_register(&hsmc_driver);
}
void intc_set_suspend_handler(unsigned long offset)
{
	intc0.suspend_ipr = offset;
}
unsigned long intc_get_pending(unsigned int group)
{
	return intc_readl(&intc0, INTREQ0 + 4 * group);
}
static int __init pdc_init(void)
{
	return platform_driver_probe(&pdc_driver, pdc_probe);
}
static int __init pio_init(void)
{
	return platform_driver_probe(&pio_driver, pio_probe);
}
static inline int notify_page_fault(struct pt_regs *regs, int trap)
{
	return 0;
}
void free_initmem(void)
{
	free_area((unsigned long)__init_begin, (unsigned long)__init_end,
		  "init");
}
void free_initrd_mem(unsigned long start, unsigned long end)
{
	free_area(start, end, "initrd");
}
static int tlb_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &tlb_ops);
}
static inline int valid_stack_ptr(struct thread_info *tinfo, unsigned long p)
{
	return (p > (unsigned long)tinfo)
		&& (p < (unsigned long)tinfo + THREAD_SIZE - 3);
}
static void avr32_perf_counter_reset(void)
{
	sysreg_write(PCCR, (SYSREG_BIT(PCCR_R)
				| SYSREG_BIT(PCCR_C)
				| SYSREG_BIT(FC)
				| SYSREG_BIT(F0)
				| SYSREG_BIT(F1)));
}
static int proc_dma_open(struct inode *inode, struct file *file)
{
	return single_open(file, proc_dma_show, NULL);
}
static int __init proc_dma_init(void)
{
	return proc_create("dma", 0, NULL, &proc_dma_operations) != NULL;
}
void __init blackfin_dma_early_init(void)
{
	bfin_write_MDMA_S0_CONFIG(0);
}
static void gpio_error(unsigned gpio)
{
	printk(KERN_ERR "bfin-gpio: GPIO %d wasn't requested!\n", gpio);
}
static char *get_label(unsigned short ident)
{
	return (*str_ident[ident].name ? str_ident[ident].name : "UNKNOWN");
}
u32 bfin_pm_standby_setup(void)
{
	return 0;
}
unsigned short get_gpio_dir(unsigned gpio)
{
	return (0x01 & (gpio_array[gpio_bank(gpio)]->dir_clear >> gpio_sub_n(gpio)));
}
int bfin_gpio_get_value(unsigned gpio)
{
	return (1 & (gpio_array[gpio_bank(gpio)]->data >> gpio_sub_n(gpio)));
}
int bfin_gpiolib_direction_input(struct gpio_chip *chip, unsigned gpio)
{
	return bfin_gpio_direction_input(gpio);
}
int bfin_gpiolib_direction_output(struct gpio_chip *chip, unsigned gpio, int level)
{
	return bfin_gpio_direction_output(gpio, level);
}
int bfin_gpiolib_get_value(struct gpio_chip *chip, unsigned gpio)
{
	return bfin_gpio_get_value(gpio);
}
void bfin_gpiolib_set_value(struct gpio_chip *chip, unsigned gpio, int value)
{
	return bfin_gpio_set_value(gpio, value);
}
int bfin_gpiolib_gpio_request(struct gpio_chip *chip, unsigned gpio)
{
	return bfin_gpio_request(gpio, chip->label);
}
void bfin_gpiolib_gpio_free(struct gpio_chip *chip, unsigned gpio)
{
	return bfin_gpio_free(gpio);
}
static int __init bfin_gpiolib_setup(void)
{
	return gpiochip_add(&bfin_chip);
}
static inline int write_permitted(int status, unsigned long data)
{
	if (status & FAULT_USERSUPV)
		return !!(data & CPLB_SUPV_WR);
	else
		return !!(data & CPLB_USER_WR);
}
static inline int write_permitted(int status, unsigned long data)
{
	if (status & FAULT_USERSUPV)
		return !!(data & CPLB_SUPV_WR);
	else
		return !!(data & CPLB_USER_WR);
}
static void cplbinfo_print_header(struct seq_file *m)
{
	seq_printf(m, "Index\tAddress\t\tData\tSize\tU/RD\tU/WR\tS/WR\tSwitch\n");
}
static int cplbinfo_nomore(struct cplbinfo_data *cdata)
{
	return cdata->pos >= MAX_CPLBS;
}
static void cplbinfo_stop(struct seq_file *m, void *p)
{
	put_cpu();
}
static inline unsigned int get_pages(size_t size)
{
	return ((size - 1) >> PAGE_SHIFT) + 1;
}
void
dma_free_coherent(struct device *dev, size_t size, void *vaddr,
		  dma_addr_t dma_handle)
{
	__free_dma_pages((unsigned long)vaddr, get_pages(size));
}
void dma_unmap_single(struct device *dev, dma_addr_t dma_addr, size_t size,
		enum dma_data_direction direction)
{
	BUG_ON(direction == DMA_NONE);
}
void dma_unmap_sg(struct device *dev, struct scatterlist *sg,
		int nhwentries, enum dma_data_direction direction)
{
	BUG_ON(direction == DMA_NONE);
}
static void __ipipe_ack_irq(unsigned irq, struct irq_desc *desc)
{
	desc->ipipe_ack(irq, desc);
}
int __ipipe_check_root(void)
{
	return ipipe_root_domain_p;
}
void ipipe_critical_exit(unsigned long flags)
{
	local_irq_restore_hw(flags);
}
void kgdb_passive_cpu_callback(void *info)
{
	kgdb_nmicallback(raw_smp_processor_id(), get_irq_regs());
}
void kgdb_roundup_cpus(unsigned long flags)
{
	smp_call_function(kgdb_passive_cpu_callback, NULL, 0);
}
void kgdb_roundup_cpu(int cpu, unsigned long flags)
{
	smp_call_function_single(cpu, kgdb_passive_cpu_callback, NULL, 0);
}
static void __exit kgdbtest_exit(void)
{
	remove_proc_entry("kgdbtest", NULL);
}
void module_free(struct module *mod, void *module_region)
{
	vfree(module_region);
}
int dump_fpu(struct pt_regs *regs, elf_fpregset_t * fpregs)
{
	return 1;
}
asmlinkage int bfin_vfork(struct pt_regs *regs)
{
	return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, rdusp(), regs, 0, NULL,
		       NULL);
}
static inline struct pt_regs *get_user_regs(struct task_struct *task)
{
	return (struct pt_regs *)
	    ((unsigned long)task_stack_page(task) +
	     (THREAD_SIZE - sizeof(struct pt_regs)));
}
void native_machine_halt(void)
{
	idle_with_irq_disabled();
}
void machine_halt(void)
{
	native_machine_halt();
}
void native_machine_power_off(void)
{
	idle_with_irq_disabled();
}
void machine_power_off(void)
{
	native_machine_power_off();
}
static u_long get_clkin_hz(void)
{
	return cached_clkin_hz;
}
asmlinkage int sys_sigaltstack(const stack_t __user *uss, stack_t __user *uoss)
{
	return do_sigaltstack(uss, uoss, rdusp());
}
asmlinkage long sys_mmap2(unsigned long addr, unsigned long len,
			  unsigned long prot, unsigned long flags,
			  unsigned long fd, unsigned long pgoff)
{
	return do_mmap2(addr, len, prot, flags, fd, pgoff);
}
asmlinkage int sys_getpagesize(void)
{
	return PAGE_SIZE;
}
asmlinkage void *sys_sram_alloc(size_t size, unsigned long flags)
{
	return sram_alloc_with_lsl(size, flags);
}
asmlinkage int sys_sram_free(const void *addr)
{
	return sram_free_with_lsl(addr);
}
asmlinkage void *sys_dma_memcpy(void *dest, const void *src, size_t len)
{
	return safe_dma_memcpy(dest, src, len);
}
static inline void set_cyc2ns_scale(unsigned long cpu_khz)
{
	cyc2ns_scale = (1000000 << CYC2NS_SCALE_FACTOR) / cpu_khz;
}
static inline unsigned long long cycles_2_ns(cycle_t cyc)
{
	return (cyc * cyc2ns_scale) >> CYC2NS_SCALE_FACTOR;
}
static cycle_t read_cycles(void)
{
	return __bfin_cycles_off + (get_cycles() << __bfin_cycles_mod);
}
unsigned long long sched_clock(void)
{
	return cycles_2_ns(read_cycles());
}
static inline int set_rtc_mmss(unsigned long nowtime)
{
	return 0;
}
unsigned long long sched_clock(void)
{
	return (unsigned long long)jiffies *(NSEC_PER_SEC / HZ);
}
__sum16 ip_fast_csum(unsigned char *iph, unsigned int ihl)
{
	return (__force __sum16)~do_csum(iph, ihl * 4);
}
__sum16 ip_compute_csum(const void *buff, int len)
{
	return (__force __sum16)~do_csum(buff, len);
}
int strcmp(const char *dest, const char *src)
{
	return __inline_strcmp(dest, src);
}
char *strcpy(char *dest, const char *src)
{
	return __inline_strcpy(dest, src);
}
int strncmp(const char *cs, const char *ct, size_t count)
{
	return __inline_strncmp(cs, ct, count);
}
char *strncpy(char *dest, const char *src, size_t n)
{
	return __inline_strncpy(dest, src, n);
}
static int bfin_plat_nand_dev_ready(struct mtd_info *mtd)
{
	return gpio_get_value(BFIN_NAND_PLAT_READY);
}
static void bfin_plat_nand_init(void)
{
	gpio_request(BFIN_NAND_PLAT_READY, "bfin_nand_plat");
}
static int bfin_mmc_spi_init(struct device *dev,
	irqreturn_t (*detect_int)(int, void *), void *data)
{
	return request_irq(MMC_SPI_CARD_DETECT_INT, detect_int,
		IRQF_TRIGGER_FALLING, "mmc-spi-detect", data);
}
static void bfin_mmc_spi_exit(struct device *dev, void *data)
{
	free_irq(MMC_SPI_CARD_DETECT_INT, data);
}
static ssize_t coreb_show_status(struct device *dev, struct device_attribute *attr, char *buf)
{
	return sprintf(buf,
		       "Base Address:\t0x%08lx\n"
		       "Core B is %s\n"
		       "SICA_SYSCR:\t%04x\n"
		       "SICB_SYSCR:\t%04x\n"
		       "\n"
		       "IRQ Status:\tCore A\t\tCore B\n"
		       "ISR0:\t\t%08x\t\t%08x\n"
		       "ISR1:\t\t%08x\t\t%08x\n"
		       "IMASK0:\t\t%08x\t\t%08x\n"
		       "IMASK1:\t\t%08x\t\t%08x\n",
		       coreb_base,
		       coreb_status & COREB_IS_RUNNING ? "running" : "stalled",
		       bfin_read_SICA_SYSCR(), bfin_read_SICB_SYSCR(),
		       bfin_read_SICA_ISR0(), bfin_read_SICB_ISR0(),
		       bfin_read_SICA_ISR1(), bfin_read_SICB_ISR0(),
		       bfin_read_SICA_IMASK0(), bfin_read_SICB_IMASK0(),
		       bfin_read_SICA_IMASK1(), bfin_read_SICB_IMASK1());
}
int __init setup_profiling_timer(unsigned int multiplier) /* not supported */
{
	return -EINVAL;
}
static void do_sync(void)
{
	__builtin_bfin_ssync();
}
static int bfin_verify_speed(struct cpufreq_policy *policy)
{
	return cpufreq_frequency_table_verify(policy, bfin_freq_table);
}
static int __init bfin_cpu_init(void)
{
	return cpufreq_register_driver(&bfin_driver);
}
static void __exit bfin_cpu_exit(void)
{
	cpufreq_unregister_driver(&bfin_driver);
}
static int __init bfin_dpmc_init(void)
{
	return platform_driver_register(&bfin_dpmc_device_driver);
}
static void __exit bfin_dpmc_exit(void)
{
	platform_driver_unregister(&bfin_dpmc_device_driver);
}
static void bfin_gpio_ack_irq(unsigned int irq)
{
	set_gpio_data(irq_to_gpio(irq), 0);
}
static void bfin_gpio_mask_irq(unsigned int irq)
{
	set_gpio_maska(irq_to_gpio(irq), 0);
}
static void bfin_gpio_unmask_irq(unsigned int irq)
{
	set_gpio_maska(irq_to_gpio(irq), 1);
}
static int bfin_pm_valid(suspend_state_t state)
{
	return (state == PM_SUSPEND_STANDBY
	|| state == PM_SUSPEND_MEM
	);
}
void __cpuinit reserve_pda(void)
{
	printk(KERN_INFO "PDA for CPU%u reserved at %p\n", smp_processor_id(),
					&cpu_pda[smp_processor_id()]);
}
void __init free_initrd_mem(unsigned long start, unsigned long end)
{
	free_init_pages("initrd memory", start, end);
}
void __init_refok free_initmem(void)
{
	free_init_pages("unused kernel memory",
			(unsigned long)(&__init_begin),
			(unsigned long)(&__init_end));
}
int sram_free(const void *addr)
{
	if (addr >= (void *)get_l1_code_start()
		 && addr < (void *)(get_l1_code_start() + L1_CODE_LENGTH))
		return l1_inst_sram_free(addr);
	else
	if (addr >= (void *)get_l1_data_a_start()
		 && addr < (void *)(get_l1_data_a_start() + L1_DATA_A_LENGTH))
		return l1_data_A_sram_free(addr);
	else
	if (addr >= (void *)get_l1_data_b_start()
		 && addr < (void *)(get_l1_data_b_start() + L1_DATA_B_LENGTH))
		return l1_data_B_sram_free(addr);
	else
	if (addr >= (void *)L2_START
		 && addr < (void *)(L2_START + L2_LENGTH))
		return l2_sram_free(addr);
	else
		return -1;
}
int __init oprofile_arch_init(struct oprofile_operations *ops)
{
	return -1;
}
void setup_normal_output_buffer(void)
{
	output_data = (char *)KERNEL_LOAD_ADR;
}
void usage(void)
{
	die("Usage: build bootsect setup system [rootdev] [> image]");
}
static void flash_copy_from(struct map_info *map, void *to,
			    unsigned long from, ssize_t len)
{
	memcpy(to, (void *)(map->map_priv_1 + from), len);
}
static void flash_write(struct map_info *map, map_word d, unsigned long adr)
{
	*(flash_data *)(map->map_priv_1 + adr) = (flash_data)d.x[0];
}
static int
i2c_release(struct inode *inode, struct file *filp)
{
	return 0;
}
void
pcf8563_writereg(int reg, unsigned char val)
{
	rtc_write(reg, val);
}
void __exit
pcf8563_exit(void)
{
	unregister_chrdev(PCF8563_MAJOR, DEVICE_NAME);
}
void
console_print_etrax(const char *buf)
{
	console_write(NULL, buf, strlen(buf));
}
static int dummy_open(struct tty_struct *tty, struct file * filp)
{
	return 0;
}
static int dummy_write(struct tty_struct * tty,
                       const unsigned char *buf, int count)
{
	return count;
}
static int dummy_write_room(struct tty_struct *tty)
{
	return 8192;
}
static inline int fast_timer_pending (const struct fast_timer * t)
{
  return (t->next != NULL) || (t->prev != NULL) || (t == fast_timer_list);
}
static unsigned char clear_group_from_set(const unsigned char groups, struct if_group *group)
{
	return (groups & ~group->group);
}
void
set_int_vector(int n, irqvectptr addr)
{
	etrax_irv->v[n + 0x20] = (irqvectptr)addr;
}
static void enable_crisv10_irq(unsigned int irq)
{
	unmask_irq(irq);
}
static void disable_crisv10_irq(unsigned int irq)
{
	mask_irq(irq);
}
static void
kill_restart ()
{
	machine_restart("");
}
void default_idle(void)
{
  etrax_gpio_wake_up_check();
}
unsigned long thread_saved_pc(struct task_struct *t)
{
	return task_pt_regs(t)->irp;
}
asmlinkage int sys_fork(long r10, long r11, long r12, long r13, long mof, long srp,
			struct pt_regs *regs)
{
	return do_fork(SIGCHLD, rdusp(), regs, 0, NULL, NULL);
}
asmlinkage int sys_vfork(long r10, long r11, long r12, long r13, long mof, long srp,
			 struct pt_regs *regs)
{
        return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, rdusp(), regs, 0, NULL, NULL);
}
unsigned long get_wchan(struct task_struct *p)
{
        return 0;
}
inline long get_reg(struct task_struct *task, unsigned int regno)
{
	if (regno == PT_USP)
		return task->thread.usp;
	else if (regno < PT_MAX)
		return ((unsigned long *)task_pt_regs(task))[regno];
	else
		return 0;
}
void 
ptrace_disable(struct task_struct *child)
{
       clear_tsk_thread_flag(child, TIF_SYSCALL_TRACE);
}
void
show_etrax_copyright(void)
{
	printk(KERN_INFO
               "Linux/CRIS port on ETRAX 100LX (c) 2001 Axis Communications AB\n");
}
int sys_sigaltstack(const stack_t *uss, stack_t __user *uoss)
{
	return do_sigaltstack(uss, uoss, rdusp());
}
void
arch_enable_nmi(void)
{
	asm volatile ("setf m");
}
void
prepare_rx_descriptor(struct etrax_dma_descr *desc)
{
	flush_etrax_cacherange((void *)desc->buf, desc->sw_len ? desc->sw_len : 65536);
}
void
flush_etrax_cache(void)
{
	flush_etrax_cacherange(0, 8192);
}
void
setup_normal_output_buffer(void)
{
	output_data = (char *)KERNEL_LOAD_ADR;
}
static void flash_copy_from(struct map_info *map, void *to,
			    unsigned long from, ssize_t len)
{
	memcpy(to, (void *)(map->map_priv_1 + from), len);
}
static void flash_write(struct map_info *map, map_word d, unsigned long adr)
{
	*(flash_data *)(map->map_priv_1 + adr) = (flash_data)d.x[0];
}
int cryptocop_job_queue_insert_csum(struct cryptocop_operation *operation)
{
	return cryptocop_job_queue_insert(cryptocop_prio_kernel_csum, operation);
}
int cryptocop_job_queue_insert_crypto(struct cryptocop_operation *operation)
{
	return cryptocop_job_queue_insert(cryptocop_prio_kernel, operation);
}
int cryptocop_job_queue_insert_user_job(struct cryptocop_operation *operation)
{
	return cryptocop_job_queue_insert(cryptocop_prio_user, operation);
}
static int
i2c_release(struct inode *inode, struct file *filp)
{
	return 0;
}
static int __init iop_fw_load_init(void)
{
	return 0;
}
void
pcf8563_writereg(int reg, unsigned char val)
{
	rtc_write(reg, val);
}
void __exit
pcf8563_exit(void)
{
	unregister_chrdev(PCF8563_MAJOR, DEVICE_NAME);
}
char * __devinit  pcibios_setup(char *str)
{
	return NULL;
}
static inline int fast_timer_pending (const struct fast_timer * t)
{
  return (t->next != NULL) || (t->prev != NULL) || (t == fast_timer_list);
}
void
unmask_irq(int irq)
{
	unblock_irq(irq, irq_cpu(irq));
}
static void shutdown_crisv32_irq(unsigned int irq)
{
	mask_irq(irq);
}
static void enable_crisv32_irq(unsigned int irq)
{
	unmask_irq(irq);
}
static void disable_crisv32_irq(unsigned int irq)
{
	mask_irq(irq);
}
void
set_exception_vector(int n, irqvectptr addr)
{
	etrax_irv->v[n] = (irqvectptr) addr;
}
int getDebugChar(void)
{
  return socketread();
}
void putDebugChar(int val)
{
  socketwrite((char *)&val, 1);
}
static void
kill_restart(void)
{
	machine_restart("");
}
void exit_thread(void)
{
	deconfigure_bp(current->pid);
}
unsigned long thread_saved_pc(struct task_struct *t)
{
	return task_pt_regs(t)->erp;
}
asmlinkage int
sys_fork(long r10, long r11, long r12, long r13, long mof, long srp,
	struct pt_regs *regs)
{
	return do_fork(SIGCHLD, rdusp(), regs, 0, NULL, NULL);
}
asmlinkage int
sys_vfork(long r10, long r11, long r12, long r13, long mof, long srp,
	struct pt_regs *regs)
{
	return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, rdusp(), regs, 0, NULL, NULL);
}
unsigned long
get_wchan(struct task_struct *p)
{
	return 0;
}
void
show_etrax_copyright(void)
{
	printk(KERN_INFO
               "Linux/CRISv32 port on ETRAX FS (C) 2003, 2004 Axis Communications AB\n");
}
int
sys_sigaltstack(const stack_t __user *uss, stack_t __user *uoss)
{
	return do_sigaltstack(uss, uoss, rdusp());
}
void smp_send_stop(void)
{
	smp_call_function(stop_this_cpu, NULL, 0);
}
int setup_profiling_timer(unsigned int multiplier)
{
	return -EINVAL;
}
static int cris_freq_verify(struct cpufreq_policy *policy)
{
	return cpufreq_frequency_table_verify(policy, &cris_freq_table[0]);
}
static int cris_freq_verify(struct cpufreq_policy *policy)
{
	return cpufreq_frequency_table_verify(policy, &cris_freq_table[0]);
}
unsigned hook_buf(unsigned i)
{
	return (HOOK_DATA(i));
}
void CPU_KICK_DOG(void)
{
	(void)hook_call(hook_kick_dog, 0);
}
void CPU_WATCHDOG_TIMEOUT(unsigned t)
{
	(void)hook_call(hook_dog_timeout, 1, t);
}
void* crisv32_intmem_phys_to_virt(unsigned long addr)
{
	return (void *)(addr - (MEM_INTMEM_START + RESERVED_SIZE) +
		(unsigned long)intmem_virtual);
}
unsigned long crisv32_intmem_virt_to_phys(void* addr)
{
	return (unsigned long)((unsigned long )addr -
		(unsigned long)intmem_virtual + MEM_INTMEM_START +
		RESERVED_SIZE);
}
void ack_bad_irq(unsigned int irq)
{
	printk("unexpected IRQ trap at vector %02x\n", irq);
}
void module_free(struct module *mod, void *module_region)
{
	FREE_MODULE(module_region);
}
int module_frob_arch_sections(Elf_Ehdr *hdr,
			      Elf_Shdr *sechdrs,
			      char *secstrings,
			      struct module *mod)
{
	return 0;
}
int module_finalize(const Elf_Ehdr *hdr,
		    const Elf_Shdr *sechdrs,
		    struct module *me)
{
 	return 0;
}
void disable_hlt(void)
{
	cris_hlt_counter++;
}
void enable_hlt(void)
{
	cris_hlt_counter--;
}
void machine_restart(char *cmd)
{
	hard_reset_now();
}
int dump_fpu(struct pt_regs *regs, elf_fpregset_t *fpu)
{
        return 0;
}
static void *c_start(struct seq_file *m, loff_t *pos)
{
	return *pos < NR_CPUS ? (void *)(int)(*pos + 1): NULL;
}
asmlinkage long
sys_mmap2(unsigned long addr, unsigned long len, unsigned long prot,
          unsigned long flags, unsigned long fd, unsigned long pgoff)
{
        return do_mmap2(addr, len, prot, flags, fd, pgoff);
}
unsigned long long sched_clock(void)
{
	return (unsigned long long)jiffies * (1000000000 / HZ) +
		get_ns_in_jiffie();
}
void
dump_stack(void)
{
	show_stack(NULL, NULL);
}
void __iomem * __ioremap(unsigned long phys_addr, unsigned long size, unsigned long flags)
{
	return __ioremap_prot(phys_addr, size,
		              __pgprot(_PAGE_PRESENT | __READABLE |
				       __WRITEABLE | _PAGE_GLOBAL |
				       _PAGE_KERNEL | flags));
}
void __iomem *ioremap_nocache (unsigned long phys_addr, unsigned long size)
{
        return __ioremap(phys_addr | MEM_NON_CACHEABLE, size, 0);
}
void debug_stub_exit(int status)
{
	gdbstub_exit(status);

} /* end debug_stub_exit() */
void __debug_bug_printk(const char *file, unsigned line)
{
	printk("kernel BUG at %s:%d!\n", file, line);

} /* end __debug_bug_printk() */
static void gdbstub_purge_cache(void)
{
	asm volatile("	dcef	@(gr0,gr0),#1	\n"
		     "	icei	@(gr0,gr0),#1	\n"
		     "	membar			\n"
		     "	bar			\n"
		     );
}
static void *malloc(size_t size)
{
	return kmalloc(size, GFP_ATOMIC);
}
static void free(void *p)
{
	kfree(p);
}
static uint32_t ___get_HSR0(void)
{
	return __get_HSR(0);
}
static void frv_fpga_ack(unsigned int irq)
{
	__clr_IFR(1 << (irq - IRQ_BASE_FPGA));
}
static void frv_fpga_ack(unsigned int irq)
{
	__clr_IFR(1 << (irq - IRQ_BASE_FPGA));
}
static void frv_cpupic_mask(unsigned int irqlevel)
{
	__set_MASK(irqlevel);
}
static void frv_cpupic_unmask(unsigned int irqlevel)
{
	__clr_MASK(irqlevel);
}
static void frv_cpupic_end(unsigned int irqlevel)
{
	__clr_MASK(irqlevel);
}
void module_free(struct module *mod, void *module_region)
{
	vfree(module_region);
}
int module_frob_arch_sections(Elf_Ehdr *hdr,
			      Elf_Shdr *sechdrs,
			      char *secstrings,
			      struct module *mod)
{
	return 0;
}
int module_finalize(const Elf_Ehdr *hdr,
		    const Elf_Shdr *sechdrs,
		    struct module *me)
{
	return 0;
}
static void mb93093_power_switch_cleanup(void)
{
	*(volatile unsigned long *)0xfeff9820 = imask;
}
static int mb93093_power_switch_check(void)
{
	return 1;
}
static void __default_power_switch_cleanup(void)
{
	*(unsigned long *)0xfeff9820 = __irq_mask;
}
static int __default_power_switch_check(void)
{
	return 1;
}
unsigned long sleep_phys_sp(void *sp)
{
	return virt_to_phys(sp);
}
void flush_thread(void)
{
	set_fs(USER_DS);
}
asmlinkage int sys_fork(void)
{
	return -EINVAL;
}
asmlinkage int sys_vfork(void)
{
	return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, user_stack(__frame), __frame, 0,
		       NULL, NULL);
}
unsigned long thread_saved_pc(struct task_struct *tsk)
{
	if (in_sched_functions(tsk->thread.pc))
		return ((unsigned long *)tsk->thread.fp)[2];
	else
		return tsk->thread.pc;
}
void ptrace_disable(struct task_struct *child)
{
	child->thread.frame0->__status &= ~REG__STATUS_STEP;
}
void ptrace_enable(struct task_struct *child)
{
	child->thread.frame0->__status |= REG__STATUS_STEP;
}
static void *c_start(struct seq_file *m, loff_t *pos)
{
	return *pos < NR_CPUS ? (void *) 0x12345678 : NULL;
}
void arch_gettod(int *year, int *mon, int *day, int *hour,
		 int *min, int *sec)
{
	*year = *mon = *day = *hour = *min = *sec = 0;
}
int sys_sigaltstack(const stack_t __user *uss, stack_t __user *uoss)
{
	return do_sigaltstack(uss, uoss, __frame->sp);
}
static inline int set_rtc_mmss(unsigned long nowtime)
{
	return -1;
}
unsigned long long sched_clock(void)
{
	return jiffies_64 * (1000000000 / HZ);
}
void dump_stack(void)
{
	show_stack(NULL, NULL);
}
void show_trace_task(struct task_struct *tsk)
{
	printk("CONTEXT: stack=0x%lx frame=0x%p LR=0x%lx RET=0x%lx\n",
	       tsk->thread.sp, tsk->thread.frame, tsk->thread.lr, tsk->thread.sched_lr);
}
__sum16 ip_compute_csum(const void *buff, int len)
{
	return (__force __sum16)~do_csum(buff, len);
}
void dma_free_coherent(struct device *hwdev, size_t size, void *vaddr, dma_addr_t dma_handle)
{
	consistent_free(vaddr);
}
void pcibios_enable_irq(struct pci_dev *dev)
{
	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, dev->irq);
}
static inline int __query(const struct pci_dev *dev)
{
	return 0;
}
struct page *kmap_atomic_to_page(void *ptr)
{
	return virt_to_page(ptr);
}
void __iomem *__ioremap(unsigned long physaddr, unsigned long size, int cacheflag)
{
	return (void __iomem *)physaddr;
}
void pgd_free(struct mm_struct *mm, pgd_t *pgd)
{
 	quicklist_free(0, pgd_dtor, pgd);
}
void check_pgt_cache(void)
{
	quicklist_trim(0, pgd_dtor, 25, 16);
}
int puts(const char *s)
{
	return 0;
}
void __init h8300_gpio_init(void)
{
	memcpy(gpio_regs,_platform_gpio_table(sizeof(gpio_regs)),sizeof(gpio_regs));
}
static inline int is_ext_irq(unsigned int irq)
{
	return (irq >= EXT_IRQ0 && irq <= (EXT_IRQ0 + EXT_IRQS));
}
static unsigned int h8300_startup_irq(unsigned int irq)
{
	if (is_ext_irq(irq))
		return h8300_enable_irq_pin(irq);
	else
		return 0;
}
void ack_bad_irq(unsigned int irq)
{
	printk("unexpected IRQ trap at vector %02x\n", irq);
}
void module_free(struct module *mod, void *module_region)
{
	vfree(module_region);
}
int module_frob_arch_sections(Elf_Ehdr *hdr,
			      Elf_Shdr *sechdrs,
			      char *secstrings,
			      struct module *mod)
{
	return 0;
}
int module_finalize(const Elf_Ehdr *hdr,
		    const Elf_Shdr *sechdrs,
		    struct module *me)
{
	return module_bug_finalize(hdr, sechdrs, me);
}
void module_arch_cleanup(struct module *mod)
{
	module_bug_cleanup(mod);
}
static void default_idle(void)
{
	cpu_relax();
}
asmlinkage int h8300_fork(struct pt_regs *regs)
{
	return -EINVAL;
}
asmlinkage int h8300_vfork(struct pt_regs *regs)
{
	return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, rdusp(), regs, 0, NULL, NULL);
}
unsigned long thread_saved_pc(struct task_struct *tsk)
{
	return ((struct pt_regs *)tsk->thread.esp0)->pc;
}
void ptrace_disable(struct task_struct *child)
{
	h8300_disable_trace(child);
}
static int __init gdb_console_setup(struct console *co, char *options)
{
	return 0;
}
static void *c_start(struct seq_file *m, loff_t *pos)
{
	return *pos < NR_CPUS ? ((void *) 0x12345678) : NULL;
}
asmlinkage int
sys_sigaltstack(const stack_t *uss, stack_t *uoss)
{
	return do_sigaltstack(uss, uoss, rdusp());
}
asmlinkage long sys_mmap2(unsigned long addr, unsigned long len,
	unsigned long prot, unsigned long flags,
	unsigned long fd, unsigned long pgoff)
{
	return do_mmap2(addr, len, prot, flags, fd, pgoff);
}
asmlinkage int
sys_cacheflush (unsigned long addr, int scope, int cache, unsigned long len)
{
	return -EINVAL;
}
asmlinkage int sys_getpagesize(void)
{
	return PAGE_SIZE;
}
asmlinkage void set_esp0 (unsigned long ssp)
{
	current->thread.esp0 = ssp;
}
void show_trace_task(struct task_struct *tsk)
{
	show_stack(tsk,(unsigned long *)tsk->thread.esp0);
}
void dump_stack(void)
{
	show_stack(NULL,NULL);
}
__sum16 ip_fast_csum(const void *iph, unsigned int ihl)
{
	return (__force __sum16)~do_csum(iph,ihl*4);
}
__sum16 ip_compute_csum(const void *buff, int len)
{
	return (__force __sum16)~do_csum(buff,len);
}
void *__ioremap(unsigned long physaddr, unsigned long size, int cacheflag)
{
	return (void *)(physaddr + VIRT_OFFSET);
}
unsigned long kernel_map(unsigned long paddr, unsigned long size,
			 int nocacheflag, unsigned long *memavailp )
{
	return paddr;
}
void h8300_disable_trace(struct task_struct *child)
{
	*(unsigned short *)(child->thread.esp0 + h8300_register_offset[PT_EXR]) &= ~EXR_TRACE;
}
void h8300_enable_trace(struct task_struct *child)
{
	*(unsigned short *)(child->thread.esp0 + h8300_register_offset[PT_EXR]) |= EXR_TRACE;
}
static int aml_nfw_add(struct acpi_device *device)
{
	return aml_nfw_add_global_handler();
}
static int aml_nfw_remove(struct acpi_device *device, int type)
{
	return aml_nfw_remove_global_handler();
}
static inline int use_swiotlb(struct device *dev)
{
	return dev && dev->dma_mask &&
		!sba_dma_ops.dma_supported(dev, *dev->dma_mask);
}
static unsigned long ptr_to_pide(struct ioc *ioc, unsigned long *res_ptr,
				 unsigned int bitshiftcnt)
{
	return (((unsigned long)res_ptr - (unsigned long)ioc->res_map) << 3)
		+ bitshiftcnt;
}
static dma_addr_t sba_map_single_attrs(struct device *dev, void *addr,
				       size_t size, enum dma_data_direction dir,
				       struct dma_attrs *attrs)
{
	return sba_map_page(dev, virt_to_page(addr),
			    (unsigned long)addr & ~PAGE_MASK, size, dir, attrs);
}
void sba_unmap_single_attrs(struct device *dev, dma_addr_t iova, size_t size,
			    enum dma_data_direction dir, struct dma_attrs *attrs)
{
	sba_unmap_page(dev, iova, size, dir, attrs);
}
static int
ioc_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &ioc_seq_ops);
}
static int sba_dma_supported (struct device *dev, u64 mask)
{
	return ((mask & 0xFFFFFFFFUL) == 0xFFFFFFFFUL);
}
static int sba_dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
{
	return 0;
}
void sba_dma_init(void)
{
	dma_ops = &sba_dma_ops;
}
static void
efi_reset_system (int reset_type, efi_status_t status, unsigned long data_size, efi_char16_t *data)
{
	ssc(status, 0, 0, 0, SSC_EXIT);
}
static efi_status_t
efi_unimplemented (void)
{
	return EFI_UNSUPPORTED;
}
static int
simcons_init (struct console *cons, char *options)
{
	return 0;
}
static unsigned int
hpsim_irq_startup (unsigned int irq)
{
	return 0;
}
void
ia64_ssc_connect_irq (long intr, long irq)
{
	ia64_ssc(intr, irq, 0, 0, SSC_CONNECT_INTERRUPT);
}
void
ia64_ctl_trace (long on)
{
	ia64_ssc(on, 0, 0, 0, SSC_CTL_TRACE);
}
static inline int
netdev_probe(char *name, unsigned char *ether)
{
	return ia64_ssc(__pa(name), __pa(ether), 0,0, SSC_NETDEV_PROBE);
}
static inline int
netdev_attach(int fd, int irq, unsigned int ipaddr)
{
	return ia64_ssc(fd, ipaddr, 0,0, SSC_NETDEV_ATTACH);
}
static inline int
netdev_detach(int fd)
{
	return ia64_ssc(fd, 0,0,0, SSC_NETDEV_DETACH);
}
static inline int
netdev_send(int fd, unsigned char *buf, unsigned int len)
{
	return ia64_ssc(fd, __pa(buf), len, 0, SSC_NETDEV_SEND);
}
static inline int
netdev_read(int fd, unsigned char *buf, unsigned int len)
{
	return ia64_ssc(fd, __pa(buf), len, 0, SSC_NETDEV_RECV);
}
static __inline__ int dev_is_ethdev(struct net_device *dev)
{
       return ( dev->type == ARPHRD_ETHER && strncmp(dev->name, "dummy", 5));
}
static void
set_multicast_list(struct net_device *dev)
{
	printk(KERN_WARNING "%s: set_multicast_list called\n", dev->name);
}
static void rs_stop(struct tty_struct *tty)
{
	printk("rs_stop: tty->stopped=%d tty->hw_stopped=%d tty->flow_stopped=%d\n",
		tty->stopped, tty->hw_stopped, tty->flow_stopped);
}
static void rs_start(struct tty_struct *tty)
{
	printk("rs_start: tty->stopped=%d tty->hw_stopped=%d tty->flow_stopped=%d\n",
		tty->stopped, tty->hw_stopped, tty->flow_stopped);
}
static void do_softint(struct work_struct *private_)
{
	printk(KERN_ERR "simserial: do_softint called\n");
}
static inline int line_info(char *buf, struct serial_state *state)
{
	return sprintf(buf, "%d: uart:%s port:%lX irq:%d\n",
		       state->line, uart_config[state->type].name,
		       state->port, state->irq);
}
int
ia32_setup_frame1 (int sig, struct k_sigaction *ka, siginfo_t *info,
		   sigset_t *set, struct pt_regs *regs)
{
       if (ka->sa.sa_flags & SA_SIGINFO)
               return setup_rt_frame_ia32(sig, ka, info, set, regs);
       else
               return setup_frame_ia32(sig, ka, set, regs);
}
void
ia32_cpu_init (void)
{
	ia64_setreg(_IA64_REG_AR_CFLAG, (((ulong) IA32_CR4 << 32) | IA32_CR0));
}
asmlinkage unsigned long
sys32_alarm (unsigned int seconds)
{
	return alarm_setitimer(seconds);
}
asmlinkage long
sys32_waitpid (int pid, unsigned int *stat_addr, int options)
{
	return compat_sys_wait4(pid, stat_addr, options, NULL);
}
asmlinkage long
sys32_lseek (unsigned int fd, int offset, unsigned int whence)
{
	return sys_lseek(fd, offset, whence);
}
asmlinkage long
sys32_truncate64 (unsigned int path, unsigned int len_lo, unsigned int len_hi)
{
	return sys_truncate(compat_ptr(path), ((unsigned long) len_hi << 32) | len_lo);
}
asmlinkage long
sys32_ftruncate64 (int fd, unsigned int len_lo, unsigned int len_hi)
{
	return sys_ftruncate(fd, ((unsigned long) len_hi << 32) | len_lo);
}
asmlinkage long
sys32_pread (unsigned int fd, void __user *buf, unsigned int count, u32 pos_lo, u32 pos_hi)
{
	return sys_pread64(fd, buf, count, ((unsigned long) pos_hi << 32) | pos_lo);
}
asmlinkage long
sys32_pwrite (unsigned int fd, void __user *buf, unsigned int count, u32 pos_lo, u32 pos_hi)
{
	return sys_pwrite64(fd, buf, count, ((unsigned long) pos_hi << 32) | pos_lo);
}
static int ia32_fpregs_get(struct task_struct *target,
		const struct user_regset *regset,
		unsigned int pos, unsigned int count,
		void *kbuf, void __user *ubuf)
{
	return do_regset_call(do_fpregs_get, target, regset, pos, count,
		kbuf, ubuf);
}
static int ia32_fpregs_set(struct task_struct *target,
		const struct user_regset *regset,
		unsigned int pos, unsigned int count,
		const void *kbuf, const void __user *ubuf)
{
	return do_regset_call(do_fpregs_set, target, regset, pos, count,
		kbuf, ubuf);
}
static int ia32_fpxregs_get(struct task_struct *target,
		const struct user_regset *regset,
		unsigned int pos, unsigned int count,
		void *kbuf, void __user *ubuf)
{
	return do_regset_call(do_fpxregs_get, target, regset, pos, count,
		kbuf, ubuf);
}
static int ia32_fpxregs_set(struct task_struct *target,
		const struct user_regset *regset,
		unsigned int pos, unsigned int count,
		const void *kbuf, const void __user *ubuf)
{
	return do_regset_call(do_fpxregs_set, target, regset, pos, count,
		kbuf, ubuf);
}

long sys32_fadvise64_64(int fd, __u32 offset_low, __u32 offset_high, 
			__u32 len_low, __u32 len_high, int advice)
{ 
	return sys_fadvise64_64(fd,
			       (((u64)offset_high)<<32) | offset_low,
			       (((u64)len_high)<<32) | len_low,
			       advice); 
} 
char *__init __acpi_map_table(unsigned long phys_addr, unsigned long size)
{
	return __va(phys_addr);
}
void set_cpei_target_cpu(unsigned int cpu)
{
	acpi_cpei_phys_cpuid = cpu_physical_id(cpu);
}
unsigned int get_cpei_target_cpu(void)
{
	return acpi_cpei_phys_cpuid;
}
int acpi_unregister_ioapic(acpi_handle handle, u32 gsi_base)
{
	return iosapic_remove(gsi_base);
}
 int acpi_save_state_mem(void) { return 0; } 
static void
final_note(void *buf)
{
	memset(buf, 0, sizeof(struct elf_note));
}
void __init cyclone_setup(void)
{
	use_cyclone = 1;
}
static cycle_t read_cyclone(void)
{
	return (cycle_t)readq((void __iomem *)cyclone_mc);
}
struct dma_map_ops *dma_get_ops(struct device *dev)
{
	return dma_ops;
}
static inline u64
kmd_end(kern_memdesc_t *kmd)
{
	return (kmd->start + (kmd->num_pages << EFI_PAGE_SHIFT));
}
static inline u64
efi_md_end(efi_memory_desc_t *md)
{
	return (md->phys_addr + efi_md_size(md));
}
static inline int
efi_wb(efi_memory_desc_t *md)
{
	return (md->attribute & EFI_MEMORY_WB);
}
static inline int
efi_uc(efi_memory_desc_t *md)
{
	return (md->attribute & EFI_MEMORY_UC);
}
void
efi_memmap_walk (efi_freemem_callback_t callback, void *arg)
{
	walk(callback, arg, EFI_MEMORY_WB);
}
void
efi_memmap_walk_uc (efi_freemem_callback_t callback, void *arg)
{
	walk(callback, arg, EFI_MEMORY_UC);
}
static int __cpuinit err_inject_add_dev(struct sys_device * sys_dev)
{
	return sysfs_create_group(&sys_dev->kobj, &err_inject_attr_group);
}
static unsigned char *ftrace_nop_replace(void)
{
	return ftrace_nop_code;
}
static unsigned int
iosapic_version (char __iomem *addr)
{
	return __iosapic_read(addr, IOSAPIC_VERSION);
}
static inline int irq_is_shared (int irq)
{
	return (iosapic_intr_info[irq].count > 1);
}
struct irq_chip*
ia64_native_iosapic_get_irq_chip(unsigned long trigger)
{
	if (trigger == IOSAPIC_EDGE)
		return &irq_type_iosapic_edge;
	else
		return &irq_type_iosapic_level;
}
static inline void
iosapic_free (int index)
{
	memset(&iosapic_lists[index], 0, sizeof(iosapic_lists[0]));
}
void ack_bad_irq(unsigned int irq)
{
	printk(KERN_ERR "Unexpected irq vector 0x%x on CPU %u!\n", irq, smp_processor_id());
}
ia64_vector __ia64_irq_to_vector(int irq)
{
	return irq_cfg[irq].vector;
}
unsigned int __ia64_local_vector_to_irq (ia64_vector vec)
{
	return __get_cpu_var(vector_irq)[vec];
}
static cpumask_t vector_allocation_domain(int cpu)
{
	return CPU_MASK_ALL;
}
static irqreturn_t dummy_handler (int irq, void *dev_id)
{
	BUG();
}
static unsigned int
lsapic_noop_startup (unsigned int irq)
{
	return 0;
}
static int __kprobes in_ivt_functions(unsigned long addr)
{
	return (addr >= (unsigned long)__start_ivt_text
		&& addr < (unsigned long)__end_ivt_text);
}
static void __kprobes set_current_kprobe(struct kprobe *p,
			struct kprobe_ctlblk *kcb)
{
	__get_cpu_var(current_kprobe) = p;
}
unsigned long arch_deref_entry_point(void *entry)
{
	return ((struct fnptr *)entry)->ip;
}
unsigned long paddr_vmcoreinfo_note(void)
{
	return ia64_tpa((unsigned long)(char *)&vmcoreinfo_note);
}
void
machvec_dma_sync_single(struct device *hwdev, dma_addr_t dma_handle, size_t size,
			enum dma_data_direction dir)
{
	mb();
}
void
machvec_dma_sync_sg(struct device *hwdev, struct scatterlist *sg, int n,
		    enum dma_data_direction dir)
{
	mb();
}
static void
ia64_mca_cmc_vector_disable_keventd(struct work_struct *unused)
{
	on_each_cpu(ia64_mca_cmc_vector_disable, NULL, 0);
}
static void
ia64_mca_cmc_vector_enable_keventd(struct work_struct *unused)
{
	on_each_cpu(ia64_mca_cmc_vector_enable, NULL, 0);
}
static void
ia64_mca_wakeup(int cpu)
{
	platform_send_ipi(cpu, IA64_MCA_WAKEUP_VECTOR, IA64_IPI_DM_INT, 0);
}
static irqreturn_t
ia64_mca_wakeup_int_handler(int wakeup_irq, void *arg)
{
	return IRQ_HANDLED;
}
static void
ia64_mca_cmc_poll (unsigned long dummy)
{
	platform_send_ipi(first_cpu(cpu_online_map), IA64_CMCP_VECTOR, IA64_IPI_DM_INT, 0);
}
static void
ia64_mca_cpe_poll (unsigned long dummy)
{
	platform_send_ipi(first_cpu(cpu_online_map), IA64_CPEP_VECTOR, IA64_IPI_DM_INT, 0);
}
static void * __init_refok mca_bootmem(void)
{
	return __alloc_bootmem(sizeof(struct ia64_mca_cpu),
	                    KERNEL_STACK_SIZE, 0);
}
static inline uint64_t
bundle (const struct insn *insn)
{
	return (uint64_t) insn & ~0xfUL;
}
static inline int
slot (const struct insn *insn)
{
	return (uint64_t) insn & 0x3;
}
static inline int
in_init (const struct module *mod, uint64_t addr)
{
	return addr - (uint64_t) mod->module_init < mod->init_size;
}
static inline int
in_core (const struct module *mod, uint64_t addr)
{
	return addr - (uint64_t) mod->module_core < mod->core_size;
}
static inline int
is_internal (const struct module *mod, uint64_t value)
{
	return in_init(mod, value) || in_core(mod, value);
}
static inline int
gp_addressable (struct module *mod, uint64_t value)
{
	return value - mod->arch.gp + MAX_LTOFF/2 < MAX_LTOFF;
}
void ia64_teardown_msi_irq(unsigned int irq)
{
	destroy_irq(irq);
}
	static void						\
	ia64_native_ ## name ## _func(unsigned long arg)	\
	{							\
		ia64_native_ ## name(arg);			\
	}							\
	static void						\
	ia64_native_ ## name ## _func(unsigned long arg0,	\
				      unsigned long arg1)	\
	{							\
		ia64_native_ ## name(arg0, arg1);		\
	}							\
	static unsigned long			\
	ia64_native_ ## name ## _func(void)	\
	{					\
		return ia64_native_ ## name();	\
	}
	static unsigned long				\
	ia64_native_ ## name ## _func(type arg)		\
	{						\
		return ia64_native_ ## name(arg);	\
	}						\
static void
ia64_native_ssm_i_func(void)
{
	ia64_native_ssm(IA64_PSR_I);
}
static void
ia64_native_rsm_i_func(void)
{
	ia64_native_rsm(IA64_PSR_I);
}
static void
ia64_native_set_rr0_to_rr4_func(unsigned long val0, unsigned long val1,
				unsigned long val2, unsigned long val3,
				unsigned long val4)
{
	ia64_native_set_rr0_to_rr4(val0, val1, val2, val3, val4);
}
static unsigned int
ia64_native_iosapic_read(char __iomem *iosapic, unsigned int reg)
{
	return __ia64_native_iosapic_read(iosapic, reg);
}
static void
ia64_native_iosapic_write(char __iomem *iosapic, unsigned int reg, u32 val)
{
	__ia64_native_iosapic_write(iosapic, reg, val);
}
static int
ia64_native_do_steal_accounting(unsigned long *new_itm)
{
	return 0;
}
void pci_iommu_shutdown(void)
{
	return;
}
void __init
iommu_dma_init(void)
{
	return;
}
static int vtd_dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
{
	return 0;
}
static inline void
pfm_reserve_page(unsigned long a)
{
	SetPageReserved(vmalloc_to_page((void *)a));
}
static inline void
pfm_unreserve_page(unsigned long a)
{
	ClearPageReserved(vmalloc_to_page((void*)a));
}
static inline void
pfm_unprotect_ctx_ctxsw(pfm_context_t *x, unsigned long f)
{
	spin_unlock(&(x)->ctx_lock);
}
static inline unsigned int
pfm_do_munmap(struct mm_struct *mm, unsigned long addr, size_t len, int acct)
{
	return do_munmap(mm, addr, len);
}
static inline unsigned long 
pfm_get_unmapped_area(struct file *file, unsigned long addr, unsigned long len, unsigned long pgoff, unsigned long flags, unsigned long exec)
{
	return get_unmapped_area(file, addr, len, pgoff, flags);
}
static int
pfmfs_get_sb(struct file_system_type *fs_type, int flags, const char *dev_name, void *data,
	     struct vfsmount *mnt)
{
	return get_sb_pseudo(fs_type, "pfm:", NULL, PFMFS_MAGIC, mnt);
}
static inline unsigned long
pfm_read_soft_counter(pfm_context_t *ctx, int i)
{
	return ctx->ctx_pmds[i].val + (ia64_get_pmd(i) & pmu_conf->ovfl_val);
}
static inline int
pfm_uuid_cmp(pfm_uuid_t a, pfm_uuid_t b)
{
	return memcmp(a, b, sizeof(pfm_uuid_t));
}
static int
pfmfs_delete_dentry(struct dentry *dentry)
{
	return 1;
}
static int
pfm_write_ibrs(pfm_context_t *ctx, void *arg, int count, struct pt_regs *regs)
{
	return pfm_write_ibr_dbr(PFM_CODE_RR, ctx, arg, count, regs);
}
static int
pfm_write_dbrs(pfm_context_t *ctx, void *arg, int count, struct pt_regs *regs)
{
	return pfm_write_ibr_dbr(PFM_DATA_RR, ctx, arg, count, regs);
}
static int
pfm_proc_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &pfm_seq_ops);
}
asmlinkage long
sys_perfmonctl (int fd, int cmd, void *arg, int count)
{
	return -ENOSYS;
}
void
dump_stack (void)
{
	show_stack(NULL, NULL);
}
void
update_pal_halt_status(int status)
{
	can_do_pal_halt = pal_halt && status;
}
static inline void play_dead(void)
{
	BUG();
}
void
do_copy_regs (struct unw_frame_info *info, void *arg)
{
	do_copy_task_regs(current, info, arg);
}
void
do_dump_fpu (struct unw_frame_info *info, void *arg)
{
	do_dump_task_fpu(current, info, arg);
}
void
ia64_elf_core_copy_regs (struct pt_regs *pt, elf_gregset_t dst)
{
	unw_init_running(do_copy_regs, dst);
}
static inline int
in_syscall (struct pt_regs *pt)
{
	return (long) pt->cr_ifs >= 0;
}
void
ptrace_disable (struct task_struct *child)
{
	user_disable_single_step(child);
}
static int
access_elf_reg(struct task_struct *target, struct unw_frame_info *info,
		unsigned long addr, unsigned long *data, int write_access)
{
	if (addr >= ELF_GR_OFFSET(1) && addr <= ELF_GR_OFFSET(15))
		return access_elf_gpreg(target, info, addr, data, write_access);
	else if (addr >= ELF_BR_OFFSET(0) && addr <= ELF_BR_OFFSET(7))
		return access_elf_breg(target, info, addr, data, write_access);
	else
		return access_elf_areg(target, info, addr, data, write_access);
}
static int
gpregs_get(struct task_struct *target,
	   const struct user_regset *regset,
	   unsigned int pos, unsigned int count,
	   void *kbuf, void __user *ubuf)
{
	return do_regset_call(do_gpregs_get, target, regset, pos, count,
		kbuf, ubuf);
}
static int gpregs_set(struct task_struct *target,
		const struct user_regset *regset,
		unsigned int pos, unsigned int count,
		const void *kbuf, const void __user *ubuf)
{
	return do_regset_call(do_gpregs_set, target, regset, pos, count,
		kbuf, ubuf);
}
static void do_gpregs_writeback(struct unw_frame_info *info, void *arg)
{
	do_sync_rbs(info, ia64_sync_user_rbs);
}
static int
fpregs_active(struct task_struct *target, const struct user_regset *regset)
{
	return (target->thread.flags & IA64_THREAD_FPH_VALID) ? 128 : 32;
}
static int fpregs_get(struct task_struct *target,
		const struct user_regset *regset,
		unsigned int pos, unsigned int count,
		void *kbuf, void __user *ubuf)
{
	return do_regset_call(do_fpregs_get, target, regset, pos, count,
		kbuf, ubuf);
}
static int fpregs_set(struct task_struct *target,
		const struct user_regset *regset,
		unsigned int pos, unsigned int count,
		const void *kbuf, const void __user *ubuf)
{
	return do_regset_call(do_fpregs_set, target, regset, pos, count,
		kbuf, ubuf);
}
static long
default_handler (void)
{
	return -1;
}
int dma_get_cache_alignment(void)
{
        return ia64_max_cacheline_size;
}
static int __init check_crashkernel_memory(unsigned long pbase, size_t size)
{
	if (ia64_platform_is("sn2") || ia64_platform_is("uv"))
		return 1;
	else
		return pbase < (1UL << 32);
}
static inline void
mark_bsp_online (void)
{
	cpu_set(smp_processor_id(), cpu_online_map);
}
void __init
check_bugs (void)
{
	ia64_patch_mckinley_e9((unsigned long) __start___mckinley_e9_bundles,
			       (unsigned long) __end___mckinley_e9_bundles);
}
asmlinkage long
sys_sigaltstack (const stack_t __user *uss, stack_t __user *uoss, long arg2,
		 long arg3, long arg4, long arg5, long arg6, long arg7,
		 struct pt_regs regs)
{
	return do_sigaltstack(uss, uoss, regs.r12);
}
static inline int
rbs_on_sig_stack (unsigned long bsp)
{
	return (bsp - current->sas_ss_sp < current->sas_ss_size);
}
static inline void
send_IPI_self (int op)
{
	send_IPI_single(smp_processor_id(), op);
}
void
kdump_smp_send_stop(void)
{
 	send_IPI_allbutself(IPI_KDUMP_CPU_STOP);
}
void
smp_send_reschedule (int cpu)
{
	platform_send_ipi(cpu, IA64_IPI_RESCHEDULE, IA64_IPI_DM_INT, 0);
}
static void
smp_send_local_flush_tlb (int cpu)
{
	platform_send_ipi(cpu, IA64_IPI_LOCAL_TLB_FLUSH, IA64_IPI_DM_INT, 0);
}
void
smp_flush_tlb_all (void)
{
	on_each_cpu((void (*)(void *))local_flush_tlb_all, NULL, 1);
}
void arch_send_call_function_single_ipi(int cpu)
{
	send_IPI_single(cpu, IPI_CALL_FUNC_SINGLE);
}
void arch_send_call_function_ipi(cpumask_t mask)
{
	send_IPI_mask(mask, IPI_CALL_FUNC);
}
void
smp_send_stop (void)
{
	send_IPI_allbutself(IPI_CPU_STOP);
}
int
setup_profiling_timer (unsigned int multiplier)
{
	return -EINVAL;
}
struct pt_regs * __cpuinit idle_regs(struct pt_regs *regs)
{
	return NULL;
}
asmlinkage unsigned long
sys_getpagesize (void)
{
	return PAGE_SIZE;
}
asmlinkage long
sys_pciconfig_read (unsigned long bus, unsigned long dfn, unsigned long off, unsigned long len,
		    void *buf)
{
	return -ENOSYS;
}
asmlinkage long
sys_pciconfig_write (unsigned long bus, unsigned long dfn, unsigned long off, unsigned long len,
		     void *buf)
{
	return -ENOSYS;
}
void
udelay (unsigned long usecs)
{
	(*ia64_udelay)(usecs);
}
static int __init arch_register_cpu(int num)
{
	return register_cpu(&sysfs_cpus[num].cpu, num);
}
static ssize_t show_coherency_line_size(struct cache_info *this_leaf,
					char *buf)
{
	return sprintf(buf, "%u\n", 1 << this_leaf->cci.pcci_line_size);
}
static ssize_t show_ways_of_associativity(struct cache_info *this_leaf,
					char *buf)
{
	return sprintf(buf, "%u\n", this_leaf->cci.pcci_assoc);
}
static ssize_t show_attributes(struct cache_info *this_leaf, char *buf)
{
	return sprintf(buf,
			"%s\n",
			cache_mattrib[this_leaf->cci.pcci_cache_attr]);
}
static ssize_t show_size(struct cache_info *this_leaf, char *buf)
{
	return sprintf(buf, "%uK\n", this_leaf->cci.pcci_cache_size / 1024);
}
static ssize_t show_level(struct cache_info *this_leaf, char *buf)
{
	return sprintf(buf, "%u\n", this_leaf->level);
}
static inline void
float_spill_f0 (struct ia64_fpreg *final)
{
	ia64_stf_spill(final, 0);
}
static inline void
float_spill_f1 (struct ia64_fpreg *final)
{
	ia64_stf_spill(final, 1);
}
static inline int
read_only (void *addr)
{
	return (unsigned long) ((char *) addr - (char *) &unw.r0) < sizeof(unw.r0);
}
static inline void
desc_mem_stack_f (unw_word t, unw_word size, struct unw_state_record *sr)
{
	set_reg(sr->curr.reg + UNW_REG_PSP, UNW_WHERE_NONE,
		sr->region_start + min_t(int, t, sr->region_len - 1), 16*size);
}
static inline void
desc_mem_stack_v (unw_word t, struct unw_state_record *sr)
{
	sr->curr.reg[UNW_REG_PSP].when = sr->region_start + min_t(int, t, sr->region_len - 1);
}
static inline void
desc_reg_gr (unsigned char reg, unsigned char dst, struct unw_state_record *sr)
{
	set_reg(sr->curr.reg + reg, UNW_WHERE_GR, sr->region_start + sr->region_len - 1, dst);
}
static inline void
desc_reg_psprel (unsigned char reg, unw_word pspoff, struct unw_state_record *sr)
{
	set_reg(sr->curr.reg + reg, UNW_WHERE_PSPREL, sr->region_start + sr->region_len - 1,
		0x10 - 4*pspoff);
}
static inline void
desc_reg_sprel (unsigned char reg, unw_word spoff, struct unw_state_record *sr)
{
	set_reg(sr->curr.reg + reg, UNW_WHERE_SPREL, sr->region_start + sr->region_len - 1,
		4*spoff);
}
static inline void
desc_rp_br (unsigned char dst, struct unw_state_record *sr)
{
	sr->return_link_reg = dst;
}
static inline void
desc_spill_base (unw_word pspoff, struct unw_state_record *sr)
{
	sr->spill_offset = 0x10 - 4*pspoff;
}
static inline unw_hash_index_t
hash (unsigned long ip)
{
	return (ip >> 4)*hashmagic >> (64 - UNW_LOG_HASH_SIZE);
}
void kvm_arch_check_processor_compat(void *rtn)
{
	*(int *)rtn = 0;
}
static int handle_switch_rr6(struct kvm_vcpu *vcpu, struct kvm_run *kvm_run)
{
	return 1;
}
static int handle_external_interrupt(struct kvm_vcpu *vcpu,
		struct kvm_run *kvm_run)
{
	return 1;
}
int kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu,
		struct kvm_sregs *sregs)
{
	return -EINVAL;
}
int kvm_arch_vcpu_ioctl_get_sregs(struct kvm_vcpu *vcpu,
		struct kvm_sregs *sregs)
{
	return -EINVAL;
}
int kvm_arch_vcpu_ioctl_translate(struct kvm_vcpu *vcpu,
		struct kvm_translation *tr)
{
	return -EINVAL;
}
int kvm_arch_vcpu_setup(struct kvm_vcpu *vcpu)
{
	return 0;
}
int kvm_arch_vcpu_ioctl_get_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)
{
	return -EINVAL;
}
int kvm_arch_vcpu_ioctl_set_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)
{
	return -EINVAL;
}
int kvm_arch_vcpu_ioctl_set_guest_debug(struct kvm_vcpu *vcpu,
					struct kvm_guest_debug *dbg)
{
	return -EINVAL;
}
long kvm_arch_dev_ioctl(struct file *filp,
			unsigned int ioctl, unsigned long arg)
{
	return -EINVAL;
}
void kvm_arch_vcpu_destroy(struct kvm_vcpu *vcpu)
{
	kvm_vcpu_uninit(vcpu);
}
int kvm_arch_hardware_setup(void)
{
	return 0;
}
int kvm_apic_match_physical_addr(struct kvm_lapic *apic, u16 dest)
{
	return apic->vcpu->vcpu_id == dest;
}
int kvm_apic_match_logical_addr(struct kvm_lapic *apic, u8 mda)
{
	return 0;
}
int kvm_cpu_has_pending_timer(struct kvm_vcpu *vcpu)
{
	return vcpu->arch.timer_fired;
}
gfn_t unalias_gfn(struct kvm *kvm, gfn_t gfn)
{
	return gfn;
}
int kvm_arch_vcpu_runnable(struct kvm_vcpu *vcpu)
{
	return vcpu->arch.mp_state == KVM_MP_STATE_RUNNABLE;
}
static void remote_pal_mc_drain(void *v)
{
	ia64_pal_mc_drain();
}
static void vlsapic_write_xtp(struct kvm_vcpu *v, uint8_t val)
{
	VLSAPIC_XTP(v) = val;
}
void nested_dtlb(struct kvm_vcpu *vcpu)
{
	inject_guest_interruption(vcpu, IA64_DATA_NESTED_TLB_VECTOR);
}
void ivhpt_fault(struct kvm_vcpu *vcpu, u64 vadr)
{
	_vhpt_fault(vcpu, vadr);
}
void dvhpt_fault(struct kvm_vcpu *vcpu, u64 vadr)
{
	_vhpt_fault(vcpu, vadr);
}
void _general_exception(struct kvm_vcpu *vcpu)
{
	inject_guest_interruption(vcpu, IA64_GENEX_VECTOR);
}
void illegal_op(struct kvm_vcpu *vcpu)
{
	_general_exception(vcpu);
}
void illegal_dep(struct kvm_vcpu *vcpu)
{
	_general_exception(vcpu);
}
void rsv_reg_field(struct kvm_vcpu *vcpu)
{
	_general_exception(vcpu);
}
void privilege_op(struct kvm_vcpu *vcpu)
{
	_general_exception(vcpu);
}
void unimpl_daddr(struct kvm_vcpu *vcpu)
{
	_general_exception(vcpu);
}
void privilege_reg(struct kvm_vcpu *vcpu)
{
	_general_exception(vcpu);
}
void inat_page_consumption(struct kvm_vcpu *vcpu, u64 vadr)
{
	_nat_consumption_fault(vcpu, vadr, INSTRUCTION);
}
void rnat_consumption(struct kvm_vcpu *vcpu)
{
	_nat_consumption_fault(vcpu, 0, REGISTER);
}
void dnat_page_consumption(struct kvm_vcpu *vcpu, u64 vadr)
{
	_nat_consumption_fault(vcpu, vadr, DATA);
}
void data_page_not_present(struct kvm_vcpu *vcpu, u64 vadr)
{
	__page_not_present(vcpu, vadr);
}
void inst_page_not_present(struct kvm_vcpu *vcpu, u64 vadr)
{
	__page_not_present(vcpu, vadr);
}
static inline void handle_lds(struct kvm_pt_regs *regs)
{
	regs->cr_ipsr |= IA64_PSR_ED;
}
void physical_mode_init(struct kvm_vcpu  *vcpu)
{
	vcpu->arch.mode_flags = GUEST_IN_PHY;
}
static int mm_switch_action(struct ia64_psr opsr, struct ia64_psr npsr)
{
	return mm_switch_table[MODE_IND(opsr)][MODE_IND(npsr)];
}
static inline u64 vcpu_get_itm(struct kvm_vcpu *vcpu)
{
	return ((u64)VCPU(vcpu, itm));
}
void vcpu_itc_i(struct kvm_vcpu *vcpu, u64 pte, u64 itir, u64 ifa)
{
	thash_purge_and_insert(vcpu, pte, itir, ifa, I_TLB);
}
void vcpu_itc_d(struct kvm_vcpu *vcpu, u64 pte, u64 itir, u64 ifa)
{
	thash_purge_and_insert(vcpu, pte, itir, ifa, D_TLB);
}
void vcpu_ptc_e(struct kvm_vcpu *vcpu, u64 va)
{
	thash_purge_all(vcpu);
}
void vcpu_ptc_g(struct kvm_vcpu *vcpu, u64 va, u64 ps)
{
	vcpu_ptc_ga(vcpu, va, ps);
}
unsigned long vcpu_get_pkr(struct kvm_vcpu *vcpu, unsigned long reg)
{
	return ((unsigned long)ia64_get_pkr(reg));
}
void vcpu_set_pkr(struct kvm_vcpu *vcpu, unsigned long reg, unsigned long val)
{
	ia64_set_pkr(reg, val);
}
unsigned long vcpu_get_cpuid(struct kvm_vcpu *vcpu, unsigned long reg)
{
	if (reg > (ia64_get_cpuid(3) & 0xff))
		return 0;
	else
		return ia64_get_cpuid(reg);
}
void vmm_spin_lock(spinlock_t *lock)
{
	_vmm_raw_spin_lock(lock);
}
void vmm_spin_unlock(spinlock_t *lock)
{
	_vmm_raw_spin_unlock(lock);
}
static int __is_tr_translated(struct thash_data *trp, u64 rid, u64 va)
{
	return ((trp->p) && (trp->rid == rid)
				&& ((va-trp->vadr) < PSIZE(trp->ps)));
}
void machine_tlb_purge(u64 va, u64 ps)
{
	ia64_ptcl(va, ps << 2);
}
 unsigned int
__ia64_inb (unsigned long port)
{
	return ___ia64_inb(port);
}

unsigned int
__ia64_inw (unsigned long port)
{
	return ___ia64_inw(port);
}

unsigned int
__ia64_inl (unsigned long port)
{
	return ___ia64_inl(port);
}

void
__ia64_outb (unsigned char val, unsigned long port)
{
	___ia64_outb(val, port);
}

void
__ia64_outw (unsigned short val, unsigned long port)
{
	___ia64_outw(val, port);
}

void
__ia64_outl (unsigned int val, unsigned long port)
{
	___ia64_outl(val, port);
}

unsigned char
__ia64_readb (void __iomem *addr)
{
	return ___ia64_readb (addr);
}

unsigned short
__ia64_readw (void __iomem *addr)
{
	return ___ia64_readw (addr);
}

unsigned int
__ia64_readl (void __iomem *addr)
{
	return ___ia64_readl (addr);
}

unsigned long
__ia64_readq (void __iomem *addr)
{
	return ___ia64_readq (addr);
}

unsigned char
__ia64_readb_relaxed (void __iomem *addr)
{
	return ___ia64_readb (addr);
}

unsigned short
__ia64_readw_relaxed (void __iomem *addr)
{
	return ___ia64_readw (addr);
}

unsigned int
__ia64_readl_relaxed (void __iomem *addr)
{
	return ___ia64_readl (addr);
}

unsigned long
__ia64_readq_relaxed (void __iomem *addr)
{
	return ___ia64_readq (addr);
}

void
__ia64_mmiowb(void)
{
	___ia64_mmiowb();
}
static inline void
alloc_per_cpu_data(void)
{
	cpu_data = __alloc_bootmem(PERCPU_PAGE_SIZE * NR_CPUS-1,
				   PERCPU_PAGE_SIZE, __pa(MAX_DMA_ADDRESS));
}
void arch_free_nodedata(pg_data_t *pgdat)
{
	kfree(pgdat);
}
int __meminit vmemmap_populate(struct page *start_page,
						unsigned long size, int node)
{
	return vmemmap_populate_basepages(start_page, size, node);
}
void sort_extable (struct exception_table_entry *start,
		   struct exception_table_entry *finish)
{
	sort(start, finish - start, sizeof(struct exception_table_entry),
	     cmp_ex, swap_ex);
}
static inline int notify_page_fault(struct pt_regs *regs, int trap)
{
	return 0;
}
int huge_pmd_unshare(struct mm_struct *mm, unsigned long *addr, pte_t *ptep)
{
	return 0;
}
int pmd_huge(pmd_t pmd)
{
	return 0;
}
int pud_huge(pud_t pud)
{
	return 0;
}
struct page *
follow_huge_pmd(struct mm_struct *mm, unsigned long address, pmd_t *pmd, int write)
{
	return NULL;
}
static inline void __iomem *
__ioremap (unsigned long phys_addr)
{
	return (void __iomem *) (__IA64_UNCACHED_OFFSET | phys_addr);
}
static inline void spinaphore_init(struct spinaphore *ss, int val)
{
	atomic_set(&ss->cur, val);
}
static inline void up_spin(struct spinaphore *ss)
{
	atomic_add(1, &ss->cur);
}
void oprofile_arch_exit(void)
{
	perfmon_exit();
}
static void perfmon_stop(void)
{
	allow_ints = 0;
}
static int pci_read(struct pci_bus *bus, unsigned int devfn, int where,
							int size, u32 *value)
{
	return raw_pci_read(pci_domain_nr(bus), bus->number,
				 devfn, where, size, value);
}
static int pci_write(struct pci_bus *bus, unsigned int devfn, int where,
							int size, u32 value)
{
	return raw_pci_write(pci_domain_nr(bus), bus->number,
				  devfn, where, size, value);
}
void __devinit pcibios_fixup_device_resources(struct pci_dev *dev)
{
	pcibios_fixup_resources(dev, 0, PCI_BRIDGE_RESOURCES);
}
static void __devinit pcibios_fixup_bridge_resources(struct pci_dev *dev)
{
	pcibios_fixup_resources(dev, PCI_BRIDGE_RESOURCES, PCI_NUM_RESOURCES);
}
void __devinit
pcibios_update_irq (struct pci_dev *dev, int irq)
{
	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq);
}
char * __devinit
pcibios_setup (char *str)
{
	return str;
}
char *ia64_pci_get_legacy_mem(struct pci_bus *bus)
{
	return (char *)__IA64_UNCACHED_OFFSET;
}
u64 dma_get_required_mask(struct device *dev)
{
	return platform_dma_get_required_mask(dev);
}
static dma_addr_t
sn_default_pci_map(struct pci_dev *pdev, unsigned long paddr, size_t size, int type)
{
	return 0;
}
static void
sn_default_pci_unmap(struct pci_dev *pdev, dma_addr_t addr, int direction)
{
	return;
}
static void *
sn_default_pci_bus_fixup(struct pcibus_bussoft *soft, struct pci_controller *controller)
{
	return NULL;
}
static unsigned int sn_startup_irq(unsigned int irq)
{
	return 0;
}
unsigned int sn_local_vector_to_irq(u8 vector)
{
	return (CPU_VECTOR_TO_IRQ(smp_processor_id(), vector));
}
static void sn_cpei_handler(int irq, void *devid, struct pt_regs *regs)
{
	ia64_sn_plat_cpei_handler();
}
static inline int __init board_needs_cnode(int type)
{
	return (type == KLTYPE_SNIA || type == KLTYPE_TIO);
}
unsigned int __sn_inb(unsigned long port)
{
	return ___sn_inb(port);
}

unsigned int __sn_inw(unsigned long port)
{
	return ___sn_inw(port);
}

unsigned int __sn_inl(unsigned long port)
{
	return ___sn_inl(port);
}

void __sn_outb(unsigned char val, unsigned long port)
{
	___sn_outb(val, port);
}

void __sn_outw(unsigned short val, unsigned long port)
{
	___sn_outw(val, port);
}

void __sn_outl(unsigned int val, unsigned long port)
{
	___sn_outl(val, port);
}

unsigned char __sn_readb(void __iomem *addr)
{
	return ___sn_readb(addr);
}

unsigned short __sn_readw(void __iomem *addr)
{
	return ___sn_readw(addr);
}

unsigned int __sn_readl(void __iomem *addr)
{
	return ___sn_readl(addr);
}

unsigned long __sn_readq(void __iomem *addr)
{
	return ___sn_readq(addr);
}

unsigned char __sn_readb_relaxed(void __iomem *addr)
{
	return ___sn_readb_relaxed(addr);
}

unsigned short __sn_readw_relaxed(void __iomem *addr)
{
	return ___sn_readw_relaxed(addr);
}

unsigned int __sn_readl_relaxed(void __iomem *addr)
{
	return ___sn_readl_relaxed(addr);
}

unsigned long __sn_readq_relaxed(void __iomem *addr)
{
	return ___sn_readq_relaxed(addr);
}
static int
get_fit_entry(unsigned long nasid, int index, unsigned long *fentry,
	      char *banner, int banlen)
{
	return ia64_sn_get_fit_compt(nasid, index, fentry, banner, banlen);
}
static int sn2_ptc_proc_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &sn2_ptc_seq_ops);
}
static void __exit sn2_ptc_exit(void)
{
	remove_proc_entry(PTC_BASENAME, NULL);
}
static inline int sn_hwperf_has_cpus(cnodeid_t node)
{
	return node < MAX_NUMNODES && node_online(node) && nr_cpus_node(node);
}
static inline int sn_hwperf_has_mem(cnodeid_t node)
{
	return node < MAX_NUMNODES && node_online(node) && NODE_DATA(node)->node_present_pages;
}
static void sn_topology_stop(struct seq_file *m, void *v)
{
	return;
}
static int partition_id_open(struct inode *inode, struct file *file)
{
	return single_open(file, partition_id_show, NULL);
}
static int system_serial_number_open(struct inode *inode, struct file *file)
{
	return single_open(file, system_serial_number_show, NULL);
}
static int licenseID_open(struct inode *inode, struct file *file)
{
	return single_open(file, licenseID_show, NULL);
}
static int sn_force_interrupt_open(struct inode *inode, struct file *file)
{
	return single_open(file, sn_force_interrupt_show, NULL);
}
static int coherence_id_open(struct inode *inode, struct file *file)
{
	return single_open(file, coherence_id_show, NULL);
}
static cycle_t read_sn2(void)
{
	return (cycle_t)readq(RTC_COUNTER_ADDR);
}
static int tiocx_uevent(struct device *dev, struct kobj_uevent_env *env)
{
	return -ENODEV;
}
static void tiocx_bus_release(struct device *dev)
{
	kfree(to_cx_dev(dev));
}
u64 tiocx_dma_addr(u64 addr)
{
	return PHYS_TO_TIODMA(addr);
}
u64 tiocx_swin_base(int nasid)
{
	return TIO_SWIN_BASE(nasid, TIOCX_CORELET);
}
static void sn_dma_sync_single_for_cpu(struct device *dev, dma_addr_t dma_handle,
				       size_t size, enum dma_data_direction dir)
{
	BUG_ON(dev->bus != &pci_bus_type);
}
static void sn_dma_sync_single_for_device(struct device *dev, dma_addr_t dma_handle,
					  size_t size,
					  enum dma_data_direction dir)
{
	BUG_ON(dev->bus != &pci_bus_type);
}
static void sn_dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg,
				   int nelems, enum dma_data_direction dir)
{
	BUG_ON(dev->bus != &pci_bus_type);
}
static void sn_dma_sync_sg_for_device(struct device *dev, struct scatterlist *sg,
				      int nelems, enum dma_data_direction dir)
{
	BUG_ON(dev->bus != &pci_bus_type);
}
static int sn_dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
{
	return 0;
}
u64 sn_dma_get_required_mask(struct device *dev)
{
	return DMA_64BIT_MASK;
}
void sn_dma_init(void)
{
	dma_ops = &sn_dma_ops;
}
static u64
tioce_dma(struct pci_dev *pdev, u64 paddr, size_t byte_count, int dma_flags)
{
	return tioce_do_dma_map(pdev, paddr, byte_count, 0, dma_flags);
}
static u64
tioce_dma_consistent(struct pci_dev *pdev, u64 paddr, size_t byte_count, int dma_flags)
{
	return tioce_do_dma_map(pdev, paddr, byte_count, 1, dma_flags);
}
void __cpuinit
xen_cpu_init(void)
{
	xen_smp_intr_init();
}
static irqreturn_t
xen_dummy_handler(int irq, void *dev_id)
{
	return IRQ_HANDLED;
}
static void
xen_register_percpu_irq(ia64_vector vec, struct irqaction *action)
{
	__xen_register_percpu_irq(smp_processor_id(), vec, action, 1);
}
static void
xen_resend_irq(unsigned int vector)
{
	(void)resend_irq_on_evtchn(vector);
}
void xen_arch_resume(void)
{
	xen_timer_resume_on_aps();
}
void
xen_timer_resume_on_aps(void)
{
	smp_call_function(&ia64_cpu_local_tick_fn, NULL, 1);
}
long
xencomm_hypercall_opt_feature(void *arg)
{
	return xencomm_arch_hypercall_opt_feature(
		xencomm_map_no_alloc(arg,
				     sizeof(struct xen_ia64_opt_feature)));
}
static void __init
xen_banner(void)
{
	printk(KERN_INFO
	       "Running on Xen! pl = %d start_info_pfn=0x%lx nr_pages=%ld "
	       "flags=0x%x\n",
	       xen_info.kernel_rpl,
	       HYPERVISOR_shared_info->arch.start_info_pfn,
	       xen_start_info->nr_pages, xen_start_info->flags);
}
static int __init
xen_arch_setup_nomca(void)
{
	return 1;
}
static void __init
xen_post_smp_prepare_boot_cpu(void)
{
	xen_setup_vcpu_info_placement();
}
static unsigned long
xen_get_psr_i(void)
{
	return xen_get_virtual_psr_i() ? IA64_PSR_I : 0;
}
static struct irq_chip*
xen_iosapic_get_irq_chip(unsigned long trigger)
{
	return NULL;
}
int
xencomm_is_initialized(void)
{
	return is_xencomm_initialized;
}
void module_free(struct module *mod, void *module_region)
{
	vfree(module_region);
}
int module_frob_arch_sections(Elf_Ehdr *hdr,
			      Elf_Shdr *sechdrs,
			      char *secstrings,
			      struct module *mod)
{
	return 0;
}
int apply_relocate(Elf32_Shdr *sechdrs,
		       const char *strtab,
		       unsigned int symindex,
		       unsigned int relsec,
		       struct module *me)
{
	return 0;
}
int module_finalize(const Elf_Ehdr *hdr,
		    const Elf_Shdr *sechdrs,
		    struct module *me)
{
	return 0;
}
unsigned long thread_saved_pc(struct task_struct *tsk)
{
	return tsk->thread.lr;
}
static void default_idle(void)
{
	cpu_relax();
}
static void poll_idle (void)
{
	cpu_relax();
}
void exit_thread(void)
{
	DPRINTK("pid = %d\n", current->pid);
}
void release_thread(struct task_struct *dead_task)
{
	DPRINTK("pid = %d\n", dead_task->pid);
}
int dump_fpu(struct pt_regs *regs, elf_fpregset_t *fpu)
{
	return 0; /* Task didn't use the fpu at all. */
}
asmlinkage int sys_fork(unsigned long r0, unsigned long r1, unsigned long r2,
	unsigned long r3, unsigned long r4, unsigned long r5, unsigned long r6,
	struct pt_regs regs)
{
	return do_fork(SIGCHLD, regs.spu, &regs, 0, NULL, NULL);
}
asmlinkage int sys_vfork(unsigned long r0, unsigned long r1, unsigned long r2,
	unsigned long r3, unsigned long r4, unsigned long r5, unsigned long r6,
	struct pt_regs regs)
{
	return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, regs.spu, &regs, 0,
			NULL, NULL);
}
unsigned long get_wchan(struct task_struct *p)
{
	return (0);
}
static inline int
check_condition_bit(struct task_struct *child)
{
	return (int)((get_stack_long(child, PT_PSW) >> 8) & 1);
}
static void *c_start(struct seq_file *m, loff_t *pos)
{
	return *pos < NR_CPUS ? cpu_data + *pos : NULL;
}
asmlinkage int
sys_sigaltstack(const stack_t __user *uss, stack_t __user *uoss,
		unsigned long r2, unsigned long r3, unsigned long r4,
		unsigned long r5, unsigned long r6, struct pt_regs *regs)
{
	return do_sigaltstack(uss, uoss, regs->spu);
}
static void flush_tlb_all_ipi(void *info)
{
	__flush_tlb_all();
}
void smp_flush_tlb_range(struct vm_area_struct *vma, unsigned long start,
	unsigned long end)
{
	smp_flush_tlb_mm(vma->vm_mm);
}
void smp_send_stop(void)
{
	smp_call_function(stop_this_cpu, NULL, 0);
}
void arch_send_call_function_ipi(cpumask_t mask)
{
	send_IPI_mask(mask, CALL_FUNCTION_IPI, 0);
}
void arch_send_call_function_single_ipi(int cpu)
{
	send_IPI_mask(cpumask_of_cpu(cpu), CALL_FUNC_SINGLE_IPI, 0);
}
void smp_send_timer(void)
{
	send_IPI_allbutself(LOCAL_TIMER_IPI, 1);
}
asmlinkage int sys_cachectl(char *addr, int nbytes, int op)
{
	return -ENOSYS;
}
static inline int set_rtc_mmss(unsigned long nowtime)
{
	return 0;
}
asmlinkage void do_##name(struct pt_regs * regs, long error_code) \
{ \
	do_trap(trapnr, signr, NULL, regs, error_code, NULL); \
}
void __udelay(unsigned long usecs)
{
	__const_udelay(usecs * 0x000010c7);  /* 2**32 / 1000000 (rounded up) */
}
void __ndelay(unsigned long nsecs)
{
	__const_udelay(nsecs * 0x00005);  /* 2**32 / 1000000000 (rounded up) */
}
void update_mmu_cache(struct vm_area_struct *vma, unsigned long addr,
	pte_t pte)
{
	BUG();
}
void local_flush_tlb_page(struct vm_area_struct *vma, unsigned long page)
{
	BUG();
}
void local_flush_tlb_range(struct vm_area_struct *vma, unsigned long start,
	unsigned long end)
{
	BUG();
}
void local_flush_tlb_mm(struct mm_struct *mm)
{
	BUG();
}
void local_flush_tlb_all(void)
{
	BUG();
}
void __iomem *
__ioremap(unsigned long phys_addr, unsigned long size, unsigned long flags)
{
	return (void *)phys_addr;
}
int __init oprofile_arch_init(struct oprofile_operations *ops)
{
	return -ENODEV;
}
static inline void *_port2addr(unsigned long port)
{
	return (void *)(port | NONCACHE_OFFSET);
}
static inline void *_port2addr_ne(unsigned long port)
{
	return (void *)(port + NONCACHE_OFFSET + 0x01000000);
}
static inline void delay(void)
{
	__asm__ __volatile__ ("push r0; \n\t pop r0;" : : :"memory");
}
static inline unsigned char _ne_inb(void *portp)
{
	return *(volatile unsigned char *)portp;
}
static inline unsigned short _ne_inw(void *portp)
{
	return (unsigned short)le16_to_cpu(*(volatile unsigned short *)portp);
}
static inline void _ne_outb(unsigned char b, void *portp)
{
	*(volatile unsigned char *)portp = b;
}
static inline void _ne_outw(unsigned short w, void *portp)
{
	*(volatile unsigned short *)portp = cpu_to_le16(w);
}
unsigned long _inl(unsigned long port)
{
	return *(volatile unsigned long *)PORT2ADDR(port);
}
void _outl(unsigned long l, unsigned long port)
{
	*(volatile unsigned long *)PORT2ADDR(port) = l;
}
static void mask_and_ack_m32104ut(unsigned int irq)
{
	disable_m32104ut_irq(irq);
}
static void end_m32104ut_irq(unsigned int irq)
{
	enable_m32104ut_irq(irq);
}
static inline void *_port2addr(unsigned long port)
{
	return (void *)(port | NONCACHE_OFFSET);
}
static inline void *_port2addr_ne(unsigned long port)
{
	return (void *)(port + 0x10000000);
}
static inline void *_port2addr_usb(unsigned long port)
{
	return (void *)((port & 0x0f) + NONCACHE_OFFSET + 0x10303000);
}
static inline void delay(void)
{
	__asm__ __volatile__ ("push r0; \n\t pop r0;" : : :"memory");
}
static inline unsigned char _ne_inb(void *portp)
{
	return *(volatile unsigned char *)portp;
}
static inline unsigned short _ne_inw(void *portp)
{
	return (unsigned short)le16_to_cpu(*(volatile unsigned short *)portp);
}
static inline void _ne_outb(unsigned char b, void *portp)
{
	*(volatile unsigned char *)portp = b;
}
static inline void _ne_outw(unsigned short w, void *portp)
{
	*(volatile unsigned short *)portp = cpu_to_le16(w);
}
static void mask_and_ack_m32700ut(unsigned int irq)
{
	disable_m32700ut_irq(irq);
}
static void end_m32700ut_irq(unsigned int irq)
{
	enable_m32700ut_irq(irq);
}
static void mask_and_ack_m32700ut_pld(unsigned int irq)
{
	disable_m32700ut_pld_irq(irq);
}
static void mask_and_ack_m32700ut_lanpld(unsigned int irq)
{
	disable_m32700ut_lanpld_irq(irq);
}
static void mask_and_ack_m32700ut_lcdpld(unsigned int irq)
{
	disable_m32700ut_lcdpld_irq(irq);
}
static inline void *_port2addr(unsigned long port)
{
	return (void *)(port | NONCACHE_OFFSET);
}
static inline void *_port2addr_ne(unsigned long port)
{
	return (void *)((port<<1) + NONCACHE_OFFSET + 0x0C000000);
}
static inline void delay(void)
{
	__asm__ __volatile__ ("push r0; \n\t pop r0;" : : :"memory");
}
static inline unsigned char _ne_inb(void *portp)
{
	return (unsigned char) *(volatile unsigned short *)portp;
}
static inline void _ne_outb(unsigned char b, void *portp)
{
	*(volatile unsigned short *)portp = (unsigned short)b;
}
static inline void _ne_outw(unsigned short w, void *portp)
{
	*(volatile unsigned short *)portp = cpu_to_le16(w);
}
static void mask_and_ack_mappi(unsigned int irq)
{
	disable_mappi_irq(irq);
}
static inline void *_port2addr(unsigned long port)
{
	return (void *)(port | NONCACHE_OFFSET);
}
static inline void *_port2addr_ne(unsigned long port)
{
	return (void *)(port + 0x10000000);
}
static inline void *_port2addr_ne(unsigned long port)
{
	return (void *)(port + 0x04000000);
}
static inline void *_port2addr_usb(unsigned long port)
{
	return (void *)(port + NONCACHE_OFFSET + 0x14000000);
}
static inline void delay(void)
{
	__asm__ __volatile__ ("push r0; \n\t pop r0;" : : :"memory");
}
static inline unsigned char _ne_inb(void *portp)
{
	return (unsigned char) *(volatile unsigned char *)portp;
}
static inline unsigned short _ne_inw(void *portp)
{
	return (unsigned short)le16_to_cpu(*(volatile unsigned short *)portp);
}
static inline void _ne_outb(unsigned char b, void *portp)
{
	*(volatile unsigned char *)portp = (unsigned char)b;
}
static inline void _ne_outw(unsigned short w, void *portp)
{
	*(volatile unsigned short *)portp = cpu_to_le16(w);
}
static void mask_and_ack_mappi2(unsigned int irq)
{
	disable_mappi2_irq(irq);
}
static void end_mappi2_irq(unsigned int irq)
{
	enable_mappi2_irq(irq);
}
static inline void *_port2addr(unsigned long port)
{
	return (void *)(port | NONCACHE_OFFSET);
}
static inline void *_port2addr_ne(unsigned long port)
{
	return (void *)(port + 0x10000000);
}
static inline void *_port2addr_usb(unsigned long port)
{
	return (void *)(port + NONCACHE_OFFSET + 0x12000000);
}
static inline void delay(void)
{
	__asm__ __volatile__ ("push r0; \n\t pop r0;" : : :"memory");
}
static inline unsigned char _ne_inb(void *portp)
{
	return (unsigned char) *(volatile unsigned char *)portp;
}
static inline unsigned short _ne_inw(void *portp)
{
	return (unsigned short)le16_to_cpu(*(volatile unsigned short *)portp);
}
static inline void _ne_outb(unsigned char b, void *portp)
{
	*(volatile unsigned char *)portp = (unsigned char)b;
}
static inline void _ne_outw(unsigned short w, void *portp)
{
	*(volatile unsigned short *)portp = cpu_to_le16(w);
}
static void mask_and_ack_mappi3(unsigned int irq)
{
	disable_mappi3_irq(irq);
}
static void end_mappi3_irq(unsigned int irq)
{
	enable_mappi3_irq(irq);
}
static inline void *_port2addr(unsigned long port)
{
	return (void *)(port | NONCACHE_OFFSET);
}
static inline  void *_port2addr_ne(unsigned long port)
{
	return (void *)((port<<1) + NONCACHE_OFFSET + 0x02000000);
}
static inline void delay(void)
{
	__asm__ __volatile__ ("push r0; \n\t pop r0;" : : :"memory");
}
static inline unsigned char _ne_inb(void *portp)
{
	return *(volatile unsigned char *)(portp+1);
}
static inline void _ne_outb(unsigned char b, void *portp)
{
	*(volatile unsigned char *)(portp+1) = b;
}
unsigned long _inl(unsigned long port)
{
	return *(volatile unsigned long *)PORT2ADDR(port);
}
void _outl(unsigned long l, unsigned long port)
{
	*(volatile unsigned long *)PORT2ADDR(port) = l;
}
static void mask_and_ack_mappi(unsigned int irq)
{
	disable_oaks32r_irq(irq);
}
static void end_oaks32r_irq(unsigned int irq)
{
	enable_oaks32r_irq(irq);
}
static inline void *_port2addr(unsigned long port)
{
	return (void *)(port | NONCACHE_OFFSET);
}
static inline void *_port2addr_ne(unsigned long port)
{
	return (void *)(port + 0x10000000);
}
static inline void *_port2addr_usb(unsigned long port)
{
	return (void *)((port & 0x0f) + NONCACHE_OFFSET + 0x10303000);
}
static inline void delay(void)
{
	__asm__ __volatile__ ("push r0; \n\t pop r0;" : : :"memory");
}
static inline unsigned char _ne_inb(void *portp)
{
	return *(volatile unsigned char *)portp;
}
static inline unsigned short _ne_inw(void *portp)
{
	return (unsigned short)le16_to_cpu(*(volatile unsigned short *)portp);
}
static inline void _ne_outb(unsigned char b, void *portp)
{
	*(volatile unsigned char *)portp = b;
}
static inline void _ne_outw(unsigned short w, void *portp)
{
	*(volatile unsigned short *)portp = cpu_to_le16(w);
}
static void mask_and_ack_opsput(unsigned int irq)
{
	disable_opsput_irq(irq);
}
static void end_opsput_irq(unsigned int irq)
{
	enable_opsput_irq(irq);
}
static void mask_and_ack_opsput_pld(unsigned int irq)
{
	disable_opsput_pld_irq(irq);
}
static void mask_and_ack_opsput_lanpld(unsigned int irq)
{
	disable_opsput_lanpld_irq(irq);
}
static void mask_and_ack_opsput_lcdpld(unsigned int irq)
{
	disable_opsput_lcdpld_irq(irq);
}
static inline void delay(void)
{
	__asm__ __volatile__ ("push r0; \n\t pop r0;" : : :"memory");
}
static void mask_and_ack_mappi(unsigned int irq)
{
	disable_mappi_irq(irq);
}
static void end_mappi_irq(unsigned int irq)
{
	enable_mappi_irq(irq);
}
static void mask_and_ack_m32700ut_pld(unsigned int irq)
{
	disable_m32700ut_pld_irq(irq);
}
static void amiga_enable_irq(unsigned int irq)
{
	amiga_custom.intena = IF_SETCLR | (1 << (irq - IRQ_USER));
}
static void amiga_disable_irq(unsigned int irq)
{
	amiga_custom.intena = 1 << (irq - IRQ_USER);
}
static void amiga_get_model(char *model)
{
	strcpy(model, amiga_model_name);
}
void pcmcia_write_enable(void)
{
	gayle.cardstatus = GAYLE_CS_WR|GAYLE_CS_DA;
}
void pcmcia_write_disable(void)
{
	gayle.cardstatus = 0;
}
unsigned long dn_gettimeoffset(void) {
	return 0xdeadbeef;
}
void dn_dummy_waitbut(void) {
  dn_serial_print("waitbut\n");
}
void ikbd_mem_write(int address, int size, char *data)
{
	panic("Attempt to write data into keyboard memory");
}
int stdma_others_waiting(void)
{
	return waitqueue_active(&stdma_wait);
}
int stdma_islocked(void)
{
	return stdma_locked;
}
void atari_stram_mem_init_hook (void)
{
	mem_init_done = 1;
}
static int stram_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, stram_proc_show, NULL);
}
int bvme6000_parse_bootinfo(const struct bi_record *bi)
{
	if (bi->tag == BI_VME_TYPE)
		return 0;
	else
		return 1;
}
static void bvme6000_get_model(char *model)
{
    sprintf(model, "BVME%d000", m68k_cputype == CPU_68060 ? 6 : 4);
}
static void __init bvme6000_init_IRQ(void)
{
	m68k_setup_user_interrupt(VEC_USER, 192, NULL);
}
static void hp300_get_model(char *model)
{
	strcpy(model, hp300_model_name);
}
static unsigned int hp300_get_ss(void)
{
	return hp300_rtc_read(RTC_REG_SEC1) * 10 +
		hp300_rtc_read(RTC_REG_SEC2);
}
void module_free(struct module *mod, void *module_region)
{
	vfree(module_region);
}
int module_frob_arch_sections(Elf_Ehdr *hdr,
			      Elf_Shdr *sechdrs,
			      char *secstrings,
			      struct module *mod)
{
	return 0;
}
asmlinkage int m68k_fork(struct pt_regs *regs)
{
	return do_fork(SIGCHLD, rdusp(), regs, 0, NULL, NULL);
}
asmlinkage int m68k_vfork(struct pt_regs *regs)
{
	return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, rdusp(), regs, 0,
		       NULL, NULL);
}
void ptrace_disable(struct task_struct *child)
{
	singlestep_disable(child);
}
static void *c_start(struct seq_file *m, loff_t *pos)
{
	return *pos < 1 ? (void *)1 : NULL;
}
static int hardware_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, hardware_proc_show, NULL);
}
asmlinkage int
sys_sigaltstack(const stack_t __user *uss, stack_t __user *uoss)
{
	return do_sigaltstack(uss, uoss, rdusp());
}
asmlinkage long sys_mmap2(unsigned long addr, unsigned long len,
	unsigned long prot, unsigned long flags,
	unsigned long fd, unsigned long pgoff)
{
	return do_mmap2(addr, len, prot, flags, fd, pgoff);
}
asmlinkage int sys_getpagesize(void)
{
	return PAGE_SIZE;
}
asmlinkage void fpsp040_die(void)
{
	do_exit(SIGSEGV);
}
char *strcpy(char *dest, const char *src)
{
	return __kernel_strcpy(dest, src);
}
char *strcat(char *dest, const char *src)
{
	return __kernel_strcpy(dest + __kernel_strlen(dest), src);
}
static void __init mac_sched_init(irq_handler_t vector)
{
	via_init_clock(vector);
}
static void __init mac_report_hardware(void)
{
	printk(KERN_INFO "Apple Macintosh %s\n", macintosh_config->name);
}
static void mac_debug_console_write(struct console *co, const char *str,
				    unsigned int count)
{
	mac_serial_print(str);
}
static __inline__ void iop_stop(volatile struct mac_iop *iop)
{
	iop->status_ctrl &= ~IOP_RUN;
}
static __inline__ void iop_start(volatile struct mac_iop *iop)
{
	iop->status_ctrl = IOP_RUN | IOP_AUTOINC;
}
static __inline__ void iop_bypass(volatile struct mac_iop *iop)
{
	iop->status_ctrl |= IOP_BYPASS;
}
static __inline__ void iop_interrupt(volatile struct mac_iop *iop)
{
	iop->status_ctrl |= IOP_IRQ;
}
static void iop_free_msg(struct iop_msg *msg)
{
	msg->status = IOP_MSGSTATUS_UNUSED;
}
static void mac_nosound( unsigned long ignored )
{
	mac_asc_regs[ ASC_ENABLE ] = 0;
}
static __u8 via_read_pram(int offset)
{
	return 0;
}
static void oss_shutdown(void)
{
	oss->rom_ctrl = OSS_POWEROFF;
}
static inline struct vm_struct *get_io_area(unsigned long size)
{
	return get_vm_area(size, VM_IOREMAP);
}
static inline void free_io_area(void *addr)
{
	vfree((void *)(PAGE_MASK & (unsigned long)addr));
}
static inline void clear040(unsigned long paddr)
{
	asm volatile (
		"nop\n\t"
		".chip 68040\n\t"
		"cinvp %%bc,(%0)\n\t"
		".chip 68k"
		: : "a" (paddr));
}
static inline void cleari040(unsigned long paddr)
{
	asm volatile (
		"nop\n\t"
		".chip 68040\n\t"
		"cinvp %%ic,(%0)\n\t"
		".chip 68k"
		: : "a" (paddr));
}
static inline void push040(unsigned long paddr)
{
	asm volatile (
		"nop\n\t"
		".chip 68040\n\t"
		"cpushp %%bc,(%0)\n\t"
		".chip 68k"
		: : "a" (paddr));
}
void __iomem *__ioremap(unsigned long phys, unsigned long size, int cache)
{
	return sun3_ioremap(phys, size, SUN3_PAGE_TYPE_IO);
}
void iounmap(void __iomem *addr)
{
	vfree((void *)(PAGE_MASK & (unsigned long)addr));
}
int mvme147_parse_bootinfo(const struct bi_record *bi)
{
	if (bi->tag == BI_VME_TYPE || bi->tag == BI_VME_BRDINFO)
		return 0;
	else
		return 1;
}
static void mvme147_get_model(char *model)
{
	sprintf(model, "Motorola MVME147");
}
void __init mvme147_init_IRQ(void)
{
	m68k_setup_user_interrupt(VEC_USER, 192, NULL);
}
static int bcd2int (unsigned char b)
{
	return ((b>>4)*10 + (b&15));
}
int mvme147_set_clock_mmss (unsigned long nowtime)
{
	return 0;
}
void mvme147_init_console_port (struct console *co, int cflag)
{
	co->write    = m147_scc_write;
}
int mvme16x_parse_bootinfo(const struct bi_record *bi)
{
	if (bi->tag == BI_VME_TYPE || bi->tag == BI_VME_BRDINFO)
		return 0;
	else
		return 1;
}
static void __init mvme16x_init_IRQ (void)
{
	m68k_setup_user_interrupt(VEC_USER, 192, NULL);
}
unsigned long mvme16x_gettimeoffset (void)
{
    return (*(volatile unsigned long *)0xfff42008);
}
int bcd2int (unsigned char b)
{
	return ((b>>4)*10 + (b&15));
}
int mvme16x_set_clock_mmss (unsigned long nowtime)
{
	return 0;
}
static void q40_get_model(char *model)
{
	sprintf(model, "Q40");
}
int q40_parse_bootinfo(const struct bi_record *rec)
{
	return 1;
}
static unsigned long q40_gettimeoffset(void)
{
	return 5000 * (ql_ticks != 0);
}
static unsigned int q40_get_ss(void)
{
	return bcd2bin(Q40_RTC_SECS);
}
int q40_probe_irq_off(unsigned long irqs)
{
	return -1;
}
static void sun3_get_hardware_list(struct seq_file *m)
{
	seq_printf(m, "PROM Revision:\t%s\n", romvec->pv_monid);
}
static void sun3_reboot (void)
{
	prom_reboot ("vmlinux");
}
static void sun3_halt (void)
{
	prom_halt ();
}
void sun3_dvma_init(void)
{
	memset(ptelist, 0, sizeof(ptelist));
}
unsigned long sun3_gettimeoffset(void)
{
  return 1;
}
int
prom_version(void)
{
	return romvec->pv_romvers;
}
int
prom_getrev(void)
{
	return prom_rev;
}
int
prom_getprev(void)
{
	return prom_prev;
}
void dvma_free(void *vaddr)
{
	return;
}
void sun3_disable_interrupts(void)
{
	sun3_disable_irq(0);
}
void sun3_enable_interrupts(void)
{
	sun3_enable_irq(0);
}
void sun3_enable_irq(unsigned int irq)
{
	*sun3_intreg |=  (1 << irq);
}
void sun3_disable_irq(unsigned int irq)
{
	*sun3_intreg &= ~(1 << irq);
}
static irqreturn_t sun3_vec255(int irq, void *dev_id)
{
	return IRQ_HANDLED;
}
static void sun3x_get_hardware_list(struct seq_file *m)
{
	seq_printf(m, "PROM Revision:\t%s\n", romvec->pv_monid);
}
int prom_getintdefault(int node, char *property, int deflt)
{
	return deflt;
}
int prom_getbool (int node, char *prop)
{
	return 1;
}
void prom_halt (void)
{
	sun3x_halt();
}
unsigned long sun3x_gettimeoffset (void)
{
    return 0L;
}
void dma_free_coherent(struct device *dev, size_t size,
			 void *vaddr, dma_addr_t dma_handle)
{
	free_pages((unsigned long)vaddr, get_order(size));
}
void ack_bad_irq(unsigned int irq)
{
	printk(KERN_ERR "IRQ: unexpected irq=%d\n", irq);
}
void module_free(struct module *mod, void *module_region)
{
	vfree(module_region);
}
int module_frob_arch_sections(Elf_Ehdr *hdr,
			      Elf_Shdr *sechdrs,
			      char *secstrings,
			      struct module *mod)
{
	return 0;
}
int module_finalize(const Elf_Ehdr *hdr,
		    const Elf_Shdr *sechdrs,
		    struct module *me)
{
	return 0;
}
asmlinkage int m68k_fork(struct pt_regs *regs)
{
	return(-EINVAL);
}
asmlinkage int m68k_vfork(struct pt_regs *regs)
{
	return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, rdusp(), regs, 0, NULL, NULL);
}
static void *c_start(struct seq_file *m, loff_t *pos)
{
	return *pos < NR_CPUS ? ((void *) 0x12345678) : NULL;
}
asmlinkage int
sys_sigaltstack(const stack_t *uss, stack_t *uoss)
{
	return do_sigaltstack(uss, uoss, rdusp());
}
asmlinkage long sys_mmap2(unsigned long addr, unsigned long len,
	unsigned long prot, unsigned long flags,
	unsigned long fd, unsigned long pgoff)
{
	return do_mmap2(addr, len, prot, flags, fd, pgoff);
}
asmlinkage int sys_getpagesize(void)
{
	return PAGE_SIZE;
}
unsigned long read_persistent_clock(void)
{
	return read_rtc_mmss();
}
int update_persistent_clock(struct timespec now)
{
	return set_rtc_mmss(now.tv_sec);
}
void time_init(void)
{
	hw_timer_init();
}
asmlinkage void set_esp0(unsigned long ssp)
{
	current->thread.esp0 = ssp;
}
__sum16 ip_fast_csum(const void *iph, unsigned int ihl)
{
	return (__force __sum16)~do_csum(iph,ihl*4);
}
__sum16 ip_compute_csum(const void *buff, int len)
{
	return (__force __sum16)~do_csum(buff,len);
}
void udelay(unsigned long usecs)
{
	_udelay(usecs);
}
void *__ioremap(unsigned long physaddr, unsigned long size, int cacheflag)
{
	return (void *)physaddr;
}
unsigned long kernel_map(unsigned long paddr, unsigned long size,
			 int nocacheflag, unsigned long *memavailp )
{
	return paddr;
}
void wtm_init(void)
{
	MCF_WTM_WCR = 0;
}
void enable_vector(unsigned int irq)
{
	IMR &= ~(1<<irq);
}
void disable_vector(unsigned int irq)
{
	IMR |= (1<<irq);
}
void
cpm_install_handler(int vec, void (*handler)(), void *dev_id)
{
	request_irq(vec, handler, IRQ_FLG_LOCK, "timer", dev_id);
}
int BSP_set_clock_mmss(unsigned long nowtime)
{
  return 0;
}
void enable_vector(unsigned int irq)
{
	pquicc->intr_cimr |= (1 << irq);
}
void disable_vector(unsigned int irq)
{
	pquicc->intr_cimr &= ~(1 << irq);
}
void ack_vector(unsigned int irq)
{
	pquicc->intr_cisr = (1 << irq);
}
static cycle_t cf_dt_get_cycles(void)
{
	return __raw_readl(DTCN0);
}
static unsigned long long cycles2ns(unsigned long cycl)
{
	return (unsigned long long) ((unsigned long long)cycl *
			CYC2NS_SCALE) >> CYC2NS_SCALE_FACTOR;
}
void coldfire_reset(void)
{
	HARD_RESET_NOW();
}
void set_au1x00_speed(unsigned int new_freq)
{
	au1x00_clock = new_freq;
}
unsigned int get_au1x00_speed(void)
{
	return au1x00_clock;
}
unsigned long get_au1x00_uart_baud_base(void)
{
	return uart_baud_base;
}
void set_au1x00_uart_baud_base(unsigned long new_baud_base)
{
	uart_baud_base = new_baud_base;
}
void *au1xxx_ddma_get_nextptr_virt(au1x_ddma_desc_t *dp)
{
	return phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));
}
static int au1xxx_gpio1_read(unsigned gpio)
{
	return (gpio1->pinstaterd >> gpio) & 0x01;
}
char * __init_or_module prom_getcmdline(void)
{
	return &(arcs_cmdline[0]);
}
void au1000_power_off(void)
{
	au1000_halt();
}
static cycle_t au1x_counter1_read(void)
{
	return au_readl(SYS_RTCREAD);
}
const char *get_system_type(void)
{
	return "Alchemy Bosporus Gateway Reference";
}
void board_reset(void)
{
	bcsr->swreset = 0x0000;
}
void __init board_init_irq(void)
{
	au1xxx_setup_irqmap(au1xxx_irq_map, ARRAY_SIZE(au1xxx_irq_map));
}
const char *get_system_type(void)
{
	return "Alchemy Pb1000";
}
void __init board_init_irq(void)
{
	au1xxx_setup_irqmap(au1xxx_irq_map, ARRAY_SIZE(au1xxx_irq_map));
}
const char *get_system_type(void)
{
	return "Alchemy Pb1100";
}
void board_reset(void)
{
	au_writel(0x00000000, PB1100_RST_VDDI);
}
void __init board_init_irq(void)
{
	au1xxx_setup_irqmap(au1xxx_irq_map, ARRAY_SIZE(au1xxx_irq_map));
}
const char *get_system_type(void)
{
	return "Alchemy Pb1200";
}
static int pb1200mmc0_card_readonly(void *mmc_host)
{
	return (bcsr->status & BCSR_STATUS_SD0WP) ? 1 : 0;
}
static int pb1200mmc0_card_inserted(void *mmc_host)
{
	return (bcsr->sig_status & BCSR_INT_SD0INSERT) ? 1 : 0;
}
static int pb1200mmc1_card_readonly(void *mmc_host)
{
	return (bcsr->status & BCSR_STATUS_SD1WP) ? 1 : 0;
}
static int pb1200mmc1_card_inserted(void *mmc_host)
{
	return (bcsr->sig_status & BCSR_INT_SD1INSERT) ? 1 : 0;
}
static int __init board_register_devices(void)
{
	return platform_add_devices(board_platform_devices,
				    ARRAY_SIZE(board_platform_devices));
}
const char *get_system_type(void)
{
	return "Alchemy Pb1500";
}
void board_reset(void)
{
	au_writel(0x00000000, PB1500_RST_VDDI);
}
void __init board_init_irq(void)
{
	au1xxx_setup_irqmap(au1xxx_irq_map, ARRAY_SIZE(au1xxx_irq_map));
}
const char *get_system_type(void)
{
	return "Alchemy Pb1550";
}
void board_reset(void)
{
	au_writew(au_readw(0xAF00001C) & ~BCSR_SYSTEM_RESET, 0xAF00001C);
}
void __init board_init_irq(void)
{
	au1xxx_setup_irqmap(au1xxx_irq_map, ARRAY_SIZE(au1xxx_irq_map));
}
void board_reset(void)
{
	au_writel(0x00000000, 0xAE00001C);
}
const char *get_system_type(void)
{
	return "MTX-1";
}
void __init board_init_irq(void)
{
	au1xxx_setup_irqmap(au1xxx_irq_map, ARRAY_SIZE(au1xxx_irq_map));
}
void board_reset(void)
{
	au_writel(0x00000000, 0xAE00001C);
}
const char *get_system_type(void)
{
	return "XXS1500";
}
void __init board_init_irq(void)
{
	au1xxx_setup_irqmap(au1xxx_irq_map, ARRAY_SIZE(au1xxx_irq_map));
}
static int __exit iodev_remove(struct platform_device *dev)
{
	return misc_deregister(&miscdev);
}
static int __init iodev_init_module(void)
{
	return platform_driver_register(&iodev_driver);
}
static void __exit iodev_cleanup_module(void)
{
	platform_driver_unregister(&iodev_driver);
}
static int excite_unit_id_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, excite_unit_id_proc_show, NULL);
}
const char *get_system_type(void)
{
	return "Basler eXcite";
}
int gpio_to_irq(unsigned gpio)
{
	if (ssb_chipco_available(&ssb_bcm47xx.chipco))
		return ssb_mips_irq(ssb_bcm47xx.chipco.dev) + 2;
	else if (ssb_extif_available(&ssb_bcm47xx.extif))
		return ssb_mips_irq(ssb_bcm47xx.extif.dev) + 2;
	else
		return -EINVAL;
}
void __init arch_init_irq(void)
{
	mips_cpu_irq_init();
}
const char *get_system_type(void)
{
	return "Broadcom BCM47XX";
}
static __init void prom_init_console(void)
{
	cfe_cons_handle = cfe_getstdhandle(CFE_STDHANDLE_CONSOLE);
}
static cycle_t octeon_cvmcount_read(void)
{
	return read_c0_cvmcount();
}
void octeon_unmap_dma_mem(struct device *dev, dma_addr_t dma_addr)
{
	return;
}
static void cvmx_bootmem_phy_set_size(uint64_t addr, uint64_t size)
{
	cvmx_write64_uint64((addr + SIZE_OFFSET) | (1ull << 63), size);
}
static void cvmx_bootmem_phy_set_next(uint64_t addr, uint64_t next)
{
	cvmx_write64_uint64((addr + NEXT_OFFSET) | (1ull << 63), next);
}
static uint64_t cvmx_bootmem_phy_get_size(uint64_t addr)
{
	return cvmx_read64_uint64((addr + SIZE_OFFSET) | (1ull << 63));
}
static uint64_t cvmx_bootmem_phy_get_next(uint64_t addr)
{
	return cvmx_read64_uint64((addr + NEXT_OFFSET) | (1ull << 63));
}
void *cvmx_bootmem_alloc_address(uint64_t size, uint64_t address,
				 uint64_t alignment)
{
	return cvmx_bootmem_alloc_range(size, alignment, address,
					address + size);
}
void *cvmx_bootmem_alloc(uint64_t size, uint64_t alignment)
{
	return cvmx_bootmem_alloc_range(size, alignment, 0, 0);
}
int cvmx_bootmem_free_named(char *name)
{
	return cvmx_bootmem_phy_named_block_free(name, 0);
}
struct cvmx_bootmem_named_block_desc *cvmx_bootmem_find_named_block(char *name)
{
	return cvmx_bootmem_phy_named_block_find(name, 0);
}
void cvmx_bootmem_lock(void)
{
	cvmx_spinlock_lock((cvmx_spinlock_t *) &(cvmx_bootmem_desc->lock));
}
void cvmx_bootmem_unlock(void)
{
	cvmx_spinlock_unlock((cvmx_spinlock_t *) &(cvmx_bootmem_desc->lock));
}
int cvmx_l2c_get_hw_way_partition(void)
{
	return cvmx_read_csr(CVMX_L2C_SPAR4) & (0xFF);
}
int cvmx_l2c_get_cache_size_bytes(void)
{
	return cvmx_l2c_get_num_sets() * cvmx_l2c_get_num_assoc() *
		CVMX_CACHE_LINE_SIZE;
}
int cvmx_l2c_get_num_sets(void)
{
	return 1 << cvmx_l2c_get_set_bits();
}
struct cvmx_sysinfo *cvmx_sysinfo_get(void)
{
	return &(state.sysinfo);
}
static void octeon_irq_ciu0_ack(unsigned int irq)
{
	clear_c0_status(0x100 << 2);
}
static void octeon_irq_ciu0_eoi(unsigned int irq)
{
	set_c0_status(0x100 << 2);
}
static void octeon_irq_ciu1_ack(unsigned int irq)
{
	clear_c0_status(0x100 << 3);
}
static void octeon_irq_ciu1_eoi(unsigned int irq)
{
	set_c0_status(0x100 << 3);
}
int octeon_is_simulation(void)
{
	return octeon_bootinfo->board_type == CVMX_BOARD_TYPE_SIM;
}
int octeon_is_pci_host(void)
{
	return octeon_bootinfo->config_flags & CVMX_BOOTINFO_CFG_FLAG_PCI_HOST;
}
int octeon_get_boot_coremask(void)
{
	return octeon_boot_desc_ptr->core_mask;
}
void octeon_hal_setup_reserved32(void)
{
	on_each_cpu(octeon_hal_setup_per_cpu_reserved32, NULL, 0, 1);
}
int dec_ecc_be_handler(struct pt_regs *regs, int is_fixup)
{
	return dec_ecc_be_backend(regs, is_fixup, 0);
}
int dec_kn01_be_handler(struct pt_regs *regs, int is_fixup)
{
	return dec_kn01_be_backend(regs, is_fixup, 0);
}
int dec_kn02xa_be_handler(struct pt_regs *regs, int is_fixup)
{
	return dec_kn02xa_be_backend(regs, is_fixup, 0);
}
void __init register_prom_console(void)
{
	register_console(&promcons);
}
static int __init prom_console_setup(struct console *co, char *options)
{
	return 0;
}
void __noreturn dec_machine_restart(char *command)
{
	back_to_prom();
}
void __noreturn dec_machine_halt(void)
{
	back_to_prom();
}
void __noreturn dec_machine_power_off(void)
{
	back_to_prom();
}
irqreturn_t dec_intr_halt(int irq, void *dev_id)
{
	dec_machine_halt();
}
int tc_preadb(u8 *valp, void __iomem *addr)
{
	return get_dbe(*valp, (u8 *)addr);
}
static void wbflush_kn01(void)
{
    asm(".set\tpush\n\t"
	".set\tnoreorder\n\t"
	"1:\tbc0f\t1b\n\t"
	"nop\n\t"
	".set\tpop");
}
static void wbflush_kn210(void)
{
    asm(".set\tpush\n\t"
	".set\tnoreorder\n\t"
	"mfc0\t$2,$12\n\t"
	"lui\t$3,0x8000\n\t"
	"or\t$3,$2,$3\n\t"
	"mtc0\t$3,$12\n\t"
	"nop\n"
	"1:\tbc3f\t1b\n\t"
	"nop\n\t"
	"mtc0\t$2,$12\n\t"
	"nop\n\t"
	".set\tpop"
	: : : "$2", "$3");
}
static void wbflush_mips(void)
{
	__fast_iob();
}
const char *get_system_type(void)
{
	return "NEC EMMA2RH Mark-eins";
}
static int prom_console_setup(struct console *co, char *options)
{
	return !(prom_flags & PROM_FLAG_USE_AS_CONSOLE);
}
char * __init prom_getcmdline(void)
{
	return arcs_cmdline;
}
const char *get_system_type(void)
{
	return system_type;
}
struct linux_mdesc * __init ArcGetMemoryDescriptor(struct linux_mdesc *Current)
{
	return (struct linux_mdesc *) ARC_CALL1(get_mdesc, Current);
}
struct linux_sysid *
ArcGetSystemId(VOID)
{
	return (struct linux_sysid *) ARC_CALL0(get_sysid);
}
struct linux_tinfo * __init
ArcGetTime(VOID)
{
	return (struct linux_tinfo *) ARC_CALL0(get_tinfo);
}
pcomponent * __init
ArcGetChild(pcomponent *Current)
{
	return (pcomponent *) ARC_CALL1(child_component, Current);
}
pcomponent * __init
ArcAddChild(pcomponent *Current, pcomponent *Template, VOID *ConfigurationData)
{
	return (pcomponent *)
	       ARC_CALL3(child_add, Current, Template, ConfigurationData);
}
pcomponent * __init
ArcGetComponent(CHAR *Path)
{
	return (pcomponent *)ARC_CALL1(component_by_path, Path);
}
int cfe_read(int handle, unsigned char *buffer, int length)
{
	return cfe_readblk(handle, 0, buffer, length);
}
int cfe_write(int handle, unsigned char *buffer, int length)
{
	return cfe_writeblk(handle, 0, buffer, length);
}
void prom_putchar(char c)
{
	_prom_putchar(c);
}
char *prom_getenv(char *s)
{
	return _prom_getenv(s);
}
const char *get_system_type(void)
{
	return system_type;
}
const char *get_system_type(void)
{
	return "Wind River PPMC (GT64120)";
}
unsigned long vdma_log2phys(unsigned long laddr)
{
	return pgtbl[laddr >> 12].frame + (laddr & (VDMA_PAGESIZE - 1));
}
static unsigned char jazz_read_status(void)
{
	return jazz_kh->command;
}
static int __init uart8250_init(void)
{
	return platform_device_register(&uart8250_device);
}
int ds1287_timer_state(void)
{
	return (CMOS_READ(RTC_REG_C) & RTC_PF) != 0;
}
static int ds1287_set_next_event(unsigned long delta,
				 struct clock_event_device *evt)
{
	return -EINVAL;
}
void gt641xx_set_base_clock(unsigned int clock)
{
	gt641xx_base_clock = clock;
}
static int c0_compare_int_pending(void)
{
	return (read_c0_cause() >> cp0_compare_irq) & 0x100;
}
static cycle_t txx9_cs_read(void)
{
	return __raw_readl(&txx9_cs_tmrptr->trr);
}
void __init check_bugs64(void)
{
	check_daddi();
}
void __init check_bugs32(void)
{
	check_errata();
}
static inline int __cpu_has_fpu(void)
{
	return ((cpu_get_fpu_id() & 0xff00) != FPIR_IMP_NONE);
}
static cycle_t bcm1480_hpt_read(void)
{
	return (cycle_t) __raw_readq(IOADDR(A_SCD_ZBBUS_CYCLE_COUNT));
}
static cycle_t dec_ioasic_hpt_read(void)
{
	return ioasic_read(IO_REG_FCTR);
}
static cycle_t c0_hpt_read(void)
{
	return read_c0_count();
}
static int txx9_gpio_get(struct gpio_chip *chip, unsigned int offset)
{
	return __raw_readl(&txx9_pioptr->din) & (1 << offset);
}
static void msc_bind_eic_interrupt(int irq, int set)
{
	MSCIC_WRITE(MSC01_IC_RAMW,
		    (irq<<MSC01_IC_RAMW_ADDR_SHF) | (set<<MSC01_IC_RAMW_DATA_SHF));
}
static inline void unmask_rm7k_irq(unsigned int irq)
{
	set_c0_intcontrol(0x100 << (irq - RM7K_CPU_IRQ_BASE));
}
static inline void mask_rm7k_irq(unsigned int irq)
{
	clear_c0_intcontrol(0x100 << (irq - RM7K_CPU_IRQ_BASE));
}
static inline void unmask_rm9k_irq(unsigned int irq)
{
	set_c0_intcontrol(0x1000 << (irq - RM9K_CPU_IRQ_BASE));
}
static inline void mask_rm9k_irq(unsigned int irq)
{
	clear_c0_intcontrol(0x1000 << (irq - RM9K_CPU_IRQ_BASE));
}
static void rm9k_perfcounter_irq_shutdown(unsigned int irq)
{
	on_each_cpu(local_rm9k_perfcounter_irq_shutdown, (void *) irq, 1);
}
asmlinkage void spurious_interrupt(void)
{
	atomic_inc(&irq_err_count);
}
void arch_kgdb_breakpoint(void)
{
	__asm__ __volatile__(
		".globl breakinst\n\t"
		".set\tnoreorder\n\t"
		"nop\n"
		"breakinst:\tbreak\n\t"
		"nop\n\t"
		".set\treorder");
}
static void kgdb_call_nmi_hook(void *ignored)
{
	kgdb_nmicallback(raw_smp_processor_id(), NULL);
}
void kgdb_arch_exit(void)
{
	unregister_die_notifier(&kgdb_notifier);
}
void kspd_notify(struct kspd_notifications *notify)
{
	list_add(&notify->list, &kspd_notifylist);
}
asmlinkage long sys32_truncate64(const char __user * path,
	unsigned long __dummy, int a2, int a3)
{
	return sys_truncate(path, merge_64(a2, a3));
}
asmlinkage long sys32_ftruncate64(unsigned int fd, unsigned long __dummy,
	int a2, int a3)
{
	return sys_ftruncate(fd, merge_64(a2, a3));
}
asmlinkage int sys32_llseek(unsigned int fd, unsigned int offset_high,
			    unsigned int offset_low, loff_t __user * result,
			    unsigned int origin)
{
	return sys_llseek(fd, offset_high, offset_low, result, origin);
}
asmlinkage ssize_t sys32_pread(unsigned int fd, char __user * buf,
			       size_t count, u32 unused, u64 a4, u64 a5)
{
	return sys_pread64(fd, buf, count, merge_64(a4, a5));
}
asmlinkage ssize_t sys32_pwrite(unsigned int fd, const char __user * buf,
			        size_t count, u32 unused, u64 a4, u64 a5)
{
	return sys_pwrite64(fd, buf, count, merge_64(a4, a5));
}
asmlinkage long
sys32_ipc(u32 call, int first, int second, int third, u32 ptr, u32 fifth)
{
	return -ENOSYS;
}
asmlinkage long sysn32_msgsnd(int msqid, u32 msgp, unsigned msgsz, int msgflg)
{
	return compat_sys_msgsnd(msqid, msgsz, msgflg, compat_ptr(msgp));
}
asmlinkage long sysn32_msgrcv(int msqid, u32 msgp, size_t msgsz, int msgtyp,
			      int msgflg)
{
	return compat_sys_msgrcv(msqid, msgsz, msgtyp, msgflg, IPC_64,
				 compat_ptr(msgp));
}
asmlinkage ssize_t sys32_readahead(int fd, u32 pad0, u64 a2, u64 a3,
                                   size_t count)
{
	return sys_readahead(fd, merge_64(a2, a3), count);
}
asmlinkage long sys32_sync_file_range(int fd, int __pad,
	unsigned long a2, unsigned long a3,
	unsigned long a4, unsigned long a5,
	int flags)
{
	return sys_sync_file_range(fd,
			merge_64(a2, a3), merge_64(a4, a5),
			flags);
}
asmlinkage long sys32_fadvise64_64(int fd, int __pad,
	unsigned long a2, unsigned long a3,
	unsigned long a4, unsigned long a5,
	int flags)
{
	return sys_fadvise64_64(fd,
			merge_64(a2, a3), merge_64(a4, a5),
			flags);
}
asmlinkage long sys32_fallocate(int fd, int mode, unsigned offset_a2,
	unsigned offset_a3, unsigned len_a4, unsigned len_a5)
{
	return sys_fallocate(fd, mode, merge_64(offset_a2, offset_a3),
	                     merge_64(len_a4, len_a5));
}
int
machine_kexec_prepare(struct kimage *kimage)
{
	return 0;
}
static inline struct task_struct *find_process_by_pid(pid_t pid)
{
	return pid ? find_task_by_vpid(pid) : current;
}
void module_free(struct module *mod, void *module_region)
{
	vfree(module_region);
}
int module_frob_arch_sections(Elf_Ehdr *hdr, Elf_Shdr *sechdrs,
			      char *secstrings, struct module *mod)
{
	return 0;
}
static int apply_r_mips_none(struct module *me, u32 *location, Elf_Addr v)
{
	return 0;
}
static void __noreturn kernel_thread_helper(void *arg, int (*fn)(void *))
{
	do_exit(fn(arg));
}
static inline int is_ra_save_ins(union mips_instruction *ip)
{
	return (ip->i_format.opcode == sw_op || ip->i_format.opcode == sd_op) &&
		ip->i_format.rs == 29 &&
		ip->i_format.rt == 31;
}
void ptrace_disable(struct task_struct *child)
{
	clear_tsk_thread_flag(child, TIF_LOAD_WATCH);
}
static void rtlx_dispatch(void)
{
	do_IRQ(MIPS_CPU_IRQ_BASE + MIPS_CPU_RTLX_IRQ);
}
static unsigned long __init init_initrd(void)
{
	return 0;
}
static void cmp_cpus_done(void)
{
	pr_debug("SMPCMP: CPU%d: %s\n", smp_processor_id(), __func__);
}
static void __init vsmp_prepare_cpus(unsigned int max_cpus)
{
	mips_mt_set_cpuoptions();
}
void up_send_ipi_single(int cpu, unsigned int action)
{
	panic(KERN_ERR "%s called", __func__);
}
static inline void up_send_ipi_mask(cpumask_t mask, unsigned int action)
{
	panic(KERN_ERR "%s called", __func__);
}
void arch_send_call_function_ipi(cpumask_t mask)
{
	mp_ops->send_ipi_mask(mask, SMP_CALL_FUNCTION);
}
void arch_send_call_function_single_ipi(int cpu)
{
	mp_ops->send_ipi_mask(cpumask_of_cpu(cpu), SMP_CALL_FUNCTION);
}
void smp_send_stop(void)
{
	smp_call_function(stop_this_cpu, NULL, 0);
}
int setup_profiling_timer(unsigned int multiplier)
{
	return 0;
}
static void flush_tlb_all_ipi(void *info)
{
	local_flush_tlb_all();
}
void flush_tlb_all(void)
{
	on_each_cpu(flush_tlb_all_ipi, NULL, 1);
}
static void flush_tlb_mm_ipi(void *mm)
{
	local_flush_tlb_mm((struct mm_struct *)mm);
}
static inline void smp_on_other_tlbs(void (*func) (void *info), void *info)
{
	smp_call_function(func, info, 1);
}
void flush_tlb_one(unsigned long vaddr)
{
	smp_on_each_tlb(flush_tlb_one_ipi, (void *) vaddr);
}
void smtc_init_secondary(void)
{
	local_irq_enable();
}
static void ipi_call_interrupt(void)
{
	smp_call_function_interrupt();
}
static void ipi_irq_dispatch(void)
{
	do_IRQ(cpu_ipi_irq);
}
void save_stack_trace(struct stack_trace *trace)
{
	save_stack_trace_tsk(current, trace);
}
static int __used noinline
_sys_fork(nabi_no_regargs struct pt_regs regs)
{
	return do_fork(SIGCHLD, regs.regs[29], &regs, 0, NULL, NULL);
}
asmlinkage int sys_cachectl(char *addr, int nbytes, int op)
{
	return -ENOSYS;
}
asmlinkage void bad_stack(void)
{
	do_exit(SIGSEGV);
}
int __weak rtc_mips_set_time(unsigned long sec)
{
	return 0;
}
int __weak rtc_mips_set_mmss(unsigned long nowtime)
{
	return rtc_mips_set_time(nowtime);
}
int update_persistent_clock(struct timespec now)
{
	return rtc_mips_set_mmss(now.tv_sec);
}
static int null_perf_irq(void)
{
	return 0;
}
void __init plat_timer_setup(void)
{
	BUG();
}
void show_regs(struct pt_regs *regs)
{
	__show_regs((struct pt_regs *)regs);
}
asmlinkage void do_mdmx(struct pt_regs *regs)
{
	force_sig(SIGILL, current);
}
void *set_vi_handler(int n, vi_handler_t addr)
{
	return set_vi_srs_handler(n, addr, 0);
}
static int smp_save_fp_context(struct sigcontext __user *sc)
{
	return raw_cpu_has_fpu
	       ? _save_fp_context(sc)
	       : fpu_emulator_save_context(sc);
}
static int smp_restore_fp_context(struct sigcontext __user *sc)
{
	return raw_cpu_has_fpu
	       ? _restore_fp_context(sc)
	       : fpu_emulator_restore_context(sc);
}
static void release_progmem(void *ptr)
{
	kfree(ptr);
}
static int apply_r_mips_none(struct module *me, uint32_t *location,
			     Elf32_Addr v)
{
	return 0;
}
static void kspd_sp_exit( int sp_id)
{
	cleanup_tc(get_tc(sp_id));
}
static void vpe_device_release(struct device *cd)
{
	kfree(cd);
}
static void at93c_reg_write(u32 val)
{
	*at93c->reg = val;
}
static void rtc_reg_write(unsigned long val)
{
	*ds1603->reg = val;
}
static void rtc_nrst_high(void)
{
	rtc_reg_write(rtc_reg_read() | ds1603->rst);
}
static void rtc_nrst_low(void)
{
	rtc_reg_write(rtc_reg_read() & ~ds1603->rst);
}
void ds1603_disable(void)
{
	ds1603_set_trimmer(TRIMMER_DISABLE_RTC);
}
void ds1603_enable(void)
{
	ds1603_set_trimmer(TRIMMER_DEFAULT);
}
static unsigned long get_int_status_100(void)
{
	return *lasat_int_status & *lasat_int_mask;
}
static void pvc_reg_write(u32 val)
{
	*picvue->reg = val;
}
static void pvc_funcset(u8 cmd)
{
	pvc_write(FUNC_SET_CMD | (cmd & (EIGHT_BYTE|TWO_LINES|LARGE_FONT)),
		  MODE_INST);
}
static void pvc_entrymode(u8 cmd)
{
	pvc_write(ENTRYMODE_CMD | (cmd & (AUTO_INC|CURSOR_FOLLOWS_DISP)),
		  MODE_INST);
}
void pvc_dispcnt(u8 cmd)
{
	pvc_write(DISP_CNT_CMD | (cmd & (DISP_ON|CUR_ON|CUR_BLINK)), MODE_INST);
}
void pvc_move(u8 cmd)
{
	pvc_write(MOVE_CMD | (cmd & (DISPLAY|RIGHT)), MODE_INST);
}
void pvc_clear(void)
{
	pvc_write(CLEAR_CMD, MODE_INST);
}
void pvc_home(void)
{
	pvc_write(HOME_CMD, MODE_INST);
}
void prom_putchar(char c)
{
	__prom_putc(c);
}
const char *get_system_type(void)
{
	return lasat_board_info.li_bmstr;
}
const char *get_system_type(void)
{
	return "lemote-fulong";
}
void prom_putchar(char c)
{
	putDebugChar(c);
}
static void loongson2e_power_off(void)
{
	loongson2e_halt();
}
void __init plat_time_init(void)
{
	mips_hpt_frequency = cpu_clock_freq / 2;
}
unsigned long read_persistent_clock(void)
{
	return mc146818_get_cmos_time();
}
static void wbflush_loongson2e(void)
{
	asm(".set\tpush\n\t"
	    ".set\tnoreorder\n\t"
	    ".set mips3\n\t"
	    "sync\n\t"
	    "nop\n\t"
	    ".set\tpop\n\t"
	    ".set mips0\n\t");
}
void dump_tlb_all(void)
{
	dump_tlb(0, current_cpu_data.tlbsize - 1);
}
void pci_iounmap(struct pci_dev *dev, void __iomem * addr)
{
	iounmap(addr);
}
unsigned int ioread8(void __iomem *addr)
{
	return readb(addr);
}
unsigned int ioread16(void __iomem *addr)
{
	return readw(addr);
}
unsigned int ioread16be(void __iomem *addr)
{
	return be16_to_cpu(__raw_readw(addr));
}
unsigned int ioread32(void __iomem *addr)
{
	return readl(addr);
}
unsigned int ioread32be(void __iomem *addr)
{
	return be32_to_cpu(__raw_readl(addr));
}
void iowrite8(u8 val, void __iomem *addr)
{
	writeb(val, addr);
}
void iowrite16(u16 val, void __iomem *addr)
{
	writew(val, addr);
}
void iowrite16be(u16 val, void __iomem *addr)
{
	__raw_writew(cpu_to_be16(val), addr);
}
void iowrite32(u32 val, void __iomem *addr)
{
	writel(val, addr);
}
void iowrite32be(u32 val, void __iomem *addr)
{
	__raw_writel(cpu_to_be32(val), addr);
}
void ioread8_rep(void __iomem *addr, void *dst, unsigned long count)
{
	mmio_insb(addr, dst, count);
}
void ioread16_rep(void __iomem *addr, void *dst, unsigned long count)
{
	mmio_insw(addr, dst, count);
}
void ioread32_rep(void __iomem *addr, void *dst, unsigned long count)
{
	mmio_insl(addr, dst, count);
}
void iowrite8_rep(void __iomem *addr, const void *src, unsigned long count)
{
	mmio_outsb(addr, src, count);
}
void iowrite16_rep(void __iomem *addr, const void *src, unsigned long count)
{
	mmio_outsw(addr, src, count);
}
void iowrite32_rep(void __iomem *addr, const void *src, unsigned long count)
{
	mmio_outsl(addr, src, count);
}
static void __iomem *ioport_map_legacy(unsigned long port, unsigned int nr)
{
	return (void __iomem *) (mips_io_port_base + port);
}
void dump_tlb_all(void)
{
	dump_tlb(0, current_cpu_data.tlbsize - 1);
}
static ieee754dp fpemu_dp_recip(ieee754dp d)
{
	return ieee754dp_div(ieee754dp_one(0), d);
}
static ieee754dp fpemu_dp_rsqrt(ieee754dp d)
{
	return ieee754dp_div(ieee754dp_one(0), ieee754dp_sqrt(d));
}
static ieee754sp fpemu_sp_recip(ieee754sp s)
{
	return ieee754sp_div(ieee754sp_one(0), s);
}
static ieee754sp fpemu_sp_rsqrt(ieee754sp s)
{
	return ieee754sp_div(ieee754sp_one(0), ieee754sp_sqrt(s));
}
ieee754dp ieee754dp_ldexp(ieee754dp x, int n)
{
	return ieee754dp_scalb(x, n);
}
int ieee754dp_finite(ieee754dp x)
{
	return DPBEXP(x) != DP_EMAX + 1 + DP_EBIAS;
}
int ieee754dp_isnan(ieee754dp x)
{
	return ieee754dp_class(x) >= IEEE754_CLASS_SNAN;
}
int ieee754sp_isnan(ieee754sp x)
{
	return ieee754sp_class(x) >= IEEE754_CLASS_SNAN;
}
void ieee754_xcpt(struct ieee754xctx *xcp)
{
	printk(KERN_DEBUG "floating point exception in \"%s\", type=%s\n",
		xcp->op, rtnames[xcp->rt]);
}
ieee754sp ieee754sp_ldexp(ieee754sp x, int n)
{
	return ieee754sp_scalb(x, n);
}
int ieee754sp_finite(ieee754sp x)
{
	return SPBEXP(x) != SP_EMAX + 1 + SP_EBIAS;
}
char * __init prom_getcmdline(void)
{
	return arcs_cmdline;
}
static inline unsigned int serial_in(int offset)
{
	return inb(0x3f8 + offset);
}
static inline void serial_out(int offset, int value)
{
	outb(value, 0x3f8 + offset);
}
static inline unsigned int irq_ffs(unsigned int pending)
{
	return -clz(pending) + 31 - CAUSEB_IP;
}
void __init arch_init_irq(void)
{
	mips_cpu_irq_init();
}
const char *get_system_type(void)
{
	return "MIPSsim";
}
static void ssmtc_send_ipi_single(int cpu, unsigned int action)
{
	smtc_send_ipi(cpu, LINUX_SMP_IPI, action);
}
static void __cpuinit ssmtc_smp_finish(void)
{
	smtc_smp_finish();
}
static void __cpuinit ssmtc_boot_secondary(int cpu, struct task_struct *idle)
{
	smtc_boot_secondary(cpu, idle);
}
static void mips_timer_dispatch(void)
{
	do_IRQ(mips_cpu_timer_irq);
}
static inline void octeon_local_flush_icache(void)
{
	asm volatile ("synci 0($0)");
}
static void local_octeon_flush_icache_range(unsigned long start,
					    unsigned long end)
{
	octeon_local_flush_icache();
}
static void octeon_flush_icache_all(void)
{
	octeon_flush_icache_all_cores(NULL);
}
static void octeon_flush_icache_range(unsigned long start, unsigned long end)
{
	octeon_flush_icache_all_cores(NULL);
}
asmlinkage void cache_parity_error_octeon_recoverable(void)
{
	cache_parity_error_octeon(0);
}
asmlinkage void cache_parity_error_octeon_non_recoverable(void)
{
	cache_parity_error_octeon(1);
}
static void r4k___flush_cache_all(void)
{
	r4k_on_each_cpu(local_r4k___flush_cache_all, NULL, 1);
}
static void r4k__flush_cache_vmap(void)
{
	r4k_blast_dcache();
}
static void r4k__flush_cache_vunmap(void)
{
	r4k_blast_dcache();
}
static inline void local_r4k_flush_data_cache_page(void * addr)
{
	r4k_blast_dcache_page((unsigned long) addr);
}
static void r4k_flush_cache_sigtramp(unsigned long addr)
{
	r4k_on_each_cpu(local_r4k_flush_cache_sigtramp, (void *) addr, 1);
}
static inline void tx39_blast_dcache_page_indexed(unsigned long addr)
{
	blast_dcache16_page_indexed(addr);
}
static inline void tx39_blast_dcache(void)
{
	blast_dcache16();
}
static void tx39__flush_cache_vmap(void)
{
	tx39_blast_dcache();
}
static void tx39__flush_cache_vunmap(void)
{
	tx39_blast_dcache();
}
static void local_tx39_flush_data_cache_page(void * addr)
{
	tx39_blast_dcache_page((unsigned long)addr);
}
static void tx39_flush_data_cache_page(unsigned long addr)
{
	tx39_blast_dcache_page(addr);
}
static inline int cpu_is_noncoherent_r10000(struct device *dev)
{
	return !plat_device_is_coherent(dev) &&
	       (current_cpu_type() == CPU_R10000 ||
	       current_cpu_type() == CPU_R12000);
}
int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
{
	return plat_dma_mapping_error(dev, dma_addr);
}
int dma_supported(struct device *dev, u64 mask)
{
	return plat_dma_supported(dev, mask);
}
int dma_is_consistent(struct device *dev, dma_addr_t dma_addr)
{
	return plat_device_is_coherent(dev);
}
void free_initrd_mem(unsigned long start, unsigned long end)
{
	free_init_pages("initrd memory",
			virt_to_phys((void *)start),
			virt_to_phys((void *)end));
}
static void mips_sc_wback_inv(unsigned long addr, unsigned long size)
{
	blast_scache_range(addr, addr + size);
}
static void mips_sc_inv(unsigned long addr, unsigned long size)
{
	blast_inv_scache_range(addr, addr + size);
}
static void rm7k_sc_disable(void)
{
	clear_c0_config(RM7K_CONF_SE);
}
static inline int r45k_bvahwbug(void)
{
	return 0;
}
static inline int r4k_250MHZhwbug(void)
{
	return 0;
}
static inline int __maybe_unused bcm1250_m3_war(void)
{
	return BCM1250_M3_WAR;
}
static inline int __maybe_unused r10000_llsc_war(void)
{
	return R10000_LLSC_WAR;
}
static int __cpuinit m4kc_tlbp_war(void)
{
	return (current_cpu_data.processor_id & 0xffff00) ==
	       (PRID_COMP_MIPS | PRID_IMP_4KC);
}
int __cpuinit uasm_in_compat_space_p(long addr)
{
	return (((addr) & 0xffffffff00000000L) == 0xffffffff00000000L);
}
static int __cpuinit uasm_rel_highest(long val)
{
	return ((((val + 0x800080008000L) >> 48) & 0xffff) ^ 0x8000) - 0x8000;
}
static int __cpuinit uasm_rel_higher(long val)
{
	return ((((val + 0x80008000L) >> 32) & 0xffff) ^ 0x8000) - 0x8000;
}
int __cpuinit uasm_rel_hi(long val)
{
	return ((((val + 0x8000L) >> 16) & 0xffff) ^ 0x8000) - 0x8000;
}
int __cpuinit uasm_rel_lo(long val)
{
	return ((val & 0xffff) ^ 0x8000) - 0x8000;
}
char * __init prom_getcmdline(void)
{
	return &(arcs_cmdline[0]);
}
static inline unsigned int serial_in(int offset)
{
	return inb(PORT(offset));
}
static inline void serial_out(int offset, int value)
{
	outb(value, PORT(offset));
}
static inline unsigned int irq_ffs(unsigned int pending)
{
	return -clz(pending) + 31 - CAUSEB_IP;
}
static void ipi_resched_dispatch(void)
{
	do_IRQ(MIPS_CPU_IRQ_BASE + MIPS_CPU_IPI_RESCHED_IRQ);
}
static void ipi_call_dispatch(void)
{
	do_IRQ(MIPS_CPU_IRQ_BASE + MIPS_CPU_IPI_CALL_IRQ);
}
static irqreturn_t ipi_resched_interrupt(int irq, void *dev_id)
{
	return IRQ_HANDLED;
}
const char *get_system_type(void)
{
	return "MIPS Malta";
}
static void __init screen_info_setup(void)
{
	screen_info = (struct screen_info) {
		.orig_x = 0,
		.orig_y = 25,
		.ext_mem_k = 0,
		.orig_video_page = 0,
		.orig_video_mode = 0,
		.orig_video_cols = 80,
		.unused2 = 0,
		.orig_video_ega_bx = 0,
		.unused3 = 0,
		.orig_video_lines = 25,
		.orig_video_isVGA = VIDEO_TYPE_VGAC,
		.orig_video_points = 16
	};
}
static void msmtc_send_ipi_single(int cpu, unsigned int action)
{
	smtc_send_ipi(cpu, LINUX_SMP_IPI, action);
}
static void __cpuinit msmtc_boot_secondary(int cpu, struct task_struct *idle)
{
	smtc_boot_secondary(cpu, idle);
}
static void __cpuinit msmtc_smp_finish(void)
{
	smtc_smp_finish();
}
static void __init msmtc_smp_setup(void)
{
	smp_num_siblings = smtc_build_cpu_map(0);
}
static void __init msmtc_prepare_cpus(unsigned int max_cpus)
{
	smtc_prepare_cpus(max_cpus);
}
static void mips_timer_dispatch(void)
{
	do_IRQ(mips_cpu_timer_irq);
}
static void mips_perf_dispatch(void)
{
	do_IRQ(mips_cpu_perf_irq);
}
unsigned long read_persistent_clock(void)
{
	return mc146818_get_cmos_time();
}
static void pnx833x_timer_dispatch(void)
{
	do_IRQ(mips_cpu_timer_irq);
}
static inline void pnx833x_hard_enable_pic_irq(unsigned int irq)
{
	PNX833X_PIC_INT_REG(irq) = irq_prio[irq];
}
static inline void pnx833x_hard_disable_pic_irq(unsigned int irq)
{
	PNX833X_PIC_INT_REG(irq) = 0;
}
char * __init prom_getcmdline(void)
{
	return arcs_cmdline;
}
void pnx833x_machine_power_off(void)
{
	pnx833x_machine_halt();
}
const char *get_system_type(void)
{
	return "NXP STB22x";
}
static inline void mask_gic_int(unsigned int irq_nr)
{
	PNX8550_GIC_REQ(irq_nr) = 1<<28; /* set priority to 0 */
}
static inline void unmask_gic_int(unsigned int irq_nr)
{
	PNX8550_GIC_REQ(irq_nr) = (1<<26 | 1<<16) | (1<<28) | gic_prio[irq_nr];
}
static int __init pnx8550_platform_init(void)
{
	return platform_add_devices(pnx8550_platform_devices,
			            ARRAY_SIZE(pnx8550_platform_devices));
}
char * prom_getcmdline(void)
{
	return &(arcs_cmdline[0]);
}
void pnx8550_machine_halt(void)
{
	printk("*** Machine halt. (Not implemented) ***\n");
}
void pnx8550_machine_power_off(void)
{
	printk("*** Machine power off.  (Not implemented) ***\n");
}
static cycle_t hpt_read(void)
{
	return read_c0_count2();
}
static inline void timer_ack(void)
{
	write_c0_compare(cpj);
}
const char *get_system_type(void)
{
	return "NXP PNX8550/JBS";
}
const char *get_system_type(void)
{
	return "NXP PNX8950/STB810";
}
static void op_mips_stop(void)
{
	on_each_cpu(model->cpu_stop, NULL, 1);
}
static inline unsigned int vpe_shift(void)
{
	return 0;
}
static inline unsigned int counters_total_to_per_cpu(unsigned int counters)
{
	return counters >> vpe_shift();
}
static inline unsigned int counters_per_cpu_to_total(unsigned int counters)
{
	return counters << vpe_shift();
}
static void rm9000_cpu_start(void *args)
{
	write_c0_perfcontrol(reg.control);
}
static void rm9000_cpu_stop(void *args)
{
	write_c0_perfcontrol(0);
}
static int __init rm9000_init(void)
{
	return request_irq(rm9000_perfcount_irq, rm9000_perfcount_handler,
	                   0, "Perfcounter", NULL);
}
static void rm9000_exit(void)
{
	free_irq(rm9000_perfcount_irq, NULL);
}
int __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
{
	return irq_tab_alchemy[slot][pin];
}
int pcibios_plat_dev_init(struct pci_dev *dev)
{
	return 0;
}
int __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
{
	return irq_tab_capcella[slot][pin];
}
int pcibios_plat_dev_init(struct pci_dev *dev)
{
	return 0;
}
int pcibios_plat_dev_init(struct pci_dev *dev)
{
	return 0;
}
int __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
{
	return irq_map[slot][pin];
}
int pcibios_plat_dev_init(struct pci_dev *dev)
{
	return 0;
}
int pcibios_plat_dev_init(struct pci_dev *dev)
{
	return 0;
}
int __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
{
	return irq_tab_mace[slot][pin];
}
int pcibios_plat_dev_init(struct pci_dev *dev)
{
	return 0;
}
int pcibios_plat_dev_init(struct pci_dev *dev)
{
	return 0;
}
static void __init loongson2e_686b_func2_fixup(struct pci_dev *pdev)
{
	pci_write_config_byte(pdev, PCI_INTERRUPT_LINE, 10);
}
static void __init loongson2e_686b_func3_fixup(struct pci_dev *pdev)
{
	pci_write_config_byte(pdev, PCI_INTERRUPT_LINE, 11);
}
int pcibios_plat_dev_init(struct pci_dev *dev)
{
	return 0;
}
int pcibios_plat_dev_init(struct pci_dev *dev)
{
	return 0;
}
int pcibios_plat_dev_init(struct pci_dev *dev)
{
	return PCIBIOS_SUCCESSFUL;
}
int __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
{
	return pnx8550_irq_tab[slot][pin];
}
int pcibios_plat_dev_init(struct pci_dev *dev)
{
	return 0;
}
int pcibios_plat_dev_init(struct pci_dev *dev)
{
	return 0;
}
static void __init quirk_sb1250_pci(struct pci_dev *dev)
{
	pci_write_config_byte(dev, 0x40, 0xff);
}
static void __init quirk_sb1250_ht(struct pci_dev *dev)
{
	dev->class = PCI_CLASS_BRIDGE_PCI << 8;
}
static void __init quirk_sp1011(struct pci_dev *dev)
{
	pci_write_config_byte(dev, 0x64, 0xff);
}
int pcibios_plat_dev_init(struct pci_dev *dev)
{
	return 0;
}
int pcibios_plat_dev_init(struct pci_dev *dev)
{
	return 0;
}
int pcibios_plat_dev_init(struct pci_dev *dev)
{
	return 0;
}
int pcibios_plat_dev_init(struct pci_dev *dev)
{
	return 0;
}
int __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
{
	return pci_irq_tab[slot][pin];
}
int pcibios_plat_dev_init(struct pci_dev *dev)
{
	return 0;
}
int pcibios_plat_dev_init(struct pci_dev *dev)
{
	return 0;
}
static inline int mkaddr(struct pci_bus *bus, unsigned int devfn,
	unsigned int reg)
{
	return ((bus->number & 0xff) << 16) |
		((devfn & 0xff) << 8) |
		(reg & 0xfc);
}
static u32 icd_readl(struct tx4927_pcic_reg __iomem *pcicptr)
{
	return __raw_readl(&pcicptr->g2pcfgdata);
}
static void icd_writel(u32 val, struct tx4927_pcic_reg __iomem *pcicptr)
{
	__raw_writel(val, &pcicptr->g2pcfgdata);
}
static inline u32 READCFG32(u32 addr)
{
	return *(u32 *)(cfg_space + (addr&~3));
}
static inline void WRITECFG32(u32 addr, u32 data)
{
	*(u32 *)(cfg_space + (addr & ~3)) = data;
}
int pcibios_plat_dev_init(struct pci_dev *dev)
{
	return 0;
}
static inline u32 READCFG32(u32 addr)
{
	return *(u32 *)(ht_cfg_space + (addr&~3));
}
static inline void WRITECFG32(u32 addr, u32 data)
{
	*(u32 *)(ht_cfg_space + (addr & ~3)) = data;
}
static int bcm1480ht_pcibios_get_busno(void)
{
	return 0;
}
int __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
{
	return 0;
}
int __devinit pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
{
	return 0;
}
static void __init pci_fixup_ioc3(struct pci_dev *d)
{
	pci_disable_swapping(d);
}
int pcibios_plat_dev_init(struct pci_dev *dev)
{
	return 0;
}
static inline u32 READCFG32(u32 addr)
{
	return *(u32 *) (cfg_space + (addr & ~3));
}
static inline void WRITECFG32(u32 addr, u32 data)
{
	*(u32 *) (cfg_space + (addr & ~3)) = data;
}
int pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
{
	return dev->irq;
}
int pcibios_plat_dev_init(struct pci_dev *dev)
{
	return 0;
}
void __init vr41xx_pciu_setup(struct pci_controller_unit_setup *setup)
{
	vr41xx_pci_controller_unit_setup = *setup;
}
unsigned int pcibios_assign_all_busses(void)
{
	return (pci_probe & PCI_ASSIGN_ALL_BUSSES) ? 1 : 0;
}
void __init
pcibios_update_irq(struct pci_dev *dev, int irq)
{
	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq);
}
static int msp71xx_direction_input(struct gpio_chip *chip, unsigned offset)
{
	return msp71xx_set_gpio_mode(chip, offset, MSP71XX_GPIO_INPUT);
}
static void softreset_release(void *data)
{
	printk(KERN_WARNING "SOFTRESET switch was released\n");
}
const char *get_system_type(void)
{
	return "PMC-Sierra MSP4200 Eval Board";
}
char identify_pci(void)
{
	return test_feature(PCI_KEY);
}
char identify_pcimux(void)
{
	return test_feature(PCIMUX_KEY);
}
char identify_sec(void)
{
	return test_feature(SEC_KEY);
}
char identify_spad(void)
{
	return test_feature(SPAD_KEY);
}
char identify_tdm(void)
{
	return test_feature(TDM_KEY);
}
char identify_zsp(void)
{
	return test_feature(ZSP_KEY);
}
char identify_enet(unsigned long interface_num)
{
	return identify_enetfeature(ENET_KEY, interface_num);
}
char identify_enetTxD(unsigned long interface_num)
{
	return identify_enetfeature(ENETTXD_KEY, interface_num);
}
char *prom_getcmdline(void)
{
	return &(arcs_cmdline[0]);
}
void msp_power_off(void)
{
	msp_halt();
}
void __init plat_timer_setup(struct irqaction *irq)
{
	setup_irq(MSP_INT_VPE0_TIMER, irq);
}
static void send_ack(void)
{
	send_bit(0);
}
int pcibios_enable_device(struct pci_dev *dev, int mask)
{
        return pcibios_enable_resources(dev);
}
void __init pcibios_fixup_bus(struct pci_bus *c)
{
        titan_ht_pcibios_fixup_bus(c);
}
unsigned __init int pcibios_assign_all_busses(void)
{
        return 0;
}
const char *get_system_type(void)
{
	return "PMC-Sierra Yosemite";
}
static void __cpuinit yos_init_secondary(void)
{
	set_c0_status(ST0_CO | ST0_IE | ST0_IM);
}
unsigned char get_latch_u5(void)
{
	return dev3.state;
}
static int rb532_dev_ready(struct mtd_info *mtd)
{
	return gpio_get_value(GPIO_RDY);
}
static inline int rb532_get_bit(unsigned offset, void __iomem *ioaddr)
{
	return (readl(ioaddr) & (1 << offset));
}
void rb532_gpio_set_ilevel(int bit, unsigned gpio)
{
	rb532_set_bit(bit, gpio, rb532_gpio_chip->regbase + GPIOILEVEL);
}
void rb532_gpio_set_istat(int bit, unsigned gpio)
{
	rb532_set_bit(bit, gpio, rb532_gpio_chip->regbase + GPIOISTAT);
}
void rb532_gpio_set_func(unsigned gpio)
{
       rb532_set_bit(1, gpio, rb532_gpio_chip->regbase + GPIOFUNC);
}
static inline int irq_to_group(unsigned int irq_nr)
{
	return (irq_nr - GROUP0_IRQ_BASE) >> 5;
}
static inline int group_to_ip(unsigned int group)
{
	return group + 2;
}
static inline int match_tag(char *arg, const char *tag)
{
	return strncmp(arg, tag, strlen(tag)) == 0;
}
void __init ip22_be_init(void)
{
	board_be_handler = ip22_be_handler;
}
static void disable_local0_irq(unsigned int irq)
{
	sgint->imask0 &= ~(1 << (irq - SGINT_LOCAL0));
}
static void disable_local1_irq(unsigned int irq)
{
	sgint->imask1 &= ~(1 << (irq - SGINT_LOCAL1));
}
static inline unsigned long get_bank_addr(unsigned int memconfig)
{
	return ((memconfig & SGIMC_MCONFIG_BASEADDR) <<
		((sgimc->systemid & SGIMC_SYSID_MASKREV) >= 5 ? 24 : 22));
}
static inline unsigned long get_bank_size(unsigned int memconfig)
{
	return ((memconfig & SGIMC_MCONFIG_RMASK) + 0x0100) <<
		((sgimc->systemid & SGIMC_SYSID_MASKREV) >= 5 ? 16 : 14);
}
static int __init sgi_hal2_devinit(void)
{
	return IS_ERR(platform_device_register_simple("sgihal2", 0, NULL, 0));
}
static void power_timeout(unsigned long data)
{
	sgi_machine_power_off();
}
void __init ip22_be_init(void)
{
	board_be_handler = ip28_be_handler;
}
cnodeid_t get_compact_nodeid(void)
{
	return NASID_TO_COMPACT_NODEID(get_nasid());
}
static void ip27_prof_timer(void)
{
	panic("CPU %d got a profiling interrupt", smp_processor_id());
}
static void ip27_hub_error(void)
{
	panic("CPU %d got a hub error interrupt", smp_processor_id());
}
void __devinit register_bridge_irq(unsigned int irq)
{
	set_irq_chip_and_handler(irq, &bridge_irq_type, handle_level_irq);
}
klinfo_t *find_first_component(lboard_t *brd, unsigned char struct_type)
{
	return find_component(brd, (klinfo_t *)NULL, struct_type);
}
cnodeid_t get_cpu_cnode(cpuid_t cpu)
{
	return CPUID_TO_COMPACT_NODEID(cpu);
}
static int is_fine_dirmode(void)
{
	return (((LOCAL_HUB_L(NI_STATUS_REV_ID) & NSRI_REGIONSIZE_MASK)
	        >> NSRI_REGIONSIZE_SHFT) & REGIONSIZE_FINE);
}
static hubreg_t get_region(cnodeid_t cnode)
{
	if (fine_mode)
		return COMPACT_TO_NASID_NODEID(cnode) >> NASID_TO_FINEREG_SHFT;
	else
		return COMPACT_TO_NASID_NODEID(cnode) >> NASID_TO_COARSEREG_SHFT;
}
static void ip27_machine_power_off(void)
{
	noreturn;
}
static void __cpuinit ip27_init_secondary(void)
{
	per_cpu_init();
}
static cycle_t hub_rt_read(void)
{
	return REMOTE_HUB_L(cputonasid(0), PI_RT_COUNT);
}
void __init ip32_be_init(void)
{
	board_be_handler = ip32_be_handler;
}
static void inline flush_crime_bus(void)
{
	crime->control;
}
static void inline flush_mace_bus(void)
{
	mace->perif.ctrl.misc;
}
static void crime_level_mask_and_ack_irq(unsigned int irq)
{
	crime_disable_irq(irq);
}
static void ip32_irq1(void)
{
	ip32_unknown_interrupt();
}
static void ip32_irq2(void)
{
	ip32_unknown_interrupt();
}
static void ip32_irq3(void)
{
	ip32_unknown_interrupt();
}
static void ip32_irq4(void)
{
	ip32_unknown_interrupt();
}
static void ip32_irq5(void)
{
	do_IRQ(MIPS_CPU_IRQ_BASE + 7);
}
static int __init uart8250_init(void)
{
	return platform_device_register(&uart8250_device);
}
static __init int sgio2btns_devinit(void)
{
	return IS_ERR(platform_device_register_simple("sgibtns", -1, NULL, 0));
}
static __init int sgio2_cmos_devinit(void)
{
	return IS_ERR(platform_device_register_simple("rtc_cmos", -1,
						      sgio2_cmos_rsrc, 1));
}
static inline void ip32_machine_halt(void)
{
	ip32_machine_power_off();
}
static void power_timeout(unsigned long data)
{
	ip32_machine_power_off();
}
static void disable_bcm1480_irq(unsigned int irq)
{
	bcm1480_mask_irq(bcm1480_irq_owner[irq], irq);
}
static void enable_bcm1480_irq(unsigned int irq)
{
	bcm1480_unmask_irq(bcm1480_irq_owner[irq], irq);
}
static void bcm1480_send_ipi_single(int cpu, unsigned int action)
{
	__raw_writeq((((u64)action)<< 48), mailbox_0_set_regs[cpu]);
}
static void disable_sb1250_irq(unsigned int irq)
{
	sb1250_mask_irq(sb1250_irq_owner[irq], irq);
}
static void enable_sb1250_irq(unsigned int irq)
{
	sb1250_unmask_irq(sb1250_irq_owner[irq], irq);
}
static void sb1250_send_ipi_single(int cpu, unsigned int action)
{
	__raw_writeq((((u64)action) << 48), mailbox_set_regs[cpu]);
}
int xicor_probe(void)
{
	return (xicor_read(X1241REG_SC) != -1);
}
const char *get_system_type(void)
{
	return "SiByte " SIBYTE_BOARD_NAME;
}
asmlinkage void plat_irq_dispatch(void)
{
	sni_hwint();
}
static void pcimt_hwint0(void)
{
	panic("Received int0 but no handler yet ...");
}
void sni_machine_power_off(void)
{
	*(volatile unsigned char *)PCIMT_CSWCSM = 0xfd;
}
unsigned long read_persistent_clock(void)
{
	return -1;
}
int pcibios_plat_dev_init(struct pci_dev *dev)
{
	return 0;
}
int __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
{
	return txx9_board_vec->pci_map_irq(dev, slot, pin);
}
int clk_enable(struct clk *clk)
{
	return 0;
}
unsigned long clk_get_rate(struct clk *clk)
{
	return (unsigned long)clk;
}
int gpio_to_irq(unsigned gpio)
{
	return -EINVAL;
}
int irq_to_gpio(unsigned irq)
{
	return -EINVAL;
}
const char *get_system_type(void)
{
	return txx9_system_type;
}
char * __init prom_getcmdline(void)
{
	return &(arcs_cmdline[0]);
}
void __init prom_putchar(char c)
{
	txx9_prom_putchar(c);
}
void __init arch_init_irq(void)
{
	txx9_board_vec->irq_setup();
}
static unsigned long __swizzle_addr_none(unsigned long port)
{
	return port;
}
static u16 ioswabw_default(volatile u16 *a, u16 x)
{
	return le16_to_cpu(x);
}
static u16 __mem_ioswabw_default(volatile u16 *a, u16 x)
{
	return x;
}
static int txx9_iocled_dir_in(struct gpio_chip *chip, unsigned int offset)
{
	return 0;
}
void __init tx3927_wdt_init(void)
{
	txx9_wdt_init(TX3927_TMR_REG(2));
}
void __init tx4927_wdt_init(void)
{
	txx9_wdt_init(TX4927_TMR_REG(2) & 0xfffffffffULL);
}
static void __init tx4927_be_init(void)
{
	board_be_handler = tx4927_be_handler;
}
void __init tx4938_wdt_init(void)
{
	txx9_wdt_init(TX4938_TMR_REG(2) & 0xfffffffffULL);
}
static void __init tx4938_be_init(void)
{
	board_be_handler = tx4938_be_handler;
}
void __init tx4938_spi_init(int busid)
{
	txx9_spi_init(busid, TX4938_SPI_REG & 0xfffffffffULL,
		      TXX9_IRQ_BASE + TX4938_IR_SPI);
}
void __init tx4939_wdt_init(void)
{
	txx9_wdt_init(TX4939_TMR_REG(2) & 0xfffffffffULL);
}
static void __init tx4939_be_init(void)
{
	board_be_handler = tx4939_be_handler;
}
static void smsc_fdc37m81x_config_dump_one(const char *key, u8 dev, u8 reg)
{
	printk(KERN_INFO "%s: dev=0x%02x reg=0x%02x val=0x%02x\n",
	       key, dev, reg,
	       smsc_fdc37m81x_rd(reg));
}
static void __init jmr3927_time_init(void)
{
	tx3927_time_init(0, 1);
}
static void __init rbtx4927_arch_init(void)
{
	tx4927_pci_setup();
}
static void __init rbtx4937_arch_init(void)
{
	tx4937_pci_setup();
}
static void __init rbtx4927_time_init(void)
{
	tx4927_time_init(0);
}
static void __init rbtx4938_spi_setup(void)
{
	txx9_set64(&tx4938_ccfgptr->pcfg, TX4938_PCFG_SPI_SEL);
}
static void __init rbtx4938_time_init(void)
{
	tx4938_time_init(0);
}
static void __init rbtx4939_time_init(void)
{
	tx4939_time_init(0);
}
static u16 rbtx4939_ioswabw(volatile u16 *a, u16 x)
{
	return IS_CE1_ADDR(a) ? x : le16_to_cpu(x);
}
static u16 rbtx4939_mem_ioswabw(volatile u16 *a, u16 x)
{
	return !IS_CE1_ADDR(a) ? x : le16_to_cpu(x);
}
static void __init rbtx4939_arch_init(void)
{
	rbtx4939_pci_setup();
}
unsigned long vr41xx_get_vtclock_frequency(void)
{
	return vr41xx_vtclock;
}
unsigned long vr41xx_get_tclock_frequency(void)
{
	return vr41xx_tclock;
}
static void disable_sysint1_irq(unsigned int irq)
{
	icu1_clear(MSYSINT1REG, 1 << SYSINT1_IRQ_TO_PIN(irq));
}
static void enable_sysint1_irq(unsigned int irq)
{
	icu1_set(MSYSINT1REG, 1 << SYSINT1_IRQ_TO_PIN(irq));
}
static void disable_sysint2_irq(unsigned int irq)
{
	icu2_clear(MSYSINT2REG, 1 << SYSINT2_IRQ_TO_PIN(irq));
}
static void enable_sysint2_irq(unsigned int irq)
{
	icu2_set(MSYSINT2REG, 1 << SYSINT2_IRQ_TO_PIN(irq));
}
void __init arch_init_irq(void)
{
	mips_cpu_irq_init();
}
const char *get_system_type(void)
{
	return "NEC VR4100 series";
}
void usage(void)
{
	die("Usage: build [-b] bootsect setup system [rootdev] [> image]");
}
void debug_to_serial(const char *p, int n)
{
	__debug_to_serial(p, n);
}
static kdev_t gdbstub_console_dev(struct console *con)
{
	return MKDEV(1, 3); /* /dev/null */
}
static void gdbstub_store_fpu(void)
{
	asm volatile(
		"or %2,epsw\n"
		"nop\n"
		"nop\n"
		"mov %1, a1\n"
		"fmov fs0,  (a1+)\n"
		"fmov fs1,  (a1+)\n"
		"fmov fs2,  (a1+)\n"
		"fmov fs3,  (a1+)\n"
		"fmov fs4,  (a1+)\n"
		"fmov fs5,  (a1+)\n"
		"fmov fs6,  (a1+)\n"
		"fmov fs7,  (a1+)\n"
		"fmov fs8,  (a1+)\n"
		"fmov fs9,  (a1+)\n"
		"fmov fs10, (a1+)\n"
		"fmov fs11, (a1+)\n"
		"fmov fs12, (a1+)\n"
		"fmov fs13, (a1+)\n"
		"fmov fs14, (a1+)\n"
		"fmov fs15, (a1+)\n"
		"fmov fs16, (a1+)\n"
		"fmov fs17, (a1+)\n"
		"fmov fs18, (a1+)\n"
		"fmov fs19, (a1+)\n"
		"fmov fs20, (a1+)\n"
		"fmov fs21, (a1+)\n"
		"fmov fs22, (a1+)\n"
		"fmov fs23, (a1+)\n"
		"fmov fs24, (a1+)\n"
		"fmov fs25, (a1+)\n"
		"fmov fs26, (a1+)\n"
		"fmov fs27, (a1+)\n"
		"fmov fs28, (a1+)\n"
		"fmov fs29, (a1+)\n"
		"fmov fs30, (a1+)\n"
		"fmov fs31, (a1+)\n"
		"fmov fpcr, %0\n"
		: "=d"(gdbstub_fpcr)
		: "g" (&gdbstub_fpufs_array), "i"(EPSW_FE)
		: "a1"
		);
}
static void gdbstub_load_fpu(void)
{
	asm volatile(
		"or %1,epsw\n"
		"nop\n"
		"nop\n"
		"mov %0, a1\n"
		"fmov (a1+), fs0\n"
		"fmov (a1+), fs1\n"
		"fmov (a1+), fs2\n"
		"fmov (a1+), fs3\n"
		"fmov (a1+), fs4\n"
		"fmov (a1+), fs5\n"
		"fmov (a1+), fs6\n"
		"fmov (a1+), fs7\n"
		"fmov (a1+), fs8\n"
		"fmov (a1+), fs9\n"
		"fmov (a1+), fs10\n"
		"fmov (a1+), fs11\n"
		"fmov (a1+), fs12\n"
		"fmov (a1+), fs13\n"
		"fmov (a1+), fs14\n"
		"fmov (a1+), fs15\n"
		"fmov (a1+), fs16\n"
		"fmov (a1+), fs17\n"
		"fmov (a1+), fs18\n"
		"fmov (a1+), fs19\n"
		"fmov (a1+), fs20\n"
		"fmov (a1+), fs21\n"
		"fmov (a1+), fs22\n"
		"fmov (a1+), fs23\n"
		"fmov (a1+), fs24\n"
		"fmov (a1+), fs25\n"
		"fmov (a1+), fs26\n"
		"fmov (a1+), fs27\n"
		"fmov (a1+), fs28\n"
		"fmov (a1+), fs29\n"
		"fmov (a1+), fs30\n"
		"fmov (a1+), fs31\n"
		"fmov %2, fpcr\n"
		:
		: "g" (&gdbstub_fpufs_array), "i"(EPSW_FE), "d"(gdbstub_fpcr)
		: "a1"
	);
}
void ack_bad_irq(int irq)
{
	printk(KERN_WARNING "unexpected IRQ trap at vector %02x\n", irq);
}
void set_intr_postackable(int irq)
{
	set_irq_chip_and_handler(irq, &mn10300_cpu_pic_level,
				 handle_level_irq);
}
int __kprobes arch_prepare_kprobe(struct kprobe *p)
{
	return 0;
}
void __kprobes arch_copy_kprobe(struct kprobe *p)
{
	memcpy(p->ainsn.insn, p->addr, MAX_INSN_SIZE);
}
int __init arch_init_kprobes(void)
{
	return 0;
}
void module_free(struct module *mod, void *module_region)
{
	vfree(module_region);
}
int module_frob_arch_sections(Elf_Ehdr *hdr,
			      Elf_Shdr *sechdrs,
			      char *secstrings,
			      struct module *mod)
{
	return 0;
}
int module_finalize(const Elf_Ehdr *hdr,
		    const Elf_Shdr *sechdrs,
		    struct module *me)
{
	return module_bug_finalize(hdr, sechdrs, me);
}
void module_arch_cleanup(struct module *mod)
{
	module_bug_cleanup(mod);
}
unsigned long thread_saved_pc(struct task_struct *tsk)
{
	return ((unsigned long *) tsk->thread.sp)[3];
}
void machine_halt(void)
{
	gdbstub_exit(0);
}
void machine_power_off(void)
{
	gdbstub_exit(0);
}
void exit_thread(void)
{
	exit_fpu();
}
void flush_thread(void)
{
	flush_fpu();
}
void prepare_to_copy(struct task_struct *tsk)
{
	unlazy_fpu(tsk);
}
asmlinkage long sys_clone(unsigned long clone_flags, unsigned long newsp,
			  int __user *parent_tidptr, int __user *child_tidptr,
			  int __user *tlsptr)
{
	return do_fork(clone_flags, newsp ?: __frame->sp, __frame, 0,
		       parent_tidptr, child_tidptr);
}
asmlinkage long sys_fork(void)
{
	return do_fork(SIGCHLD, __frame->sp, __frame, 0, NULL, NULL);
}
asmlinkage long sys_vfork(void)
{
	return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, __frame->sp, __frame,
		       0, NULL, NULL);
}
unsigned long get_wchan(struct task_struct *p)
{
	return p->thread.wchan;
}
static inline int get_stack_long(struct task_struct *task, int offset)
{
	return *(unsigned long *)
		((unsigned long) task->thread.uregs + offset);
}
static inline unsigned long get_fpregs(struct fpu_state_struct *buf,
				       struct task_struct *tsk)
{
	return __copy_to_user(buf, &tsk->thread.fpu_state,
			      sizeof(struct fpu_state_struct));
}
static inline unsigned long set_fpregs(struct task_struct *tsk,
				       struct fpu_state_struct *buf)
{
	return __copy_from_user(&tsk->thread.fpu_state, buf,
				sizeof(struct fpu_state_struct));
}
static inline void fpsave_init(struct task_struct *task)
{
	memset(&task->thread.fpu_state, 0, sizeof(struct fpu_state_struct));
}
static void *c_start(struct seq_file *m, loff_t *pos)
{
	return *pos < NR_CPUS ? cpu_data + *pos : NULL;
}
asmlinkage long sys_sigaltstack(const stack_t __user *uss, stack_t *uoss)
{
	return do_sigaltstack(uss, uoss, __frame->sp);
}
static void __init mn10300_sched_clock_init(void)
{
	sched_clock_multiplier =
		__muldiv64u(NSEC_PER_SEC, 1 << 16, MN10300_TSCCLK);
}
int is_valid_bugaddr(unsigned long pc)
{
	return pc >= PAGE_OFFSET;
}
__sum16 ip_fast_csum(const void *iph, unsigned int ihl)
{
	return ~do_csum(iph, ihl * 4);
}
__sum16 ip_compute_csum(const void *buff, int len)
{
	return ~from32to16(do_csum(buff, len));
}
void free_initmem(void)
{
	free_init_pages("unused kernel memory",
			(unsigned long) &__init_begin,
			(unsigned long) &__init_end);
}
void free_initrd_mem(unsigned long start, unsigned long end)
{
	free_init_pages("initrd memory", start, end);
}
pgd_t *pgd_alloc(struct mm_struct *mm)
{
	return quicklist_alloc(0, GFP_KERNEL, pgd_ctor);
}
void pgd_free(struct mm_struct *mm, pgd_t *pgd)
{
	quicklist_free(0, pgd_dtor, pgd);
}
void check_pgt_cache(void)
{
	quicklist_trim(0, pgd_dtor, 25, 16);
}
int __init oprofile_arch_init(struct oprofile_operations *ops)
{
	return -ENODEV;
}
void pcibios_enable_irq(struct pci_dev *dev)
{
	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, dev->irq);
}
static inline int __query(const struct pci_bus *bus, unsigned int devfn)
{
	return 1;
}
asmlinkage void __init unit_init(void)
{
	set_intr_level(XIRQ0, GxICR_LEVEL_3);
}
void __init unit_setup(void)
{
	unit_pci_init();
}
int hpux_mount(const char *fs, const char *path, int mflag,
		const char *fstype, const char *dataptr, int datalen)
{
	return -ENOSYS;
}
unsigned long hpux_brk(unsigned long addr)
{
	return sys_brk(addr + PAGE_SIZE);
}
int hpux_sbrk(void)
{
	return -ENOSYS;
}
int hpux_nice(int priority_change)
{
	return -ENOSYS;
}
int hpux_ptrace(void)
{
	return -ENOSYS;
}
int hpux_wait(int __user *stat_loc)
{
	return sys_waitpid(-1, stat_loc, 0);
}
int hpux_setpgrp(void)
{
	return sys_setpgid(0,0);
}
int hpux_setpgrp3(void)
{
	return hpux_setpgrp();
}
int hpux_lockf(int fildes, int function, off_t size)
{
	return 0;
}
void
flush_data_cache(void)
{
	on_each_cpu(flush_data_cache_local, NULL, 1);
}
void 
flush_instruction_cache(void)
{
	on_each_cpu(flush_instruction_cache_local, NULL, 1);
}
static void cacheflush_h_tmp_function(void *dummy)
{
	flush_cache_all_local();
}
void flush_cache_all(void)
{
	on_each_cpu(cacheflush_h_tmp_function, NULL, 1);
}
static inline int is_pci_dev(struct device *dev)
{
	return dev->bus == &pci_bus_type;
}
static inline int is_pci_dev(struct device *dev)
{
	return 0;
}
void get_pci_node_path(struct pci_dev *pdev, struct hardware_path *path)
{
	get_node_path(&pdev->dev, path);
}
static int parisc_generic_match(struct device *dev, struct device_driver *drv)
{
	return match_device(to_parisc_driver(drv), to_parisc_device(dev));
}
static ssize_t modalias_show(struct device *dev, struct device_attribute *attr, char *buf)
{
	return make_modalias(dev, buf);
}
void walk_central_bus(void)
{
	walk_native_bus(CENTRAL_BUS_ADDR,
			CENTRAL_BUS_ADDR + (MAX_NATIVE_DEVICES * NATIVE_DEVICE_OFFSET),
			&root);
}
void print_parisc_devices(void)
{
	for_each_padev(print_one_device, NULL);
}
void __init set_firmware_width_unlocked(void) {
	return;
}
void __init set_firmware_width(void) {
	return;
}
int txn_claim_irq(int irq)
{
	return cpu_claim_irq(irq, NULL, NULL) ? -1 : irq;
}
unsigned int txn_alloc_data(unsigned int virt_irq)
{
	return virt_irq - CPU_IRQ_BASE;
}
void ack_bad_irq(unsigned int irq)
{
	printk(KERN_WARNING "unexpected IRQ %d\n", irq);
}
static inline int in_init(struct module *me, void *loc)
{
	return (loc >= me->module_init &&
		loc <= (me->module_init + me->init_size));
}
static inline int in_core(struct module *me, void *loc)
{
	return (loc >= me->module_core &&
		loc <= (me->module_core + me->core_size));
}
static inline int in_local(struct module *me, void *loc)
{
	return in_init(me, loc) || in_core(me, loc);
}
static inline int reassemble_14(int as14)
{
	return (((as14 & 0x1fff) << 1) |
		((as14 & 0x2000) >> 13));
}
static inline int reassemble_17(int as17)
{
	return (((as17 & 0x10000) >> 16) |
		((as17 & 0x0f800) << 5) |
		((as17 & 0x00400) >> 8) |
		((as17 & 0x003ff) << 3));
}
static inline int reassemble_21(int as21)
{
	return (((as21 & 0x100000) >> 20) |
		((as21 & 0x0ffe00) >> 8) |
		((as21 & 0x000180) << 7) |
		((as21 & 0x00007c) << 14) |
		((as21 & 0x000003) << 12));
}
static inline int reassemble_22(int as22)
{
	return (((as22 & 0x200000) >> 21) |
		((as22 & 0x1f0000) << 5) |
		((as22 & 0x00f800) << 5) |
		((as22 & 0x000400) >> 8) |
		((as22 & 0x0003ff) << 3));
}
static inline unsigned long count_gots(const Elf_Rela *rela, unsigned long n)
{
	return 0;
}
static inline unsigned long count_fdescs(const Elf_Rela *rela, unsigned long n)
{
	return 0;
}
unsigned int arch_mod_section_prepend(struct module *mod,
				      unsigned int section)
{
	return (mod->arch.section[section].stub_entries + 1)
		* sizeof(struct stub_entry);
}
static u32 cpu_hpa(void)
{
	return 0xfffb0000;
}
void pa7300lc_init(void)
{
	cpu_lpmc = pa7300lc_lpmc;
}
static inline void dump_resmap(void) {;}
static int pa11_dma_supported( struct device *dev, u64 mask)
{
	return 1;
}
static int proc_pcxl_dma_open(struct inode *inode, struct file *file)
{
	return single_open(file, proc_pcxl_dma_show, NULL);
}
static void *fail_alloc_consistent(struct device *dev, size_t size,
				   dma_addr_t *dma_handle, gfp_t flag)
{
	return NULL;
}
char *pcibios_setup(char *str)
{
	return str;
}
static int pdc_console_setup(struct console *co, char *options)
{
	return 0;
}
static ssize_t perf_read(struct file *file, char __user *buf, size_t cnt, loff_t *ppos)
{
	return 0;
}
static void perf_start_counters(void)
{
	perf_intrigue_enable_perf_counters();
}
pid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
{
	return __kernel_thread(fn, arg, flags);
}
void flush_thread(void)
{
	set_fs(USER_DS);
}
int
sys_vfork(struct pt_regs *regs)
{
	return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, regs->gr[30], regs, 0, NULL, NULL);
}
unsigned long thread_saved_pc(struct task_struct *t)
{
	return t->thread.regs.kpc;
}
int kernel_execve(const char *filename, char *const argv[], char *const envp[])
{
	return __execve(filename, argv, envp, current);
}
void __init processor_init(void)
{
	register_parisc_driver(&cpu_driver);
}
void user_disable_single_step(struct task_struct *task)
{
	ptrace_disable(task);
}
static compat_ulong_t translate_usr_offset(compat_ulong_t offset)
{
	if (offset < 0)
		return sizeof(struct pt_regs);
	else if (offset <= 32*4)	/* gr[0..31] */
		return offset * 2 + 4;
	else if (offset <= 32*4+32*8)	/* gr[0..31] + fr[0..31] */
		return offset + 32*4;
	else if (offset < sizeof(struct pt_regs)/2 + 32*4)
		return offset * 2 + 4 - 32*8;
	else
		return sizeof(struct pt_regs);
}
static void *
c_start (struct seq_file *m, loff_t *pos)
{
	return ((long)*pos < 1) ? (void *)1 : NULL;
}
inline void
sigset_32to64(sigset_t *s64, compat_sigset_t *s32)
{
	s64->sig[0] = s32->sig[0] | ((unsigned long)s32->sig[1] << 32);
}
inline void 
smp_send_stop(void)	{ send_IPI_allbutself(IPI_CPU_STOP); }
static inline void
smp_send_start(void)	{ send_IPI_allbutself(IPI_CPU_START); }
void 
smp_send_reschedule(int cpu) { send_IPI_single(cpu, IPI_RESCHEDULE); }
void
smp_send_all_nop(void)
{
	send_IPI_allbutself(IPI_NOP);
}
void arch_send_call_function_ipi(cpumask_t mask)
{
	send_IPI_mask(mask, IPI_CALL_FUNC);
}
void arch_send_call_function_single_ipi(int cpu)
{
	send_IPI_single(cpu, IPI_CALL_FUNC_SINGLE);
}
void
smp_flush_tlb_all(void)
{
	on_each_cpu(flush_tlb_all_local, NULL, 1);
}
void smp_cpus_done(unsigned int cpu_max)
{
	return;
}
int __init
setup_profiling_timer(unsigned int multiplier)
{
	return -EINVAL;
}
asmlinkage unsigned long sys_mmap2(unsigned long addr, unsigned long len,
	unsigned long prot, unsigned long flags, unsigned long fd,
	unsigned long pgoff)
{
	return do_mmap2(addr, len, prot, flags, fd, pgoff >> (PAGE_SHIFT - 12));
}
asmlinkage long parisc_truncate64(const char __user * path,
					unsigned int high, unsigned int low)
{
	return sys_truncate(path, (long)high << 32 | low);
}
asmlinkage long parisc_ftruncate64(unsigned int fd,
					unsigned int high, unsigned int low)
{
	return sys_ftruncate(fd, (long)high << 32 | low);
}
asmlinkage long sys_truncate64(const char __user * path, unsigned long length)
{
	return sys_truncate(path, length);
}
asmlinkage long sys_ftruncate64(unsigned int fd, unsigned long length)
{
	return sys_ftruncate(fd, length);
}
asmlinkage long sys_fcntl64(unsigned int fd, unsigned int cmd, unsigned long arg)
{
	return sys_fcntl(fd, cmd, arg);
}
asmlinkage long parisc_truncate64(const char __user * path,
					unsigned int high, unsigned int low)
{
	return sys_truncate64(path, (loff_t)high << 32 | low);
}
asmlinkage long parisc_ftruncate64(unsigned int fd,
					unsigned int high, unsigned int low)
{
	return sys_ftruncate64(fd, (loff_t)high << 32 | low);
}
asmlinkage ssize_t parisc_pread64(unsigned int fd, char __user *buf, size_t count,
					unsigned int high, unsigned int low)
{
	return sys_pread64(fd, buf, count, (loff_t)high << 32 | low);
}
asmlinkage ssize_t parisc_pwrite64(unsigned int fd, const char __user *buf,
			size_t count, unsigned int high, unsigned int low)
{
	return sys_pwrite64(fd, buf, count, (loff_t)high << 32 | low);
}
asmlinkage ssize_t parisc_readahead(int fd, unsigned int high, unsigned int low,
		                    size_t count)
{
	return sys_readahead(fd, (loff_t)high << 32 | low, count);
}
asmlinkage long parisc_fadvise64_64(int fd,
			unsigned int high_off, unsigned int low_off,
			unsigned int high_len, unsigned int low_len, int advice)
{
	return sys_fadvise64_64(fd, (loff_t)high_off << 32 | low_off,
			(loff_t)high_len << 32 | low_len, advice);
}
asmlinkage long parisc_sync_file_range(int fd,
			u32 hi_off, u32 lo_off, u32 hi_nbytes, u32 lo_nbytes,
			unsigned int flags)
{
	return sys_sync_file_range(fd, (loff_t)hi_off << 32 | lo_off,
			(loff_t)hi_nbytes << 32 | lo_nbytes, flags);
}
asmlinkage unsigned long sys_alloc_hugepages(int key, unsigned long addr, unsigned long len, int prot, int flag)
{
	return -ENOMEM;
}
asmlinkage int sys_free_hugepages(unsigned long addr)
{
	return -EINVAL;
}
asmlinkage int sys32_lseek(unsigned int fd, int offset, unsigned int origin)
{
	return sys_lseek(fd, offset, origin);
}
long sys32_lookup_dcookie(u32 cookie_high, u32 cookie_low, char __user *buf,
			  size_t len)
{
	return sys_lookup_dcookie((u64)cookie_high << 32 | cookie_low,
				  buf, len);
}
asmlinkage long compat_sys_fallocate(int fd, int mode, u32 offhi, u32 offlo,
				u32 lenhi, u32 lenlo)
{
        return sys_fallocate(fd, mode, ((loff_t)offhi << 32) | offlo,
                             ((loff_t)lenhi << 32) | lenlo);
}
static cycle_t read_cr16(void)
{
	return get_cycles();
}
int update_cr16_clocksource(void)
{
	return 0; /* no change */
}
void dump_stack(void)
{
	show_stack(NULL, NULL);
}
void show_stack(struct task_struct *t, unsigned long *sp)
{
	return parisc_show_stack(t, sp, NULL);
}
int is_valid_bugaddr(unsigned long iaoq)
{
	return 1;
}
int syscall_ipi(int (*syscall) (struct pt_regs *), struct pt_regs *regs)
{
	return syscall(regs);
}
void unwind_frame_init_running(struct unwind_frame_info *info, struct pt_regs *regs)
{
	unwind_frame_init(info, current, regs);
}
static unsigned int ioport_read8(void __iomem *addr)
{
	return inb(ADDR2PORT(addr));
}
static unsigned int ioport_read16(void __iomem *addr)
{
	return inw(ADDR2PORT(addr));
}
static unsigned int ioport_read32(void __iomem *addr)
{
	return inl(ADDR2PORT(addr));
}
static void ioport_write8(u8 datum, void __iomem *addr)
{
	outb(datum, ADDR2PORT(addr));
}
static void ioport_write16(u16 datum, void __iomem *addr)
{
	outw(datum, ADDR2PORT(addr));
}
static void ioport_write32(u32 datum, void __iomem *addr)
{
	outl(datum, ADDR2PORT(addr));
}
static void ioport_read8r(void __iomem *addr, void *dst, unsigned long count)
{
	insb(ADDR2PORT(addr), dst, count);
}
static void ioport_read16r(void __iomem *addr, void *dst, unsigned long count)
{
	insw(ADDR2PORT(addr), dst, count);
}
static void ioport_read32r(void __iomem *addr, void *dst, unsigned long count)
{
	insl(ADDR2PORT(addr), dst, count);
}
static void ioport_write8r(void __iomem *addr, const void *s, unsigned long n)
{
	outsb(ADDR2PORT(addr), s, n);
}
static void ioport_write16r(void __iomem *addr, const void *s, unsigned long n)
{
	outsw(ADDR2PORT(addr), s, n);
}
static void ioport_write32r(void __iomem *addr, const void *s, unsigned long n)
{
	outsl(ADDR2PORT(addr), s, n);
}
static unsigned int iomem_read8(void __iomem *addr)
{
	return readb(addr);
}
static unsigned int iomem_read16(void __iomem *addr)
{
	return readw(addr);
}
static unsigned int iomem_read16be(void __iomem *addr)
{
	return __raw_readw(addr);
}
static unsigned int iomem_read32(void __iomem *addr)
{
	return readl(addr);
}
static unsigned int iomem_read32be(void __iomem *addr)
{
	return __raw_readl(addr);
}
static void iomem_write8(u8 datum, void __iomem *addr)
{
	writeb(datum, addr);
}
static void iomem_write16(u16 datum, void __iomem *addr)
{
	writew(datum, addr);
}
static void iomem_write16be(u16 datum, void __iomem *addr)
{
	__raw_writew(datum, addr);
}
static void iomem_write32(u32 datum, void __iomem *addr)
{
	writel(datum, addr);
}
static void iomem_write32be(u32 datum, void __iomem *addr)
{
	__raw_writel(datum, addr);
}
void __iomem *ioport_map(unsigned long port, unsigned int nr)
{
	return (void __iomem *)(IOPORT_MAP_BASE | port);
}
static inline void prefetch_src(const void *addr)
{
	__asm__("ldw 0(" s_space ",%0), %%r0" : : "r" (addr));
}
static inline void prefetch_dst(const void *addr)
{
	__asm__("ldd 0(" d_space ",%0), %%r0" : : "r" (addr));
}
void mark_rodata_ro(void)
{
	printk (KERN_INFO "Write protecting the kernel read-only data: %luk\n",
		(unsigned long)(__end_rodata - __start_rodata) >> 10);
}
int __init oprofile_arch_init(struct oprofile_operations *ops)
{
	return -ENODEV;
}
static inline u32 __fix_zero(u32 v, u32 def)
{
	return v ? v : def;
}
void put4k(FILE *file, char *buf )
{
	fwrite(buf, 1, 4096, file);
}
struct data data_append_byte(struct data d, uint8_t byte)
{
	return data_append_data(d, &byte, 1);
}
static void bin_emit_beginnode(void *e, const char *label)
{
	bin_emit_cell(e, FDT_BEGIN_NODE);
}
static void bin_emit_endnode(void *e, const char *label)
{
	bin_emit_cell(e, FDT_END_NODE);
}
static void bin_emit_property(void *e, const char *label)
{
	bin_emit_cell(e, FDT_PROP);
}
const char *get_unitname(struct node *node)
{
	if (node->name[node->basenamelen] == '\0')
		return "";
	else
		return node->name + node->basenamelen + 1;
}
struct node *get_node_by_ref(struct node *tree, const char *ref)
{
	if (ref[0] == '/')
		return get_node_by_path(tree, ref);
	else
		return get_node_by_label(tree, ref);
}
int isstring(char c)
{
	return (isprint(c)
		|| (c == '\0')
		|| strchr("\a\b\t\n\v\f\r", c));
}
int main(void)
{
	return 0;
}
static void *fdt_wrapper_finddevice(const char *path)
{
	return offset_devp(fdt_path_offset(fdt, path));
}
static int fdt_wrapper_del_node(const void *devp)
{
	return fdt_del_node(fdt, devp_offset(devp));
}
static void *fdt_wrapper_get_parent(const void *devp)
{
	return offset_devp(fdt_parent_offset(fdt, devp_offset(devp)));
}
const char *fdt_string(const void *fdt, int stroffset)
{
	return (const char *)fdt + fdt_off_dt_strings(fdt) + stroffset;
}
int fdt_subnode_offset(const void *fdt, int parentoffset,
		       const char *name)
{
	return fdt_subnode_offset_namelen(fdt, parentoffset, name, strlen(name));
}
static int _fdt_blocks_misordered(const void *fdt,
			      int mem_rsv_size, int struct_size)
{
	return (fdt_off_mem_rsvmap(fdt) < FDT_ALIGN(sizeof(struct fdt_header), 8))
		|| (fdt_off_dt_struct(fdt) <
		    (fdt_off_mem_rsvmap(fdt) + mem_rsv_size))
		|| (fdt_off_dt_strings(fdt) <
		    (fdt_off_dt_struct(fdt) + struct_size))
		|| (fdt_totalsize(fdt) <
		    (fdt_off_dt_strings(fdt) + fdt_size_dt_strings(fdt)));
}
static inline int _fdt_data_size(void *fdt)
{
	return fdt_off_dt_strings(fdt) + fdt_size_dt_strings(fdt);
}
int fdt_add_subnode(void *fdt, int parentoffset, const char *name)
{
	return fdt_add_subnode_namelen(fdt, parentoffset, name, strlen(name));
}
int fdt_finish_reservemap(void *fdt)
{
	return fdt_add_reservemap_entry(fdt, 0, 0);
}
static int psc_open(void)
{
	return 0;
}
static unsigned char psc_tstc(void)
{
	return (in_be16(psc + MPC52xx_PSC_SR) & MPC52xx_PSC_SR_RXRDY) != 0;
}
static u8 mpsc_tstc(void)
{
	return (u8)((in_le32((u32 *)(mpscintr_base + MPSC_INTR_CAUSE))
				& MPSC_INTR_CAUSE_RCC) != 0);
}
void mv64x60_i2c_close(void)
{
	ctlr_base = NULL;
}
static u8 ns16550_tstc(void)
{
	return ((in_8(reg_base + (UART_LSR << reg_shift)) & UART_LSR_DR) != 0);
}
static void of_console_write(const char *buf, int len)
{
	of_call_prom("write", 3, 1, of_stdout_handle, buf, len);
}
void of_init(void *promptr)
{
	prom = (int (*)(void *))promptr;
}
void of_exit(void)
{
	of_call_prom("exit", 0, 0);
}
void *of_finddevice(const char *name)
{
	return (phandle) of_call_prom("finddevice", 1, 1, name);
}
int of_getprop(const void *phandle, const char *name, void *buf,
	       const int buflen)
{
	return of_call_prom("getprop", 4, 1, phandle, name, buf, buflen);
}
int of_setprop(const void *phandle, const char *name, const void *buf,
	       const int buflen)
{
	return of_call_prom("setprop", 4, 1, phandle, name, buf, buflen);
}
void __init btext_unmap(void)
{
	boot_text_mapped = 0;
}
void __init udbg_init_btext(void)
{
	udbg_putc = btext_drawchar;
}
static struct cache_index_dir *kobj_to_cache_index_dir(struct kobject *k)
{
	return container_of(k, struct cache_index_dir, kobj);
}
static const char *cache_type_string(const struct cache *cache)
{
	return cache_type_info[cache->type].name;
}
static bool cache_node_is_unified(const struct device_node *np)
{
	return of_get_property(np, "cache-unified", NULL);
}
static void crash_kexec_prepare_cpus(int cpu)
{
	smp_release_cpus();
}
void crash_kexec_secondary(struct pt_regs *regs)
{
	cpus_in_sr = CPU_MASK_NONE;
}
void __init reserve_kdump_trampoline(void)
{
	lmb_reserve(0, KDUMP_RESERVE_LIMIT);
}
static void *dma_iommu_alloc_coherent(struct device *dev, size_t size,
				      dma_addr_t *dma_handle, gfp_t flag)
{
	return iommu_alloc_coherent(dev, dev->archdata.dma_data, size,
				    dma_handle, device_to_mask(dev), flag,
				    dev_to_node(dev));
}
static void dma_iommu_free_coherent(struct device *dev, size_t size,
				    void *vaddr, dma_addr_t dma_handle)
{
	iommu_free_coherent(dev->archdata.dma_data, size, vaddr, dma_handle);
}
static dma_addr_t dma_iommu_map_page(struct device *dev, struct page *page,
				     unsigned long offset, size_t size,
				     enum dma_data_direction direction,
				     struct dma_attrs *attrs)
{
	return iommu_map_page(dev, dev->archdata.dma_data, page, offset, size,
			      device_to_mask(dev), direction, attrs);
}
static void dma_iommu_unmap_page(struct device *dev, dma_addr_t dma_handle,
				 size_t size, enum dma_data_direction direction,
				 struct dma_attrs *attrs)
{
	iommu_unmap_page(dev->archdata.dma_data, dma_handle, size, direction,
			 attrs);
}
static int dma_iommu_map_sg(struct device *dev, struct scatterlist *sglist,
			    int nelems, enum dma_data_direction direction,
			    struct dma_attrs *attrs)
{
	return iommu_map_sg(dev, dev->archdata.dma_data, sglist, nelems,
			    device_to_mask(dev), direction, attrs);
}
static void dma_iommu_unmap_sg(struct device *dev, struct scatterlist *sglist,
		int nelems, enum dma_data_direction direction,
		struct dma_attrs *attrs)
{
	iommu_unmap_sg(dev->archdata.dma_data, sglist, nelems, direction,
		       attrs);
}
static int dma_direct_dma_supported(struct device *dev, u64 mask)
{
	return mask >= DMA_32BIT_MASK;
}
static inline void dma_direct_sync_single_range(struct device *dev,
		dma_addr_t dma_handle, unsigned long offset, size_t size,
		enum dma_data_direction direction)
{
	__dma_sync(bus_to_virt(dma_handle+offset), size, direction);
}
static unsigned int ftrace_calc_offset(long ip, long addr)
{
	return (int)(addr - ip);
}
static unsigned char *ftrace_nop_replace(void)
{
	return (char *)&ftrace_nop;
}
static int test_24bit_addr(unsigned long ip, unsigned long addr)
{
	return create_branch((unsigned int *)ip, addr, 0);
}
static int is_bl_op(unsigned int op)
{
	return (op & 0xfc000003) == 0x48000001;
}
static void ibmebus_free_coherent(struct device *dev,
				  size_t size, void *vaddr,
				  dma_addr_t dma_handle)
{
	kfree(vaddr);
}
static dma_addr_t ibmebus_map_page(struct device *dev,
				   struct page *page,
				   unsigned long offset,
				   size_t size,
				   enum dma_data_direction direction,
				   struct dma_attrs *attrs)
{
	return (dma_addr_t)(page_address(page) + offset);
}
static void ibmebus_unmap_page(struct device *dev,
			       dma_addr_t dma_addr,
			       size_t size,
			       enum dma_data_direction direction,
			       struct dma_attrs *attrs)
{
	return;
}
static void ibmebus_unmap_sg(struct device *dev,
			     struct scatterlist *sg,
			     int nents, enum dma_data_direction direction,
			     struct dma_attrs *attrs)
{
	return;
}
static int ibmebus_dma_supported(struct device *dev, u64 mask)
{
	return 1;
}
static int ibmebus_match_node(struct device *dev, void *data)
{
	return to_of_device(dev)->node == data;
}
void ibmebus_unregister_driver(struct of_platform_driver *drv)
{
	of_unregister_driver(drv);
}
unsigned int ioread8(void __iomem *addr)
{
	return readb(addr);
}
unsigned int ioread16(void __iomem *addr)
{
	return readw(addr);
}
unsigned int ioread16be(void __iomem *addr)
{
	return in_be16(addr);
}
unsigned int ioread32(void __iomem *addr)
{
	return readl(addr);
}
unsigned int ioread32be(void __iomem *addr)
{
	return in_be32(addr);
}
void iowrite8(u8 val, void __iomem *addr)
{
	writeb(val, addr);
}
void iowrite16(u16 val, void __iomem *addr)
{
	writew(val, addr);
}
void iowrite16be(u16 val, void __iomem *addr)
{
	out_be16(addr, val);
}
void iowrite32(u32 val, void __iomem *addr)
{
	writel(val, addr);
}
void iowrite32be(u32 val, void __iomem *addr)
{
	out_be32(addr, val);
}
void ioread8_rep(void __iomem *addr, void *dst, unsigned long count)
{
	_insb((u8 __iomem *) addr, dst, count);
}
void ioread16_rep(void __iomem *addr, void *dst, unsigned long count)
{
	_insw_ns((u16 __iomem *) addr, dst, count);
}
void ioread32_rep(void __iomem *addr, void *dst, unsigned long count)
{
	_insl_ns((u32 __iomem *) addr, dst, count);
}
void iowrite8_rep(void __iomem *addr, const void *src, unsigned long count)
{
	_outsb((u8 __iomem *) addr, src, count);
}
void iowrite16_rep(void __iomem *addr, const void *src, unsigned long count)
{
	_outsw_ns((u16 __iomem *) addr, src, count);
}
void iowrite32_rep(void __iomem *addr, const void *src, unsigned long count)
{
	_outsl_ns((u32 __iomem *) addr, src, count);
}
void __iomem *ioport_map(unsigned long port, unsigned int len)
{
	return (void __iomem *) (port + _IO_BASE);
}
irq_hw_number_t virq_to_hw(unsigned int virq)
{
	return irq_map[virq].hwirq;
}
static int default_irq_host_match(struct irq_host *h, struct device_node *np)
{
	return h->of_node != NULL && h->of_node == np;
}
static int virq_debug_open(struct inode *inode, struct file *file)
{
	return single_open(file, virq_debug_show, inode->i_private);
}
void kgdb_roundup_cpus(unsigned long flags)
{
	smp_send_debugger_break(MSG_ALL_BUT_SELF);
}
static int kgdb_debugger(struct pt_regs *regs)
{
	return kgdb_handle_exception(0, computeSignal(TRAP(regs)), 0, regs);
}
static int kgdb_not_implemented(struct pt_regs *regs)
{
	return 0;
}
static void __used kretprobe_trampoline_holder(void)
{
	asm volatile(".global kretprobe_trampoline\n"
			"kretprobe_trampoline:\n"
			"nop\n");
}
unsigned long arch_deref_entry_point(void *entry)
{
	return ((func_descr_t *)entry)->entry;
}
void __used __kprobes jprobe_return(void)
{
	asm volatile("trap" ::: "memory");
}
int __init arch_init_kprobes(void)
{
	return register_kprobe(&trampoline_p);
}
static int iseries_lparcfg_data(struct seq_file *m, void *v)
{
	return 0;
}
static int pseries_lparcfg_data(struct seq_file *m, void *v)
{
	return 0;
}
static ssize_t lparcfg_write(struct file *file, const char __user * buf,
			     size_t count, loff_t * off)
{
	return -EINVAL;
}
static int lparcfg_open(struct inode *inode, struct file *file)
{
	return single_open(file, lparcfg_data, NULL);
}
int machine_kexec_prepare(struct kimage *image)
{
	if (ppc_md.machine_kexec_prepare)
		return ppc_md.machine_kexec_prepare(image);
	else
		return default_machine_kexec_prepare(image);
}
int overlaps_crashkernel(unsigned long start, unsigned long size)
{
	return (start + size) > crashk_res.start && start <= crashk_res.end;
}
int default_machine_kexec_prepare(struct kimage *image)
{
	return 0;
}
void module_free(struct module *mod, void *module_region)
{
	vfree(module_region);
}
void module_arch_cleanup(struct module *mod)
{
	module_bug_cleanup(mod);
}
static inline unsigned long my_r2(Elf64_Shdr *sechdrs, struct module *me)
{
	return sechdrs[me->arch.toc_section].sh_addr + 0x8000;
}
int arch_setup_msi_irqs(struct pci_dev *dev, int nvec, int type)
{
	return ppc_md.setup_msi_irqs(dev, nvec, type);
}
void arch_teardown_msi_irqs(struct pci_dev *dev)
{
	ppc_md.teardown_msi_irqs(dev);
}
void __exit nvram_cleanup(void)
{
        misc_deregister( &nvram_dev );
}
static int __init of_bus_driver_init(void)
{
	return of_bus_type_init(&of_platform_bus_type, "of_platform");
}
static int of_dev_node_match(struct device *dev, void *data)
{
	return to_of_device(dev)->node == data;
}
static __init int of_pci_phb_init(void)
{
	return of_register_platform_driver(&of_pci_phb_driver);
}
void set_pci_dma_ops(struct dma_mapping_ops *dma_ops)
{
	pci_dma_ops = dma_ops;
}
struct dma_mapping_ops *get_pci_dma_ops(void)
{
	return pci_dma_ops;
}
int pci_set_dma_mask(struct pci_dev *dev, u64 mask)
{
	return dma_set_mask(&dev->dev, mask);
}
int pcibios_add_platform_entries(struct pci_dev *pdev)
{
	return device_create_file(&pdev->dev, &dev_attr_devspec);
}
char __devinit *pcibios_setup(char *str)
{
	return str;
}
struct device_node*
pci_device_to_OF_node(struct pci_dev *dev)
{
	return pci_busdev_to_OF_node(dev->bus, dev->devfn);
}
static int
find_OF_pci_device_filter(struct device_node* node, void* data)
{
	return ((void *)node == data);
}
void __init
pcibios_update_irq(struct pci_dev *dev, int irq)
{
	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq);
}
static int								\
null_##rw##_config_##size(struct pci_dev *dev, int offset, type val)	\
{									\
	return PCIBIOS_DEVICE_NOT_FOUND;    				\
}
static int
null_read_config(struct pci_bus *bus, unsigned int devfn, int offset,
		 int len, u32 *val)
{
	return PCIBIOS_DEVICE_NOT_FOUND;
}
static int
null_write_config(struct pci_bus *bus, unsigned int devfn, int offset,
		  int len, u32 val)
{
	return PCIBIOS_DEVICE_NOT_FOUND;
}
int early_##rw##_config_##size(struct pci_controller *hose, int bus,	\
			       int devfn, int offset, type value)	\
{									\
	return pci_bus_##rw##_config_##size(fake_pci_bus(hose, bus),	\
					    devfn, offset, value);	\
}
int early_find_capability(struct pci_controller *hose, int bus, int devfn,
			  int cap)
{
	return pci_bus_find_capability(fake_pci_bus(hose, bus), devfn, cap);
}
void __devinit of_scan_bus(struct device_node *node,
			   struct pci_bus *bus)
{
	__of_scan_bus(node, bus, 0);
}
void __devinit of_rescan_bus(struct device_node *node,
			     struct pci_bus *bus)
{
	__of_scan_bus(node, bus, 1);
}
void exit_thread(void)
{
	discard_lazy_cpu_state();
}
int get_unalign_ctl(struct task_struct *tsk, unsigned long adr)
{
	return put_user(tsk->thread.align_ctl, (unsigned int __user *)adr);
}
void dump_stack(void)
{
	show_stack(current, NULL);
}
void free_thread_info(struct thread_info *ti)
{
	kmem_cache_free(thread_info_cache, ti);
}
static inline char *find_flat_dt_string(u32 offset)
{
	return ((char *)initial_boot_params) +
		initial_boot_params->off_dt_strings + offset;
}
static inline struct device_node * kref_to_device_node(struct kref *kref)
{
	return container_of(kref, struct device_node, kref);
}
static int __init prom_reconfig_setup(void)
{
	return pSeries_reconfig_notifier_register(&prom_reconfig_nb);
}
static inline int enter_prom(struct prom_args *args, unsigned long entry)
{
	return ((int (*)(struct prom_args *))entry)(args);
}
static int inline prom_getprop(phandle node, const char *pname,
			       void *value, size_t valuelen)
{
	return call_prom("getprop", 4, 1, node, ADDR(pname),
			 (u32)(unsigned long) value, (u32) valuelen);
}
static int inline prom_getproplen(phandle node, const char *pname)
{
	return call_prom("getproplen", 2, 1, node, ADDR(pname));
}
static int __init prom_set_color(ihandle ih, int i, int r, int g, int b)
{
	return call_prom("call-method", 6, 1, ADDR("color!"), ih, i, b, g, r);
}
static unsigned int of_bus_default_get_flags(const u32 *addr)
{
	return IORESOURCE_MEM;
}
static int of_bus_pci_match(struct device_node *np)
{
	return !strcmp(np->type, "pci") || !strcmp(np->type, "vci");
}
static int of_bus_pci_translate(u32 *addr, u64 offset, int na)
{
	return of_bus_default_translate(addr + 1, offset, na - 1);
}
static int of_bus_isa_match(struct device_node *np)
{
	return !strcmp(np->name, "isa");
}
static int of_bus_isa_translate(u32 *addr, u64 offset, int na)
{
	return of_bus_default_translate(addr + 1, offset, na - 1);
}
u64 of_translate_address(struct device_node *dev, const u32 *in_addr)
{
	return __of_translate_address(dev, in_addr, "ranges");
}
u64 of_translate_dma_address(struct device_node *dev, const u32 *in_addr)
{
	return __of_translate_address(dev, in_addr, "dma-ranges");
}
static int of_irq_map_oldworld(struct device_node *device, int index,
			       struct of_irq *out_irq)
{
	return -EINVAL;
}
static unsigned long get_user_msr(struct task_struct *task)
{
	return task->thread.regs->msr | task->thread.fpexc_mode;
}
void ptrace_disable(struct task_struct *child)
{
	user_disable_single_step(child);
}
static int sensors_open(struct inode *inode, struct file *file)
{
	return single_open(file, ppc_rtas_sensors_show, NULL);
}
static int poweron_open(struct inode *inode, struct file *file)
{
	return single_open(file, ppc_rtas_poweron_show, NULL);
}
static int progress_open(struct inode *inode, struct file *file)
{
	return single_open(file, ppc_rtas_progress_show, NULL);
}
static int clock_open(struct inode *inode, struct file *file)
{
	return single_open(file, ppc_rtas_clock_show, NULL);
}
static int tone_freq_open(struct inode *inode, struct file *file)
{
	return single_open(file, ppc_rtas_tone_freq_show, NULL);
}
static int tone_volume_open(struct inode *inode, struct file *file)
{
	return single_open(file, ppc_rtas_tone_volume_show, NULL);
}
static int rmo_buf_open(struct inode *inode, struct file *file)
{
	return single_open(file, ppc_rtas_rmo_buf_show, NULL);
}
void __init udbg_init_rtas_panel(void)
{
	udbg_putc = call_rtas_display_status_delay;
}
int rtas_service_present(const char *service)
{
	return rtas_token(service) != RTAS_UNKNOWN_SERVICE;
}
static int rtas_ibm_suspend_me(struct rtas_args *args)
{
	return -ENOSYS;
}
void rtas_block_ctor(void *ptr)
{
	memset(ptr, 0, RTAS_BLK_SIZE);
}
static struct proc_dir_entry *create_flash_pde(const char *filename,
					       const struct file_operations *fops)
{
	return proc_create(filename, S_IRUSR | S_IWUSR, NULL, fops);
}
void __init setup_panic(void)
{
	atomic_notifier_chain_register(&panic_notifier_list, &ppc_panic_block);
}
long sys_sigaltstack(const stack_t __user *uss, stack_t __user *uoss,
		unsigned long r5, unsigned long r6, unsigned long r7,
		unsigned long r8, struct pt_regs *regs)
{
	return do_sigaltstack(uss, uoss, regs->gpr[1]);
}
static inline int put_sigset_t(sigset_t __user *uset, sigset_t *set)
{
	return copy_to_user(uset, set, sizeof(*uset));
}
static inline int get_sigset_t(sigset_t *set, const sigset_t __user *uset)
{
	return copy_from_user(set, uset, sizeof(*uset));
}
inline unsigned long copy_fpr_to_user(void __user *to,
				      struct task_struct *task)
{
	return __copy_to_user(to, task->thread.fpr,
			      ELF_NFPREG * sizeof(double));
}
inline unsigned long copy_fpr_from_user(struct task_struct *task,
					void __user *from)
{
	return __copy_from_user(task->thread.fpr, from,
			      ELF_NFPREG * sizeof(double));
}
static irqreturn_t reschedule_action(int irq, void *data)
{
	return IRQ_HANDLED;
}
void arch_send_call_function_single_ipi(int cpu)
{
	smp_ops->message_pass(cpu, PPC_MSG_CALL_FUNC_SINGLE);
}
void smp_send_stop(void)
{
	smp_call_function(stop_this_cpu, NULL, 0);
}
static void __devinit smp_store_cpu_info(int id)
{
	per_cpu(pvr, id) = mfspr(SPRN_PVR);
}
int setup_profiling_timer(unsigned int multiplier)
{
	return 0;
}
void restore_processor_state(void)
{
	switch_mmu_context(NULL, current->active_mm);
}
void _iommu_save(void)
{
	iommu_save();
}
asmlinkage long ppc32_select(u32 n, compat_ulong_t __user *inp,
		compat_ulong_t __user *outp, compat_ulong_t __user *exp,
		compat_uptr_t tvp_x)
{
	return compat_sys_select((int)n, inp, outp, exp, compat_ptr(tvp_x));
}
asmlinkage long compat_sys_sysfs(u32 option, u32 arg1, u32 arg2)
{
	return sys_sysfs((int)option, arg1, arg2);
}
asmlinkage long compat_sys_prctl(u32 option, u32 arg2, u32 arg3, u32 arg4, u32 arg5)
{
	return sys_prctl((int)option,
			 (unsigned long) arg2,
			 (unsigned long) arg3,
			 (unsigned long) arg4,
			 (unsigned long) arg5);
}
asmlinkage long compat_sys_access(const char __user * filename, u32 mode)
{
	return sys_access(filename, (int)mode);
}
asmlinkage long compat_sys_creat(const char __user * pathname, u32 mode)
{
	return sys_creat(pathname, (int)mode);
}
asmlinkage long compat_sys_waitpid(u32 pid, unsigned int __user * stat_addr, u32 options)
{
	return sys_waitpid((int)pid, stat_addr, (int)options);
}
asmlinkage long compat_sys_getgroups(u32 gidsetsize, gid_t __user *grouplist)
{
	return sys_getgroups((int)gidsetsize, grouplist);
}
asmlinkage long compat_sys_getpgid(u32 pid)
{
	return sys_getpgid((int)pid);
}
asmlinkage long compat_sys_getsid(u32 pid)
{
	return sys_getsid((int)pid);
}
asmlinkage long compat_sys_kill(u32 pid, u32 sig)
{
	return sys_kill((int)pid, (int)sig);
}
asmlinkage long compat_sys_mkdir(const char __user * pathname, u32 mode)
{
	return sys_mkdir(pathname, (int)mode);
}
long compat_sys_nice(u32 increment)
{
	return sys_nice((int)increment);
}
off_t ppc32_lseek(unsigned int fd, u32 offset, unsigned int origin)
{
	return sys_lseek(fd, (int)offset, origin);
}
asmlinkage long compat_sys_readlink(const char __user * path, char __user * buf, u32 bufsiz)
{
	return sys_readlink(path, buf, (int)bufsiz);
}
asmlinkage long compat_sys_sched_get_priority_max(u32 policy)
{
	return sys_sched_get_priority_max((int)policy);
}
asmlinkage long compat_sys_sched_get_priority_min(u32 policy)
{
	return sys_sched_get_priority_min((int)policy);
}
asmlinkage long compat_sys_sched_getparam(u32 pid, struct sched_param __user *param)
{
	return sys_sched_getparam((int)pid, param);
}
asmlinkage long compat_sys_sched_getscheduler(u32 pid)
{
	return sys_sched_getscheduler((int)pid);
}
asmlinkage long compat_sys_sched_setparam(u32 pid, struct sched_param __user *param)
{
	return sys_sched_setparam((int)pid, param);
}
asmlinkage long compat_sys_sched_setscheduler(u32 pid, u32 policy, struct sched_param __user *param)
{
	return sys_sched_setscheduler((int)pid, (int)policy, param);
}
asmlinkage long compat_sys_setdomainname(char __user *name, u32 len)
{
	return sys_setdomainname(name, (int)len);
}
asmlinkage long compat_sys_setgroups(u32 gidsetsize, gid_t __user *grouplist)
{
	return sys_setgroups((int)gidsetsize, grouplist);
}
asmlinkage long compat_sys_sethostname(char __user *name, u32 len)
{
	return sys_sethostname(name, (int)len);
}
asmlinkage long compat_sys_setpgid(u32 pid, u32 pgid)
{
	return sys_setpgid((int)pid, (int)pgid);
}
long compat_sys_getpriority(u32 which, u32 who)
{
	return sys_getpriority((int)which, (int)who);
}
long compat_sys_setpriority(u32 which, u32 who, u32 niceval)
{
	return sys_setpriority((int)which, (int)who, (int)niceval);
}
long compat_sys_ioprio_get(u32 which, u32 who)
{
	return sys_ioprio_get((int)which, (int)who);
}
long compat_sys_ioprio_set(u32 which, u32 who, u32 ioprio)
{
	return sys_ioprio_set((int)which, (int)who, (int)ioprio);
}
asmlinkage long compat_sys_ssetmask(u32 newmask)
{
	return sys_ssetmask((int) newmask);
}
asmlinkage long compat_sys_syslog(u32 type, char __user * buf, u32 len)
{
	return sys_syslog(type, buf, (int)len);
}
asmlinkage long compat_sys_umask(u32 mask)
{
	return sys_umask((int)mask);
}
unsigned long compat_sys_mmap2(unsigned long addr, size_t len,
			  unsigned long prot, unsigned long flags,
			  unsigned long fd, unsigned long pgoff)
{
	return sys_mmap(addr, len, prot, flags, fd, pgoff << 12);
}
long compat_sys_tgkill(u32 tgid, u32 pid, int sig)
{
	return sys_tgkill((int)tgid, (int)pid, sig);
}
compat_ssize_t compat_sys_pread64(unsigned int fd, char __user *ubuf, compat_size_t count,
			     u32 reg6, u32 poshi, u32 poslo)
{
	return sys_pread64(fd, ubuf, count, ((loff_t)poshi << 32) | poslo);
}
compat_ssize_t compat_sys_pwrite64(unsigned int fd, char __user *ubuf, compat_size_t count,
			      u32 reg6, u32 poshi, u32 poslo)
{
	return sys_pwrite64(fd, ubuf, count, ((loff_t)poshi << 32) | poslo);
}
compat_ssize_t compat_sys_readahead(int fd, u32 r4, u32 offhi, u32 offlo, u32 count)
{
	return sys_readahead(fd, ((loff_t)offhi << 32) | offlo, count);
}
asmlinkage int compat_sys_truncate64(const char __user * path, u32 reg4,
				unsigned long high, unsigned long low)
{
	return sys_truncate(path, (high << 32) | low);
}
asmlinkage long compat_sys_fallocate(int fd, int mode, u32 offhi, u32 offlo,
				     u32 lenhi, u32 lenlo)
{
	return sys_fallocate(fd, mode, ((loff_t)offhi << 32) | offlo,
			     ((loff_t)lenhi << 32) | lenlo);
}
asmlinkage int compat_sys_ftruncate64(unsigned int fd, u32 reg4, unsigned long high,
				 unsigned long low)
{
	return sys_ftruncate(fd, (high << 32) | low);
}
long ppc32_lookup_dcookie(u32 cookie_high, u32 cookie_low, char __user *buf,
			  size_t len)
{
	return sys_lookup_dcookie((u64)cookie_high << 32 | cookie_low,
				  buf, len);
}
long ppc32_fadvise64(int fd, u32 unused, u32 offset_high, u32 offset_low,
		     size_t len, int advice)
{
	return sys_fadvise64(fd, (u64)offset_high << 32 | offset_low, len,
			     advice);
}
asmlinkage long compat_sys_add_key(const char __user *_type,
			      const char __user *_description,
			      const void __user *_payload,
			      u32 plen,
			      u32 ringid)
{
	return sys_add_key(_type, _description, _payload, plen, ringid);
}
asmlinkage long compat_sys_request_key(const char __user *_type,
				  const char __user *_description,
				  const char __user *_callout_info,
				  u32 destringid)
{
	return sys_request_key(_type, _description, _callout_info, destringid);
}
unsigned long sys_mmap2(unsigned long addr, size_t len,
			unsigned long prot, unsigned long flags,
			unsigned long fd, unsigned long pgoff)
{
	return do_mmap2(addr, len, prot, flags, fd, pgoff, PAGE_SHIFT-12);
}
unsigned long sys_mmap(unsigned long addr, size_t len,
		       unsigned long prot, unsigned long flags,
		       unsigned long fd, off_t offset)
{
	return do_mmap2(addr, len, prot, flags, fd, offset, PAGE_SHIFT);
}
long ppc_fadvise64_64(int fd, int advice, u32 offset_high, u32 offset_low,
		      u32 len_high, u32 len_low)
{
	return sys_fadvise64(fd, (u64)offset_high << 32 | offset_low,
			     (u64)len_high << 32 | len_low, advice);
}
void do_show_syscall(unsigned long r3, unsigned long r4, unsigned long r5,
		     unsigned long r6, unsigned long r7, unsigned long r8,
		     struct pt_regs *regs)
{
	printk("syscall %ld(%lx, %lx, %lx, %lx, %lx, %lx) regs=%p current=%p"
	       " cpu=%d\n", regs->gpr[0], r3, r4, r5, r6, r7, r8, regs,
	       current, smp_processor_id());
}
void do_show_syscall_exit(unsigned long r3)
{
	printk(" -> %lx, current=%p cpu=%d\n", r3, current, smp_processor_id());
}
static void register_nodes(void)
{
	return;
}
u32 cpu_temp_both(unsigned long cpu)
{
	return ((tau[cpu].high << 16) | tau[cpu].low);
}
int cpu_temp(unsigned long cpu)
{
	return ((tau[cpu].high + tau[cpu].low) / 2);
}
int tau_interrupts(unsigned long cpu)
{
	return (tau[cpu].interrupts);
}
void udelay(unsigned long usecs)
{
	__delay(tb_ticks_per_usec * usecs);
}
static cycle_t rtc_read(void)
{
	return (cycle_t)get_rtc();
}
static cycle_t timebase_read(void)
{
	return (cycle_t)get_tb();
}
void secondary_cpu_time_init(void)
{
	register_decrementer_clockevent(smp_processor_id());
}
void SMIException(struct pt_regs *regs)
{
	die("System Management Interrupt", regs, SIGABRT);
}
void RunModeException(struct pt_regs *regs)
{
	_exception(SIGTRAP, regs, 0, 0);
}
int is_valid_bugaddr(unsigned long addr)
{
	return is_kernel_addr(addr);
}
void trace_syscall(struct pt_regs *regs)
{
	printk("Task: %p(%d), PC: %08lX/%08lX, Syscall: %3ld, Result: %s%ld    %s\n",
	       current, task_pid_nr(current), regs->nip, regs->link, regs->gpr[0],
	       regs->ccr&0x10000000?"Error=":"", regs->gpr[3], print_tainted());
}
void performance_monitor_exception(struct pt_regs *regs)
{
	perf_irq(regs);
}
void TAUException(struct pt_regs *regs)
{
	printk("TAU trap at PC: %lx, MSR: %lx, vector=%lx    %s\n",
	       regs->nip, regs->msr, regs->trap, print_tainted());
}
static void udbg_console_write(struct console *con, const char *s,
		unsigned int n)
{
	udbg_write(s, n);
}
int in_gate_area_no_task(unsigned long addr)
{
	return 0;
}
int in_gate_area(struct task_struct *task, unsigned long addr)
{
	return 0;
}
struct vm_area_struct *get_gate_vma(struct task_struct *tsk)
{
	return NULL;
}
static ssize_t viodev_cmo_##name##_show(struct device *dev,             \
                                        struct device_attribute *attr,  \
                                         char *buf)                     \
{                                                                       \
	return sprintf(buf, "%lu\n", to_vio_dev(dev)->cmo.name);        \
}
static ssize_t                                                          \
viobus_cmo_##name##_show(struct bus_type *bt, char *buf)                \
{                                                                       \
	return sprintf(buf, "%lu\n", vio_cmo.name);                     \
}
static ssize_t                                                          \
viobus_cmo_##name##_pool_show_##var(struct bus_type *bt, char *buf)     \
{                                                                       \
	return sprintf(buf, "%lu\n", vio_cmo.name.var);                 \
}
int vio_cmo_entitlement_update(size_t new_entitlement) { return 0; }
static int vio_cmo_bus_probe(struct vio_dev *viodev) { return 0; }
void vio_unregister_driver(struct vio_driver *viodrv)
{
	driver_unregister(&viodrv->driver);
}
static ssize_t name_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	return sprintf(buf, "%s\n", to_vio_dev(dev)->name);
}
void __devinit vio_unregister_device(struct vio_dev *viodev)
{
	device_unregister(&viodev->dev);
}
const void *vio_get_attribute(struct vio_dev *vdev, char *which, int *length)
{
	return of_get_property(vdev->dev.archdata.of_node, which, length);
}
void kvmppc_core_vcpu_load(struct kvm_vcpu *vcpu, int cpu)
{
	kvmppc_44x_tlb_load(vcpu);
}
void kvmppc_core_vcpu_put(struct kvm_vcpu *vcpu)
{
	kvmppc_44x_tlb_put(vcpu);
}
static void kvmppc_44x_exit(void)
{
	kvmppc_booke_exit();
}
static void kvmppc_booke_queue_irqprio(struct kvm_vcpu *vcpu,
                                       unsigned int priority)
{
	set_bit(priority, &vcpu->arch.pending_exceptions);
}
void kvmppc_core_queue_program(struct kvm_vcpu *vcpu)
{
	kvmppc_booke_queue_irqprio(vcpu, BOOKE_IRQPRIO_PROGRAM);
}
void kvmppc_core_queue_dec(struct kvm_vcpu *vcpu)
{
	kvmppc_booke_queue_irqprio(vcpu, BOOKE_IRQPRIO_DECREMENTER);
}
int kvmppc_core_pending_dec(struct kvm_vcpu *vcpu)
{
	return test_bit(BOOKE_IRQPRIO_DECREMENTER, &vcpu->arch.pending_exceptions);
}
void kvmppc_core_queue_external(struct kvm_vcpu *vcpu,
                                struct kvm_interrupt *irq)
{
	kvmppc_booke_queue_irqprio(vcpu, BOOKE_IRQPRIO_EXTERNAL);
}
int kvm_arch_vcpu_ioctl_get_sregs(struct kvm_vcpu *vcpu,
                                  struct kvm_sregs *sregs)
{
	return -ENOTSUPP;
}
int kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu,
                                  struct kvm_sregs *sregs)
{
	return -ENOTSUPP;
}
int kvm_arch_vcpu_ioctl_get_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)
{
	return -ENOTSUPP;
}
int kvm_arch_vcpu_ioctl_set_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)
{
	return -ENOTSUPP;
}
int kvm_arch_vcpu_ioctl_translate(struct kvm_vcpu *vcpu,
                                  struct kvm_translation *tr)
{
	return kvmppc_core_vcpu_translate(vcpu, tr);
}
void kvmppc_core_vcpu_load(struct kvm_vcpu *vcpu, int cpu)
{
	kvmppc_e500_tlb_load(vcpu, cpu);
}
void kvmppc_core_vcpu_put(struct kvm_vcpu *vcpu)
{
	kvmppc_e500_tlb_put(vcpu);
}
static void kvmppc_e500_exit(void)
{
	kvmppc_booke_exit();
}
static inline unsigned int tlb1_max_shadow_size(void)
{
	return tlb1_entry_num - tlbcam_index;
}
static inline int tlbe_is_writable(struct tlbe *tlbe)
{
	return tlbe->mas3 & (MAS3_SW|MAS3_UW);
}
static inline u32 e500_shadow_mas2_attrib(u32 mas2, int usermode)
{
	return mas2 & MAS2_ATTRIB_MASK;
}
void kvmppc_e500_tlb_put(struct kvm_vcpu *vcpu)
{
	_tlbil_all();
}
gfn_t unalias_gfn(struct kvm *kvm, gfn_t gfn)
{
	return gfn;
}
int kvm_cpu_has_interrupt(struct kvm_vcpu *v)
{
	return !!(v->arch.pending_exceptions);
}
int kvm_arch_vcpu_runnable(struct kvm_vcpu *v)
{
	return !(v->arch.msr & MSR_WE);
}
int kvm_arch_hardware_setup(void)
{
	return 0;
}
void kvm_arch_check_processor_compat(void *rtn)
{
	*(int *)rtn = kvmppc_core_check_processor_compat();
}
long kvm_arch_dev_ioctl(struct file *filp,
                        unsigned int ioctl, unsigned long arg)
{
	return -EINVAL;
}
int kvm_arch_set_memory_region(struct kvm *kvm,
                               struct kvm_userspace_memory_region *mem,
                               struct kvm_memory_slot old,
                               int user_alloc)
{
	return 0;
}
void kvm_arch_vcpu_destroy(struct kvm_vcpu *vcpu)
{
	kvm_arch_vcpu_free(vcpu);
}
int kvm_cpu_has_pending_timer(struct kvm_vcpu *vcpu)
{
	return kvmppc_core_pending_dec(vcpu);
}
void kvm_arch_vcpu_uninit(struct kvm_vcpu *vcpu)
{
	kvmppc_mmu_destroy(vcpu);
}
void kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu)
{
	kvmppc_core_vcpu_load(vcpu, cpu);
}
void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)
{
	kvmppc_core_vcpu_put(vcpu);
}
int kvm_arch_vcpu_ioctl_set_guest_debug(struct kvm_vcpu *vcpu,
                                        struct kvm_guest_debug *dbg)
{
	return -EINVAL;
}
int kvm_arch_vcpu_ioctl_get_mpstate(struct kvm_vcpu *vcpu,
                                    struct kvm_mp_state *mp_state)
{
	return -EINVAL;
}
int kvm_arch_vcpu_ioctl_set_mpstate(struct kvm_vcpu *vcpu,
                                    struct kvm_mp_state *mp_state)
{
	return -EINVAL;
}
int kvm_vm_ioctl_get_dirty_log(struct kvm *kvm, struct kvm_dirty_log *log)
{
	return -ENOTSUPP;
}
int kvm_arch_init(void *opaque)
{
	return 0;
}
static int kvmppc_exit_timing_open(struct inode *inode, struct file *file)
{
	return single_open(file, kvmppc_exit_timing_show, inode->i_private);
}
void * __init_refok alloc_maybe_bootmem(size_t size, gfp_t mask)
{
	if (mem_init_done)
		return kmalloc(size, mask);
	else
		return alloc_bootmem(size);
}
void patch_branch(unsigned int *addr, unsigned long target, int flags)
{
	patch_instruction(addr, create_branch(addr, target, flags));
}
static unsigned int branch_opcode(unsigned int instr)
{
	return (instr >> 26) & 0x3F;
}
static int instr_is_branch_iform(unsigned int instr)
{
	return branch_opcode(instr) == 18;
}
static int instr_is_branch_bform(unsigned int instr)
{
	return branch_opcode(instr) == 16;
}
static void __init test_trampoline(void)
{
	asm ("nop;\n");
}
static unsigned int *calc_addr(struct fixup_entry *fcur, long offset)
{
	return (unsigned int *)((unsigned long)fcur + offset);
}
static long calc_offset(struct fixup_entry *entry, unsigned int *p)
{
	return (unsigned long)p - (unsigned long)entry;
}
unsigned long rh_alloc(rh_info_t * info, int size, const char *owner)
{
	return rh_alloc_align(info, size, info->alignment, owner);
}
void rh_dump_blk(rh_info_t * info, rh_block_t * blk)
{
	printk(KERN_INFO
	       "blk @0x%p: 0x%lx-0x%lx (%u)\n",
	       blk, blk->start, blk->start + blk->size, blk->size);
}
static inline int notify_page_fault(struct pt_regs *regs)
{
	return 0;
}
void __init MMU_init_hw(void)
{
	flush_instruction_cache();
}
static inline int tlb_batching_enabled(void)
{
	return 1;
}
static void __init htab_init_seg_sizes(void)
{
	of_scan_flat_dt(htab_dt_scan_seg_sizes, NULL);
}
void create_section_mapping(unsigned long start, unsigned long end)
{
	BUG_ON(htab_bolt_mapping(start, end, __pa(start),
				 pgprot_val(PAGE_KERNEL), mmu_linear_psize,
				 mmu_kernel_ssize));
}
int remove_section_mapping(unsigned long start, unsigned long end)
{
	return htab_remove_mapping(start, end, mmu_linear_psize,
			mmu_kernel_ssize);
}
unsigned int get_paca_psize(unsigned long addr)
{
	return get_paca()->context.user_psize;
}
static inline int subpage_protection(pgd_t *pgdir, unsigned long ea)
{
	return 0;
}
static pud_t *hpud_offset(pgd_t *pgd, unsigned long addr, struct hstate *hstate)
{
	if (huge_page_shift(hstate) < PUD_SHIFT)
		return pud_offset(pgd, addr);
	else
		return (pud_t *) pgd;
}
static pud_t *hpud_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long addr,
			 struct hstate *hstate)
{
	if (huge_page_shift(hstate) < PUD_SHIFT)
		return pud_alloc(mm, pgd, addr);
	else
		return (pud_t *) pgd;
}
static pmd_t *hpmd_offset(pud_t *pud, unsigned long addr, struct hstate *hstate)
{
	if (huge_page_shift(hstate) < PMD_SHIFT)
		return pmd_offset(pud, addr);
	else
		return (pmd_t *) pud;
}
static pmd_t *hpmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long addr,
			 struct hstate *hstate)
{
	if (huge_page_shift(hstate) < PMD_SHIFT)
		return pmd_alloc(mm, pud, addr);
	else
		return (pmd_t *) pud;
}
int huge_pmd_unshare(struct mm_struct *mm, unsigned long *addr, pte_t *ptep)
{
	return 0;
}
int pmd_huge(pmd_t pmd)
{
	return 0;
}
int pud_huge(pud_t pud)
{
	return 0;
}
static void pgd_ctor(void *addr)
{
	memset(addr, 0, PGD_TABLE_SIZE);
}
static void pmd_ctor(void *addr)
{
	memset(addr, 0, PMD_TABLE_SIZE);
}
static inline pte_t *virt_to_kpte(unsigned long vaddr)
{
	return pte_offset_kernel(pmd_offset(pud_offset(pgd_offset_k(vaddr),
			vaddr), vaddr), vaddr);
}
int page_is_ram(unsigned long pfn)
{
	return pfn < max_pfn;
}
int memory_add_physaddr_to_nid(u64 start)
{
	return hot_add_scn_to_nid(start);
}
static const int *of_get_associativity(struct device_node *dev)
{
	return of_get_property(dev, "ibm,associativity", NULL);
}
static inline int __init read_usm_ranges(const u32 **usm)
{
	return read_n_cells(n_mem_size_cells, usm);
}
void __iomem *
ioremap(phys_addr_t addr, unsigned long size)
{
	return __ioremap(addr, size, _PAGE_NO_CACHE | _PAGE_GUARDED);
}
void __this_fixmap_does_not_exist(void)
{
	WARN_ON(1);
}
unsigned long __init mmu_mapin_ram(void)
{
	return 0;
}
static void slb_allocate(unsigned long ea)
{
	slb_allocate_realmode(ea);
}
static inline unsigned long mk_esid_data(unsigned long ea, int ssize,
					 unsigned long slot)
{
	return (ea & slb_esid_mask(ssize)) | SLB_ESID_V | slot;
}
static inline unsigned long mk_vsid_data(unsigned long ea, int ssize,
					 unsigned long flags)
{
	return (get_kernel_vsid(ea, ssize) << slb_vsid_shift(ssize)) | flags |
		((unsigned long) ssize << SLB_VSID_SSIZE_SHIFT);
}
static inline void slb_shadow_clear(unsigned long entry)
{
	get_slb_shadow()->save_area[entry].esid = 0;
}
static int slice_low_has_vma(struct mm_struct *mm, unsigned long slice)
{
	return !slice_area_is_free(mm, slice << SLICE_LOW_SHIFT,
				   1ul << SLICE_LOW_SHIFT);
}
static int slice_check_fit(struct slice_mask mask, struct slice_mask available)
{
	return (mask.low_slices & available.low_slices) == mask.low_slices &&
		(mask.high_slices & available.high_slices) == mask.high_slices;
}
static unsigned long slice_find_area(struct mm_struct *mm, unsigned long len,
				     struct slice_mask mask, int psize,
				     int topdown, int use_cache)
{
	if (topdown)
		return slice_find_area_topdown(mm, len, mask, psize, use_cache);
	else
		return slice_find_area_bottomup(mm, len, mask, psize, use_cache);
}
unsigned long arch_get_unmapped_area(struct file *filp,
				     unsigned long addr,
				     unsigned long len,
				     unsigned long pgoff,
				     unsigned long flags)
{
	return slice_get_unmapped_area(addr, len, flags,
				       current->mm->context.user_psize,
				       0, 1);
}

unsigned long arch_get_unmapped_area_topdown(struct file *filp,
					     const unsigned long addr0,
					     const unsigned long len,
					     const unsigned long pgoff,
					     const unsigned long flags)
{
	return slice_get_unmapped_area(addr0, len, flags,
				       current->mm->context.user_psize,
				       1, 1);
}
int ste_allocate(unsigned long ea)
{
	return __ste_allocate(ea, current->mm);
}
void flush_tlb_range(struct vm_area_struct *vma, unsigned long start,
		     unsigned long end)
{
	flush_tlb_mm(vma->vm_mm);
}
void stop_spu_profiling_events(void)
{
	spu_prof_running = 0;
}
static void op_handle_interrupt(struct pt_regs *regs)
{
	model->handle_interrupt(regs, ctr);
}
static void op_powerpc_shutdown(void)
{
	release_pmc_hardware();
}
static inline void op_powerpc_cpu_stop(void *dummy)
{
	model->stop();
}
static int cell_global_start(struct op_counter_config *ctr)
{
	if (profiling_mode == SPU_PROFILING_CYCLES)
		return cell_global_start_spu_cycles(ctr);
	else if (profiling_mode == SPU_PROFILING_EVENTS)
		return cell_global_start_spu_events(ctr);
	else
		return cell_global_start_ppu(ctr);
}
static int cell_sync_start(void)
{
	if ((profiling_mode == SPU_PROFILING_CYCLES) ||
	    (profiling_mode == SPU_PROFILING_EVENTS))
		return spu_sync_start();
	else
		return DO_GENERIC_SYNC;
}
static int cell_sync_stop(void)
{
	if ((profiling_mode == SPU_PROFILING_CYCLES) ||
	    (profiling_mode == SPU_PROFILING_EVENTS))
		return spu_sync_stop();
	else
		return 1;
}
static int sam440ep_setup_rtc(void)
{
	return i2c_register_board_info(0, &sam440ep_rtc_info, 1);
}
int pika_dtm_register_shutdown(void (*func)(void *arg), void *arg)
{
	return 0;
}
int pika_dtm_unregister_shutdown(void (*func)(void *arg), void *arg)
{
	return 0;
}
static void mpc5121_clk_put(struct clk *clk)
{
	module_put(clk->owner);
}
static unsigned long mpc5121_clk_get_rate(struct clk *clk)
{
	if (clk->flags & CLK_HAS_RATE)
		return clk->rate;
	else
		return 0;
}
static long mpc5121_clk_round_rate(struct clk *clk, unsigned long rate)
{
	return rate;
}
static int mpc5121_clk_set_rate(struct clk *clk, unsigned long rate)
{
	return 0;
}
static void sys_clk_calc(struct clk *clk)
{
	clk->rate = ref_to_sys(ref_clk.rate);
}
static void half_clk_calc(struct clk *clk)
{
	clk->rate = clk->parent->rate / 2;
}
static void unity_clk_calc(struct clk *clk)
{
	clk->rate = clk->parent->rate;
}
static void ac97_clk_calc(struct clk *clk)
{
	clk->rate = 24567000;
}
static void __iomem *
irq_to_pic_mask(unsigned int irq)
{
	return irq <= 7 ? &cpld_regs->pci_mask : &cpld_regs->misc_mask;
}
static unsigned int
irq_to_pic_bit(unsigned int irq)
{
	return 1 << (irq & 0x7);
}
static int
cpld_pic_host_match(struct irq_host *h, struct device_node *node)
{
	return cpld_pic_node == node;
}
static void lite5200_resume_finish(void __iomem *mbar)
{
	out_be32(mbar + 0x1050, 0x00010000);
}
static void lite5200_pm_end(void)
{
	lite5200_pm_target_state = PM_SUSPEND_ON;
}
static int mpc52xx_gpiochip_remove(struct of_device *ofdev)
{
	return -EBUSY;
}
static inline struct mpc52xx_gpt_priv *gc_to_mpc52xx_gpt(struct gpio_chip *gc)
{
	return container_of(to_of_gpio_chip(gc), struct mpc52xx_gpt_priv,of_gc);
}
static void mpc52xx_gpt_create_attribs(struct mpc52xx_gpt_priv *) { return 0; }
static int mpc52xx_gpt_remove(struct of_device *ofdev)
{
	return -EBUSY;
}
static inline void io_be_setbit(u32 __iomem *addr, int bitno)
{
	out_be32(addr, in_be32(addr) | (1 << bitno));
}
static inline void io_be_clrbit(u32 __iomem *addr, int bitno)
{
	out_be32(addr, in_be32(addr) & ~(1 << bitno));
}
static int mpc52xx_null_set_type(unsigned int virq, unsigned int flow_type)
{
	return 0; /* Do nothing so that the sense mask will get updated */
}
static int mpc52xx_is_extirq(int l1, int l2)
{
	return ((l1 == 0) && (l2 == 0)) ||
	       ((l1 == 1) && (l2 >= 1) && (l2 <= 3));
}
static int ep8248e_get_mdio_data(struct mdiobb_ctrl *ctrl)
{
	return in_8(&ep8248e_bcsr[8]) & BCSR8_MDIO_DATA;
}
static int pq2_pci_exclude_device(struct pci_controller *hose,
                                  u_char bus, u8 devfn)
{
	if (bus == 0 && PCI_SLOT(devfn) == 0)
		return PCIBIOS_DEVICE_NOT_FOUND;
	else
		return PCIBIOS_SUCCESSFUL;
}
static int __init mcu_init(void)
{
	return i2c_add_driver(&mcu_driver);
}
static void __exit mcu_exit(void)
{
	i2c_del_driver(&mcu_driver);
}
static int __init mpc834x_itx_declare_of_platform_devices(void)
{
	return of_platform_bus_probe(NULL, mpc834x_itx_ids, NULL);
}
static int __init mpc836x_rdk_declare_of_platform_devices(void)
{
	return of_platform_bus_probe(NULL, mpc836x_rdk_ids, NULL);
}
int fsl_deep_sleep(void)
{
	return deep_sleeping;
}
static void mpc83xx_suspend_finish(void)
{
	deep_sleeping = 0;
}
static int mpc83xx_suspend_valid(suspend_state_t state)
{
	return state == PM_SUSPEND_STANDBY || state == PM_SUSPEND_MEM;
}

static int pmc_remove(struct of_device *ofdev)
{
	return -EPERM;
}
static int pmc_init(void)
{
	return of_register_platform_driver(&pmc_driver);
}
static int __init mpc8536_ds_publish_devices(void)
{
	return of_platform_bus_probe(NULL, mpc8536_ds_ids, NULL);
}
static int mpc85xx_exclude_device(struct pci_controller *hose,
				   u_char bus, u_char devfn)
{
	if (bus == 0 && PCI_SLOT(devfn) == 0)
		return PCIBIOS_DEVICE_NOT_FOUND;
	else
		return PCIBIOS_SUCCESSFUL;
}
static void __devinit skip_fake_bridge(struct pci_dev *dev)
{
	dev->hdr_type = 0x7f;
}
static irqreturn_t mpc85xx_8259_cascade_action(int irq, void *dev_id)
{
	return IRQ_HANDLED;
}
static int __init declare_of_platform_devices(void)
{
	return of_platform_bus_probe(NULL, of_bus_ids, NULL);
}
static int __init mpc85xxds_publish_devices(void)
{
	return of_platform_bus_probe(NULL, mpc85xxds_ids, NULL);
}
void __init
mpc85xx_smp_init(void)
{
	smp_ops = &smp_85xx_ops;
}
static void gef_pic_mask_ack(unsigned int virq)
{
	gef_pic_mask(virq);
}
ssize_t mpc8610hpcd_show_monitor_port(int monitor_port, char *buf)
{
	return snprintf(buf, PAGE_SIZE,
			"%c0 - DVI\n"
			"%c1 - Single link LVDS\n"
			"%c2 - Dual link LVDS\n",
			monitor_port == 0 ? '*' : ' ',
			monitor_port == 1 ? '*' : ' ',
			monitor_port == 2 ? '*' : ' ');
}
int mpc8610hpcd_set_sysfs_monitor_port(int val)
{
	return val < 3 ? val : 0;
}
static void __init
smp_86xx_setup_cpu(int cpu_nr)
{
	mpic_setup_this_cpu();
}
void __init
mpc86xx_smp_init(void)
{
	smp_ops = &smp_86xx_ops;
}
static int __init axon_msi_init(void)
{
	return of_register_platform_driver(&axon_msi_driver);
}
void beat_restart(char *cmd)
{
	beat_shutdown_logical_partition(!beat_pm_poweroff_flag);
}
void beat_power_off(void)
{
	beat_shutdown_logical_partition(0);
}
void beat_halt(void)
{
	beat_shutdown_logical_partition(beat_halt_code);
}
ssize_t beat_nvram_get_size(void)
{
	return BEAT_NVRAM_SIZE;
}
void beat_power_save(void)
{
	beat_pause(0);
}
void beat_kexec_cpu_down(int crash, int secondary)
{
	beatic_deinit_IRQ();
}
static int64_t _beat_lpar_hptab_clear_v3(void)
{
	return beat_clear_htab3(0);
}
static void beat_lpar_hptab_clear_v3(void)
{
	_beat_lpar_hptab_clear_v3();
}
static void beatic_pic_host_unmap(struct irq_host *h, unsigned int virq)
{
	beat_destruct_irq_plug(virq);
}
static void beatic_pic_host_remap(struct irq_host *h, unsigned int virq,
			       irq_hw_number_t hw)
{
	beat_construct_and_connect_irq_plug(virq, hw);
}
static int beatic_pic_host_match(struct irq_host *h, struct device_node *np)
{
	return 1;
}
static void celleb_pci_dma_dev_setup(struct pci_dev *pdev)
{
	celleb_dma_dev_setup(&pdev->dev);
}
static inline int __devinit smp_startup_cpu(unsigned int lcpu)
{
	return 0;
}
static int __init smp_beatic_probe(void)
{
	return cpus_weight(cpu_possible_map);
}
static void __devinit smp_beatic_setup_cpu(int cpu)
{
	beatic_setup_cpu(cpu);
}
static int smp_celleb_cpu_bootable(unsigned int nr)
{
	return 1;
}
static inline u64 _int_mask_get(struct spu *spu, int class)
{
	return spu->shadow_int_mask_RW[class];
}
static void int_mask_set(struct spu *spu, int class, u64 mask)
{
	_int_mask_set(spu, class, mask);
}
static u64 int_mask_get(struct spu *spu, int class)
{
	return _int_mask_get(spu, class);
}
static void int_stat_clear(struct spu *spu, int class, u64 stat)
{
	beat_clear_interrupt_status_of_spe(spu->spe_id, class, stat);
}
static void cpu_affinity_set(struct spu *spu, int cpu)
{
	return;
}
static void mfc_dsisr_set(struct spu *spu, u64 dsisr)
{
	beat_set_spe_privileged_state_1_registers(
		spu->spe_id,
		offsetof(struct spu_priv1, mfc_dsisr_RW), dsisr);
}
static void mfc_sdr_setup(struct spu *spu)
{
	return;
}
static void mfc_sr1_set(struct spu *spu, u64 sr1)
{
	beat_set_spe_privileged_state_1_registers(
		spu->spe_id,
		offsetof(struct spu_priv1, mfc_sr1_RW), sr1);
}
static void mfc_tclass_id_set(struct spu *spu, u64 tclass_id)
{
	beat_set_spe_privileged_state_1_registers(
		spu->spe_id,
		offsetof(struct spu_priv1, mfc_tclass_id_RW), tclass_id);
}
static void tlb_invalidate(struct spu *spu)
{
	beat_set_spe_privileged_state_1_registers(
		spu->spe_id,
		offsetof(struct spu_priv1, tlb_invalidate_entry_W), 0ul);
}
static void resource_allocation_groupID_set(struct spu *spu, u64 id)
{
	beat_set_spe_privileged_state_1_registers(
		spu->spe_id,
		offsetof(struct spu_priv1, resource_allocation_groupID_RW),
		id);
}
static void resource_allocation_enable_set(struct spu *spu, u64 enable)
{
	beat_set_spe_privileged_state_1_registers(
		spu->spe_id,
		offsetof(struct spu_priv1, resource_allocation_enable_RW),
		enable);
}
static int cbe_cpufreq_verify(struct cpufreq_policy *policy)
{
	return cpufreq_frequency_table_verify(policy, cbe_freqs);
}
static void __exit cbe_cpufreq_exit(void)
{
	cpufreq_unregister_driver(&cbe_cpufreq_driver);
}
static inline u8 reg_to_temp(u8 reg_value)
{
	return ((reg_value & 0x3f) << 1) + TEMP_MIN;
}
static inline u8 temp_to_reg(u8 temp)
{
	return ((temp - TEMP_MIN) >> 1) & 0x3f;
}
static ssize_t spu_show_throttle_end(struct sys_device *sysdev,
			struct sysdev_attribute *attr, char *buf)
{
	return show_throttle(get_pmd_regs(sysdev), buf, 0);
}
static ssize_t spu_show_throttle_begin(struct sys_device *sysdev,
			struct sysdev_attribute *attr, char *buf)
{
	return show_throttle(get_pmd_regs(sysdev), buf, 8);
}
static ssize_t spu_show_throttle_full_stop(struct sys_device *sysdev,
			struct sysdev_attribute *attr, char *buf)
{
	return show_throttle(get_pmd_regs(sysdev), buf, 16);
}
static ssize_t spu_store_throttle_end(struct sys_device *sysdev,
			struct sysdev_attribute *attr, const char *buf, size_t size)
{
	return store_throttle(get_pmd_regs(sysdev), buf, size, 0);
}
static ssize_t spu_store_throttle_begin(struct sys_device *sysdev,
			struct sysdev_attribute *attr, const char *buf, size_t size)
{
	return store_throttle(get_pmd_regs(sysdev), buf, size, 8);
}
static ssize_t spu_store_throttle_full_stop(struct sys_device *sysdev,
			struct sysdev_attribute *attr, const char *buf, size_t size)
{
	return store_throttle(get_pmd_regs(sysdev), buf, size, 16);
}
static ssize_t ppe_show_temp0(struct sys_device *sysdev,
			struct sysdev_attribute *attr, char *buf)
{
	return ppe_show_temp(sysdev, buf, 32);
}
static ssize_t ppe_show_temp1(struct sys_device *sysdev,
			struct sysdev_attribute *attr, char *buf)
{
	return ppe_show_temp(sysdev, buf, 0);
}
static ssize_t ppe_show_throttle_end(struct sys_device *sysdev,
			struct sysdev_attribute *attr, char *buf)
{
	return show_throttle(cbe_get_cpu_pmd_regs(sysdev->id), buf, 32);
}
static ssize_t ppe_show_throttle_begin(struct sys_device *sysdev,
			struct sysdev_attribute *attr, char *buf)
{
	return show_throttle(cbe_get_cpu_pmd_regs(sysdev->id), buf, 40);
}
static ssize_t ppe_show_throttle_full_stop(struct sys_device *sysdev,
			struct sysdev_attribute *attr, char *buf)
{
	return show_throttle(cbe_get_cpu_pmd_regs(sysdev->id), buf, 48);
}
static ssize_t ppe_store_throttle_end(struct sys_device *sysdev,
			struct sysdev_attribute *attr, const char *buf, size_t size)
{
	return store_throttle(cbe_get_cpu_pmd_regs(sysdev->id), buf, size, 32);
}
static ssize_t ppe_store_throttle_begin(struct sys_device *sysdev,
			struct sysdev_attribute *attr, const char *buf, size_t size)
{
	return store_throttle(cbe_get_cpu_pmd_regs(sysdev->id), buf, size, 40);
}
static ssize_t ppe_store_throttle_full_stop(struct sys_device *sysdev,
			struct sysdev_attribute *attr, const char *buf, size_t size)
{
	return store_throttle(cbe_get_cpu_pmd_regs(sysdev->id), buf, size, 48);
}
static void __init celleb_alloc_private_mem(struct pci_controller *hose)
{
	hose->private_data =
		alloc_maybe_bootmem(sizeof(struct celleb_pci_private),
			GFP_KERNEL);
}
int celleb_pci_probe_mode(struct pci_bus *bus)
{
	return PCI_PROBE_DEVTREE;
}
static inline PCI_IO_ADDR celleb_epci_get_epci_base(
					struct pci_controller *hose)
{
	return hose->cfg_addr;
}
static inline PCI_IO_ADDR celleb_epci_get_epci_cfg(
					struct pci_controller *hose)
{
	return hose->cfg_data;
}
static void scc_pciex_io_flush(struct iowa_bus *bus)
{
	(void)PEX_IN(bus->phb->cfg_addr, PEXDMRDEN0);
}
static inline unsigned long get_bus_address(struct pci_controller *phb,
					    unsigned long port)
{
	return port - ((unsigned long)(phb->io_base_virt) - _IO_BASE);
}
static u8 __scc_pciex_inb(struct pci_controller *phb, unsigned long port)
{
	return (u8)scc_pciex_read_port(phb, port, 1);
}
static void __scc_pciex_outb(struct pci_controller *phb,
			     u8 val, unsigned long port)
{
	scc_pciex_write_port(phb, port, 1, (u32)val);
}
static void celleb_progress(char *s, unsigned short hex)
{
	printk("*** %04x : %s\n", hex, s ? s : "");
}
static void spu_gov_cancel_work(struct spu_gov_info_struct *info)
{
	cancel_delayed_work_sync(&info->work);
}
void iic_setup_cpu(void)
{
	out_be64(&__get_cpu_var(iic).regs->prio, 0xff);
}
u8 iic_get_target_id(int cpu)
{
	return per_cpu(iic, cpu).target_id;
}
static inline int iic_ipi_to_irq(int ipi)
{
	return IIC_IRQ_TYPE_IPI + 0xf - ipi;
}
void iic_cause_IPI(int cpu, int mesg)
{
	out_be64(&per_cpu(iic, cpu).regs->generate, (0xf - mesg) << 4);
}
struct irq_host *iic_get_irq_host(int node)
{
	return iic_host;
}
static int iic_host_match(struct irq_host *h, struct device_node *node)
{
	return of_device_is_compatible(node,
				    "IBM,CBEA-Internal-Interrupt-Controller");
}
static void *dma_fixed_alloc_coherent(struct device *dev, size_t size,
				      dma_addr_t *dma_handle, gfp_t flag)
{
	if (iommu_fixed_is_weak)
		return iommu_alloc_coherent(dev, cell_get_iommu_table(dev),
					    size, dma_handle,
					    device_to_mask(dev), flag,
					    dev_to_node(dev));
	else
		return dma_direct_ops.alloc_coherent(dev, size, dma_handle,
						     flag);
}
static dma_addr_t dma_fixed_map_page(struct device *dev, struct page *page,
				     unsigned long offset, size_t size,
				     enum dma_data_direction direction,
				     struct dma_attrs *attrs)
{
	if (iommu_fixed_is_weak == dma_get_attr(DMA_ATTR_WEAK_ORDERING, attrs))
		return dma_direct_ops.map_page(dev, page, offset, size,
					       direction, attrs);
	else
		return iommu_map_page(dev, cell_get_iommu_table(dev), page,
				      offset, size, device_to_mask(dev),
				      direction, attrs);
}
static int dma_fixed_map_sg(struct device *dev, struct scatterlist *sg,
			   int nents, enum dma_data_direction direction,
			   struct dma_attrs *attrs)
{
	if (iommu_fixed_is_weak == dma_get_attr(DMA_ATTR_WEAK_ORDERING, attrs))
		return dma_direct_ops.map_sg(dev, sg, nents, direction, attrs);
	else
		return iommu_map_sg(dev, cell_get_iommu_table(dev), sg, nents,
				    device_to_mask(dev), direction, attrs);
}
static int dma_fixed_dma_supported(struct device *dev, u64 mask)
{
	return mask == DMA_64BIT_MASK;
}
static void cell_pci_dma_dev_setup(struct pci_dev *dev)
{
	cell_dma_dev_setup(&dev->dev);
}
u32 cbe_get_and_clear_pm_interrupts(u32 cpu)
{
	return cbe_read_pm(cpu, pm_status);
}
static void qpace_progress(char *s, unsigned short hex)
{
	printk("*** %04x : %s\n", hex, s ? s : "");
}
static int cbe_ptcal_notify_reboot(struct notifier_block *nb,
		unsigned long code, void *data)
{
	return cbe_ptcal_disable();
}
static void cbe_ptcal_crash_shutdown(void)
{
	cbe_ptcal_disable();
}
static void cell_progress(char *s, unsigned short hex)
{
	printk("*** %04x : %s\n", hex, s ? s : "");
}
static void __init cell_set_dabrx(void)
{
	mtspr(SPRN_DABRX, DABRX_KERNEL | DABRX_USER);
}
static struct spider_pic *spider_virq_to_pic(unsigned int virq)
{
	return irq_map[virq].host->host_data;
}
static void __iomem *spider_get_irq_config(struct spider_pic *pic,
					   unsigned int src)
{
	return pic->regs + TIR_CFGA + 8 * src;
}
int spu_64k_pages_available(void)
{
	return mmu_psize_defs[MMU_PAGE_64K].shift != 0;
}
struct device_node *spu_devnode(struct spu *spu)
{
	return spu->devnode;
}
static void enable_spu_by_master_run(struct spu_context *ctx)
{
	ctx->ops->master_start(ctx);
}
static void disable_spu_by_master_run(struct spu_context *ctx)
{
	ctx->ops->master_stop(ctx);
}
void spu_switch_notify(struct spu *spu, struct spu_context *ctx)
{
	blocking_notifier_call_chain(&spu_switch_notifier,
				     ctx ? ctx->object_id : 0, spu);
}
int spu_switch_event_unregister(struct notifier_block *n)
{
	return blocking_notifier_chain_unregister(&spu_switch_notifier, n);
}
void *spu_get_profile_private_kref(struct spu_context *ctx)
{
	return ctx->prof_priv_kref;
}
static void int_mask_set(struct spu *spu, int class, u64 mask)
{
	out_be64(&spu->priv1->int_mask_RW[class], mask);
}
static u64 int_mask_get(struct spu *spu, int class)
{
	return in_be64(&spu->priv1->int_mask_RW[class]);
}
static void int_stat_clear(struct spu *spu, int class, u64 stat)
{
	out_be64(&spu->priv1->int_stat_RW[class], stat);
}
static u64 int_stat_get(struct spu *spu, int class)
{
	return in_be64(&spu->priv1->int_stat_RW[class]);
}
static u64 mfc_dar_get(struct spu *spu)
{
	return in_be64(&spu->priv1->mfc_dar_RW);
}
static u64 mfc_dsisr_get(struct spu *spu)
{
	return in_be64(&spu->priv1->mfc_dsisr_RW);
}
static void mfc_dsisr_set(struct spu *spu, u64 dsisr)
{
	out_be64(&spu->priv1->mfc_dsisr_RW, dsisr);
}
static void mfc_sdr_setup(struct spu *spu)
{
	out_be64(&spu->priv1->mfc_sdr_RW, mfspr(SPRN_SDR1));
}
static void mfc_sr1_set(struct spu *spu, u64 sr1)
{
	out_be64(&spu->priv1->mfc_sr1_RW, sr1);
}
static u64 mfc_sr1_get(struct spu *spu)
{
	return in_be64(&spu->priv1->mfc_sr1_RW);
}
static void mfc_tclass_id_set(struct spu *spu, u64 tclass_id)
{
	out_be64(&spu->priv1->mfc_tclass_id_RW, tclass_id);
}
static u64 mfc_tclass_id_get(struct spu *spu)
{
	return in_be64(&spu->priv1->mfc_tclass_id_RW);
}
static void tlb_invalidate(struct spu *spu)
{
	out_be64(&spu->priv1->tlb_invalidate_entry_W, 0ul);
}
static void resource_allocation_groupID_set(struct spu *spu, u64 id)
{
	out_be64(&spu->priv1->resource_allocation_groupID_RW, id);
}
static u64 resource_allocation_groupID_get(struct spu *spu)
{
	return in_be64(&spu->priv1->resource_allocation_groupID_RW);
}
static void resource_allocation_enable_set(struct spu *spu, u64 enable)
{
	out_be64(&spu->priv1->resource_allocation_enable_RW, enable);
}
static u64 resource_allocation_enable_get(struct spu *spu)
{
	return in_be64(&spu->priv1->resource_allocation_enable_RW);
}
static inline struct spufs_calls *spufs_calls_get(void)
{
	return spufs_calls;
}
static u32 spu_backing_mbox_stat_read(struct spu_context *ctx)
{
	return ctx->csa.prob.mb_stat_R;
}
static u32 spu_backing_signal1_read(struct spu_context *ctx)
{
	return ctx->csa.spu_chnldata_RW[3];
}
static u32 spu_backing_signal2_read(struct spu_context *ctx)
{
	return ctx->csa.spu_chnldata_RW[4];
}
static u64 spu_backing_signal1_type_get(struct spu_context *ctx)
{
	return ((ctx->csa.priv2.spu_cfg_RW & 1) != 0);
}
static u64 spu_backing_signal2_type_get(struct spu_context *ctx)
{
	return ((ctx->csa.priv2.spu_cfg_RW & 2) != 0);
}
static u32 spu_backing_npc_read(struct spu_context *ctx)
{
	return ctx->csa.prob.spu_npc_RW;
}
static void spu_backing_npc_write(struct spu_context *ctx, u32 val)
{
	ctx->csa.prob.spu_npc_RW = val;
}
static u32 spu_backing_status_read(struct spu_context *ctx)
{
	return ctx->csa.prob.spu_status_R;
}
static char *spu_backing_get_ls(struct spu_context *ctx)
{
	return ctx->csa.lscsa->ls;
}
static void spu_backing_privcntl_write(struct spu_context *ctx, u64 val)
{
	ctx->csa.priv2.spu_privcntl_RW = val;
}
static u32 spu_backing_runcntl_read(struct spu_context *ctx)
{
	return ctx->csa.prob.spu_runcntl_RW;
}
static void spu_backing_runcntl_stop(struct spu_context *ctx)
{
	spu_backing_runcntl_write(ctx, SPU_RUNCNTL_STOP);
}
static u32 spu_backing_read_mfc_tagstatus(struct spu_context * ctx)
{
	return ctx->csa.prob.dma_tagstatus_R;
}
static u32 spu_backing_get_mfc_free_elements(struct spu_context *ctx)
{
	return ctx->csa.prob.dma_qstatus_R;
}
static void spu_backing_restart_dma(struct spu_context *ctx)
{
	ctx->csa.priv2.mfc_control_RW |= MFC_CNTL_RESTART_DMA_COMMAND;
}
int put_spu_context(struct spu_context *ctx)
{
	return kref_put(&ctx->kref, &destroy_spu_context);
}
static int spufs_cntl_mmap_fault(struct vm_area_struct *vma,
					   struct vm_fault *vmf)
{
	return spufs_ps_fault(vma, vmf, 0x4000, SPUFS_CNTL_MAP_SIZE);
}
size_t spu_ibox_read(struct spu_context *ctx, u32 *data)
{
	return ctx->ops->ibox_read(ctx, data);
}
size_t spu_wbox_write(struct spu_context *ctx, u32 data)
{
	return ctx->ops->wbox_write(ctx, data);
}
static int
spufs_signal1_mmap_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
{
	return spufs_ps_fault(vma, vmf, 0x14000, SPUFS_SIGNAL_MAP_SIZE);
}
static int
spufs_signal2_mmap_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
{
	return spufs_ps_fault(vma, vmf, 0x1c000, SPUFS_SIGNAL_MAP_SIZE);
}
static u64 spufs_signal1_type_get(struct spu_context *ctx)
{
	return ctx->ops->signal1_type_get(ctx);
}
static u64 spufs_signal2_type_get(struct spu_context *ctx)
{
	return ctx->ops->signal2_type_get(ctx);
}
static int
spufs_mss_mmap_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
{
	return spufs_ps_fault(vma, vmf, 0x0000, SPUFS_MSS_MAP_SIZE);
}
static int
spufs_psmap_mmap_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
{
	return spufs_ps_fault(vma, vmf, 0x0000, SPUFS_PS_MAP_SIZE);
}
static int
spufs_mfc_mmap_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
{
	return spufs_ps_fault(vma, vmf, 0x3000, SPUFS_MFC_MAP_SIZE);
}
static int spufs_mfc_fsync(struct file *file, struct dentry *dentry,
			   int datasync)
{
	return spufs_mfc_flush(file, NULL);
}
static u64 spufs_npc_get(struct spu_context *ctx)
{
	return ctx->ops->npc_read(ctx);
}
static u64 spufs_decr_status_get(struct spu_context *ctx)
{
	if (ctx->csa.priv2.mfc_control_RW & MFC_CNTL_DECREMENTER_RUNNING)
		return SPU_DECR_STATUS_RUNNING;
	else
		return 0;
}
static u64 spufs_object_id_get(struct spu_context *ctx)
{
	return ctx->object_id;
}
static u64 spufs_lslr_get(struct spu_context *ctx)
{
	return ctx->csa.priv2.spu_lslr_RW;
}
static int spufs_caps_open(struct inode *inode, struct file *file)
{
	return single_open(file, spufs_caps_show, SPUFS_I(inode)->i_ctx);
}
static int spufs_tid_open(struct inode *inode, struct file *file)
{
	return single_open(file, spufs_show_tid, SPUFS_I(inode)->i_ctx);
}
static int spufs_stat_open(struct inode *inode, struct file *file)
{
	return single_open(file, spufs_show_stat, SPUFS_I(inode)->i_ctx);
}
static inline int spufs_switch_log_used(struct spu_context *ctx)
{
	return (ctx->switch_log->head - ctx->switch_log->tail) %
		SWITCH_LOG_BUFSIZE;
}
static inline int spufs_switch_log_avail(struct spu_context *ctx)
{
	return SWITCH_LOG_BUFSIZE - spufs_switch_log_used(ctx);
}
static int spufs_ctx_open(struct inode *inode, struct file *file)
{
	return single_open(file, spufs_show_ctx, SPUFS_I(inode)->i_ctx);
}
int put_spu_gang(struct spu_gang *gang)
{
	return kref_put(&gang->kref, &destroy_spu_gang);
}
static u32 spu_hw_mbox_stat_read(struct spu_context *ctx)
{
	return in_be32(&ctx->spu->problem->mb_stat_R);
}
static void spu_hw_signal1_write(struct spu_context *ctx, u32 data)
{
	out_be32(&ctx->spu->problem->signal_notify1, data);
}
static void spu_hw_signal2_write(struct spu_context *ctx, u32 data)
{
	out_be32(&ctx->spu->problem->signal_notify2, data);
}
static u64 spu_hw_signal1_type_get(struct spu_context *ctx)
{
	return ((in_be64(&ctx->spu->priv2->spu_cfg_RW) & 1) != 0);
}
static u64 spu_hw_signal2_type_get(struct spu_context *ctx)
{
	return ((in_be64(&ctx->spu->priv2->spu_cfg_RW) & 2) != 0);
}
static u32 spu_hw_npc_read(struct spu_context *ctx)
{
	return in_be32(&ctx->spu->problem->spu_npc_RW);
}
static void spu_hw_npc_write(struct spu_context *ctx, u32 val)
{
	out_be32(&ctx->spu->problem->spu_npc_RW, val);
}
static u32 spu_hw_status_read(struct spu_context *ctx)
{
	return in_be32(&ctx->spu->problem->spu_status_R);
}
static char *spu_hw_get_ls(struct spu_context *ctx)
{
	return ctx->spu->local_store;
}
static void spu_hw_privcntl_write(struct spu_context *ctx, u64 val)
{
	out_be64(&ctx->spu->priv2->spu_privcntl_RW, val);
}
static u32 spu_hw_runcntl_read(struct spu_context *ctx)
{
	return in_be32(&ctx->spu->problem->spu_runcntl_RW);
}
static u32 spu_hw_read_mfc_tagstatus(struct spu_context * ctx)
{
	return in_be32(&ctx->spu->problem->dma_tagstatus_R);
}
static u32 spu_hw_get_mfc_free_elements(struct spu_context *ctx)
{
	return in_be32(&ctx->spu->problem->dma_qstatus_R);
}
static struct spufs_sb_info *spufs_get_sb_info(struct super_block *sb)
{
	return sb->s_fs_info;
}
static void
spufs_destroy_inode(struct inode *inode)
{
	kmem_cache_free(spufs_inode_cache, SPUFS_I(inode));
}
static void spufs_exit_isolated_loader(void)
{
	free_pages((unsigned long) isolated_loader,
			get_order(isolated_loader_size));
}
static int
spufs_get_sb(struct file_system_type *fstype, int flags,
		const char *name, void *data, struct vfsmount *mnt)
{
	return get_sb_single(fstype, flags, data, spufs_fill_super, mnt);
}
int spu_alloc_lscsa(struct spu_state *csa)
{
	return spu_alloc_lscsa_std(csa);
}
void spu_free_lscsa(struct spu_state *csa)
{
	spu_free_lscsa_std(csa);
}
static int spu_loadavg_open(struct inode *inode, struct file *file)
{
	return single_open(file, show_spu_loadavg, NULL);
}
static inline void save_complete(void)
{
	spu_stop(SPU_SAVE_COMPLETE);
}
static int sputrace_used(void)
{
	return (sputrace_head - sputrace_tail) % bufsize;
}
static inline int sputrace_avail(void)
{
	return bufsize - sputrace_used();
}
static inline void save_mfc_sr1(struct spu_state *csa, struct spu *spu)
{
	csa->priv1.mfc_sr1_RW = spu_mfc_sr1_get(spu);
}
static inline void save_timebase(struct spu_state *csa, struct spu *spu)
{
	csa->suspend_time = get_cycles();
}
static inline void save_mfc_tclass_id(struct spu_state *csa, struct spu *spu)
{
	csa->priv1.mfc_tclass_id_RW = spu_mfc_tclass_id_get(spu);
}
static inline void setup_mfc_sr1(struct spu_state *csa, struct spu *spu)
{
	spu_mfc_sr1_set(spu, (MFC_STATE1_MASTER_RUN_CONTROL_MASK |
			      MFC_STATE1_RELOCATE_MASK |
			      MFC_STATE1_BUS_TLBIE_MASK));
}
static inline void setup_ppu_mb(struct spu_state *csa, struct spu *spu)
{
	csa->lscsa->ppu_mb.slot[0] = csa->prob.pu_mb_R;
}
static inline void setup_ppuint_mb(struct spu_state *csa, struct spu *spu)
{
	csa->lscsa->ppuint_mb.slot[0] = csa->priv2.puint_mb_R;
}
void spu_fini_csa(struct spu_state *csa)
{
	spu_free_lscsa(csa);
}
static void __devinit smp_chrp_setup_cpu(int cpu_nr)
{
	mpic_setup_this_cpu();
}
int holly_exclude_device(struct pci_controller *hose, u_char bus, u_char devfn)
{
	if (bus == 0 && PCI_SLOT(devfn) == 0)
		return PCIBIOS_DEVICE_NOT_FOUND;
	else
		return PCIBIOS_SUCCESSFUL;
}
void holly_halt(void)
{
	holly_power_off();
}
static void linkstation_halt(void)
{
	linkstation_power_off();
}
int mpc7448_hpc2_exclude_device(struct pci_controller *hose,
				u_char bus, u_char devfn)
{
	if (bus == 0 && PCI_SLOT(devfn) == 0)
		return PCIBIOS_DEVICE_NOT_FOUND;
	else
		return PCIBIOS_SUCCESSFUL;
}
void mpc7448_hpc2_show_cpuinfo(struct seq_file *m)
{
	seq_printf(m, "vendor\t\t: Freescale Semiconductor\n");
}
void mpc7448_hpc2_halt(void)
{
	mpc7448_hpc2_power_off();
}
static void __init dt_prop_str(struct iseries_flat_dt *dt, const char *name,
		const char *data)
{
	dt_prop(dt, name, data, strlen(data) + 1); /* + 1 for NULL */
}
static void __init dt_prop_u32(struct iseries_flat_dt *dt, const char *name,
		u32 data)
{
	dt_prop(dt, name, &data, sizeof(u32));
}
static void __init dt_prop_u64(struct iseries_flat_dt *dt, const char *name,
		u64 data)
{
	dt_prop(dt, name, &data, sizeof(u64));
}
static void __init dt_prop_u64_list(struct iseries_flat_dt *dt,
		const char *name, u64 *data, int n)
{
	dt_prop(dt, name, data, sizeof(u64) * n);
}
static void __init dt_prop_u32_list(struct iseries_flat_dt *dt,
		const char *name, u32 *data, int n)
{
	dt_prop(dt, name, data, sizeof(u32) * n);
}
static void __init dt_prop_empty(struct iseries_flat_dt *dt, const char *name)
{
	dt_prop(dt, name, NULL, 0);
}
HvLpIndex HvLpConfig_getLpIndex_outline(void)
{
	return HvLpConfig_getLpIndex();
}
HvLpIndex HvLpConfig_getLpIndex(void)
{
	return itLpNaca.xLpIndex;
}
HvLpIndex HvLpConfig_getPrimaryLpIndex(void)
{
	return itLpNaca.xPrimaryLpIndex;
}
void *iseries_hv_alloc(size_t size, dma_addr_t *dma_handle, gfp_t flag)
{
	return iommu_alloc_coherent(NULL, &vio_iommu_table, size, dma_handle,
				DMA_32BIT_MASK, flag, -1);
}
void iseries_hv_free(size_t size, void *vaddr, dma_addr_t dma_handle)
{
	iommu_free_coherent(&vio_iommu_table, size, vaddr, dma_handle);
}
dma_addr_t iseries_hv_map(void *vaddr, size_t size,
			enum dma_data_direction direction)
{
	return iommu_map_page(NULL, &vio_iommu_table, virt_to_page(vaddr),
			      (unsigned long)vaddr % PAGE_SIZE, size,
			      DMA_32BIT_MASK, direction, NULL);
}
void iseries_hv_unmap(dma_addr_t dma_handle, size_t size,
			enum dma_data_direction direction)
{
	iommu_unmap_page(&vio_iommu_table, dma_handle, size, direction, NULL);
}
static int iseries_irq_host_match(struct irq_host *h, struct device_node *np)
{
	return 1;
}
static int proc_lpevents_open(struct inode *inode, struct file *file)
{
	return single_open(file, proc_lpevents_show, NULL);
}
static void mf_clear_src(void)
{
	signal_ce_msg_simple(0x4b, NULL);
}
static int proc_mf_dump_src(char *page, char **start, off_t off,
		int count, int *eof, void *data)
{
	return 0;
}
static u16 iseries_readw(const volatile void __iomem *addr)
{
	return le16_to_cpu(iseries_readw_be(addr));
}
static u32 iseries_readl(const volatile void __iomem *addr)
{
	return le32_to_cpu(iseries_readl_be(addr));
}
static void iseries_writew(u16 data, volatile void __iomem *addr)
{
	iseries_writew_be(cpu_to_le16(data), addr);
}
static void iseries_writel(u32 data, volatile void __iomem *addr)
{
	iseries_writel(cpu_to_le32(data), addr);
}
static int proc_titantod_open(struct inode *inode, struct file *file)
{
	return single_open(file, proc_titantod_show, NULL);
}
static void iSeries_show_cpuinfo(struct seq_file *m)
{
	seq_printf(m, "machine\t\t: 64-bit iSeries Logical Partition\n");
}
static inline void process_iSeries_events(void)
{
	asm volatile ("li 0,0x5555; sc" : : : "r0", "r3");
}
static void __iomem *iseries_ioremap(phys_addr_t address, unsigned long size,
				     unsigned long flags)
{
	return (void __iomem *)address;
}
static int iseries_kexec_prepare(struct kimage *image)
{
	return -ENOSYS;
}
void __init udbg_init_iseries(void)
{
	udbg_putc = hvputc;
}
static int smp_iSeries_probe(void)
{
	return cpus_weight(cpu_possible_map);
}
void __init smp_init_iSeries(void)
{
	smp_ops = &iSeries_smp_ops;
}
static void free_property(struct property *np)
{
	kfree(np);
}
static int proc_viopath_open(struct inode *inode, struct file *file)
{
	return single_open(file, proc_viopath_show, NULL);
}
HvLpInstanceId viopath_sourceinst(HvLpIndex lp)
{
	return viopathStatus[lp].mSourceInst;
}
HvLpInstanceId viopath_targetinst(HvLpIndex lp)
{
	return viopathStatus[lp].mTargetInst;
}
static unsigned long u3_agp_cfa0(u8 devfn, u8 off)
{
	return (1 << (unsigned long)PCI_SLOT(devfn)) |
		((unsigned long)PCI_FUNC(devfn) << 8) |
		((unsigned long)off & 0xFCUL);
}
static unsigned long u3_agp_cfa1(u8 bus, u8 devfn, u8 off)
{
	return ((unsigned long)bus << 16) |
		((unsigned long)devfn << 8) |
		((unsigned long)off & 0xFCUL) |
		1UL;
}
static unsigned long u3_ht_cfa0(u8 devfn, u8 off)
{
	return (devfn << 8) | off;
}
static unsigned long u3_ht_cfa1(u8 bus, u8 devfn, u8 off)
{
	return u3_ht_cfa0(devfn, off) + (bus << 16) + 0x01000000UL;
}
static unsigned int u4_pcie_cfa0(unsigned int devfn, unsigned int off)
{
	return (1 << PCI_SLOT(devfn))	|
	       (PCI_FUNC(devfn) << 8)	|
	       ((off >> 8) << 28) 	|
	       (off & 0xfcu);
}
static unsigned int u4_pcie_cfa1(unsigned int bus, unsigned int devfn,
				 unsigned int off)
{
        return (bus << 16)		|
	       (devfn << 8)		|
	       ((off >> 8) << 28)	|
	       (off & 0xfcu)		| 1u;
}
static void maple_halt(void)
{
	maple_power_off();
}
static void __init maple_progress(char *s, unsigned short hex)
{
	printk("*** %04x : %s\n", hex, s ? s : "");
}
int check_astate(void)
{
	return get_cur_astate(hard_smp_processor_id());
}
void restore_astate(int cpu)
{
	set_astate(cpu, current_astate);
}
static int pas_cpufreq_verify(struct cpufreq_policy *policy)
{
	return cpufreq_frequency_table_verify(policy, pas_freqs);
}
static void __exit pas_cpufreq_exit(void)
{
	cpufreq_unregister_driver(&pas_cpufreq_driver);
}
unsigned int pasemi_read_iob_reg(unsigned int reg)
{
	return in_le32(iob_regs+reg);
}
void pasemi_write_iob_reg(unsigned int reg, unsigned int val)
{
	out_le32(iob_regs+reg, val);
}
unsigned int pasemi_read_mac_reg(int intf, unsigned int reg)
{
	return in_le32(mac_regs[intf]+reg);
}
void pasemi_write_mac_reg(int intf, unsigned int reg, unsigned int val)
{
	out_le32(mac_regs[intf]+reg, val);
}
unsigned int pasemi_read_dma_reg(unsigned int reg)
{
	return in_le32(dma_regs+reg);
}
void pasemi_write_dma_reg(unsigned int reg, unsigned int val)
{
	out_le32(dma_regs+reg, val);
}
void *pasemi_dma_alloc_buf(struct pasemi_dmachan *chan, int size,
			   dma_addr_t *handle)
{
	return dma_alloc_coherent(&dma_pdev->dev, size, handle, GFP_KERNEL);
}
void pasemi_dma_free_buf(struct pasemi_dmachan *chan, int size,
			 dma_addr_t *handle)
{
	dma_free_coherent(&dma_pdev->dev, size, handle, GFP_KERNEL);
}
static inline void mdio_lo(struct mii_bus *bus)
{
	out_le32(gpio_regs+0x10, 1 << MDIO_PIN(bus));
}
static inline void mdio_hi(struct mii_bus *bus)
{
	out_le32(gpio_regs, 1 << MDIO_PIN(bus));
}
static inline void mdc_lo(struct mii_bus *bus)
{
	out_le32(gpio_regs+0x10, 1 << MDC_PIN(bus));
}
static inline void mdc_hi(struct mii_bus *bus)
{
	out_le32(gpio_regs, 1 << MDC_PIN(bus));
}
static inline void mdio_active(struct mii_bus *bus)
{
	out_le32(gpio_regs+0x20, (1 << MDC_PIN(bus)) | (1 << MDIO_PIN(bus)));
}
static inline void mdio_tristate(struct mii_bus *bus)
{
	out_le32(gpio_regs+0x30, (1 << MDIO_PIN(bus)));
}
static inline int mdio_read(struct mii_bus *bus)
{
	return !!(in_le32(gpio_regs+0x40) & (1 << MDIO_PIN(bus)));
}
static int gpio_mdio_reset(struct mii_bus *bus)
{
	return 0;
}
void __init alloc_iobmap_l2(void)
{
	return;
}
static inline int pa_pxp_offset_valid(u8 bus, u8 devfn, int offset)
{
	if (bus == 0 && devfn == 0)
		return offset < 8192;
	else
		return offset < 4096;
}
static void volatile __iomem *pa_pxp_cfg_addr(struct pci_controller *hose,
				       u8 bus, u8 devfn, int offset)
{
	return hose->cfg_data + PA_PXP_CFA(bus, devfn, offset);
}
static inline int is_root_port(int busno, int devfn)
{
	return ((busno == 0) && (PCI_FUNC(devfn) < 4) &&
		 ((PCI_SLOT(devfn) == 16) || (PCI_SLOT(devfn) == 17)));
}
static inline int is_5945_reg(int reg)
{
	return (((reg >= 0x18) && (reg < 0x34)) ||
		((reg >= 0x158) && (reg < 0x178)));
}
static void __init pas_progress(char *s, unsigned short hex)
{
	printk("[%04x] : %s\n", hex, s ? s : "");
}
static void __init pas_init_early(void)
{
	iommu_init_early_pasemi();
}
unsigned long __init pas_get_boot_time(void)
{
	return mktime(2006, 1, 1, 12, 0, 0);
}
int pmac_backlight_set_legacy_brightness(int brightness)
{
	return __pmac_backlight_set_legacy_brightness(brightness);
}
void pmac_backlight_disable()
{
	atomic_inc(&kernel_backlight_disabled);
}
void pmac_backlight_enable()
{
	atomic_dec(&kernel_backlight_disabled);
}
static unsigned int cpu_750fx_get_cpu_speed(void)
{
	if (mfspr(SPRN_HID1) & HID1_PS)
		return low_freq;
	else
		return hi_freq;
}
static unsigned int dfs_get_cpu_speed(void)
{
	if (mfspr(SPRN_HID1) & HID1_DFS)
		return low_freq;
	else
		return hi_freq;
}
static unsigned int pmac_cpufreq_get_speed(unsigned int cpu)
{
	return cur_freq;
}
static int pmac_cpufreq_verify(struct cpufreq_policy *policy)
{
	return cpufreq_frequency_table_verify(policy, pmac_cpu_freqs);
}
static int g5_cpufreq_verify(struct cpufreq_policy *policy)
{
	return cpufreq_frequency_table_verify(policy, g5_cpu_freqs);
}
static unsigned int g5_cpufreq_get_speed(unsigned int cpu)
{
	return g5_cpu_freqs[g5_pmode_cur].frequency;
}
static long ohare_floppy_enable(struct device_node *node, long param,
				long value)
{
	return simple_feature_tweak(node, macio_ohare,
		OHARE_FCR, OH_FLOPPY_ENABLE, value);
}
static long ohare_mesh_enable(struct device_node *node, long param, long value)
{
	return simple_feature_tweak(node, macio_ohare,
		OHARE_FCR, OH_MESH_ENABLE, value);
}
static long heathrow_floppy_enable(struct device_node *node, long param,
				   long value)
{
	return simple_feature_tweak(node, macio_unknown,
		HEATHROW_FCR,
		HRW_SWIM_ENABLE|HRW_BAY_FLOPPY_ENABLE,
		value);
}
int pmac_get_uninorth_variant(void)
{
	return uninorth_maj;
}
static inline u8 __kw_read_reg(struct pmac_i2c_host_kw *host, reg_t reg)
{
	return readb(host->base + (((unsigned int)reg) << host->bsteps));
}
static void pmu_i2c_complete(struct adb_request *req)
{
	complete(req->arg);
}
static void smu_i2c_complete(struct smu_i2c_cmd *cmd, void *misc)
{
	complete(misc);
}
struct device_node *pmac_i2c_get_controller(struct pmac_i2c_bus *bus)
{
	return bus->controller;
}
struct device_node *pmac_i2c_get_bus_node(struct pmac_i2c_bus *bus)
{
	return bus->busnode;
}
int pmac_i2c_get_type(struct pmac_i2c_bus *bus)
{
	return bus->type;
}
int pmac_i2c_get_flags(struct pmac_i2c_bus *bus)
{
	return bus->flags;
}
int pmac_i2c_get_channel(struct pmac_i2c_bus *bus)
{
	return bus->channel;
}
struct i2c_adapter *pmac_i2c_get_adapter(struct pmac_i2c_bus *bus)
{
	return bus->adapter;
}
void pmac_pfunc_i2c_suspend(void)
{
	pmac_i2c_devscan(pmac_i2c_dev_suspend);
}
void pmac_pfunc_i2c_resume(void)
{
	pmac_i2c_devscan(pmac_i2c_dev_resume);
}
static unsigned char direct_nvram_read_byte(int addr)
{
	return in_8(&nvram_data[(addr & (NVRAM_SIZE - 1)) * nvram_mult]);
}
static void direct_nvram_write_byte(int addr, unsigned char val)
{
	out_8(&nvram_data[(addr & (NVRAM_SIZE - 1)) * nvram_mult], val);
}
int pmac_get_partition(int partition)
{
	return nvram_partitions[partition];
}
static inline void pmf_put_device(struct pmf_device *dev)
{
	kref_put(&dev->ref, pmf_release_device);
}
static inline void __pmf_put_function(struct pmf_function *func)
{
	kref_put(&func->ref, pmf_release_function);
}
static int pmac_pic_host_match(struct irq_host *h, struct device_node *node)
{
	return 1;
}
int smu_init(void)
{
	return 0;
}
static void
pmac_halt(void)
{
	pmac_power_off();
}
static unsigned long from_rtc_time(struct rtc_time *tm)
{
	return mktime(tm->tm_year+1900, tm->tm_mon+1, tm->tm_mday,
		      tm->tm_hour, tm->tm_min, tm->tm_sec);
}
static int __init ps3_setup_ehci_device(
	const struct ps3_repository_device *repo)
{
	return ps3_setup_uhc_device(repo, PS3_MATCH_ID_EHCI,
		PS3_INTERRUPT_TYPE_SB_EHCI, PS3_REG_TYPE_SB_EHCI);
}
static int __init ps3_setup_ohci_device(
	const struct ps3_repository_device *repo)
{
	return ps3_setup_uhc_device(repo, PS3_MATCH_ID_OHCI,
		PS3_INTERRUPT_TYPE_SB_OHCI, PS3_REG_TYPE_SB_OHCI);
}
static void ps3_hpte_updateboltedpp(unsigned long newpp, unsigned long ea,
	int psize, int ssize)
{
	panic("ps3_hpte_updateboltedpp() not implemented");
}
int ps3_send_event_locally(unsigned int virq)
{
	return lv1_send_event_locally(virq_to_hw(virq));
}
static void _dump_64_bmp(const char *header, const u64 *p, unsigned cpu,
	const char* func, int line)
{
	pr_debug("%s:%d: %s %u {%04lx_%04lx_%04lx_%04lx}\n",
		func, line, header, cpu,
		*p >> 48, (*p >> 32) & 0xffff, (*p >> 16) & 0xffff,
		*p & 0xffff);
}
static void __maybe_unused _dump_256_bmp(const char *header,
	const u64 *p, unsigned cpu, const char* func, int line)
{
	pr_debug("%s:%d: %s %u {%016lx:%016lx:%016lx:%016lx}\n",
		func, line, header, cpu, p[0], p[1], p[2], p[3]);
}
static void ps3_host_unmap(struct irq_host *h, unsigned int virq)
{
	set_irq_chip_data(virq, NULL);
}
static int ps3_host_match(struct irq_host *h, struct device_node *np)
{
	return 1;
}
static unsigned long make_page_sizes(unsigned long a, unsigned long b)
{
	return (a << 56) | (b << 48);
}

static int dma_sb_unmap_area_linear(struct ps3_dma_region *r,
	dma_addr_t bus_addr, unsigned long len)
{
	return 0;
}
int ps3_dma_map(struct ps3_dma_region *r, unsigned long virt_addr,
	unsigned long len, dma_addr_t *bus_addr,
	u64 iopte_flag)
{
	return r->region_ops->map(r, virt_addr, len, bus_addr, iopte_flag);
}
int ps3_dma_unmap(struct ps3_dma_region *r, dma_addr_t bus_addr,
	unsigned long len)
{
	return r->region_ops->unmap(r, bus_addr, len);
}
void ps3_mm_shutdown(void)
{
	ps3_mm_region_destroy(&map.r1);
}
static unsigned int db_align_up(unsigned int val, unsigned int size)
{
	return (val + (size - 1)) & (~(size - 1));
}
static int db_get_rtc_diff(const struct os_area_db *db, int64_t *rtc_diff)
{
	return db_get_64(db, &os_area_db_id_rtc_diff, (uint64_t*)rtc_diff);
}
u64 ps3_os_area_get_rtc_diff(void)
{
	return saved_params.rtc_diff;
}
enum ps3_param_av_multi_out ps3_os_area_get_av_multi_out(void)
{
    return saved_params.av_multi_out;
}
int ps3_repository_read_bus_str(unsigned int bus_index, const char *bus_str,
	u64 *value)
{
	return read_node(PS3_LPAR_ID_PME,
		make_first_field("bus", bus_index),
		make_field(bus_str, 0),
		0, 0,
		value, NULL);
}
int ps3_repository_read_dev_str(unsigned int bus_index,
	unsigned int dev_index, const char *dev_str, u64 *value)
{
	return read_node(PS3_LPAR_ID_PME,
		make_first_field("bus", bus_index),
		make_field("dev", dev_index),
		make_field(dev_str, 0),
		0,
		value, NULL);
}
int ps3_repository_read_dev_reg_addr(unsigned int bus_index,
	unsigned int dev_index, unsigned int reg_index, u64 *bus_addr, u64 *len)
{
	return read_node(PS3_LPAR_ID_PME,
		make_first_field("bus", bus_index),
		make_field("dev", dev_index),
		make_field("reg", reg_index),
		make_field("data", 0),
		bus_addr, len);
}
int ps3_repository_read_stor_dev_port(unsigned int bus_index,
	unsigned int dev_index, u64 *port)
{
	return read_node(PS3_LPAR_ID_PME,
		make_first_field("bus", bus_index),
		make_field("dev", dev_index),
		make_field("port", 0),
		0, port, NULL);
}
int ps3_repository_read_stor_dev_blk_size(unsigned int bus_index,
	unsigned int dev_index, u64 *blk_size)
{
	return read_node(PS3_LPAR_ID_PME,
		make_first_field("bus", bus_index),
		make_field("dev", dev_index),
		make_field("blk_size", 0),
		0, blk_size, NULL);
}
int ps3_repository_read_stor_dev_num_blocks(unsigned int bus_index,
	unsigned int dev_index, u64 *num_blocks)
{
	return read_node(PS3_LPAR_ID_PME,
		make_first_field("bus", bus_index),
		make_field("dev", dev_index),
		make_field("n_blocks", 0),
		0, num_blocks, NULL);
}
int ps3_repository_read_stor_dev_region_size(unsigned int bus_index,
	unsigned int dev_index,	unsigned int region_index, u64 *region_size)
{
	return read_node(PS3_LPAR_ID_PME,
	    make_first_field("bus", bus_index),
	    make_field("dev", dev_index),
	    make_field("region", region_index),
	    make_field("size", 0),
	    region_size, NULL);
}
int ps3_repository_read_stor_dev_region_start(unsigned int bus_index,
	unsigned int dev_index, unsigned int region_index, u64 *region_start)
{
	return read_node(PS3_LPAR_ID_PME,
	    make_first_field("bus", bus_index),
	    make_field("dev", dev_index),
	    make_field("region", region_index),
	    make_field("start", 0),
	    region_start, NULL);
}
int ps3_repository_read_pu_id(unsigned int pu_index, u64 *pu_id)
{
	return read_node(PS3_LPAR_ID_CURRENT,
		make_first_field("bi", 0),
		make_field("pu", pu_index),
		0, 0,
		pu_id, NULL);
}
int ps3_repository_read_rm_size(unsigned int ppe_id, u64 *rm_size)
{
	return read_node(PS3_LPAR_ID_CURRENT,
		make_first_field("bi", 0),
		make_field("pu", 0),
		ppe_id,
		make_field("rm_size", 0),
		rm_size, NULL);
}
int ps3_repository_read_region_total(u64 *region_total)
{
	return read_node(PS3_LPAR_ID_CURRENT,
		make_first_field("bi", 0),
		make_field("rgntotal", 0),
		0, 0,
		region_total, NULL);
}
static int ps3_repository_read_boot_dat_address(u64 *address)
{
	return read_node(PS3_LPAR_ID_CURRENT,
		make_first_field("bi", 0),
		make_field("boot_dat", 0),
		make_field("address", 0),
		0,
		address, NULL);
}
int ps3_repository_read_be_node_id(unsigned int be_index, u64 *node_id)
{
	return read_node(PS3_LPAR_ID_PME,
		make_first_field("be", be_index),
		0,
		0,
		0,
		node_id, NULL);
}
int ps3_repository_read_be_id(u64 node_id, u64 *be_id)
{
	return read_node(PS3_LPAR_ID_PME,
		make_first_field("be", 0),
		node_id,
		0,
		0,
		be_id, NULL);
}
int ps3_repository_read_tb_freq(u64 node_id, u64 *tb_freq)
{
	return read_node(PS3_LPAR_ID_PME,
		make_first_field("be", 0),
		node_id,
		make_field("clock", 0),
		0,
		tb_freq, NULL);
}
void ps3_get_firmware_version(union ps3_firmware_version *v)
{
	*v = ps3_firmware_version;
}
static void ps3_power_save(void)
{
	lv1_pause(0);
}
static void __init ps3_progress(char *s, unsigned short hex)
{
	printk("*** %04x : %s\n", hex, s ? s : "");
}
static int ps3_smp_probe(void)
{
	return 2;
}
static struct spu_pdata *spu_pdata(struct spu *spu)
{
	return spu->pdata;
}
inline u64 ps3_get_spe_id(void *arg)
{
	return spu_pdata(arg)->spe_id;
}
static int ps3_init_affinity(void)
{
	return 0;
}
static void ps3_disable_spu(struct spu_context *ctx)
{
	ctx->ops->runcntl_stop(ctx);
}
static u64 int_mask_get(struct spu *spu, int class)
{
	return spu_pdata(spu)->cache.masks[class];
}
static void int_stat_clear(struct spu *spu, int class, u64 stat)
{
	lv1_clear_spe_interrupt_status(spu_pdata(spu)->spe_id, class,
		stat, 0);
}
static u64 mfc_dar_get(struct spu *spu)
{
	return in_be64(&spu_pdata(spu)->shadow->mfc_dar_RW);
}
static u64 mfc_dsisr_get(struct spu *spu)
{
	return in_be64(&spu_pdata(spu)->shadow->mfc_dsisr_RW);
}
static u64 mfc_sr1_get(struct spu *spu)
{
	return spu_pdata(spu)->cache.sr1;
}
static u64 mfc_tclass_id_get(struct spu *spu)
{
	return spu_pdata(spu)->cache.tclass_id;
}
static u64 resource_allocation_groupID_get(struct spu *spu)
{
	return 0; /* No support. */
}
static u64 resource_allocation_enable_get(struct spu *spu)
{
	return 0; /* No support. */
}
static int ps3_is_device(struct ps3_system_bus_device *dev, u64 bus_id,
			 u64 dev_id)
{
	return dev->bus_id == bus_id && dev->dev_id == dev_id;
}
static int ps3_ioc0_mmio_region_create(struct ps3_mmio_region *r)
{
	return 0;
}
int ps3_mmio_region_create(struct ps3_mmio_region *r)
{
	return r->mmio_ops->create(r);
}
static int ps3_ioc0_free_mmio_region(struct ps3_mmio_region *r)
{
	return 0;
}
int ps3_free_mmio_region(struct ps3_mmio_region *r)
{
	return r->mmio_ops->free(r);
}
static void ps3_sb_unmap_sg(struct device *_dev, struct scatterlist *sg,
	int nents, enum dma_data_direction direction, struct dma_attrs *attrs)
{
	BUG_ON("do");
}
static void ps3_ioc0_unmap_sg(struct device *_dev, struct scatterlist *sg,
			    int nents, enum dma_data_direction direction,
			    struct dma_attrs *attrs)
{
	BUG();
}
static int ps3_dma_supported(struct device *_dev, u64 mask)
{
	return mask >= DMA_32BIT_MASK;
}
unsigned long __init ps3_get_boot_time(void)
{
	return read_rtc() + ps3_os_area_get_rtc_diff();
}
static ssize_t show_oom_pages(struct sys_device *dev,
			      struct sysdev_attribute *attr, char *buf)
{
	return sprintf(buf, "%lu\n", PAGES2KB(oom_freed_pages));
}
static int proc_eeh_open(struct inode *inode, struct file *file)
{
	return single_open(file, proc_eeh_show, NULL);
}
void __init setup_kexec_cpu_down_mpic(void)
{
	ppc_md.kexec_cpu_down = pseries_kexec_cpu_down_mpic;
}
void __init setup_kexec_cpu_down_xics(void)
{
	ppc_md.kexec_cpu_down = pseries_kexec_cpu_down_xics;
}
static int check_req_msi(struct pci_dev *pdev, int nvec)
{
	return check_req(pdev, nvec, "ibm,req#msi");
}
static int check_req_msix(struct pci_dev *pdev, int nvec)
{
	return check_req(pdev, nvec, "ibm,req#msi-x");
}
static ssize_t pSeries_nvram_get_size(void)
{
	return nvram_size ? nvram_size : -ENODEV;
}
static ssize_t show_phyp_dump_active(struct kobject *kobj,
			struct kobj_attribute *attr, char *buf)
{
	return sprintf(buf, "%lx\n", phyp_dump_info->phyp_dump_at_boot);
}
static ssize_t auto_poweron_show(struct kobject *kobj,
				 struct kobj_attribute *attr, char *buf)
{
        return sprintf(buf, "%lu\n", rtas_poweron_auto);
}
static int __init apo_pm_init(void)
{
	return (sysfs_create_file(power_kobj, &auto_poweron_attr.attr));
}
static void add_node_proc_entries(struct device_node *np)
{
	return;
}
static void remove_node_proc_entries(struct device_node *np)
{
	return;
}
int pSeries_reconfig_notifier_register(struct notifier_block *nb)
{
	return blocking_notifier_chain_register(&pSeries_reconfig_chain, nb);
}
void pSeries_reconfig_notifier_unregister(struct notifier_block *nb)
{
	blocking_notifier_chain_unregister(&pSeries_reconfig_chain, nb);
}
static int rtas_log_open(struct inode * inode, struct file * file)
{
	return 0;
}
static int rtas_log_release(struct inode * inode, struct file * file)
{
	return 0;
}
static int pseries_set_dabr(unsigned long dabr)
{
	return plpar_hcall_norets(H_SET_DABR, dabr);
}
static int pseries_set_xdabr(unsigned long dabr)
{
	return plpar_hcall_norets(H_SET_XDABR, dabr,
			H_DABRX_KERNEL | H_DABRX_USER);
}
static inline void direct_qirr_info(int n_cpu, u8 value)
{
	out_8(&xics_per_cpu[n_cpu]->qirr.bytes[0], value);
}
static int get_irq_server(unsigned int virq, unsigned int strict_check)
{
	return default_server;
}
static inline unsigned int xics_xirr_vector(unsigned int xirr)
{
	return xirr & 0x00ffffff;
}
static int xics_host_match(struct irq_host *h, struct device_node *node)
{
	return !of_device_is_compatible(node, "chrp,iic");
}
void bcom_ata_release(struct bcom_task *tsk)
{
	bcom_task_free(tsk);
}
void
bcom_enable(struct bcom_task *tsk)
{
	bcom_enable_task(tsk->tasknum);
}
void
bcom_disable(struct bcom_task *tsk)
{
	bcom_disable_task(tsk->tasknum);
}
static int __init
mpc52xx_bcom_init(void)
{
	return of_register_platform_driver(&mpc52xx_bcom_of_platform_driver);
}
static void __exit
mpc52xx_bcom_exit(void)
{
	of_unregister_platform_driver(&mpc52xx_bcom_of_platform_driver);
}
void
bcom_fec_rx_release(struct bcom_task *tsk)
{
	bcom_task_free(tsk);
}
void
bcom_fec_tx_release(struct bcom_task *tsk)
{
	bcom_task_free(tsk);
}
void
bcom_gen_bd_rx_release(struct bcom_task *tsk)
{
	bcom_task_free(tsk);
}
void
bcom_gen_bd_tx_release(struct bcom_task *tsk)
{
	bcom_task_free(tsk);
}
static irqreturn_t cpm_error_interrupt(int irq, void *dev)
{
	return IRQ_HANDLED;
}
static inline struct cpm1_gpio16_chip *
to_cpm1_gpio16_chip(struct of_mm_gpio_chip *mm_gc)
{
	return container_of(mm_gc, struct cpm1_gpio16_chip, mm_gc);
}
static inline struct cpm1_gpio32_chip *
to_cpm1_gpio32_chip(struct of_mm_gpio_chip *mm_gc)
{
	return container_of(mm_gc, struct cpm1_gpio32_chip, mm_gc);
}
void __iomem *cpm_muram_addr(unsigned long offset)
{
	return muram_vbase + offset;
}
unsigned long cpm_muram_offset(void __iomem *addr)
{
	return addr - (void __iomem *)muram_vbase;
}
dma_addr_t cpm_muram_dma(void __iomem *addr)
{
	return muram_pbase + ((u8 __iomem *)addr - muram_vbase);
}
static inline struct cpm2_gpio32_chip *
to_cpm2_gpio32_chip(struct of_mm_gpio_chip *mm_gc)
{
	return container_of(mm_gc, struct cpm2_gpio32_chip, mm_gc);
}
static void pci_dma_dev_setup_dart(struct pci_dev *dev)
{
	dev->dev.archdata.dma_data = &iommu_table_dart;
}
static void iommu_dart_save(void)
{
	memcpy(dart_copy, dart_vbase, 2*1024*1024);
}
bool dcr_map_ok_generic(dcr_host_t host)
{
	if (host.type == DCR_HOST_NATIVE)
		return dcr_map_ok_native(host.host.native);
	else if (host.type == DCR_HOST_MMIO)
		return dcr_map_ok_mmio(host.host.mmio);
	else
		return 0;
}
void gtm_ack_timer16(struct gtm_timer *tmr, u16 events)
{
	out_be16(tmr->gtevr, events);
}
static inline u32 fsl_msi_read(u32 __iomem *base, unsigned int reg)
{
	return in_be32(base + (reg >> 2));
}
static __init int fsl_of_msi_init(void)
{
	return of_register_platform_driver(&fsl_of_msi_driver);
}
static __init int fsl_of_rio_rpn_init(void)
{
	return of_register_platform_driver(&fsl_of_rio_rpn_driver);
}
static int i8259_host_match(struct irq_host *h, struct device_node *node)
{
	return h->of_node == NULL || h->of_node == node;
}
struct irq_host *i8259_get_host(void)
{
	return i8259_host;
}
static inline u32 ipic_read(volatile u32 __iomem *base, unsigned int reg)
{
	return in_be32(base + (reg >> 2));
}
static inline void ipic_write(volatile u32 __iomem *base, unsigned int reg, u32 value)
{
	out_be32(base + (reg >> 2), value);
}
static inline struct ipic * ipic_from_irq(unsigned int virq)
{
	return primary_ipic;
}
static int ipic_host_match(struct irq_host *h, struct device_node *node)
{
	return h->of_node == NULL || h->of_node == node;
}
u32 ipic_get_mcp_status(void)
{
	return ipic_read(primary_ipic->regs, IPIC_SERMR);
}
void ipic_clear_mcp_status(u32 mask)
{
	ipic_write(primary_ipic->regs, IPIC_SERMR, mask);
}
static ssize_t mmio_nvram_get_size(void)
{
	return mmio_nvram_len;
}
static inline u32 mpc8xxx_gpio2mask(unsigned int gpio)
{
	return 1u << (MPC8XXX_GPIO_PINS - 1 - gpio);
}
static inline struct mpc8xxx_gpio_chip *
to_mpc8xxx_gpio_chip(struct of_mm_gpio_chip *mm)
{
	return container_of(mm, struct mpc8xxx_gpio_chip, mm_gc);
}
static void __init mpic_scan_ht_msi(struct mpic *mpic, u8 __iomem *devbase,
				    unsigned int devfn)
{
	return;
}
static inline int mpic_is_ht_interrupt(struct mpic *mpic, unsigned int source)
{
	return 0;
}
static int irq_choose_cpu(unsigned int virt_irq)
{
	return hard_smp_processor_id();
}
static inline struct mpic * mpic_from_ipi(unsigned int ipi)
{
	return irq_desc[ipi].chip_data;
}
static inline struct mpic * mpic_from_irq(unsigned int irq)
{
	return irq_desc[irq].chip_data;
}
static int mpic_host_match(struct irq_host *h, struct device_node *node)
{
	return h->of_node == NULL || h->of_node == node;
}
unsigned int mpic_get_one_irq(struct mpic *mpic)
{
	return _mpic_get_one_irq(mpic, MPIC_INFO(CPU_INTACK));
}
void __devinit smp_mpic_setup_cpu(int cpu)
{
	mpic_setup_this_cpu();
}
static int mpic_msi_reserve_u3_hwirqs(struct mpic *mpic)
{
	return -1;
}
static void __init mv64x60_pci_fixup_early(struct pci_dev *dev)
{
	dev->hdr_type = PCI_HEADER_TYPE_INVALID;
}
static int mv64x60_udbg_testc(void)
{
	return (in_le32(mpsc_intr_cause) & MPSC_INTR_CAUSE_RCC) != 0;
}
void mv64x60_init_early(void)
{
	mv64x60_udbg_init();
}
static int __init pmi_module_init(void)
{
	return of_register_platform_driver(&pmi_of_platform_driver);
}
static void __exit pmi_module_exit(void)
{
	of_unregister_platform_driver(&pmi_of_platform_driver);
}
static inline struct ppc4xx_gpio_chip *
to_ppc4xx_gpiochip(struct of_mm_gpio_chip *mm_gc)
{
	return container_of(mm_gc, struct ppc4xx_gpio_chip, mm_gc);
}
static inline int ppc440spe_revA(void)
{
        if ((mfspr(SPRN_PVR) & 0xffefffff) == 0x53421890)
                return 1;
        else
                return 0;
}
static int ppc440speA_pciex_init_port_hw(struct ppc4xx_pciex_port *port)
{
	return ppc440spe_pciex_init_port_hw(port);
}
static int __init ppc460ex_pciex_core_init(struct device_node *np)
{
	return 2;
}
static int __init ppc405ex_pciex_core_init(struct device_node *np)
{
	return 2;
}
static inline struct qe_gpio_chip *
to_qe_gpio_chip(struct of_mm_gpio_chip *mm_gc)
{
	return container_of(mm_gc, struct qe_gpio_chip, mm_gc);
}
static inline u32 qe_ic_read(volatile __be32  __iomem * base, unsigned int reg)
{
	return in_be32(base + (reg >> 2));
}
static inline void qe_ic_write(volatile __be32  __iomem * base, unsigned int reg,
			       u32 value)
{
	out_be32(base + (reg >> 2), value);
}
static inline struct qe_ic *qe_ic_from_irq(unsigned int virq)
{
	return irq_desc[virq].chip_data;
}
static int qe_ic_host_match(struct irq_host *h, struct device_node *node)
{
	return h->of_node == NULL || h->of_node == node;
}
void ucc_fast_transmit_on_demand(struct ucc_fast_private * uccf)
{
	out_be16(&uccf->uf_regs->utodr, UCC_FAST_TOD);
}
void ucc_slow_poll_transmitter_now(struct ucc_slow_private * uccs)
{
	out_be16(&uccs->us_regs->utodr, UCC_SLOW_TOD);
}
static struct u8_gpio_chip *to_u8_gpio_chip(struct of_mm_gpio_chip *mm_gc)
{
	return container_of(mm_gc, struct u8_gpio_chip, mm_gc);
}
static u8 u8_pin2mask(unsigned int pin)
{
	return 1 << (8 - 1 - pin);
}
static int u8_gpio_dir_in(struct gpio_chip *gc, unsigned int gpio)
{
	return 0;
}
u32 get_vir_csrbase(void)
{
	return (u32) (ioremap(get_csrbase(), 0x10000));
}
void tsi108_clear_pci_cfg_error(void)
{
	tsi108_clear_pci_error(tsi108_pci_cfg_phys);
}
static void tsi108_pci_irq_enable(u_int irq)
{
	tsi108_pci_int_unmask(irq);
}
static void tsi108_pci_irq_disable(u_int irq)
{
	tsi108_pci_int_mask(irq);
}
static void tsi108_pci_irq_ack(u_int irq)
{
	tsi108_pci_int_mask(irq);
}
void xmon_puts(const char *str)
{
	xmon_write(str, strlen(str));
}
static unsigned long
insert_bat (unsigned long insn,
	    long value ATTRIBUTE_UNUSED,
	    int dialect ATTRIBUTE_UNUSED,
	    const char **errmsg ATTRIBUTE_UNUSED)
{
  return insn | (((insn >> 21) & 0x1f) << 16);
}
static unsigned long
insert_bba (unsigned long insn,
	    long value ATTRIBUTE_UNUSED,
	    int dialect ATTRIBUTE_UNUSED,
	    const char **errmsg ATTRIBUTE_UNUSED)
{
  return insn | (((insn >> 16) & 0x1f) << 11);
}
static unsigned long
insert_bd (unsigned long insn,
	   long value,
	   int dialect ATTRIBUTE_UNUSED,
	   const char **errmsg ATTRIBUTE_UNUSED)
{
  return insn | (value & 0xfffc);
}
static long
extract_bd (unsigned long insn,
	    int dialect ATTRIBUTE_UNUSED,
	    int *invalid ATTRIBUTE_UNUSED)
{
  return ((insn & 0xfffc) ^ 0x8000) - 0x8000;
}
static long
extract_dq (unsigned long insn,
	    int dialect ATTRIBUTE_UNUSED,
	    int *invalid ATTRIBUTE_UNUSED)
{
  return ((insn & 0xfff0) ^ 0x8000) - 0x8000;
}
static long
extract_ev2 (unsigned long insn,
	     int dialect ATTRIBUTE_UNUSED,
	     int *invalid ATTRIBUTE_UNUSED)
{
  return (insn >> 10) & 0x3e;
}
static long
extract_ev4 (unsigned long insn,
	     int dialect ATTRIBUTE_UNUSED,
	     int *invalid ATTRIBUTE_UNUSED)
{
  return (insn >> 9) & 0x7c;
}
static long
extract_ev8 (unsigned long insn,
	     int dialect ATTRIBUTE_UNUSED,
	     int *invalid ATTRIBUTE_UNUSED)
{
  return (insn >> 8) & 0xf8;
}
static long
extract_ds (unsigned long insn,
	    int dialect ATTRIBUTE_UNUSED,
	    int *invalid ATTRIBUTE_UNUSED)
{
  return ((insn & 0xfffc) ^ 0x8000) - 0x8000;
}
static long
extract_de (unsigned long insn,
	    int dialect ATTRIBUTE_UNUSED,
	    int *invalid ATTRIBUTE_UNUSED)
{
  return (insn & 0xfff0) >> 4;
}
static long
extract_des (unsigned long insn,
	     int dialect ATTRIBUTE_UNUSED,
	     int *invalid ATTRIBUTE_UNUSED)
{
  return (((insn >> 2) & 0x3ffc) ^ 0x2000) - 0x2000;
}
static long
extract_li (unsigned long insn,
	    int dialect ATTRIBUTE_UNUSED,
	    int *invalid ATTRIBUTE_UNUSED)
{
  return ((insn & 0x3fffffc) ^ 0x2000000) - 0x2000000;
}
static unsigned long
insert_mb6 (unsigned long insn,
	    long value,
	    int dialect ATTRIBUTE_UNUSED,
	    const char **errmsg ATTRIBUTE_UNUSED)
{
  return insn | ((value & 0x1f) << 6) | (value & 0x20);
}
static long
extract_mb6 (unsigned long insn,
	     int dialect ATTRIBUTE_UNUSED,
	     int *invalid ATTRIBUTE_UNUSED)
{
  return ((insn >> 6) & 0x1f) | (insn & 0x20);
}
static unsigned long
insert_nsi (unsigned long insn,
	    long value,
	    int dialect ATTRIBUTE_UNUSED,
	    const char **errmsg ATTRIBUTE_UNUSED)
{
  return insn | (-value & 0xffff);
}
static unsigned long
insert_rbs (unsigned long insn,
	    long value ATTRIBUTE_UNUSED,
	    int dialect ATTRIBUTE_UNUSED,
	    const char **errmsg ATTRIBUTE_UNUSED)
{
  return insn | (((insn >> 21) & 0x1f) << 11);
}
static unsigned long
insert_sh6 (unsigned long insn,
	    long value,
	    int dialect ATTRIBUTE_UNUSED,
	    const char **errmsg ATTRIBUTE_UNUSED)
{
  return insn | ((value & 0x1f) << 11) | ((value & 0x20) >> 4);
}
static long
extract_sh6 (unsigned long insn,
	     int dialect ATTRIBUTE_UNUSED,
	     int *invalid ATTRIBUTE_UNUSED)
{
  return ((insn >> 11) & 0x1f) | ((insn << 4) & 0x20);
}
static unsigned long
insert_spr (unsigned long insn,
	    long value,
	    int dialect ATTRIBUTE_UNUSED,
	    const char **errmsg ATTRIBUTE_UNUSED)
{
  return insn | ((value & 0x1f) << 16) | ((value & 0x3e0) << 6);
}
static long
extract_spr (unsigned long insn,
	     int dialect ATTRIBUTE_UNUSED,
	     int *invalid ATTRIBUTE_UNUSED)
{
  return ((insn >> 16) & 0x1f) | ((insn >> 6) & 0x3e0);
}
int xmon_write(const void *ptr, int nb)
{
	return udbg_write(ptr, nb);
}
static inline void sync(void)
{
	asm volatile("sync; isync");
}
static inline void store_inst(void *p)
{
	asm volatile ("dcbst 0,%0; sync; icbi 0,%0; isync" : : "r" (p));
}
static inline void cflush(void *p)
{
	asm volatile ("dcbf 0,%0; icbi 0,%0" : : "r" (p));
}
static inline void cinval(void *p)
{
	asm volatile ("dcbi 0,%0; icbi 0,%0" : : "r" (p));
}
static void release_output_lock(void)
{
	xmon_speaker = 0;
}
int cpus_are_in_xmon(void)
{
	return !cpus_empty(cpus_in_xmon);
}
static int
ppc_inst_dump(unsigned long adr, long count, int praddr)
{
	return generic_inst_dump(adr, count, praddr, print_insn_powerpc);
}
void
print_address(unsigned long addr)
{
	xmon_print_symbol(addr, "\t# ", "");
}
static void
flush_input(void)
{
	lineptr = NULL;
}
static void
take_input(char *str)
{
	lineptr = str;
}
int
spu_inst_dump(unsigned long adr, long count, int praddr)
{
	return generic_inst_dump(adr, count, praddr, print_insn_spu);
}
static int do_spu_cmd(void)
{
	return -1;
}
static int __init appldata_mem_init(void)
{
	return appldata_register_ops(&ops);
}
static void __exit appldata_mem_exit(void)
{
	appldata_unregister_ops(&ops);
}
static int __init appldata_net_init(void)
{
	return appldata_register_ops(&ops);
}
static void __exit appldata_net_exit(void)
{
	appldata_unregister_ops(&ops);
}
static void __exit sha1_s390_fini(void)
{
	crypto_unregister_shash(&alg);
}
static void __exit sha256_s390_fini(void)
{
	crypto_unregister_shash(&alg);
}
static inline int info_blk_hdr__size(enum diag204_format type)
{
	if (type == INFO_SIMPLE)
		return sizeof(struct info_blk_hdr);
	else /* INFO_EXT */
		return sizeof(struct x_info_blk_hdr);
}
static inline __u8 info_blk_hdr__npar(enum diag204_format type, void *hdr)
{
	if (type == INFO_SIMPLE)
		return ((struct info_blk_hdr *)hdr)->npar;
	else /* INFO_EXT */
		return ((struct x_info_blk_hdr *)hdr)->npar;
}
static inline __u8 info_blk_hdr__flags(enum diag204_format type, void *hdr)
{
	if (type == INFO_SIMPLE)
		return ((struct info_blk_hdr *)hdr)->flags;
	else /* INFO_EXT */
		return ((struct x_info_blk_hdr *)hdr)->flags;
}
static inline __u16 info_blk_hdr__pcpus(enum diag204_format type, void *hdr)
{
	if (type == INFO_SIMPLE)
		return ((struct info_blk_hdr *)hdr)->phys_cpus;
	else /* INFO_EXT */
		return ((struct x_info_blk_hdr *)hdr)->phys_cpus;
}
static inline int part_hdr__size(enum diag204_format type)
{
	if (type == INFO_SIMPLE)
		return sizeof(struct part_hdr);
	else /* INFO_EXT */
		return sizeof(struct x_part_hdr);
}
static inline __u8 part_hdr__rcpus(enum diag204_format type, void *hdr)
{
	if (type == INFO_SIMPLE)
		return ((struct part_hdr *)hdr)->cpus;
	else /* INFO_EXT */
		return ((struct x_part_hdr *)hdr)->rcpus;
}
static inline int cpu_info__size(enum diag204_format type)
{
	if (type == INFO_SIMPLE)
		return sizeof(struct cpu_info);
	else /* INFO_EXT */
		return sizeof(struct x_cpu_info);
}
static inline __u8 cpu_info__ctidx(enum diag204_format type, void *hdr)
{
	if (type == INFO_SIMPLE)
		return ((struct cpu_info *)hdr)->ctidx;
	else /* INFO_EXT */
		return ((struct x_cpu_info *)hdr)->ctidx;
}
static inline __u16 cpu_info__cpu_addr(enum diag204_format type, void *hdr)
{
	if (type == INFO_SIMPLE)
		return ((struct cpu_info *)hdr)->cpu_addr;
	else /* INFO_EXT */
		return ((struct x_cpu_info *)hdr)->cpu_addr;
}
static inline __u64 cpu_info__acc_time(enum diag204_format type, void *hdr)
{
	if (type == INFO_SIMPLE)
		return ((struct cpu_info *)hdr)->acc_time;
	else /* INFO_EXT */
		return ((struct x_cpu_info *)hdr)->acc_time;
}
static inline __u64 cpu_info__lp_time(enum diag204_format type, void *hdr)
{
	if (type == INFO_SIMPLE)
		return ((struct cpu_info *)hdr)->lp_time;
	else /* INFO_EXT */
		return ((struct x_cpu_info *)hdr)->lp_time;
}
static inline __u64 cpu_info__online_time(enum diag204_format type, void *hdr)
{
	if (type == INFO_SIMPLE)
		return 0;	/* online_time not available in simple info */
	else /* INFO_EXT */
		return ((struct x_cpu_info *)hdr)->online_time;
}
static inline int phys_hdr__size(enum diag204_format type)
{
	if (type == INFO_SIMPLE)
		return sizeof(struct phys_hdr);
	else /* INFO_EXT */
		return sizeof(struct x_phys_hdr);
}
static inline __u8 phys_hdr__cpus(enum diag204_format type, void *hdr)
{
	if (type == INFO_SIMPLE)
		return ((struct phys_hdr *)hdr)->cpus;
	else /* INFO_EXT */
		return ((struct x_phys_hdr *)hdr)->cpus;
}
static inline int phys_cpu__size(enum diag204_format type)
{
	if (type == INFO_SIMPLE)
		return sizeof(struct phys_cpu);
	else /* INFO_EXT */
		return sizeof(struct x_phys_cpu);
}
static inline __u16 phys_cpu__cpu_addr(enum diag204_format type, void *hdr)
{
	if (type == INFO_SIMPLE)
		return ((struct phys_cpu *)hdr)->cpu_addr;
	else /* INFO_EXT */
		return ((struct x_phys_cpu *)hdr)->cpu_addr;
}
static inline __u64 phys_cpu__mgm_time(enum diag204_format type, void *hdr)
{
	if (type == INFO_SIMPLE)
		return ((struct phys_cpu *)hdr)->mgm_time;
	else /* INFO_EXT */
		return ((struct x_phys_cpu *)hdr)->mgm_time;
}
static inline __u64 phys_cpu__ctidx(enum diag204_format type, void *hdr)
{
	if (type == INFO_SIMPLE)
		return ((struct phys_cpu *)hdr)->ctidx;
	else /* INFO_EXT */
		return ((struct x_phys_cpu *)hdr)->ctidx;
}
static void diag224_delete_name_table(void)
{
	kfree(diag224_cpu_names);
}
static void diag2fc_free(void *data)
{
	vfree(data);
}
static inline int hypfs_positive(struct dentry *dentry)
{
	return dentry->d_inode && !d_unhashed(dentry);
}
static int hypfs_get_super(struct file_system_type *fst, int flags,
			const char *devname, void *data, struct vfsmount *mnt)
{
	return get_sb_single(fst, flags, data, hypfs_fill_super, mnt);
}
asmlinkage long sys32_chown16(const char __user * filename, u16 user, u16 group)
{
	return sys_chown(filename, low2highuid(user), low2highgid(group));
}
asmlinkage long sys32_lchown16(const char __user * filename, u16 user, u16 group)
{
	return sys_lchown(filename, low2highuid(user), low2highgid(group));
}
asmlinkage long sys32_fchown16(unsigned int fd, u16 user, u16 group)
{
	return sys_fchown(fd, low2highuid(user), low2highgid(group));
}
asmlinkage long sys32_setregid16(u16 rgid, u16 egid)
{
	return sys_setregid(low2highgid(rgid), low2highgid(egid));
}
asmlinkage long sys32_setgid16(u16 gid)
{
	return sys_setgid((gid_t)gid);
}
asmlinkage long sys32_setreuid16(u16 ruid, u16 euid)
{
	return sys_setreuid(low2highuid(ruid), low2highuid(euid));
}
asmlinkage long sys32_setuid16(u16 uid)
{
	return sys_setuid((uid_t)uid);
}
asmlinkage long sys32_setresuid16(u16 ruid, u16 euid, u16 suid)
{
	return sys_setresuid(low2highuid(ruid), low2highuid(euid),
		low2highuid(suid));
}
asmlinkage long sys32_setresgid16(u16 rgid, u16 egid, u16 sgid)
{
	return sys_setresgid(low2highgid(rgid), low2highgid(egid),
		low2highgid(sgid));
}
asmlinkage long sys32_setfsuid16(u16 uid)
{
	return sys_setfsuid((uid_t)uid);
}
asmlinkage long sys32_setfsgid16(u16 gid)
{
	return sys_setfsgid((gid_t)gid);
}
asmlinkage long sys32_getuid16(void)
{
	return high2lowuid(current->cred->uid);
}
asmlinkage long sys32_geteuid16(void)
{
	return high2lowuid(current->cred->euid);
}
asmlinkage long sys32_getgid16(void)
{
	return high2lowgid(current->cred->gid);
}
asmlinkage long sys32_getegid16(void)
{
	return high2lowgid(current->cred->egid);
}
asmlinkage long sys32_truncate64(const char __user * path, unsigned long high, unsigned long low)
{
	if ((int)high < 0)
		return -EINVAL;
	else
		return sys_truncate(path, (high << 32) | low);
}
asmlinkage long sys32_ftruncate64(unsigned int fd, unsigned long high, unsigned long low)
{
	if ((int)high < 0)
		return -EINVAL;
	else
		return sys_ftruncate(fd, (high << 32) | low);
}
asmlinkage long
sys32_init_module(void __user *umod, unsigned long len,
		const char __user *uargs)
{
	return sys_init_module(umod, len, uargs);
}
asmlinkage long
sys32_delete_module(const char __user *name_user, unsigned int flags)
{
	return sys_delete_module(name_user, flags);
}
asmlinkage long
sys32_init_module(void __user *umod, unsigned long len,
		const char __user *uargs)
{
	return -ENOSYS;
}
asmlinkage long
sys32_delete_module(const char __user *name_user, unsigned int flags)
{
	return -ENOSYS;
}
asmlinkage compat_ssize_t sys32_readahead(int fd, u32 offhi, u32 offlo, s32 count)
{
	return sys_readahead(fd, ((loff_t)AA(offhi) << 32) | AA(offlo), count);
}
static inline int map_signal(int sig)
{
	if (current_thread_info()->exec_domain
	    && current_thread_info()->exec_domain->signal_invmap
	    && sig < 32)
		return current_thread_info()->exec_domain->signal_invmap[sig];
        else
		return sig;
}
debug_info_t *debug_register(const char *name, int pages_per_area,
			     int nr_areas, int buf_size)
{
	return debug_register_mode(name, pages_per_area, nr_areas, buf_size,
				   S_IRUSR | S_IWUSR, 0, 0);
}
static inline debug_entry_t*
get_active_entry(debug_info_t * id)
{
	return (debug_entry_t *) (((char *) id->areas[id->active_area]
					[id->active_pages[id->active_area]]) +
					id->active_entries[id->active_area]);
}
static int
s390dbf_procactive(ctl_table *table, int write, struct file *filp,
                     void __user *buffer, size_t *lenp, loff_t *ppos)
{
	if (!write || debug_stoppable || !debug_active)
		return proc_dointvec(table, write, filp, buffer, lenp, ppos);
	else
		return 0;
}
static int
debug_prolog_pages_fn(debug_info_t * id,
				 struct debug_view *view, char *out_buf)
{
	return sprintf(out_buf, "%i\n", id->pages_per_area);
}
static inline int insn_length(unsigned char code)
{
	return ((((int) code + 64) >> 7) + 1) << 1;
}
static noinline __init void clear_bss_section(void)
{
	memset(__bss_start, 0, __bss_stop - __bss_start);
}
static ssize_t ipl_type_show(struct kobject *kobj, struct kobj_attribute *attr,
			     char *page)
{
	return sprintf(page, "%s\n", ipl_type_str(ipl_info.type));
}
static ssize_t ipl_parameter_read(struct kobject *kobj, struct bin_attribute *attr,
				  char *buf, loff_t off, size_t count)
{
	return memory_read_from_buffer(buf, count, &off, IPL_PARMBLOCK_START,
					IPL_PARMBLOCK_SIZE);
}
static ssize_t reipl_nss_vmparm_show(struct kobject *kobj,
				     struct kobj_attribute *attr, char *page)
{
	return reipl_generic_vmparm_show(reipl_block_nss, page);
}
static ssize_t reipl_nss_vmparm_store(struct kobject *kobj,
				      struct kobj_attribute *attr,
				      const char *buf, size_t len)
{
	return reipl_generic_vmparm_store(reipl_block_nss, 56, buf, len);
}
static ssize_t reipl_ccw_vmparm_show(struct kobject *kobj,
				     struct kobj_attribute *attr, char *page)
{
	return reipl_generic_vmparm_show(reipl_block_ccw, page);
}
static ssize_t reipl_ccw_vmparm_store(struct kobject *kobj,
				      struct kobj_attribute *attr,
				      const char *buf, size_t len)
{
	return reipl_generic_vmparm_store(reipl_block_ccw, 64, buf, len);
}
static ssize_t reipl_nss_loadparm_show(struct kobject *kobj,
				       struct kobj_attribute *attr, char *page)
{
	return reipl_generic_loadparm_show(reipl_block_nss, page);
}
static ssize_t reipl_nss_loadparm_store(struct kobject *kobj,
					struct kobj_attribute *attr,
					const char *buf, size_t len)
{
	return reipl_generic_loadparm_store(reipl_block_nss, buf, len);
}
static ssize_t reipl_ccw_loadparm_show(struct kobject *kobj,
				       struct kobj_attribute *attr, char *page)
{
	return reipl_generic_loadparm_show(reipl_block_ccw, page);
}
static ssize_t reipl_ccw_loadparm_store(struct kobject *kobj,
					struct kobj_attribute *attr,
					const char *buf, size_t len)
{
	return reipl_generic_loadparm_store(reipl_block_ccw, buf, len);
}
static ssize_t reipl_type_show(struct kobject *kobj,
			       struct kobj_attribute *attr, char *page)
{
	return sprintf(page, "%s\n", ipl_type_str(reipl_type));
}
static ssize_t dump_type_show(struct kobject *kobj,
			      struct kobj_attribute *attr, char *page)
{
	return sprintf(page, "%s\n", dump_type_str(dump_type));
}
static int __init dump_reipl_init(void)
{
	if (!diag308_set_works)
		return -EOPNOTSUPP;
	else
		return 0;
}
static ssize_t on_reboot_show(struct kobject *kobj,
			      struct kobj_attribute *attr, char *page)
{
	return sprintf(page, "%s\n", on_reboot_trigger.action->name);
}
static ssize_t on_reboot_store(struct kobject *kobj,
			       struct kobj_attribute *attr,
			       const char *buf, size_t len)
{
	return set_trigger(buf, &on_reboot_trigger, len);
}
static ssize_t on_panic_show(struct kobject *kobj,
			     struct kobj_attribute *attr, char *page)
{
	return sprintf(page, "%s\n", on_panic_trigger.action->name);
}
static ssize_t on_panic_store(struct kobject *kobj,
			      struct kobj_attribute *attr,
			      const char *buf, size_t len)
{
	return set_trigger(buf, &on_panic_trigger, len);
}
static ssize_t on_halt_show(struct kobject *kobj,
			    struct kobj_attribute *attr, char *page)
{
	return sprintf(page, "%s\n", on_halt_trigger.action->name);
}
static ssize_t on_halt_store(struct kobject *kobj,
			     struct kobj_attribute *attr,
			     const char *buf, size_t len)
{
	return set_trigger(buf, &on_halt_trigger, len);
}
static ssize_t on_poff_show(struct kobject *kobj,
			    struct kobj_attribute *attr, char *page)
{
	return sprintf(page, "%s\n", on_poff_trigger.action->name);
}
static ssize_t on_poff_store(struct kobject *kobj,
			     struct kobj_attribute *attr,
			     const char *buf, size_t len)
{
	return set_trigger(buf, &on_poff_trigger, len);
}
static void __used kretprobe_trampoline_holder(void)
{
	asm volatile(".global kretprobe_trampoline\n"
		     "kretprobe_trampoline: bcr 0,0\n");
}
void __kprobes jprobe_return(void)
{
	asm volatile(".word 0x0002");
}
void __kprobes jprobe_return_end(void)
{
	asm volatile("bcr 0,0");
}
int __init arch_init_kprobes(void)
{
	return register_kprobe(&trampoline_p);
}
void module_free(struct module *mod, void *module_region)
{
	vfree(module_region);
}
void module_arch_cleanup(struct module *mod)
{
	module_bug_cleanup(mod);
}
void __cpuinit print_cpu_info(struct cpuinfo_S390 *cpuinfo)
{
	pr_info("Processor %d started, address %d, identification %06X\n",
		cpuinfo->cpu_nr, cpuinfo->cpu_addr, cpuinfo->cpu_id.ident);
}
static void *c_start(struct seq_file *m, loff_t *pos)
{
	return *pos < NR_CPUS ? (void *)((unsigned long) *pos + 1) : NULL;
}
void
ptrace_disable(struct task_struct *child)
{
	user_disable_single_step(child);
}
static inline int ext_hash(__u16 code)
{
	return (code + (code >> 9)) & 0xff;
}
static inline int set_amode_and_uaccess(unsigned long user_amode,
					unsigned long user32_amode)
{
	return 0;
}
static inline int map_signal(int sig)
{
	if (current_thread_info()->exec_domain
	    && current_thread_info()->exec_domain->signal_invmap
	    && sig < 32)
		return current_thread_info()->exec_domain->signal_invmap[sig];
	else
		return sig;
}
void arch_send_call_function_single_ipi(int cpu)
{
	smp_ext_bitcall(cpu, ec_call_function_single);
}
static void smp_ptlb_callback(void *info)
{
	__tlb_flush_local();
}
void smp_ptlb_all(void)
{
	on_each_cpu(smp_ptlb_callback, NULL, 1);
}
void smp_send_reschedule(int cpu)
{
	smp_ext_bitcall(cpu, ec_schedule);
}
int setup_profiling_timer(unsigned int multiplier)
{
	return 0;
}
static ssize_t show_cpu_address(struct sys_device *dev,
				struct sysdev_attribute *attr, char *buf)
{
	return sprintf(buf, "%d\n", __cpu_logical_map[dev->id]);
}
asmlinkage long SyS_s390_fallocate(long fd, long mode, loff_t offset,
				   long len_high, long len_low)
{
	return SYSC_s390_fallocate((int) fd, (int) mode, offset,
				   (u32) len_high, (u32) len_low);
}
static void *service_level_next(struct seq_file *m, void *p, loff_t *pos)
{
	return seq_list_next(p, &service_level_list, pos);
}
static void service_level_stop(struct seq_file *m, void *p)
{
	up_read(&service_level_sem);
}
static int service_level_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &service_level_seq_ops);
}
unsigned long long sched_clock(void)
{
	return ((get_clock_xt() - sched_clock_base_cc) * 125) >> 9;
}
unsigned long long monotonic_clock(void)
{
	return sched_clock();
}
static cycle_t read_tod_clock(void)
{
	return get_clock();
}
static inline int etr_mode_is_pps(struct etr_eacr eacr)
{
	return eacr.es && !eacr.sl;
}
static inline int etr_mode_is_etr(struct etr_eacr eacr)
{
	return eacr.es && eacr.sl;
}
static int etr_compare_network(struct etr_aib *aib1, struct etr_aib *aib2)
{
	return aib1->edf1.net_id == aib2->edf1.net_id;
}
static void etr_set_sync_timeout(void)
{
	mod_timer(&etr_timer, jiffies + HZ/2);
}
static ssize_t etr_stepping_port_show(struct sysdev_class *class, char *buf)
{
	return sprintf(buf, "%i\n", etr_port0.esw.p);
}
static inline struct etr_aib *etr_aib_from_dev(struct sys_device *dev)
{
	if (dev == &etr_port0_dev)
		return etr_port0_online ? &etr_port0 : NULL;
	else
		return etr_port1_online ? &etr_port1 : NULL;
}
static ssize_t etr_stepping_control_show(struct sys_device *dev,
					struct sysdev_attribute *attr,
					char *buf)
{
	return sprintf(buf, "%i\n", (dev == &etr_port0_dev) ?
		       etr_eacr.e0 : etr_eacr.e1);
}
static ssize_t stp_online_show(struct sysdev_class *class, char *buf)
{
	return sprintf(buf, "%i\n", stp_online);
}
const struct cpumask *cpu_coregroup_mask(unsigned int cpu)
{
	return &cpu_core_map[cpu];
}
static union tl_entry *next_tle(union tl_entry *tle)
{
	if (tle->nl)
		return (union tl_entry *)((struct tl_container *)tle + 1);
	else
		return (union tl_entry *)((struct tl_cpu *)tle + 1);
}
static void topology_work_fn(struct work_struct *work)
{
	rebuild_sched_domains();
}
void topology_schedule_update(void)
{
	schedule_work(&topology_work);
}
static inline int mask_bits(struct pt_regs *regs, unsigned long bits)
{
	return (regs->psw.mask & bits) / ((~bits + 1) & bits);
}
int is_valid_bugaddr(unsigned long addr)
{
	return 1;
}
static inline void __user *get_check_address(struct pt_regs *regs)
{
	return (void __user *)((regs->psw.addr-S390_lowcore.pgm_ilc) & PSW_ADDR_INSN);
}
int in_gate_area_no_task(unsigned long addr)
{
	return 0;
}
int in_gate_area(struct task_struct *task, unsigned long addr)
{
	return 0;
}
struct vm_area_struct *get_gate_vma(struct task_struct *tsk)
{
	return NULL;
}
void account_process_tick(struct task_struct *tsk, int user_tick)
{
	do_account_vtime(tsk, HARDIRQ_OFFSET);
}
static inline int vtimer_pending(struct vtimer_list *timer)
{
	return (!list_empty(&timer->entry));
}
static int psw_extint_disabled(struct kvm_vcpu *vcpu)
{
	return !(vcpu->arch.sie_block->gpsw.mask & PSW_MASK_EXT);
}
static void __set_cpuflag(struct kvm_vcpu *vcpu, u32 flag)
{
	atomic_set_mask(flag, &vcpu->arch.sie_block->cpuflags);
}
int kvm_cpu_has_pending_timer(struct kvm_vcpu *vcpu)
{
	return 0;
}
int kvm_arch_hardware_setup(void)
{
	return 0;
}
int kvm_arch_init(void *opaque)
{
	return 0;
}
int kvm_vm_ioctl_get_dirty_log(struct kvm *kvm,
			       struct kvm_dirty_log *log)
{
	return 0;
}
int kvm_arch_vcpu_init(struct kvm_vcpu *vcpu)
{
	return 0;
}
int kvm_arch_vcpu_ioctl_translate(struct kvm_vcpu *vcpu,
				  struct kvm_translation *tr)
{
	return -EINVAL; /* not implemented yet */
}
int kvm_arch_vcpu_ioctl_set_guest_debug(struct kvm_vcpu *vcpu,
					struct kvm_guest_debug *dbg)
{
	return -EINVAL; /* not implemented yet */
}
int kvm_arch_vcpu_ioctl_get_mpstate(struct kvm_vcpu *vcpu,
				    struct kvm_mp_state *mp_state)
{
	return -EINVAL; /* not implemented yet */
}
int kvm_arch_vcpu_ioctl_set_mpstate(struct kvm_vcpu *vcpu,
				    struct kvm_mp_state *mp_state)
{
	return -EINVAL; /* not implemented yet */
}
static int __guestcopy(struct kvm_vcpu *vcpu, u64 guestdest, const void *from,
		       unsigned long n, int prefix)
{
	if (prefix)
		return copy_to_guest(vcpu, guestdest, from, n);
	else
		return copy_to_guest_absolute(vcpu, guestdest, from, n);
}
gfn_t unalias_gfn(struct kvm *kvm, gfn_t gfn)
{
	return gfn;
}
static int __init kvm_s390_init(void)
{
	return kvm_init(NULL, sizeof(struct kvm_vcpu), THIS_MODULE);
}
static void __exit kvm_s390_exit(void)
{
	kvm_exit();
}
void __delay(unsigned long loops)
{
	asm volatile("0: brct %0,0b" : : "d" ((loops/2) + 1));
}
size_t strlen(const char *s)
{
	return __strend(s) - s;
}
size_t strnlen(const char * s, size_t n)
{
	return __strnend(s, n) - s;
}
void *memcpy(void *dest, const void *src, size_t n)
{
	return __builtin_memcpy(dest, src, n);
}
static inline void emu_set_CC (struct pt_regs *regs, int cc)
{
        regs->psw.mask = (regs->psw.mask & 0xFFFFCFFF) | ((cc&3) << 12);
}
static void
cmm_kick_thread(void)
{
	wake_up(&cmm_thread_wait);
}
long
cmm_get_pages(void)
{
	return cmm_pages;
}
long
cmm_get_timed_pages(void)
{
	return cmm_timed_pages;
}
static inline int notify_page_fault(struct pt_regs *regs, long err)
{
	return 0;
}
void __kprobes do_dat_exception(struct pt_regs *regs, long error_code)
{
	do_exception(regs, error_code & 0xff, 0);
}
int huge_pmd_unshare(struct mm_struct *mm, unsigned long *addr, pte_t *ptep)
{
	return 0;
}
struct page *follow_huge_addr(struct mm_struct *mm, unsigned long address,
			      int write)
{
	return ERR_PTR(-EINVAL);
}
int pud_huge(pud_t pud)
{
	return 0;
}
static void remove_memory_segment(struct memory_segment *seg)
{
	list_del(&seg->list);
}
static void sh7785lcr_power_off(void)
{
	ctrl_outb(0x01, P2SEGADDR(PLD_POFCR));
}
static void __init shmin_setup(char **cmdline_p)
{
	__set_io_port_base(SHMIN_IO_BASE);
}
static void ack_cayman_irq(unsigned int irq)
{
	disable_cayman_irq(irq);
}
static void __init sh_edosk7705_init_irq(void)
{
	make_imask_irq(0x09);
}
static int __init psw_init(void)
{
	return platform_add_devices(psw_devices, ARRAY_SIZE(psw_devices));
}
static void ivdr_clk_enable(struct clk *clk)
{
	ctrl_outw(ctrl_inw(PA_IVDRCTL) | (1 << IVDR_CK_ON), PA_IVDRCTL);
}
static void ivdr_clk_disable(struct clk *clk)
{
	ctrl_outw(ctrl_inw(PA_IVDRCTL) & ~(1 << IVDR_CK_ON), PA_IVDRCTL);
}
static void __exit hp6x0_apm_exit(void)
{
	free_irq(HP680_BTN_IRQ, 0);
}
static void __init hp6xx_init_irq(void)
{
	plat_irq_setup_pins(IRQ_MODE_IRQ);
}
static int __init hp6xx_devices_setup(void)
{
	return platform_add_devices(hp6xx_devices, ARRAY_SIZE(hp6xx_devices));
}
static int __init psw_init(void)
{
	return platform_add_devices(psw_devices, ARRAY_SIZE(psw_devices));
}
static void landisk_power_off(void)
{
        ctrl_outb(0x01, PA_SHUTDOWN);
}
static void mask_and_ack_microdev(unsigned int irq)
{
	disable_microdev_irq(irq);
}
static int __init microdev_devices_setup(void)
{
	return platform_add_devices(microdev_devices, ARRAY_SIZE(microdev_devices));
}
static void write_reg(void *sys_ops_handle,
		       struct sh_mobile_lcdc_sys_bus_ops *sys_ops,
		       unsigned short reg, unsigned short data)
{
	sys_ops->write_index(sys_ops_handle, adjust_reg18(reg << 8 | data));
}
static int migor_nand_flash_ready(struct mtd_info *mtd)
{
	return gpio_get_value(GPIO_PTA1); /* NAND_RBn */
}
static void rts7751r2d_power_off(void)
{
	ctrl_outw(0x0001, PA_POWOFF);
}
static int __init sdk7780_devices_setup(void)
{
	return platform_add_devices(sdk7780_devices,
		ARRAY_SIZE(sdk7780_devices));
}
static inline void delay(void)
{
	ctrl_inw(0x20000000);  /* P2 ROM Area */
}
unsigned char se7206_inb(unsigned long port)
{
	return (*port2adr(port)) & 0xff;
}
unsigned short se7206_inw(unsigned long port)
{
	return *port2adr(port);;
}
void se7206_outb(unsigned char value, unsigned long port)
{
	*(port2adr(port)) = value;
}
void se7206_outw(unsigned short value, unsigned long port)
{
	*port2adr(port) = value;
}
static int __init se7206_devices_setup(void)
{
	return platform_add_devices(se7206_devices, ARRAY_SIZE(se7206_devices));
}
static void isp116x_delay(struct device *dev, int delay)
{
	ndelay(delay);
}
static int __init sh7343se_devices_setup(void)
{
	return platform_add_devices(sh7343se_platform_devices,
				    ARRAY_SIZE(sh7343se_platform_devices));
}
static inline int
shifted_port(unsigned long port)
{
	if ((0x1f0 <= port && port < 0x1f8) || port == 0x3f6)
		return 0;
	else
		return 1;
}
unsigned char se_inb(unsigned long port)
{
	if (shifted_port(port))
		return (*port2adr(port) >> 8);
	else
		return (*port2adr(port))&0xff;
}
void se_outl(unsigned int value, unsigned long port)
{
	maybebadio(port);
}
void se_insl(unsigned long port, void *addr, unsigned long count)
{
	maybebadio(port);
}
void se_outsl(unsigned long port, const void *addr, unsigned long count)
{
	maybebadio(port);
}
unsigned char sh7751se_inb(unsigned long port)
{
	if (PXSEG(port))
		return *(volatile unsigned char *)port;
	else if (is_pci_ioaddr(port))
		return *(volatile unsigned char *)pci_ioaddr(port);
	else
		return (*port2adr(port)) & 0xff;
}
void sh7751se_insl(unsigned long port, void *addr, unsigned long count)
{
	maybebadio(port);
}
void sh7751se_outsl(unsigned long port, const void *addr, unsigned long count)
{
	maybebadio(port);
}
void __init init_7751se_IRQ(void)
{
	register_ipr_controller(&ipr_irq_desc);
}
static int __init se7751_devices_setup(void)
{
	return platform_add_devices(se7751_devices, ARRAY_SIZE(se7751_devices));
}
static int __init se7780_devices_setup(void)
{
	return platform_add_devices(se7780_devices,
		ARRAY_SIZE(se7780_devices));
}
static void __init init_sh03_IRQ(void)
{
	plat_irq_setup_pins(IRQ_MODE_IRQ);
}
static void __init sh03_setup(char **cmdline_p)
{
	board_time_init = sh03_time_init;
}
static int __init sh7763rdp_devices_setup(void)
{
	return platform_add_devices(sh7763rdp_devices,
				    ARRAY_SIZE(sh7763rdp_devices));
}
unsigned char snapgear_inb(unsigned long port)
{
	if (PXSEG(port))
		return *(volatile unsigned char *)port;
	else if (is_pci_ioaddr(port))
		return *(volatile unsigned char *)pci_ioaddr(port);
	else
		return (*port2adr(port)) & 0xff;
}
void snapgear_insl(unsigned long port, void *addr, unsigned long count)
{
	maybebadio(port);
}
void snapgear_outsl(unsigned long port, const void *addr, unsigned long count)
{
	maybebadio(port);
}
unsigned char sh7751systemh_inb(unsigned long port)
{
	if (PXSEG(port))
		return *(volatile unsigned char *)port;
	else if (is_pci_ioaddr(port))
		return *(volatile unsigned char *)pci_ioaddr(port);
	else if (port <= 0x3F1)
		return *(volatile unsigned char *)ETHER_IOMAP(port);
	else
		return (*port2adr(port))&0xff;
}
void sh7751systemh_insl(unsigned long port, void *addr, unsigned long count)
{
	maybebadio(port);
}
void sh7751systemh_outsl(unsigned long port, const void *addr, unsigned long count)
{
	maybebadio(port);
}
static void mask_and_ack_systemh(unsigned int irq)
{
	disable_systemh_irq(irq);
}
static void __init sh7751systemh_init_irq(void)
{
	make_systemh_irq(0xb);	/* Ethernet interrupt */
}
void titan_insl(unsigned long port, void *dst, unsigned long count)
{
        maybebadio(port);
}
void titan_outsl(unsigned long port, const void *src, unsigned long count)
{
        maybebadio(port);
}
static void __init init_titan_irq(void)
{
	plat_irq_setup_pins(IRQ_MODE_IRQ);
}
static inline unsigned int ilsel_offset(unsigned int bit)
{
	return ILSEL_LEVELS - bit - 1;
}
static inline unsigned long mk_ilsel_addr(unsigned int bit)
{
	return ILSEL_BASE + ((ilsel_offset(bit) >> 1) & ~0x1);
}
static inline unsigned int mk_ilsel_shift(unsigned int bit)
{
	return (ilsel_offset(bit) & 0x3) << 2;
}
int puts(const char *s)
{
	return 0;
}
static int g2_get_residue(struct dma_channel *chan)
{
	return g2_bytes_remaining(chan->chan);
}
static int pvr2_get_dma_residue(struct dma_channel *chan)
{
	return xfer_complete == 0;
}
static void sh_dmac_free_dma(struct dma_channel *chan)
{
	free_irq(get_dmte_irq(chan->chan), chan);
}
static inline void dmabrg_call_handler(int i)
{
	dmabrg_handlers[i].handler(dmabrg_handlers[i].data);
}
static void __exit heartbeat_exit(void)
{
	platform_driver_unregister(&heartbeat_driver);
}
int __init pcibios_map_platform_irq(struct pci_dev *dev, u8 slot, u8 pin)
{
	return GAPSPCI_IRQ;
}
int __init pcibios_init_platform(void)
{
	return sh5pci_init(__pa(memory_start),
			   __pa(memory_end) - __pa(memory_start));
}
static int gapspci_config_access(unsigned char bus, unsigned int devfn)
{
	return (bus == 0) && (devfn == 0);
}
char * __devinit pcibios_setup(char *str)
{
	return str;
}
int __init pcibios_init_platform(void)
{
	return sh7751_pcic_init(&sh7751_pci_map);
}
int __init pcibios_map_platform_irq(struct pci_dev *pdev, u8 slot, u8 pin)
{
	return lboxre2_irq_tab[slot];
}
int __init pcibios_init_platform(void)
{
	return sh7751_pcic_init(&sh7751_pci_map);
}
int __init pcibios_map_platform_irq(struct pci_dev *pdev, u8 slot, u8 pin)
{
	return irq_tab[slot];
}
int __init pcibios_init_platform(void)
{
	return sh7780_pcic_init(&sh7780_pci_map);
}
int __init pcibios_map_platform_irq(struct pci_dev *pdev, u8 slot, u8 pin)
{
	return rts7751r2d_irq_tab[slot];
}
int __init pcibios_map_platform_irq(struct pci_dev *pdev, u8 slot, u8 pin)
{
       return sdk7780_irq_tab[pin-1][slot];
}
int __init pcibios_map_platform_irq(struct pci_dev *pdev, u8 slot, u8 pin)
{
       return se7780_irq_tab[pin-1][slot];
}
int __attribute__((weak)) pci_fixup_pcic(void)
{
	return 0;
}
char * __devinit pcibios_setup(char *str)
{
	return str;
}
int __init pcibios_map_platform_irq(struct pci_dev *pdev, u8 slot, u8 pin)
{
	return irq_tab[slot];
}
int __init pcibios_init_platform(void)
{
	return sh7780_pcic_init(&sh7785_pci_map);
}
int __init pcibios_init_platform(void)
{
	return sh7751_pcic_init(&sh7751_pci_map);
}
int __init pcibios_init_platform(void)
{
	return sh7751_pcic_init(&sh7751_pci_map);
}
static int early_##rw##_config_##size(struct pci_channel *hose,		\
	int top_bus, int bus, int devfn, int offset, type value)	\
{									\
	return pci_##rw##_config_##size(				\
		fake_pci_dev(hose, top_bus, bus, devfn),		\
		offset, value);						\
}
void __devinit __weak pcibios_fixup_bus(struct pci_bus *bus)
{
	pci_read_bridge_bases(bus);
}
void __init pcibios_update_irq(struct pci_dev *dev, int irq)
{
	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq);
}
void pci_iounmap(struct pci_dev *dev, void __iomem *addr)
{
	iounmap(addr);
}
static void __exit switch_exit(void)
{
	platform_driver_unregister(&switch_driver);
}
int __init superhyway_scan_bus(struct superhyway_bus *bus)
{
	return superhyway_add_devices(bus, sh4202_devices,
				      ARRAY_SIZE(sh4202_devices));
}
unsigned long clk_get_rate(struct clk *clk)
{
	return clk->rate;
}
int clk_set_rate(struct clk *clk, unsigned long rate)
{
	return clk_set_rate_ex(clk, rate, 0);
}
int __init __attribute__ ((weak))
arch_clk_init(void)
{
	return 0;
}
static unsigned int startup_imask_irq(unsigned int irq)
{
	return 0; /* never anything pending */
}
static void mask_and_ack_imask(unsigned int irq)
{
	disable_imask_irq(irq);
}
static void shutdown_intc_irq(unsigned int irq)
{
	disable_intc_irq(irq);
}
static void mask_and_ack_intc(unsigned int irq)
{
	disable_intc_irq(irq);
}
static void end_intc_irq(unsigned int irq)
{
	enable_intc_irq(irq);
}
int intc_irq_describe(char* p, int irq)
{
	if (irq < NR_INTC_IRQS)
		return sprintf(p, "(0x%3x)", IRQ_to_vectorN[irq]*0x20);
	else
		return 0;
}
static void master_clk_init(struct clk *clk)
{
	clk->rate *= PLL2 * pll1rate[(ctrl_inw(FREQCR) >> 8) & 7];
}
static void bus_clk_recalc(struct clk *clk)
{
	clk->rate = clk->parent->rate / pll1rate[(ctrl_inw(FREQCR) >> 8) & 7];
}
static void cpu_clk_recalc(struct clk *clk)
{
	clk->rate = clk->parent->rate;
}
static int __init sh7619_devices_setup(void)
{
	return platform_add_devices(sh7619_devices,
				    ARRAY_SIZE(sh7619_devices));
}
void __init plat_irq_setup(void)
{
	register_intc_controller(&intc_desc);
}
static void master_clk_init(struct clk *clk)
{
	clk->rate = 10000000 * PLL2 * pll1rate[(ctrl_inw(FREQCR) >> 8) & 0x0007];
}
static void master_clk_init(struct clk *clk)
{
	clk->rate *= pll1rate[(ctrl_inw(FREQCR) >> 8) & 0x0003] * PLL2 ;
}
static void cpu_clk_recalc(struct clk *clk)
{
	clk->rate = clk->parent->rate;
}
static void master_clk_init(struct clk *clk)
{
	clk->rate *= PLL2 * pll1rate[(ctrl_inw(FREQCR) >> 8) & 0x0007];
}
static void bus_clk_recalc(struct clk *clk)
{
	clk->rate = clk->parent->rate / pll1rate[(ctrl_inw(FREQCR) >> 8) & 0x0007];
}
static int __init plat_pinmux_setup(void)
{
	return register_pinmux(&sh7203_pinmux_info);
}
static int __init mxg_devices_setup(void)
{
	return platform_add_devices(mxg_devices,
				    ARRAY_SIZE(mxg_devices));
}
void __init plat_irq_setup(void)
{
	register_intc_controller(&intc_desc);
}
static int __init sh7201_devices_setup(void)
{
	return platform_add_devices(sh7201_devices,
				    ARRAY_SIZE(sh7201_devices));
}
void __init plat_irq_setup(void)
{
	register_intc_controller(&intc_desc);
}
static int __init sh7203_devices_setup(void)
{
	return platform_add_devices(sh7203_devices,
				    ARRAY_SIZE(sh7203_devices));
}
void __init plat_irq_setup(void)
{
	register_intc_controller(&intc_desc);
}
static int __init sh7206_devices_setup(void)
{
	return platform_add_devices(sh7206_devices,
				    ARRAY_SIZE(sh7206_devices));
}
void __init plat_irq_setup(void)
{
	register_intc_controller(&intc_desc);
}
static void master_clk_init(struct clk *clk)
{
	clk->rate *= pfc_divisors[ctrl_inw(FRQCR) & 0x0003];
}
static void master_clk_init(struct clk *clk)
{
	clk->rate *= md_table[ctrl_inw(FRQCR) & 0x0007];
}
static int __init plat_pinmux_setup(void)
{
	return register_pinmux(&sh7720_pinmux_info);
}
void __init plat_irq_setup_sh3(void)
{
	register_intc_controller(&intc_desc_irq45);
}
static int __init sh7705_devices_setup(void)
{
	return platform_add_devices(sh7705_devices,
				    ARRAY_SIZE(sh7705_devices));
}
static int __init sh770x_devices_setup(void)
{
	return platform_add_devices(sh770x_devices,
		ARRAY_SIZE(sh770x_devices));
}
static int __init sh7710_devices_setup(void)
{
	return platform_add_devices(sh7710_devices,
				    ARRAY_SIZE(sh7710_devices));
}
static int __init sh7720_devices_setup(void)
{
	return platform_add_devices(sh7720_devices,
				    ARRAY_SIZE(sh7720_devices));
}
static void master_clk_init(struct clk *clk)
{
	clk->rate *= pfc_divisors[ctrl_inw(FRQCR) & 0x0007];
}
void float_raise(unsigned int flags)
{
	fpu_exception_flags |= flags;
}
static int __init sh4202_devices_setup(void)
{
	return platform_add_devices(sh4202_devices,
				    ARRAY_SIZE(sh4202_devices));
}
static int __init sh7750_devices_setup(void)
{
	return platform_add_devices(sh7750_devices,
				    ARRAY_SIZE(sh7750_devices));
}
static int __init sh7760_devices_setup(void)
{
	return platform_add_devices(sh7760_devices,
				    ARRAY_SIZE(sh7760_devices));
}
void __init plat_irq_setup(void)
{
	register_intc_controller(&intc_desc);
}
bits64 extractFloat64Frac(float64 a)
{
	return a & LIT64(0x000FFFFFFFFFFFFF);
}
flag extractFloat64Sign(float64 a)
{
	return a >> 63;
}
int16 extractFloat64Exp(float64 a)
{
	return (a >> 52) & 0x7FF;
}
int16 extractFloat32Exp(float32 a)
{
	return (a >> 23) & 0xFF;
}
flag extractFloat32Sign(float32 a)
{
	return a >> 31;
}
bits32 extractFloat32Frac(float32 a)
{
	return a & 0x007FFFFF;
}
float64 packFloat64(flag zSign, int16 zExp, bits64 zSig)
{
	return (((bits64) zSign) << 63) + (((bits64) zExp) << 52) + zSig;
}
float32 packFloat32(flag zSign, int16 zExp, bits32 zSig)
{
	return (((bits32) zSign) << 31) + (((bits32) zExp) << 23) + zSig;
}
static void sh7722_siu_enable(struct clk *clk)
{
	sh7722_siu_start_stop(clk, 1);
}
static void sh7722_siu_disable(struct clk *clk)
{
	sh7722_siu_start_stop(clk, 0);
}
static void sh7722_mstpcr_enable(struct clk *clk)
{
	sh7722_mstpcr_start_stop(clk, 1);
}
static void sh7722_mstpcr_disable(struct clk *clk)
{
	sh7722_mstpcr_start_stop(clk, 0);
}
static void master_clk_init(struct clk *clk)
{
	clk->rate *= p0fc_divisors[(ctrl_inl(FRQCR) >> 4) & 0x07];
}
static void cpu_clk_recalc(struct clk *clk)
{
	clk->rate = clk->parent->rate;
}
static void master_clk_init(struct clk *clk)
{
	clk->rate *= pfc_divisors[(ctrl_inl(FRQCR) >> 28) & 0x000f];
}
static void master_clk_init(struct clk *clk)
{
	clk->rate *= pfc_divisors[ctrl_inl(FRQCR) & 0x0003];
}
static void master_clk_init(struct clk *clk)
{
	clk->rate *= pfc_divisors[ctrl_inl(FRQMR1) & 0x000f];
}
static void master_clk_init(struct clk *clk)
{
	clk->rate *= pfc_divisors[(ctrl_inl(FRQCR) >> PFC_POS) & PFC_MSK];
}
static int __init plat_pinmux_setup(void)
{
	return register_pinmux(&sh7722_pinmux_info);
}
static int __init plat_pinmux_setup(void)
{
	return register_pinmux(&sh7723_pinmux_info);
}
static int __init plat_pinmux_setup(void)
{
	return register_pinmux(&sh7785_pinmux_info);
}
void __init plat_irq_setup(void)
{
	register_intc_controller(&intc_desc);
}
void __init plat_irq_setup(void)
{
	register_intc_controller(&intc_desc);
}
void __init plat_irq_setup(void)
{
	register_intc_controller(&intc_desc);
}
void __init plat_mem_setup(void)
{
	setup_bootmem_node(1, 0x055f0000, 0x05610000);
}
void __init plat_irq_setup(void)
{
	register_intc_controller(&intc_desc);
}
static int __init sh7763_devices_setup(void)
{
	return platform_add_devices(sh7763_devices,
				    ARRAY_SIZE(sh7763_devices));
}
static int __init sh7770_devices_setup(void)
{
	return platform_add_devices(sh7770_devices,
				    ARRAY_SIZE(sh7770_devices));
}
static int __init sh7780_devices_setup(void)
{
	return platform_add_devices(sh7780_devices,
				    ARRAY_SIZE(sh7780_devices));
}
static int __init sh7785_devices_setup(void)
{
	return platform_add_devices(sh7785_devices,
				    ARRAY_SIZE(sh7785_devices));
}
void __init plat_mem_setup(void)
{
	setup_bootmem_node(1, 0xe55f0000, 0xe5610000);
}
static int __init shx3_devices_setup(void)
{
	return platform_add_devices(shx3_devices,
				    ARRAY_SIZE(shx3_devices));
}
void __init plat_irq_setup(void)
{
	register_intc_controller(&intc_desc);
}
int plat_smp_processor_id(void)
{
	return ctrl_inl(0xff000048); /* CPIDR */
}
void save_fpu(struct task_struct *tsk, struct pt_regs *regs)
{
	asm volatile("fst.p     %0, (0*8), fp0\n\t"
		     "fst.p     %0, (1*8), fp2\n\t"
		     "fst.p     %0, (2*8), fp4\n\t"
		     "fst.p     %0, (3*8), fp6\n\t"
		     "fst.p     %0, (4*8), fp8\n\t"
		     "fst.p     %0, (5*8), fp10\n\t"
		     "fst.p     %0, (6*8), fp12\n\t"
		     "fst.p     %0, (7*8), fp14\n\t"
		     "fst.p     %0, (8*8), fp16\n\t"
		     "fst.p     %0, (9*8), fp18\n\t"
		     "fst.p     %0, (10*8), fp20\n\t"
		     "fst.p     %0, (11*8), fp22\n\t"
		     "fst.p     %0, (12*8), fp24\n\t"
		     "fst.p     %0, (13*8), fp26\n\t"
		     "fst.p     %0, (14*8), fp28\n\t"
		     "fst.p     %0, (15*8), fp30\n\t"
		     "fst.p     %0, (16*8), fp32\n\t"
		     "fst.p     %0, (17*8), fp34\n\t"
		     "fst.p     %0, (18*8), fp36\n\t"
		     "fst.p     %0, (19*8), fp38\n\t"
		     "fst.p     %0, (20*8), fp40\n\t"
		     "fst.p     %0, (21*8), fp42\n\t"
		     "fst.p     %0, (22*8), fp44\n\t"
		     "fst.p     %0, (23*8), fp46\n\t"
		     "fst.p     %0, (24*8), fp48\n\t"
		     "fst.p     %0, (25*8), fp50\n\t"
		     "fst.p     %0, (26*8), fp52\n\t"
		     "fst.p     %0, (27*8), fp54\n\t"
		     "fst.p     %0, (28*8), fp56\n\t"
		     "fst.p     %0, (29*8), fp58\n\t"
		     "fst.p     %0, (30*8), fp60\n\t"
		     "fst.p     %0, (31*8), fp62\n\t"

		     "fgetscr   fr63\n\t"
		     "fst.s     %0, (32*8), fr63\n\t"
		: /* no output */
		: "r" (&tsk->thread.fpu.hard)
		: "memory");
}
static inline void
fpload(struct sh_fpu_hard_struct *fpregs)
{
	asm volatile("fld.p     %0, (0*8), fp0\n\t"
		     "fld.p     %0, (1*8), fp2\n\t"
		     "fld.p     %0, (2*8), fp4\n\t"
		     "fld.p     %0, (3*8), fp6\n\t"
		     "fld.p     %0, (4*8), fp8\n\t"
		     "fld.p     %0, (5*8), fp10\n\t"
		     "fld.p     %0, (6*8), fp12\n\t"
		     "fld.p     %0, (7*8), fp14\n\t"
		     "fld.p     %0, (8*8), fp16\n\t"
		     "fld.p     %0, (9*8), fp18\n\t"
		     "fld.p     %0, (10*8), fp20\n\t"
		     "fld.p     %0, (11*8), fp22\n\t"
		     "fld.p     %0, (12*8), fp24\n\t"
		     "fld.p     %0, (13*8), fp26\n\t"
		     "fld.p     %0, (14*8), fp28\n\t"
		     "fld.p     %0, (15*8), fp30\n\t"
		     "fld.p     %0, (16*8), fp32\n\t"
		     "fld.p     %0, (17*8), fp34\n\t"
		     "fld.p     %0, (18*8), fp36\n\t"
		     "fld.p     %0, (19*8), fp38\n\t"
		     "fld.p     %0, (20*8), fp40\n\t"
		     "fld.p     %0, (21*8), fp42\n\t"
		     "fld.p     %0, (22*8), fp44\n\t"
		     "fld.p     %0, (23*8), fp46\n\t"
		     "fld.p     %0, (24*8), fp48\n\t"
		     "fld.p     %0, (25*8), fp50\n\t"
		     "fld.p     %0, (26*8), fp52\n\t"
		     "fld.p     %0, (27*8), fp54\n\t"
		     "fld.p     %0, (28*8), fp56\n\t"
		     "fld.p     %0, (29*8), fp58\n\t"
		     "fld.p     %0, (30*8), fp60\n\t"

		     "fld.s     %0, (32*8), fr63\n\t"
		     "fputscr   fr63\n\t"

		     "fld.p     %0, (31*8), fp62\n\t"
		: /* no output */
		: "r" (fpregs) );
}
void fpinit(struct sh_fpu_hard_struct *fpregs)
{
	*fpregs = init_fpuregs.hard;
}
static unsigned int sh_cpufreq_get(unsigned int cpu)
{
	return (clk_get_rate(cpuclk) + 500) / 1000;
}
static void __exit sh_cpufreq_module_exit(void)
{
	cpufreq_unregister_driver(&sh_cpufreq_driver);
}
static void sh_console_write(struct console *co, const char *s,
				 unsigned count)
{
	sh_bios_console_write(s, count);
}
unsigned char *ftrace_nop_replace(void)
{
	return ftrace_nop;
}
static int is_sh_nop(unsigned char *ip)
{
	return strncmp(ip, ftrace_nop, sizeof(ftrace_nop));
}
static struct pinmux_info *chip_to_pinmux(struct gpio_chip *chip)
{
	return container_of(chip, struct pinmux_info, chip);
}
static int sh_gpio_get(struct gpio_chip *chip, unsigned offset)
{
	return sh_gpio_get_value(chip_to_pinmux(chip), offset);
}
static void sh_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
{
	sh_gpio_set_value(chip_to_pinmux(chip), offset, value);
}
void ioport_unmap(void __iomem *addr)
{
	sh_mv.mv_ioport_unmap(addr);
}
u8 generic_inb(unsigned long port)
{
	return __raw_readb(__ioport_map(port, 1));
}
u16 generic_inw(unsigned long port)
{
	return __raw_readw(__ioport_map(port, 2));
}
u32 generic_inl(unsigned long port)
{
	return __raw_readl(__ioport_map(port, 4));
}
void generic_outb(u8 b, unsigned long port)
{
	__raw_writeb(b, __ioport_map(port, 1));
}
void generic_outw(u16 b, unsigned long port)
{
	__raw_writew(b, __ioport_map(port, 2));
}
void generic_outl(u32 b, unsigned long port)
{
	__raw_writel(b, __ioport_map(port, 4));
}
void __iomem *generic_ioport_map(unsigned long addr, unsigned int size)
{
	return (void __iomem *)(addr + generic_io_base);
}
void irq_ctx_exit(int cpu)
{
	hardirq_ctx[cpu] = NULL;
}
int kgdb_arch_init(void)
{
	return 0;
}
static void __kprobes set_current_kprobe(struct kprobe *p, struct pt_regs *regs,
					 struct kprobe_ctlblk *kcb)
{
	__get_cpu_var(current_kprobe) = p;
}
static void __used kretprobe_trampoline_holder(void)
{
	asm volatile (".globl kretprobe_trampoline\n"
		      "kretprobe_trampoline:\n\t"
		      "nop\n");
}
void __kprobes jprobe_return(void)
{
	asm volatile ("trapa #0x3a\n\t" "jprobe_return_end:\n\t" "nop\n\t");
}
int machine_kexec_prepare(struct kimage *image)
{
	return 0;
}
void module_free(struct module *mod, void *module_region)
{
	vfree(module_region);
}
int module_frob_arch_sections(Elf_Ehdr *hdr,
			      Elf_Shdr *sechdrs,
			      char *secstrings,
			      struct module *mod)
{
	return 0;
}
int module_finalize(const Elf_Ehdr *hdr,
		    const Elf_Shdr *sechdrs,
		    struct module *me)
{
	return module_bug_finalize(hdr, sechdrs, me);
}
void module_arch_cleanup(struct module *mod)
{
	module_bug_cleanup(mod);
}
void machine_restart(char * __unused)
{
	asm volatile("ldc %0, sr\n\t"
		     "mov.l @%1, %0" : : "r" (0x10000000), "r" (0x80000001));
}
ATTRIB_NORET void kernel_thread_helper(void *arg, int (*fn)(void *))
{
	do_exit(fn(arg));
}
ATTRIB_NORET void kernel_thread_helper(void *arg, int (*fn)(void *))
{
	do_exit(fn(arg));
}
asmlinkage int sys_fork(unsigned long r2, unsigned long r3,
			unsigned long r4, unsigned long r5,
			unsigned long r6, unsigned long r7,
			struct pt_regs *pregs)
{
	return do_fork(SIGCHLD, pregs->regs[15], pregs, 0, 0, 0);
}
asmlinkage int sys_vfork(unsigned long r2, unsigned long r3,
			 unsigned long r4, unsigned long r5,
			 unsigned long r6, unsigned long r7,
			 struct pt_regs *pregs)
{
	return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, pregs->regs[15], pregs, 0, 0, 0);
}
void ptrace_disable(struct task_struct *child)
{
	user_disable_single_step(child);
}
static int fpregs_active(struct task_struct *target,
			 const struct user_regset *regset)
{
	return tsk_used_math(target) ? regset->n : 0;
}
const struct user_regset_view *task_user_regset_view(struct task_struct *task)
{
	return &user_sh_native_view;
}
static int fpregs_active(struct task_struct *target,
			 const struct user_regset *regset)
{
	return tsk_used_math(target) ? regset->n : 0;
}
const struct user_regset_view *task_user_regset_view(struct task_struct *task)
{
	return &user_sh64_native_view;
}
void ptrace_disable(struct task_struct *child)
{
	user_disable_single_step(child);
}
const char *get_cpu_subtype(struct sh_cpuinfo *c)
{
	return cpu_name[c->type];
}
static void *c_start(struct seq_file *m, loff_t *pos)
{
	return *pos < NR_CPUS ? cpu_data + *pos : NULL;
}
void sh_bios_console_write(const char *buf, unsigned int len)
{
	sh_bios_call(BIOS_CALL_CONSOLE_WRITE, (long)buf, (long)len, 0, 0);
}
void sh_bios_char_out(char ch)
{
	sh_bios_call(BIOS_CALL_CHAR_OUT, ch, 0, 0, 0);
}
void sh_bios_gdb_detach(void)
{
	sh_bios_call(BIOS_CALL_GDB_DETACH, 0, 0, 0, 0);
}
void sh_bios_get_node_addr(unsigned char *node_addr)
{
	sh_bios_call(BIOS_CALL_ETH_NODE_ADDR, 0, (long)node_addr, 0, 0);
}
void sh_bios_shutdown(unsigned int how)
{
	sh_bios_call(BIOS_CALL_SHUTDOWN, how, 0, 0, 0);
}
asmlinkage int
sys_sigaltstack(const stack_t __user *uss, stack_t __user *uoss,
	        unsigned long r4, unsigned long r5, unsigned long r6,
	        unsigned long r7,
	        struct pt_regs * regs)
{
	return do_sigaltstack(uss, uoss, REF_REG_SP);
}
static inline int
restore_sigcontext_fpu(struct pt_regs *regs, struct sigcontext __user *sc)
{
	return 0;
}
static inline int
setup_sigcontext_fpu(struct pt_regs *regs, struct sigcontext __user *sc)
{
	return 0;
}
void smp_send_reschedule(int cpu)
{
	plat_send_ipi(cpu, SMP_MSG_RESCHEDULE);
}
void smp_send_stop(void)
{
	smp_call_function(stop_this_cpu, 0, 0);
}
void arch_send_call_function_single_ipi(int cpu)
{
	plat_send_ipi(cpu, SMP_MSG_FUNCTION_SINGLE);
}
int setup_profiling_timer(unsigned int multiplier)
{
	return 0;
}
static void flush_tlb_all_ipi(void *info)
{
	local_flush_tlb_all();
}
void flush_tlb_all(void)
{
	on_each_cpu(flush_tlb_all_ipi, 0, 1);
}
static void flush_tlb_mm_ipi(void *mm)
{
	local_flush_tlb_mm((struct mm_struct *)mm);
}
asmlinkage long sys_mmap2(unsigned long addr, unsigned long len,
	unsigned long prot, unsigned long flags,
	unsigned long fd, unsigned long pgoff)
{
	return do_mmap2(addr, len, prot, flags, fd, pgoff);
}
asmlinkage ssize_t sys_pread_wrapper(unsigned int fd, char __user *buf,
			     size_t count, long dummy, loff_t pos)
{
	return sys_pread64(fd, buf, count, pos);
}
asmlinkage ssize_t sys_pwrite_wrapper(unsigned int fd, const char __user *buf,
			      size_t count, long dummy, loff_t pos)
{
	return sys_pwrite64(fd, buf, count, pos);
}
asmlinkage int sys_fadvise64_64_wrapper(int fd, u32 offset0, u32 offset1,
				u32 len0, u32 len1, int advice)
{
	return sys_fadvise64_64(fd, (u64)offset1 << 32 | offset0,
				(u64)len1 << 32 | len0,	advice);
}
static int null_rtc_set_time(const time_t secs)
{
	return 0;
}
static int null_rtc_set_time(const time_t secs)
{
	return 0;
}
static inline void _tmu_start(int tmu_num)
{
	ctrl_outb(ctrl_inb(TMU_012_TSTR) | (0x1<<tmu_num), TMU_012_TSTR);
}
static inline void _tmu_stop(int tmu_num)
{
	ctrl_outb(ctrl_inb(TMU_012_TSTR) & ~(0x1<<tmu_num), TMU_012_TSTR);
}
static inline unsigned long _tmu_read(int tmu_num)
{
        return ctrl_inl(TMU0_TCNT+0xC*tmu_num);
}
static cycle_t tmu_timer_read(void)
{
	return ((cycle_t)(~_tmu_read(TMU1)))<<tmus_are_scaled;
}
void dump_stack(void)
{
	show_stack(NULL, NULL);
}
asmlinkage void do_##name(unsigned long error_code, struct pt_regs *regs) \
{ \
	do_unhandled_exception(trapnr, signr, str, __stringify(name), error_code, regs, current); \
}
void show_task(unsigned long *sp)
{
	show_stack(NULL, sp);
}
void dump_stack(void)
{
	show_task(NULL);
}
struct vm_area_struct *get_gate_vma(struct task_struct *task)
{
	return NULL;
}
int in_gate_area(struct task_struct *task, unsigned long address)
{
	return 0;
}
int in_gate_area_no_task(unsigned long address)
{
	return 0;
}
void __delay(unsigned long loops)
{
	__asm__ __volatile__(
		"tst	%0, %0\n\t"
		"1:\t"
		"bf/s	1b\n\t"
		" dt	%0"
		: "=r" (loops)
		: "0" (loops)
		: "t");
}
void __udelay(unsigned long usecs)
{
	__const_udelay(usecs * 0x000010c6);  /* 2**32 / 1000000 */
}
void __ndelay(unsigned long nsecs)
{
	__const_udelay(nsecs * 0x00000005);
}
inline void __const_udelay(unsigned long xloops)
{
	__delay(xloops * (HZ * cpu_data[raw_smp_processor_id()].loops_per_jiffy));
}
void __udelay(unsigned long usecs)
{
	__const_udelay(usecs * 0x000010c6);  /* 2**32 / 1000000 */
}
void __ndelay(unsigned long nsecs)
{
	__const_udelay(nsecs * 0x00000005);
}
static int
fnop_mn(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m, int n)
{
	return -EINVAL;
}
static int fnop_n(struct sh_fpu_soft_struct *fregs, int n)
{
	return -EINVAL;
}
static int
id_fnxd(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int x, int n)
{
	return (fnxd[x])(fregs, n);
}
static int fpu_emulate(u16 code, struct sh_fpu_soft_struct *fregs, struct pt_regs *regs)
{
	if ((code & 0xf000) == 0xf000)
		return id_fnmx(fregs, regs, code);
	else
		return id_sys(fregs, regs, code);
}
static int asids_debugfs_open(struct inode *inode, struct file *file)
{
	return single_open(file, asids_seq_show, inode->i_private);
}
static int cache_debugfs_open(struct inode *inode, struct file *file)
{
	return single_open(file, cache_seq_show, inode->i_private);
}
void __init p3_cache_init(void)
{
	dtlb_cache_slot	= sh64_get_wired_dtlb_entry();
}
static void sh64_dcache_purge_all(void)
{
	sh64_dcache_purge_sets(0, cpu_data->dcache.sets);
}
void flush_cache_mm(struct mm_struct *mm)
{
	sh64_dcache_purge_all();
}
void flush_icache_range(unsigned long start, unsigned long end)
{
	__flush_wback_region((void *)start, end - start);
}
void flush_cache_mm(struct mm_struct *mm)
{
	flush_cache_all();
}
void flush_cache_range(struct vm_area_struct *vma, unsigned long start,
		       unsigned long end)
{
	flush_cache_all();
}
void flush_cache_page(struct vm_area_struct *vma, unsigned long address,
		      unsigned long pfn)
{
	__flush_dcache_page(pfn << PAGE_SHIFT);
}
void flush_icache_page(struct vm_area_struct *vma, struct page *page)
{
	__flush_purge_region(page_address(page), PAGE_SIZE);
}
static int __init memchunk_setup(char *str)
{
	return 1; /* accept anything that begins with "memchunk." */
}
int huge_pmd_unshare(struct mm_struct *mm, unsigned long *addr, pte_t *ptep)
{
	return 0;
}
struct page *follow_huge_addr(struct mm_struct *mm,
			      unsigned long address, int write)
{
	return ERR_PTR(-EINVAL);
}
int pmd_huge(pmd_t pmd)
{
	return 0;
}
int pud_huge(pud_t pud)
{
	return 0;
}
struct page *follow_huge_pmd(struct mm_struct *mm, unsigned long address,
			     pmd_t *pmd, int write)
{
	return NULL;
}
void free_thread_info(struct thread_info *ti)
{
	kmem_cache_free(thread_info_cache, ti);
}
int memory_add_physaddr_to_nid(u64 addr)
{
	return 0;
}
static void xres_free(struct xresource *xrp)
{
	xrp->xflag = 0;
}
int valid_mmap_phys_addr_range(unsigned long pfn, size_t size)
{
	return 1;
}
void copy_page(void *to, void *from)
{
	memcpy(to, from, PAGE_SIZE);
}
void clear_page(void *to)
{
	memset(to, 0, PAGE_SIZE);
}
static inline unsigned long mk_pmb_entry(unsigned int entry)
{
	return (entry & PMB_E_MASK) << PMB_E_SHIFT;
}
static inline unsigned long mk_pmb_addr(unsigned int entry)
{
	return mk_pmb_entry(entry) | PMB_ADDR;
}
static inline unsigned long mk_pmb_data(unsigned int entry)
{
	return mk_pmb_entry(entry) | PMB_DATA;
}
static int pmb_debugfs_open(struct inode *inode, struct file *file)
{
	return single_open(file, pmb_seq_show, NULL);
}
void local_flush_tlb_all(void)
{
	BUG();
}
void local_flush_tlb_mm(struct mm_struct *mm)
{
	BUG();
}
void local_flush_tlb_range(struct vm_area_struct *vma, unsigned long start,
			    unsigned long end)
{
	BUG();
}
void local_flush_tlb_page(struct vm_area_struct *vma, unsigned long page)
{
	BUG();
}
void local_flush_tlb_one(unsigned long asid, unsigned long page)
{
	BUG();
}
void local_flush_tlb_kernel_range(unsigned long start, unsigned long end)
{
	BUG();
}
void update_mmu_cache(struct vm_area_struct * vma,
		      unsigned long address, pte_t pte)
{
	BUG();
}
unsigned long long sh64_next_free_dtlb_entry(void)
{
	return cpu_data->dtlb.next;
}
static inline void print_task(struct task_struct *tsk)
{
	printk("Task pid %d\n", task_pid_nr(tsk));
}
void local_flush_tlb_kernel_range(unsigned long start, unsigned long end)
{
        flush_tlb_all();
}
static void op_sh_stop(void)
{
	on_each_cpu(model->cpu_stop, NULL, 1);
}
static u64 sh7750_read_counter(int counter)
{
	return (u64)((u64)(__raw_readl(PMCTRH(counter)) & 0xffff) << 32) |
			   __raw_readl(PMCTRL(counter));
}
static int sh7750_ppc_create_files(struct super_block *sb, struct dentry *dir)
{
	return oprofilefs_create_file(sb, dir, "count", &count_fops);
}
unsigned short ld2(char *p)
{
	return (p[0] << 8) | p[1];
}
unsigned int ld4(char *p)
{
	return (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3];
}
static inline void apc_free(struct of_device *op)
{
	of_iounmap(&op->resource[0], regs, resource_size(&op->resource[0]));
}
static int apc_release(struct inode *inode, struct file *f)
{
	return 0;
}
static int __init apc_init(void)
{
	return of_register_driver(&apc_driver, &of_bus_type);
}
int sparc64_foo(void)
{
	return 0;
}
static void __auxio_sbus_set_lte(int on)
{
	__auxio_set_bit(AUXIO_AUX1_LTE, on, 0);
}
static int __init auxio_init(void)
{
	return of_register_driver(&auxio_driver, &of_platform_bus_type);
}
int cpu_find_by_instance(int instance, int *prom_node, int *mid)
{
	return __cpu_find_by(cpu_instance_compare, (void *)instance,
			     prom_node, mid);
}
int cpu_find_by_mid(int mid, int *prom_node)
{
	return __cpu_find_by(cpu_mid_compare, (void *)mid,
			     prom_node, NULL);
}
int cpu_get_hwmid(int prom_node)
{
	return prom_getintdefault(prom_node, cpu_mid_prop(), -ENODEV);
}
void dma_sync_single_range_for_cpu(struct device *dev,
				   dma_addr_t dma_handle,
				   unsigned long offset,
				   size_t size,
				   enum dma_data_direction direction)
{
	dma_sync_single_for_cpu(dev, dma_handle+offset, size, direction);
}
void dma_sync_single_range_for_device(struct device *dev, dma_addr_t dma_handle,
				      unsigned long offset, size_t size,
				      enum dma_data_direction direction)
{
	dma_sync_single_for_device(dev, dma_handle+offset, size, direction);
}
int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
{
	return (dma_addr == DMA_ERROR_CODE);
}
int dma_get_cache_alignment(void)
{
	return 32;
}
static int dr_cpu_size_response(int ncpus)
{
	return (sizeof(struct ds_data) +
		sizeof(struct dr_cpu_tag) +
		(sizeof(struct dr_cpu_resp_entry) * ncpus));
}
void ldom_power_off(void)
{
	sun4v_mach_exit(0);
}
static void ds_conn_reset(struct ds_info *dp)
{
	printk(KERN_ERR "ds-%llu: ds_conn_reset() from %p\n",
	       dp->id, __builtin_return_address(0));
}
static int ds_remove(struct vio_dev *vdev)
{
	return 0;
}
unsigned int ebus_dma_residue(struct ebus_dma_info *p)
{
	return readl(p->regs + EBDMA_COUNT);
}
unsigned int ebus_dma_addr(struct ebus_dma_info *p)
{
	return readl(p->regs + EBDMA_ADDR);
}
unsigned char *ftrace_nop_replace(void)
{
	return (char *)&ftrace_nop;
}
static void __get_ref(struct api_info *p)
{
	p->refcnt++;
}
static void xres_free(struct xresource *xrp) {
	xrp->xflag = 0;
}
void __iomem *of_ioremap(struct resource *res, unsigned long offset,
			 unsigned long size, char *name)
{
	return _sparc_alloc_io(res->flags & 0xF,
			       res->start + offset,
			       size, name);
}
void of_iounmap(struct resource *res, void __iomem *base, unsigned long size)
{
	iounmap(base);
}
void sbus_set_sbus64(struct device *dev, int x)
{
	printk("sbus_set_sbus64: unsupported\n");
}
void sbus_unmap_single(struct device *dev, dma_addr_t ba, size_t n, int direction)
{
	mmu_release_scsi_one(dev, ba, n);
}
void sbus_unmap_sg(struct device *dev, struct scatterlist *sg, int n, int direction)
{
	mmu_release_scsi_sgl(dev, sg, n);
}
void pci_unmap_page(struct pci_dev *hwdev,
			dma_addr_t dma_address, size_t size, int direction)
{
	BUG_ON(direction == PCI_DMA_NONE);
}
void disable_irq_nosync(unsigned int irq)
{
	__disable_irq(irq);
}
void disable_irq(unsigned int irq)
{
	__disable_irq(irq);
}
void enable_irq(unsigned int irq)
{
	__enable_irq(irq);
}
unsigned long probe_irq_on(void)
{
	return 0;
}
int probe_irq_off(unsigned long mask)
{
	return 0;
}
static void bucket_clear_chain_pa(unsigned long bucket_pa)
{
	__asm__ __volatile__("stxa	%%g0, [%0] %1"
			     : /* no outputs */
			     : "r" (bucket_pa +
				    offsetof(struct ino_bucket,
					     __irq_chain_pa)),
			       "i" (ASI_PHYS_USE_EC));
}
static void bucket_set_virt_irq(unsigned long bucket_pa,
				unsigned int virt_irq)
{
	__asm__ __volatile__("stwa	%0, [%1] %2"
			     : /* no outputs */
			     : "r" (virt_irq),
			       "r" (bucket_pa +
				    offsetof(struct ino_bucket,
					     __virt_irq)),
			       "i" (ASI_PHYS_USE_EC));
}
static int irq_choose_cpu(unsigned int virt_irq)
{
	return real_hard_smp_processor_id();
}
static void sun4u_set_affinity(unsigned int virt_irq,
			       const struct cpumask *mask)
{
	sun4u_irq_enable(virt_irq);
}
static __attribute__((always_inline)) void restore_hardirq_stack(void *orig_sp)
{
	__asm__ __volatile__("mov %0, %%sp" : : "r" (orig_sp));
}
int kgdb_arch_init(void)
{
	return 0;
}
int kgdb_arch_init(void)
{
	return 0;
}
void kretprobe_trampoline_holder(void)
{
	asm volatile(".global kretprobe_trampoline\n"
		     "kretprobe_trampoline:\n"
		     "\tnop\n"
		     "\tnop\n");
}
int __init arch_init_kprobes(void)
{
	return register_kprobe(&trampoline_p);
}
static int led_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, led_proc_show, NULL);
}
static void mdesc_free(struct mdesc_handle *hp)
{
	hp->mops->free(hp);
}
static struct mdesc_elem *node_block(struct mdesc_hdr *mdesc)
{
	return (struct mdesc_elem *) (mdesc + 1);
}
static void *name_block(struct mdesc_hdr *mdesc)
{
	return ((void *) node_block(mdesc)) + mdesc->node_sz;
}
static void *data_block(struct mdesc_hdr *mdesc)
{
	return ((void *) name_block(mdesc)) + mdesc->name_sz;
}
static int __init mdesc_misc_init(void)
{
	return misc_register(&mdesc_misc);
}
static char *dot2underscore(char *name)
{
	return name;
}
static void *module_map(unsigned long size)
{
	return vmalloc(size);
}
void module_free(struct module *mod, void *module_region)
{
	vfree(module_region);
}
int module_finalize(const Elf_Ehdr *hdr,
                    const Elf_Shdr *sechdrs,
                    struct module *me)
{
        return 0;
}
static inline int has_imm13(int insn)
{
	return (insn & 0x2000);
}
static inline int is_foocc(int insn)
{
	return (insn & 0x800000);
}
static inline int sign_extend_imm13(int imm)
{
	return imm << 19 >> 19;
}
static inline unsigned int get_nmi_count(int cpu)
{
	return cpu_data(cpu).__nmi_count;
}
static void stop_watchdog(void *unused)
{
	pcr_ops->write(PCR_PIC_PRIV);
}
static void of_bus_default_count_cells(struct device_node *dev,
				       int *addrc, int *sizec)
{
	get_cells(dev, addrc, sizec);
}
static int of_bus_sbus_match(struct device_node *np)
{
	return !strcmp(np->name, "sbus") ||
		!strcmp(np->name, "sbi");
}
static int of_bus_sbus_map(u32 *addr, const u32 *range, int na, int ns, int pna)
{
	return of_bus_default_map(addr, range, na, ns, pna);
}
static unsigned long of_bus_sbus_get_flags(const u32 *addr, unsigned long flags)
{
	return IORESOURCE_MEM;
}
static void of_bus_default_count_cells(struct device_node *dev,
				       int *addrc, int *sizec)
{
	get_cells(dev, addrc, sizec);
}
static int of_bus_simba_map(u32 *addr, const u32 *range,
			    int na, int ns, int pna)
{
	return 0;
}
static int of_bus_sbus_match(struct device_node *np)
{
	return !strcmp(np->name, "sbus") ||
		!strcmp(np->name, "sbi");
}
static int of_bus_fhc_match(struct device_node *np)
{
	return !strcmp(np->name, "fhc") ||
		!strcmp(np->name, "central");
}
char * __devinit pcibios_setup(char *str)
{
	return str;
}
static void __pci_mmap_set_flags(struct pci_dev *dev, struct vm_area_struct *vma,
					    enum pci_mmap_state mmap_state)
{
	vma->vm_flags |= (VM_IO | VM_RESERVED);
}
struct device_node *pci_device_to_OF_node(struct pci_dev *pdev)
{
	return pdev->dev.archdata.prom_node;
}
static void pci_fire_msi_init(struct pci_pbm_info *pbm)
{
	sparc64_pbm_msi_init(pbm, &pci_fire_msiq_ops);
}
static int __init fire_init(void)
{
	return of_register_driver(&fire_driver, &of_bus_type);
}
static int __init psycho_init(void)
{
	return of_register_driver(&psycho_driver, &of_bus_type);
}
static int __init sabre_init(void)
{
	return of_register_driver(&sabre_driver, &of_bus_type);
}
static int __devinit schizo_probe(struct of_device *op,
				  const struct of_device_id *match)
{
	return __schizo_init(op, (unsigned long) match->data);
}
static int __init schizo_init(void)
{
	return of_register_driver(&schizo_driver, &of_bus_type);
}
static void pci_sun4v_msi_init(struct pci_pbm_info *pbm)
{
	sparc64_pbm_msi_init(pbm, &pci_sun4v_msiq_ops);
}
static int __init pci_sun4v_init(void)
{
	return of_register_driver(&pci_sun4v_driver, &of_bus_type);
}
int pcic_present(void)
{
	return pcic0_up;
}
static inline struct pcidev_cookie *pci_devcookie_alloc(void)
{
	return kmalloc(sizeof(struct pcidev_cookie), GFP_ATOMIC);
}
static void pcic_clear_clock_irq(void)
{
	pcic_timer_dummy = readl(pcic0.pcic_regs+PCI_SYS_LIMIT);
}
char * __devinit pcibios_setup(char *str)
{
	return str;
}
int pcibios_enable_device(struct pci_dev *pdev, int mask)
{
	return 0;
}
static inline unsigned long get_irqmask(int irq_nr)
{
	return 1 << irq_nr;
}
static void pcic_load_profile_irq(int cpu, unsigned int limit)
{
	printk("PCIC: unimplemented code: FILE=%s LINE=%d", __FILE__, __LINE__);
}
static void pcic_disable_pil_irq(unsigned int pil)
{
	writel(get_irqmask(pil), pcic0.pcic_regs+PCI_SYS_INT_TARGET_MASK_SET);
}
static void pcic_enable_pil_irq(unsigned int pil)
{
	writel(get_irqmask(pil), pcic0.pcic_regs+PCI_SYS_INT_TARGET_MASK_CLEAR);
}
int pcibios_assign_resource(struct pci_dev *pdev, int resource)
{
	return -ENXIO;
}
void deferred_pcr_work_irq(int irq, struct pt_regs *regs)
{
	clear_softint(1 << PIL_DEFERRED_PCR_WORK);
}
void schedule_deferred_pcr_work(void)
{
	set_softint(1 << PIL_DEFERRED_PCR_WORK);
}
static void direct_pcr_write(u64 val)
{
	write_pcr(val);
}
static int __init pmc_init(void)
{
	return of_register_driver(&pmc_driver, &of_bus_type);
}
static int __init power_init(void)
{
	return of_register_driver(&power_driver, &of_platform_bus_type);
}
static void sysrq_handle_globreg(int key, struct tty_struct *tty)
{
	__trigger_all_cpu_backtrace();
}
static int __init sparc_globreg_init(void)
{
	return register_sysrq_key('y', &sparc_globalreg_op);
}
static const char *get_mid_prop(void)
{
	return (tlb_type == spitfire ? "upa-portid" : "portid");
}
static unsigned long schizo_imap_offset(unsigned long ino)
{
	return SCHIZO_IMAP_BASE + (ino * 8UL);
}
static unsigned long schizo_iclr_offset(unsigned long ino)
{
	return SCHIZO_ICLR_BASE + (ino * 8UL);
}
static unsigned long schizo_ino_to_iclr(unsigned long pbm_regs,
					unsigned int ino)
{
	return pbm_regs + schizo_iclr_offset(ino);
}
static unsigned long schizo_ino_to_imap(unsigned long pbm_regs,
					unsigned int ino)
{
	return pbm_regs + schizo_imap_offset(ino);
}
static void __init schizo_irq_trans_init(struct device_node *dp)
{
	__schizo_irq_trans_init(dp, 0);
}
static void __init tomatillo_irq_trans_init(struct device_node *dp)
{
	__schizo_irq_trans_init(dp, 1);
}
static unsigned long fire_imap_offset(unsigned long ino)
{
	return FIRE_IMAP_BASE + (ino * 8UL);
}
static unsigned long fire_iclr_offset(unsigned long ino)
{
	return FIRE_ICLR_BASE + (ino * 8UL);
}
static unsigned long fire_ino_to_iclr(unsigned long pbm_regs,
					    unsigned int ino)
{
	return pbm_regs + fire_iclr_offset(ino);
}
static unsigned long fire_ino_to_imap(unsigned long pbm_regs,
					    unsigned int ino)
{
	return pbm_regs + fire_imap_offset(ino);
}
const struct user_regset_view *task_user_regset_view(struct task_struct *task)
{
	return &user_sparc32_view;
}
asmlinkage int sys_sigsuspend(old_sigset_t set)
{
	return _sigpause_common(set);
}
asmlinkage long sys_sigpause(unsigned int set)
{
	return _sigpause_common(set);
}
asmlinkage long sys_sigsuspend(old_sigset_t set)
{
	return _sigpause_common(set);
}
void smp_reschedule_irq(void)
{
	set_need_resched();
}
static void smp_cross_call(unsigned long *func, u32 ctx, u64 data1, u64 data2)
{
	smp_cross_call_masked(func, ctx, data1, data2, &cpu_online_map);
}
static void smp_start_sync_tick_client(int cpu)
{
	xcall_deliver((u64) &xcall_sync_tick, 0, 0,
		      &cpumask_of_cpu(cpu));
}
void arch_send_call_function_ipi(cpumask_t mask)
{
	xcall_deliver((u64) &xcall_call_function, 0, 0, &mask);
}
void arch_send_call_function_single_ipi(int cpu)
{
	xcall_deliver((u64) &xcall_call_function_single, 0, 0,
		      &cpumask_of_cpu(cpu));
}
void smp_tsb_sync(struct mm_struct *mm)
{
	smp_call_function_mask(mm->cpu_vm_mask, tsb_sync, mm, 1);
}
void smp_new_mmu_context_version(void)
{
	smp_cross_call(&xcall_new_mmu_context_version, 0, 0, 0);
}
void kgdb_roundup_cpus(unsigned long flags)
{
	smp_cross_call(&xcall_kgdb_capture, 0, 0, 0);
}
void smp_fetch_global_regs(void)
{
	smp_cross_call(&xcall_fetch_glob_regs, 0, 0, 0);
}
int setup_profiling_timer(unsigned int multiplier)
{
	return -EINVAL;
}
void smp_send_reschedule(int cpu)
{
	xcall_deliver((u64) &xcall_receive_signal, 0, 0,
		      &cpumask_of_cpu(cpu));
}
void smp_receive_signal_client(int irq, struct pt_regs *regs)
{
	clear_softint(1 << irq);
}
void save_stack_trace(struct stack_trace *trace)
{
	__save_stack_trace(current_thread_info(), trace, false);
}
int starfire_hard_smp_processor_id(void)
{
	return upa_readl(0x1fff40000d0UL);
}
static void sun4c_clear_clock_irq(void)
{
	sbus_readl(&sun4c_timers->l10_limit);
}
static void sun4d_set_cpu_int(int cpu, int level)
{
	sun4d_send_ipi(cpu, level);
}
static void sun4d_clear_clock_irq(void)
{
	sbus_readl(&sun4d_timers->l10_timer_limit);
}
static void sun4d_load_profile_irq(int cpu, unsigned int limit)
{
	bw_set_prof_limit(cpu, limit);
}
static void sun4m_disable_pil_irq(unsigned int pil)
{
	sbus_writel(cpu_pil_to_imask[pil], &sun4m_irq_global->mask_set);
}
static void sun4m_enable_pil_irq(unsigned int pil)
{
	sbus_writel(cpu_pil_to_imask[pil], &sun4m_irq_global->mask_clear);
}
static void sun4m_set_udt(int cpu)
{
	sbus_writel(cpu, &sun4m_irq_global->interrupt_target);
}
static void sun4m_clear_clock_irq(void)
{
	sbus_readl(&timers_global->l10_limit);
}
void sun4m_clear_profile_irq(int cpu)
{
	sbus_readl(&timers_percpu[cpu]->l14_limit);
}
static void sun4m_load_profile_irq(int cpu, unsigned int limit)
{
	sbus_writel(limit, &timers_percpu[cpu]->l14_limit);
}
asmlinkage long sys32_truncate64(const char __user * path, unsigned long high, unsigned long low)
{
	if ((int)high < 0)
		return -EINVAL;
	else
		return sys_truncate(path, (high << 32) | low);
}
asmlinkage long sys32_ftruncate64(unsigned int fd, unsigned long high, unsigned long low)
{
	if ((int)high < 0)
		return -EINVAL;
	else
		return sys_ftruncate(fd, (high << 32) | low);
}
asmlinkage long compat_sys_sysfs(int option, u32 arg1, u32 arg2)
{
	return sys_sysfs(option, arg1, arg2);
}
asmlinkage long sys32_init_module(void __user *umod, u32 len,
				  const char __user *uargs)
{
	return sys_init_module(umod, len, uargs);
}
asmlinkage long sys32_delete_module(const char __user *name_user,
				    unsigned int flags)
{
	return sys_delete_module(name_user, flags);
}
asmlinkage long sys32_init_module(const char __user *name_user,
				  struct module __user *mod_user)
{
	return -ENOSYS;
}
asmlinkage long sys32_delete_module(const char __user *name_user)
{
	return -ENOSYS;
}
asmlinkage compat_ssize_t sys32_pread64(unsigned int fd,
					char __user *ubuf,
					compat_size_t count,
					unsigned long poshi,
					unsigned long poslo)
{
	return sys_pread64(fd, ubuf, count, (poshi << 32) | poslo);
}
asmlinkage compat_ssize_t sys32_pwrite64(unsigned int fd,
					 char __user *ubuf,
					 compat_size_t count,
					 unsigned long poshi,
					 unsigned long poslo)
{
	return sys_pwrite64(fd, ubuf, count, (poshi << 32) | poslo);
}
asmlinkage long compat_sys_readahead(int fd,
				     unsigned long offhi,
				     unsigned long offlo,
				     compat_size_t count)
{
	return sys_readahead(fd, (offhi << 32) | offlo, count);
}
long compat_sys_fadvise64(int fd,
			  unsigned long offhi,
			  unsigned long offlo,
			  compat_size_t len, int advice)
{
	return sys_fadvise64_64(fd, (offhi << 32) | offlo, len, advice);
}
long compat_sys_fadvise64_64(int fd,
			     unsigned long offhi, unsigned long offlo,
			     unsigned long lenhi, unsigned long lenlo,
			     int advice)
{
	return sys_fadvise64_64(fd,
				(offhi << 32) | offlo,
				(lenhi << 32) | lenlo,
				advice);
}
asmlinkage long sparc32_open(const char __user *filename,
			     int flags, int mode)
{
	return do_sys_open(AT_FDCWD, filename, flags, mode);
}
long sys32_lookup_dcookie(unsigned long cookie_high,
			  unsigned long cookie_low,
			  char __user *buf, size_t len)
{
	return sys_lookup_dcookie((cookie_high << 32) | cookie_low,
				  buf, len);
}
long compat_sync_file_range(int fd, unsigned long off_high, unsigned long off_low, unsigned long nb_high, unsigned long nb_low, int flags)
{
	return sys_sync_file_range(fd,
				   (off_high << 32) | off_low,
				   (nb_high << 32) | nb_low,
				   flags);
}
asmlinkage long compat_sys_fallocate(int fd, int mode, u32 offhi, u32 offlo,
				     u32 lenhi, u32 lenlo)
{
	return sys_fallocate(fd, mode, ((loff_t)offhi << 32) | offlo,
			     ((loff_t)lenhi << 32) | lenlo);
}
asmlinkage unsigned long sys_getpagesize(void)
{
	return PAGE_SIZE; /* Possibly older binaries want 8192 on sun4's? */
}
asmlinkage unsigned long sys_mmap2(unsigned long addr, unsigned long len,
	unsigned long prot, unsigned long flags, unsigned long fd,
	unsigned long pgoff)
{
	return do_mmap2(addr, len, prot, flags, fd, pgoff >> (PAGE_SHIFT - 12));
}
asmlinkage unsigned long sys_mmap(unsigned long addr, unsigned long len,
	unsigned long prot, unsigned long flags, unsigned long fd,
	unsigned long off)
{
	return do_mmap2(addr, len, prot, flags, fd, off >> PAGE_SHIFT);
}
long sparc_remap_file_pages(unsigned long start, unsigned long size,
			   unsigned long prot, unsigned long pgoff,
			   unsigned long flags)
{
	return sys_remap_file_pages(start, size, prot,
				    (pgoff >> (PAGE_SHIFT - 12)), flags);
}
asmlinkage unsigned long sys_getpagesize(void)
{
	return PAGE_SIZE;
}
static void clk_init(void)
{
	__asm__ __volatile__("mov 0x6c, %%g1\n\t"
			     "mov 0x4c, %%g2\n\t"
			     "mov 0xdf, %%g3\n\t"
			     "stb %%g1, [%0+3]\n\t"
			     "stb %%g2, [%0+3]\n\t"
			     "stb %%g3, [%0+3]\n\t" : :
			     "r" (clk_ctrl) :
			     "g1", "g2", "g3");
}
static void clk_slow(void)
{
	__asm__ __volatile__("mov 0xcc, %%g2\n\t"
			     "mov 0x4c, %%g3\n\t"
			     "mov 0xcf, %%g4\n\t"
			     "mov 0xdf, %%g5\n\t"
			     "stb %%g2, [%0+3]\n\t"
			     "stb %%g3, [%0+3]\n\t"
			     "stb %%g4, [%0+3]\n\t"
			     "stb %%g5, [%0+3]\n\t" : :
			     "r" (clk_ctrl) :
			     "g2", "g3", "g4", "g5");
}
static int __init clock_init(void)
{
	return of_register_driver(&clock_driver, &of_platform_bus_type);
}
static void tick_disable_protection(void)
{
	__asm__ __volatile__(
	"	ba,pt	%%xcc, 1f\n"
	"	 nop\n"
	"	.align	64\n"
	"1:	rd	%%tick, %%g2\n"
	"	add	%%g2, 6, %%g2\n"
	"	andn	%%g2, %0, %%g2\n"
	"	wrpr	%%g2, 0, %%tick\n"
	"	rdpr	%%tick, %%g0"
	: /* no outputs */
	: "r" (TICK_PRIV_BIT)
	: "g2");
}

static void tick_disable_irq(void)
{
	__asm__ __volatile__(
	"	ba,pt	%%xcc, 1f\n"
	"	 nop\n"
	"	.align	64\n"
	"1:	wr	%0, 0x0, %%tick_cmpr\n"
	"	rd	%%tick_cmpr, %%g0"
	: /* no outputs */
	: "r" (TICKCMP_IRQ_BIT));
}
static void stick_disable_irq(void)
{
	__asm__ __volatile__(
	"wr	%0, 0x0, %%asr25"
	: /* no outputs */
	: "r" (TICKCMP_IRQ_BIT));
}
static void hbtick_disable_irq(void)
{
	__hbird_write_compare(TICKCMP_IRQ_BIT);
}
static unsigned long long hbtick_get_tick(void)
{
	return __hbird_read_stick() & ~TICK_PRIV_BIT;
}
static int sparc64_next_event(unsigned long delta,
			      struct clock_event_device *evt)
{
	return tick_ops->add_compare(delta) ? -ETIME : 0;
}
void udelay(unsigned long usecs)
{
	__delay(tb_ticks_per_usec * usecs);
}
void do_BUG(const char *file, int line)
{
        printk("kernel BUG at %s:%d!\n", file, line);
}
static void spitfire_enable_estate_errors(void)
{
	__asm__ __volatile__("stxa	%0, [%%g0] %1\n\t"
			     "membar	#Sync"
			     : /* no outputs */
			     : "r" (ESTATE_ERR_ALL),
			       "i" (ASI_ESTATE_ERROR_EN));
}
void sun4v_resum_overflow(struct pt_regs *regs)
{
	atomic_inc(&sun4v_resum_oflow_cnt);
}
void sun4v_nonresum_overflow(struct pt_regs *regs)
{
	atomic_inc(&sun4v_nonresum_oflow_cnt);
}
void hypervisor_tlbop_error(unsigned long err, unsigned long op)
{
	printk(KERN_CRIT "SUN4V: TLB hv call error %lu for op %lu\n",
	       err, op);
}
void hypervisor_tlbop_error_xcall(unsigned long err, unsigned long op)
{
	printk(KERN_CRIT "SUN4V: XCALL TLB hv call error %lu for op %lu\n",
	       err, op);
}
void dump_stack(void)
{
	show_stack(current, NULL);
}
void do_privact(struct pt_regs *regs)
{
	do_privop(regs);
}
void do_cee(struct pt_regs *regs)
{
	die_if_kernel("TL0: Cache Error Exception", regs);
}
void do_paw(struct pt_regs *regs)
{
	die_if_kernel("TL0: Phys Watchpoint Exception", regs);
}
void do_vaw(struct pt_regs *regs)
{
	die_if_kernel("TL0: Virt Watchpoint Exception", regs);
}
static inline int decode_signedness(unsigned int insn)
{
	return (insn & 0x400000);
}
static inline int sign_extend_imm13(int imm)
{
	return imm << 19 >> 19;
}
static void unaligned_panic(char *str)
{
	panic(str);
}
static inline int floating_point_load_or_store_p(unsigned int insn)
{
	return (insn >> 24) & 1;
}
static inline int ok_for_kernel(unsigned int insn)
{
	return !floating_point_load_or_store_p(insn);
}
static inline int decode_asi(unsigned int insn, struct pt_regs *regs)
{
	if (insn & 0x800000) {
	} else
		return ASI_P;
}
static inline int decode_signedness(unsigned int insn)
{
	return (insn & 0x400000);
}
static inline long sign_extend_imm13(long imm)
{
	return imm << 51 >> 51;
}
static void __used unaligned_panic(char *str, struct pt_regs *regs)
{
	die_if_kernel(str, regs);
}
static inline int floating_point_load_or_store_p(unsigned int insn)
{
	return (insn >> 24) & 1;
}
static inline int ok_for_kernel(unsigned int insn)
{
	return !floating_point_load_or_store_p(insn);
}
static int us2e_freq_verify(struct cpufreq_policy *policy)
{
	return cpufreq_frequency_table_verify(policy,
					      &us2e_freq_table[policy->cpu].table[0]);
}
static void write_safari_cfg(unsigned long val)
{
	__asm__ __volatile__("stxa	%0, [%%g0] %1\n\t"
			     "membar	#Sync"
			     : /* no outputs */
			     : "r" (val), "i" (ASI_SAFARI_CONFIG)
			     : "memory");
}
static int us3_freq_verify(struct cpufreq_policy *policy)
{
	return cpufreq_frequency_table_verify(policy,
					      &us3_freq_table[policy->cpu].table[0]);
}
void vio_unregister_driver(struct vio_driver *viodrv)
{
	driver_unregister(&viodrv->driver);
}
static void vio_dev_release(struct device *dev)
{
	kfree(to_vio_dev(dev));
}
static void vio_add(struct mdesc_handle *hp, u64 node)
{
	(void) vio_create_one(hp, node, &root_vdev->dev);
}
static int send_attr(struct vio_driver_state *vio)
{
	return vio->ops->send_attr(vio);
}
static inline unsigned int fps_regval(struct fpustate *f,
				      unsigned int insn_regnum)
{
	return f->regs[insn_regnum];
}
static inline unsigned int *fps_regaddr(struct fpustate *f,
					unsigned int insn_regnum)
{
	return &f->regs[insn_regnum];
}
void __iomem *ioport_map(unsigned long port, unsigned int nr)
{
	return (void __iomem *) (unsigned long) port;
}
static inline void set_addr(unsigned int *addr, unsigned int q1, int fmangled, unsigned int value)
{
	*addr = value;
}
static inline int notify_page_fault(struct pt_regs *regs)
{
	return 0;
}
int huge_pmd_unshare(struct mm_struct *mm, unsigned long *addr, pte_t *ptep)
{
	return 0;
}
struct page *follow_huge_addr(struct mm_struct *mm,
			      unsigned long address, int write)
{
	return ERR_PTR(-EINVAL);
}
int pmd_huge(pmd_t pmd)
{
	return 0;
}
int pud_huge(pud_t pud)
{
	return 0;
}
struct page *follow_huge_pmd(struct mm_struct *mm, unsigned long address,
			     pmd_t *pmd, int write)
{
	return NULL;
}
void check_pgt_cache(void)
{
	do_check_pgt_cache(pgt_cache_water[0], pgt_cache_water[1]);
}
static inline int in_obp_range(unsigned long vaddr)
{
	return (vaddr >= LOW_OBP_ADDRESS &&
		vaddr < HI_OBP_ADDRESS);
}
static int bootmem_init_numa(void)
{
	return -1;
}
static char *iounit_lockarea(char *vaddr, unsigned long len)
{
	return vaddr;
}
static __u32 iommu_get_scsi_one_noflush(struct device *dev, char *vaddr, unsigned long len)
{
	return iommu_get_scsi_one(dev, vaddr, len);
}
static char *iommu_lockarea(char *vaddr, unsigned long len)
{
	return vaddr;
}
void __init ld_mmu_sun4c(void)
{
	should_not_happen();
}
pte_t *sun4c_pte_offset(pmd_t * dir, unsigned long address)
{
	return NULL;
}
pte_t *sun4c_pte_offset_kernel(pmd_t *dir, unsigned long address)
{
	return NULL;
}
void __init sun4c_probe_vac(void)
{
	should_not_happen();
}
void __init sun4c_probe_memerr_reg(void)
{
	should_not_happen();
}
static inline void srmmu_set_pte(pte_t *ptep, pte_t pteval)
{
	srmmu_swap((unsigned long *)ptep, pte_val(pteval));
}
static inline int srmmu_device_memory(unsigned long x)
{
	return ((x & 0xF0000000) != 0);
}
static inline unsigned long srmmu_pgd_page(pgd_t pgd)
{ return srmmu_device_memory(pgd_val(pgd))?~0:(unsigned long)__nocache_va((pgd_val(pgd) & SRMMU_PTD_PMASK) << 4); }
static inline int srmmu_pte_none(pte_t pte)
{ return !(pte_val(pte) & 0xFFFFFFF); }
static inline int srmmu_pte_present(pte_t pte)
{ return ((pte_val(pte) & SRMMU_ET_MASK) == SRMMU_ET_PTE); }
static inline void srmmu_pte_clear(pte_t *ptep)
{ srmmu_set_pte(ptep, __pte(0)); }
static inline int srmmu_pmd_none(pmd_t pmd)
{ return !(pmd_val(pmd) & 0xFFFFFFF); }
static inline int srmmu_pmd_bad(pmd_t pmd)
{ return (pmd_val(pmd) & SRMMU_ET_MASK) != SRMMU_ET_PTD; }
static inline int srmmu_pmd_present(pmd_t pmd)
{ return ((pmd_val(pmd) & SRMMU_ET_MASK) == SRMMU_ET_PTD); }
static inline int srmmu_pgd_none(pgd_t pgd)          
{ return !(pgd_val(pgd) & 0xFFFFFFF); }
static inline int srmmu_pgd_bad(pgd_t pgd)
{ return (pgd_val(pgd) & SRMMU_ET_MASK) != SRMMU_ET_PTD; }
static inline int srmmu_pgd_present(pgd_t pgd)
{ return ((pgd_val(pgd) & SRMMU_ET_MASK) == SRMMU_ET_PTD); }
static inline void srmmu_pgd_clear(pgd_t * pgdp)
{ srmmu_set_pte((pte_t *)pgdp, __pte(0)); }
static inline pte_t srmmu_pte_wrprotect(pte_t pte)
{ return __pte(pte_val(pte) & ~SRMMU_WRITE);}
static inline pte_t srmmu_pte_mkclean(pte_t pte)
{ return __pte(pte_val(pte) & ~SRMMU_DIRTY);}
static inline pte_t srmmu_pte_mkold(pte_t pte)
{ return __pte(pte_val(pte) & ~SRMMU_REF);}
static inline pte_t srmmu_pte_mkwrite(pte_t pte)
{ return __pte(pte_val(pte) | SRMMU_WRITE);}
static inline pte_t srmmu_pte_mkdirty(pte_t pte)
{ return __pte(pte_val(pte) | SRMMU_DIRTY);}
static inline pte_t srmmu_pte_mkyoung(pte_t pte)
{ return __pte(pte_val(pte) | SRMMU_REF);}
static pte_t srmmu_mk_pte(struct page *page, pgprot_t pgprot)
{ return __pte((page_to_pfn(page) << (PAGE_SHIFT-4)) | pgprot_val(pgprot)); }
static pte_t srmmu_mk_pte_phys(unsigned long page, pgprot_t pgprot)
{ return __pte(((page) >> 4) | pgprot_val(pgprot)); }
static pte_t srmmu_mk_pte_io(unsigned long page, pgprot_t pgprot, int space)
{ return __pte(((page) >> 4) | (space << 28) | pgprot_val(pgprot)); }
static inline void srmmu_ctxd_set(ctxd_t *ctxp, pgd_t *pgdp)
{ srmmu_set_pte((pte_t *)ctxp, (SRMMU_ET_PTD | (__nocache_pa((unsigned long) pgdp) >> 4))); }
static inline void srmmu_pgd_set(pgd_t * pgdp, pmd_t * pmdp)
{ srmmu_set_pte((pte_t *)pgdp, (SRMMU_ET_PTD | (__nocache_pa((unsigned long) pmdp) >> 4))); }
static inline pte_t srmmu_pte_modify(pte_t pte, pgprot_t newprot)
{ return __pte((pte_val(pte) & SRMMU_CHG_MASK) | pgprot_val(newprot)); }
static inline pgd_t *srmmu_pgd_offset(struct mm_struct * mm, unsigned long address)
{ return mm->pgd + (address >> SRMMU_PGDIR_SHIFT); }
static inline pmd_t *srmmu_pmd_offset(pgd_t * dir, unsigned long address)
{
	return (pmd_t *) srmmu_pgd_page(*dir) +
	    ((address >> PMD_SHIFT) & (PTRS_PER_PMD - 1));
}
static unsigned long srmmu_swp_type(swp_entry_t entry)
{
	return (entry.val >> SRMMU_SWP_TYPE_SHIFT) & SRMMU_SWP_TYPE_MASK;
}
static unsigned long srmmu_swp_offset(swp_entry_t entry)
{
	return (entry.val >> SRMMU_SWP_OFF_SHIFT) & SRMMU_SWP_OFF_MASK;
}
static swp_entry_t srmmu_swp_entry(unsigned long type, unsigned long offset)
{
	return (swp_entry_t) {
		  (type & SRMMU_SWP_TYPE_MASK) << SRMMU_SWP_TYPE_SHIFT
		    | (offset & SRMMU_SWP_OFF_MASK) << SRMMU_SWP_OFF_SHIFT };
}
static void srmmu_free_pgd_fast(pgd_t *pgd)
{
	srmmu_free_nocache((unsigned long)pgd, SRMMU_PGD_TABLE_SIZE);
}
static pmd_t *srmmu_pmd_alloc_one(struct mm_struct *mm, unsigned long address)
{
	return (pmd_t *)srmmu_get_nocache(SRMMU_PMD_TABLE_SIZE, SRMMU_PMD_TABLE_SIZE);
}
static void srmmu_pmd_free(pmd_t * pmd)
{
	srmmu_free_nocache((unsigned long)pmd, SRMMU_PMD_TABLE_SIZE);
}
static pte_t *
srmmu_pte_alloc_one_kernel(struct mm_struct *mm, unsigned long address)
{
	return (pte_t *)srmmu_get_nocache(PTE_SIZE, PTE_SIZE);
}
static void srmmu_free_pte_fast(pte_t *pte)
{
	srmmu_free_nocache((unsigned long)pte, PTE_SIZE);
}
static void srmmu_free_thread_info(struct thread_info *ti)
{
	free_pages((unsigned long)ti, THREAD_INFO_ORDER);
}
static void cypress_flush_tlb_all(void)
{
	srmmu_flush_whole_tlb();
}
static void srmmu_mmu_info(struct seq_file *m)
{
	seq_printf(m, 
		   "MMU type\t: %s\n"
		   "contexts\t: %d\n"
		   "nocache total\t: %ld\n"
		   "nocache used\t: %d\n",
		   srmmu_name,
		   num_contexts,
		   srmmu_nocache_size,
		   srmmu_nocache_map.used << SRMMU_NOCACHE_BITMAP_SHIFT);
}
static void turbosparc_flush_page_for_dma(unsigned long page)
{
	turbosparc_flush_dcache();
}
static void turbosparc_flush_tlb_all(void)
{
	srmmu_flush_whole_tlb();
}
static pte_t srmmu_pgoff_to_pte(unsigned long pgoff)
{
	return __pte((pgoff << SRMMU_PTE_FILE_SHIFT) | SRMMU_FILE);
}
static unsigned long srmmu_pte_to_pgoff(pte_t pte)
{
	return pte_val(pte) >> SRMMU_PTE_FILE_SHIFT;
}
static void sun4c_set_pte(pte_t *ptep, pte_t pte)
{
	*ptep = pte;
}
static void sun4c_pmd_set(pmd_t * pmdp, pte_t * ptep)
{
	pmdp->pmdv[0] = PGD_TABLE | (unsigned long) ptep;
}
static int sun4c_pte_present(pte_t pte)
{
	return ((pte_val(pte) & (_SUN4C_PAGE_PRESENT | _SUN4C_PAGE_PRIV)) != 0);
}
static void sun4c_pte_clear(pte_t *ptep)	{ *ptep = __pte(0); }
static int sun4c_pmd_bad(pmd_t pmd)
{
	return (((pmd_val(pmd) & ~PAGE_MASK) != PGD_TABLE) ||
		(!virt_addr_valid(pmd_val(pmd))));
}
static int sun4c_pmd_present(pmd_t pmd)
{
	return ((pmd_val(pmd) & PGD_PRESENT) != 0);
}
static void sun4c_pmd_clear(pmd_t *pmdp) {
	memset((void *)pmdp, 0, sizeof(pmd_t));
}
static int sun4c_pgd_none(pgd_t pgd)		{ return 0; }
static int sun4c_pgd_bad(pgd_t pgd)		{ return 0; }
static int sun4c_pgd_present(pgd_t pgd)	        { return 1; }
static pte_t sun4c_mk_pte(struct page *page, pgprot_t pgprot)
{
	return __pte(page_to_pfn(page) | pgprot_val(pgprot));
}
static pte_t sun4c_mk_pte_phys(unsigned long phys_page, pgprot_t pgprot)
{
	return __pte((phys_page >> PAGE_SHIFT) | pgprot_val(pgprot));
}
static pte_t sun4c_mk_pte_io(unsigned long page, pgprot_t pgprot, int space)
{
	return __pte(((page - PAGE_OFFSET) >> PAGE_SHIFT) | pgprot_val(pgprot));
}
static unsigned long sun4c_pte_pfn(pte_t pte)
{
	return pte_val(pte) & SUN4C_PFN_MASK;
}
static pte_t sun4c_pgoff_to_pte(unsigned long pgoff)
{
	return __pte(pgoff | _SUN4C_PAGE_FILE);
}
static unsigned long sun4c_pte_to_pgoff(pte_t pte)
{
	return pte_val(pte) & ((1UL << PTE_FILE_MAX_BITS) - 1);
}
static inline unsigned long sun4c_pmd_page_v(pmd_t pmd)
{
	return (pmd_val(pmd) & PAGE_MASK);
}
static struct page *sun4c_pmd_page(pmd_t pmd)
{
	return virt_to_page(sun4c_pmd_page_v(pmd));
}
static unsigned long sun4c_pgd_page(pgd_t pgd) { return 0; }
static inline pgd_t *sun4c_pgd_offset(struct mm_struct * mm, unsigned long address)
{
	return mm->pgd + (address >> SUN4C_PGDIR_SHIFT);
}
static pmd_t *sun4c_pmd_offset(pgd_t * dir, unsigned long address)
{
	return (pmd_t *) dir;
}
pte_t *sun4c_pte_offset_kernel(pmd_t * dir, unsigned long address)
{
	return (pte_t *) sun4c_pmd_page_v(*dir) +
			((address >> PAGE_SHIFT) & (SUN4C_PTRS_PER_PTE - 1));
}
static unsigned long sun4c_swp_type(swp_entry_t entry)
{
	return (entry.val & SUN4C_SWP_TYPE_MASK);
}
static unsigned long sun4c_swp_offset(swp_entry_t entry)
{
	return (entry.val >> SUN4C_SWP_OFF_SHIFT) & SUN4C_SWP_OFF_MASK;
}
static swp_entry_t sun4c_swp_entry(unsigned long type, unsigned long offset)
{
	return (swp_entry_t) {
		  (offset & SUN4C_SWP_OFF_MASK) << SUN4C_SWP_OFF_SHIFT
		    | (type & SUN4C_SWP_TYPE_MASK) };
}
static void sun4c_free_pte_slow(pte_t *pte)
{
	free_page((unsigned long)pte);
}
static void sun4c_free_pgd_slow(pgd_t *pgd)
{
	free_page((unsigned long)pgd);
}
static inline int tag_compare(unsigned long tag, unsigned long vaddr)
{
	return (tag == (vaddr >> 22));
}
void
prom_puts(const char *s, int len)
{
	p1275_cmd("write", P1275_ARG(1,P1275_ARG_IN_BUF)|
			   P1275_INOUT(3,1),
			   prom_stdout, s, P1275_SIZE(len));
}
int
prom_devopen(const char *dstr)
{
	return p1275_cmd ("open", P1275_ARG(0,P1275_ARG_IN_STRING)|
				  P1275_INOUT(1,1),
				  dstr);
}
void
prom_seek(int dhandle, unsigned int seekhi, unsigned int seeklo)
{
	p1275_cmd ("seek", P1275_INOUT(3,1), dhandle, seekhi, seeklo);
}
int
prom_version(void)
{
	return romvec->pv_romvers;
}
int
prom_getrev(void)
{
	return prom_rev;
}
int
prom_getprev(void)
{
	return prom_prev;
}
long prom_itlb_load(unsigned long index,
		    unsigned long tte_data,
		    unsigned long vaddr)
{
	return p1275_cmd(prom_callmethod_name,
			 (P1275_ARG(0, P1275_ARG_IN_STRING) |
			  P1275_ARG(2, P1275_ARG_IN_64B) |
			  P1275_ARG(3, P1275_ARG_IN_64B) |
			  P1275_INOUT(5, 1)),
			 "SUNW,itlb-load",
			 prom_get_mmu_ihandle(),
			 vaddr,
			 tte_data,
			 index);
}
long prom_dtlb_load(unsigned long index,
		    unsigned long tte_data,
		    unsigned long vaddr)
{
	return p1275_cmd(prom_callmethod_name,
			 (P1275_ARG(0, P1275_ARG_IN_STRING) |
			  P1275_ARG(2, P1275_ARG_IN_64B) |
			  P1275_ARG(3, P1275_ARG_IN_64B) |
			  P1275_INOUT(5, 1)),
			 "SUNW,dtlb-load",
			 prom_get_mmu_ihandle(),
			 vaddr,
			 tte_data,
			 index);
}
void prom_unmap(unsigned long size, unsigned long vaddr)
{
	p1275_cmd(prom_callmethod_name,
		  (P1275_ARG(0, P1275_ARG_IN_STRING) |
		   P1275_ARG(2, P1275_ARG_IN_64B) |
		   P1275_ARG(3, P1275_ARG_IN_64B) |
		   P1275_INOUT(4, 0)),
		  prom_unmap_name,
		  prom_get_mmu_ihandle(),
		  size,
		  vaddr);
}
unsigned long prom_retain(const char *name,
			  unsigned long pa_low, unsigned long pa_high,
			  long size, long align)
{
	if (align == 0)
		return p1275_cmd("SUNW,retain",
				 (P1275_ARG(0, P1275_ARG_IN_BUF) | P1275_INOUT(5, 2)),
				 name, pa_low, pa_high, size, align);
	else
		return p1275_cmd("SUNW,retain",
				 (P1275_ARG(0, P1275_ARG_IN_BUF) | P1275_INOUT(3, 2)),
				 name, size, align);
}
int prom_getunumber(int syndrome_code,
		    unsigned long phys_addr,
		    char *buf, int buflen)
{
	return p1275_cmd(prom_callmethod_name,
			 (P1275_ARG(0, P1275_ARG_IN_STRING)	|
			  P1275_ARG(3, P1275_ARG_OUT_BUF)	|
			  P1275_ARG(6, P1275_ARG_IN_64B)	|
			  P1275_INOUT(8, 2)),
			 "SUNW,get-unumber", prom_get_memory_ihandle(),
			 buflen, buf, P1275_SIZE(buflen),
			 0, phys_addr, syndrome_code);
}
void prom_sleepself(void)
{
	p1275_cmd("SUNW,sleep-self", P1275_INOUT(0, 0));
}
int prom_sleepsystem(void)
{
	return p1275_cmd("SUNW,sleep-system", P1275_INOUT(0, 1));
}
int prom_wakeupsystem(void)
{
	return p1275_cmd("SUNW,wakeup-system", P1275_INOUT(0, 1));
}
void prom_startcpu(int cpunode, unsigned long pc, unsigned long arg)
{
	p1275_cmd("SUNW,start-cpu", P1275_INOUT(3, 0), cpunode, pc, arg);
}
void prom_startcpu_cpuid(int cpuid, unsigned long pc, unsigned long arg)
{
	p1275_cmd("SUNW,start-cpu-by-cpuid", P1275_INOUT(3, 0),
		  cpuid, pc, arg);
}
void prom_stopcpu_cpuid(int cpuid)
{
	p1275_cmd("SUNW,stop-cpu-by-cpuid", P1275_INOUT(1, 0),
		  cpuid);
}
void prom_stopself(void)
{
	p1275_cmd("SUNW,stop-self", P1275_INOUT(0, 0));
}
void prom_idleself(void)
{
	p1275_cmd("SUNW,idle-self", P1275_INOUT(0, 0));
}
void prom_resumecpu(int cpunode)
{
	p1275_cmd("SUNW,resume-cpu", P1275_INOUT(1, 0), cpunode);
}
inline int __prom_getchild(int node)
{
	return p1275_cmd ("child", P1275_INOUT(1, 1), node);
}
inline int __prom_getsibling(int node)
{
	return p1275_cmd(prom_peer_name, P1275_INOUT(1, 1), node);
}
int prom_ihandle2path(int handle, char *buffer, int bufsize)
{
	return p1275_cmd("instance-to-path",
			 P1275_ARG(1,P1275_ARG_OUT_BUF)|
			 P1275_INOUT(3, 1),
			 handle, buffer, P1275_SIZE(bufsize));
}
static void not_configged_close(int fd, void *data)
{
	printk(KERN_ERR "Using a channel type which is configured out of "
	       "UML\n");
}
static void not_configged_free(void *data)
{
	printk(KERN_ERR "Using a channel type which is configured out of "
	       "UML\n");
}
void generic_close(int fd, void *unused)
{
	close(fd);
}
void generic_free(void *data)
{
	kfree(data);
}
static int daemon_read(int fd, struct sk_buff *skb, struct uml_net_private *lp)
{
	return net_recvfrom(fd, skb_mac_header(skb),
			    skb->dev->mtu + ETH_HEADER_OTHER);
}
static int daemon_write(int fd, struct sk_buff *skb, struct uml_net_private *lp)
{
	return daemon_user_write(fd, skb->data, skb->len,
				 (struct daemon_data *) &lp->user);
}
static void __exit harddog_exit(void)
{
	misc_deregister(&harddog_miscdev);
}
void line_flush_chars(struct tty_struct *tty)
{
	line_flush_buffer(tty);
}
int line_put_char(struct tty_struct *tty, unsigned char ch)
{
	return line_write(tty, &ch, sizeof(ch));
}
static int mcast_read(int fd, struct sk_buff *skb, struct uml_net_private *lp)
{
	return net_recvfrom(fd, skb_mac_header(skb),
			    skb->dev->mtu + ETH_HEADER_OTHER);
}
static int mcast_write(int fd, struct sk_buff *skb, struct uml_net_private *lp)
{
	return mcast_user_write(fd, skb->data, skb->len,
				(struct mcast_data *) &lp->user);
}
static int do_unlink_socket(struct notifier_block *notifier,
			    unsigned long what, void *data)
{
	return mconsole_unlink_socket();
}
void mconsole_help(struct mc_request *req)
{
	mconsole_reply(req, UML_MCONSOLE_HELPTEXT, 0, 0);
}
void mconsole_go(struct mc_request *req)
{
	mconsole_reply(req, "Not stopped", 1, 0);
}
void mconsole_sysrq(struct mc_request *req)
{
	mconsole_reply(req, "Sysrq not compiled in", 1, 0);
}
void lock_notify(void)
{
	spin_lock(&notify_spinlock);
}
void unlock_notify(void)
{
	spin_unlock(&notify_spinlock);
}
char *mconsole_notify_socket(void)
{
	return notify_socket;
}
int mconsole_reply(struct mc_request *req, const char *str, int err, int more)
{
	return mconsole_reply_len(req, str, strlen(str), err, more);
}
static ssize_t mmapper_read(struct file *file, char __user *buf, size_t count,
			    loff_t *ppos)
{
	return simple_read_from_buffer(buf, count, ppos, v_buf, mmapper_size);
}
static int mmapper_ioctl(struct inode *inode, struct file *file,
			 unsigned int cmd, unsigned long arg)
{
	return -ENOIOCTLCMD;
}
static int mmapper_release(struct inode *inode, struct file *file)
{
	return 0;
}
static void mmapper_exit(void)
{
	misc_deregister(&mmapper_dev);
}
static inline void set_ether_mac(struct net_device *dev, unsigned char *addr)
{
	memcpy(dev->dev_addr, addr, ETH_ALEN);
}
static void uml_net_set_multicast_list(struct net_device *dev)
{
	return;
}
void free_output_buffer(void *buffer)
{
	free_pages((unsigned long) buffer, 0);
}
unsigned short eth_protocol(struct sk_buff *skb)
{
	return eth_type_trans(skb, skb->dev);
}
void open_addr(unsigned char *addr, unsigned char *netmask, void *arg)
{
	change(arg, "add", addr, netmask);
}
void close_addr(unsigned char *addr, unsigned char *netmask, void *arg)
{
	change(arg, "del", addr, netmask);
}
static void *null_init(char *str, int device, const struct chan_opts *opts)
{
	return &null_chan;
}
static int null_read(int fd, char *c_out, void *unused)
{
	return -ENODEV;
}
static int pcap_read(int fd, struct sk_buff *skb, struct uml_net_private *lp)
{
	return pcap_user_read(fd, skb_mac_header(skb),
			      skb->dev->mtu + ETH_HEADER_OTHER,
			      (struct pcap_data *) &lp->user);
}
static int pcap_write(int fd, struct sk_buff *skb, struct uml_net_private *lp)
{
	return -EPERM;
}
static unsigned short slip_protocol(struct sk_buff *skbuff)
{
	return htons(ETH_P_IP);
}
static int slip_read(int fd, struct sk_buff *skb, struct uml_net_private *lp)
{
	return slip_user_read(fd, skb_mac_header(skb), skb->dev->mtu,
			      (struct slip_data *) &lp->user);
}
static int slip_write(int fd, struct sk_buff *skb, struct uml_net_private *lp)
{
	return slip_user_write(fd, skb->data, skb->len,
			       (struct slip_data *) &lp->user);
}
int slip_user_read(int fd, void *buf, int len, struct slip_data *pri)
{
	return slip_proto_read(fd, buf, len, &pri->slip);
}
int slip_user_write(int fd, void *buf, int len, struct slip_data *pri)
{
	return slip_proto_write(fd, buf, len, &pri->slip);
}
static unsigned short slirp_protocol(struct sk_buff *skbuff)
{
	return htons(ETH_P_IP);
}
static int slirp_read(int fd, struct sk_buff *skb, struct uml_net_private *lp)
{
	return slirp_user_read(fd, skb_mac_header(skb), skb->dev->mtu,
			       (struct slirp_data *) &lp->user);
}
static int slirp_write(int fd, struct sk_buff *skb, struct uml_net_private *lp)
{
	return slirp_user_write(fd, skb->data, skb->len,
				(struct slirp_data *) &lp->user);
}
int slirp_user_read(int fd, void *buf, int len, struct slirp_data *pri)
{
	return slip_proto_read(fd, buf, len, &pri->slip);
}
int slirp_user_write(int fd, void *buf, int len, struct slirp_data *pri)
{
	return slip_proto_write(fd, buf, len, &pri->slip);
}
static void ssl_announce(char *dev_name, int dev)
{
	printk(KERN_INFO "Serial line %d assigned device '%s'\n", dev,
	       dev_name);
}
static int ssl_config(char *str, char **error_out)
{
	return line_config(serial_lines, ARRAY_SIZE(serial_lines), str, &opts,
			   error_out);
}
static int ssl_get_config(char *dev, char *str, int size, char **error_out)
{
	return line_get_config(dev, serial_lines, ARRAY_SIZE(serial_lines), str,
			       size, error_out);
}
static int ssl_remove(int n, char **error_out)
{
	return line_remove(serial_lines, ARRAY_SIZE(serial_lines), n,
			   error_out);
}
static void stderr_console_write(struct console *console, const char *string,
				 unsigned len)
{
	generic_write(2 /* stderr */, string, len, NULL);
}
static void stdio_announce(char *dev_name, int dev)
{
	printk(KERN_INFO "Virtual console %d assigned device '%s'\n", dev,
	       dev_name);
}
static int con_config(char *str, char **error_out)
{
	return line_config(vts, ARRAY_SIZE(vts), str, &opts, error_out);
}
static int con_get_config(char *dev, char *str, int size, char **error_out)
{
	return line_get_config(dev, vts, ARRAY_SIZE(vts), str, size, error_out);
}
static int con_remove(int n, char **error_out)
{
	return line_remove(vts, ARRAY_SIZE(vts), n, error_out);
}
static void ubd_end_request(struct request *req, int bytes, int error)
{
	blk_end_request(req, error, bytes);
}
void ignore_sigwinch_sig(void)
{
	signal(SIGWINCH, SIG_IGN);
}
static int same_fd(struct irq_fd *irq, void *fd)
{
	return (irq->fd == *((int *)fd));
}
void free_irq_by_fd(int fd)
{
	free_irq_by_cb(same_fd, &fd);
}
void pgd_free(struct mm_struct *mm, pgd_t *pgd)
{
	free_page((unsigned long) pgd);
}
void *uml_kmalloc(int size, int flags)
{
	return kmalloc(size, flags);
}
static inline int external_pid(void)
{
	return userspace_pid[0];
}
void free_stack(unsigned long stack, int order)
{
	free_pages(stack, order);
}
static inline void set_current(struct task_struct *task)
{
	cpu_tasks[task_thread_info(task)->cpu] = ((struct cpu_task)
		{ external_pid(), task });
}
void *get_current(void)
{
	return current;
}
int __cant_sleep(void) {
	return in_atomic() || irqs_disabled() || in_interrupt();
}
char *uml_strdup(const char *string)
{
	return kstrdup(string, GFP_KERNEL);
}
int copy_to_user_proc(void __user *to, void *from, int size)
{
	return copy_to_user(to, from, size);
}
int copy_from_user_proc(void *to, void __user *from, int size)
{
	return copy_from_user(to, from, size);
}
int clear_user_proc(void __user *buf, int size)
{
	return clear_user(buf, size);
}
int strlen_user_proc(char __user *str)
{
	return strlen_user(str);
}
int cpu(void)
{
	return current_thread_info()->cpu;
}
int get_using_sysemu(void)
{
	return atomic_read(&using_sysemu);
}
void ptrace_disable(struct task_struct *child)
{
	set_singlestepping(child,0);
}
void machine_halt(void)
{
	machine_power_off();
}
void sigio_lock(void)
{
	spin_lock(&sigio_spinlock);
}
void sigio_unlock(void)
{
	spin_unlock(&sigio_spinlock);
}
int do_signal(void)
{
	return kern_do_signal(&current->thread.regs);
}
long sys_sigaltstack(const stack_t __user *uss, stack_t __user *uoss)
{
	return do_sigaltstack(uss, uoss, PT_REGS_SP(&current->thread.regs));
}
int __clear_user(void __user *mem, int len)
{
	return buffer_op((unsigned long) mem, len, 1, clear_chunk, NULL);
}
void smp_prepare_boot_cpu(void)
{
	cpu_set(smp_processor_id(), cpu_online_map);
}
int hard_smp_processor_id(void)
{
	return pid_to_processor_id(os_getpid());
}
static int itimer_next_event(unsigned long delta,
			     struct clock_event_device *evt)
{
	return timer_one_shot(delta + 1);
}
static cycle_t itimer_read(void)
{
	return os_nsecs() / 1000;
}
pgd_t *pgd_offset_proc(struct mm_struct *mm, unsigned long address)
{
	return pgd_offset(mm, address);
}
pud_t *pud_offset_proc(pgd_t *pgd, unsigned long address)
{
	return pud_offset(pgd, address);
}
pmd_t *pmd_offset_proc(pud_t *pud, unsigned long address)
{
	return pmd_offset(pud, address);
}
pte_t *pte_offset_proc(pmd_t *pmd, unsigned long address)
{
	return pte_offset_kernel(pmd, address);
}
void flush_tlb_all(void)
{
	flush_tlb_mm(current->mm);
}
void flush_tlb_kernel_range(unsigned long start, unsigned long end)
{
	flush_tlb_kernel_range_common(start, end);
}
void flush_tlb_kernel_vm(void)
{
	flush_tlb_kernel_range_common(start_vm, end_vm);
}
void __flush_tlb_one(unsigned long addr)
{
	flush_tlb_kernel_range_common(addr, addr + PAGE_SIZE);
}
static void fix_range(struct mm_struct *mm, unsigned long start_addr,
		      unsigned long end_addr, int force)
{
	fix_range_common(mm, start_addr, end_addr, force);
}
void winch(int sig, struct uml_pt_regs *regs)
{
	do_IRQ(WINCH_IRQ, regs);
}
static void __do_copy(void *to, const void *from, int n)
{
	memcpy(to, from, n);
}
unsigned long thread_saved_pc(struct task_struct *task)
{
	return os_process_pc(userspace_pid[0]);
}
static void *c_start(struct seq_file *m, loff_t *pos)
{
	return *pos < NR_CPUS ? cpu_data + *pos : NULL;
}
static long io_setup(int n, aio_context_t *ctxp)
{
	return syscall(__NR_io_setup, n, ctxp);
}
static long io_submit(aio_context_t ctx, long nr, struct iocb **iocbpp)
{
	return syscall(__NR_io_submit, ctx, nr, iocbpp);
}
static long io_getevents(aio_context_t ctx_id, long min_nr, long nr,
			 struct io_event *events, struct timespec *timeout)
{
	return syscall(__NR_io_getevents, ctx_id, min_nr, nr, events, timeout);
}
static int init_aio_26(void)
{
	return -ENOSYS;
}
static int submit_aio_26(enum aio_type type, int io_fd, char *buf, int len,
			 unsigned long long offset, struct aio_context *aio)
{
	return -ENOSYS;
}
static void etap_open_addr(unsigned char *addr, unsigned char *netmask,
			   void *arg)
{
	etap_change(ADD_ADDR, addr, netmask, *((int *) arg));
}
static void etap_close_addr(unsigned char *addr, unsigned char *netmask,
			    void *arg)
{
	etap_change(DEL_ADDR, addr, netmask, *((int *) arg));
}
static int tuntap_read(int fd, struct sk_buff *skb, struct uml_net_private *lp)
{
	return net_read(fd, skb_mac_header(skb),
			skb->dev->mtu + ETH_HEADER_OTHER);
}
static int tuntap_write(int fd, struct sk_buff *skb, struct uml_net_private *lp)
{
	return net_write(fd, skb->data, skb->len);
}
static void copy_stat(struct uml_stat *dst, const struct stat64 *src)
{
	*dst = ((struct uml_stat) {
		.ust_dev     = src->st_dev,     /* device */
		.ust_ino     = src->st_ino,     /* inode */
		.ust_mode    = src->st_mode,    /* protection */
		.ust_nlink   = src->st_nlink,   /* number of hard links */
		.ust_uid     = src->st_uid,     /* user ID of owner */
		.ust_gid     = src->st_gid,     /* group ID of owner */
		.ust_size    = src->st_size,    /* total size, in bytes */
		.ust_blksize = src->st_blksize, /* blocksize for filesys I/O */
		.ust_blocks  = src->st_blocks,  /* number of blocks allocated */
		.ust_atime   = src->st_atime,   /* time of last access */
		.ust_mtime   = src->st_mtime,   /* time of last modification */
		.ust_ctime   = src->st_ctime,   /* time of last change */
	});
}
void os_close_file(int fd)
{
	close(fd);
}
void os_flush_stdout(void)
{
	fflush(stdout);
}
int os_get_pollfd(int i)
{
	return pollfds[i].fd;
}
void os_set_pollfd(int i, int fd)
{
	pollfds[i].fd = fd;
}
void os_set_ioignore(void)
{
	signal(SIGIO, SIG_IGN);
}
void os_stop_process(int pid)
{
	kill(pid, SIGSTOP);
}
int os_getpid(void)
{
	return syscall(__NR_getpid);
}
int os_getpgrp(void)
{
	return getpgrp();
}
void get_safe_registers(unsigned long *regs)
{
	memcpy(regs, exec_regs, sizeof(exec_regs));
}
static void __init handler(int sig)
{
	got_sigio = 1;
}
void __init os_check_bugs(void)
{
	check_sigio();
}
void timer_init(void)
{
	set_handler(SIGVTALRM, (__sighandler_t) alarm_handler,
		    SA_ONSTACK | SA_RESTART, SIGUSR1, SIGIO, SIGWINCH, -1);
}
int get_signals(void)
{
	return signals_enabled;
}
int get_fp_registers(int pid, unsigned long *regs)
{
	if (have_fpx_regs)
		return save_fpx_registers(pid, regs);
	else
		return save_fp_registers(pid, regs);
}
int put_fp_registers(int pid, unsigned long *regs)
{
	if (have_fpx_regs)
		return restore_fpx_registers(pid, regs);
	else
		return restore_fp_registers(pid, regs);
}
void hard_handler(int sig)
{
	handle_signal(sig, (struct sigcontext *) (&sig + 1));
}
static void segfault(int sig)
{
	longjmp(buf, 1);
}
int os_arch_prctl(int pid, int code, unsigned long *addr)
{
        return ptrace(PTRACE_ARCH_PRCTL, pid, (unsigned long) addr, code);
}
int get_fp_registers(int pid, unsigned long *regs)
{
	return save_fp_registers(pid, regs);
}
int put_fp_registers(int pid, unsigned long *regs)
{
	return restore_fp_registers(pid, regs);
}
unsigned long os_get_top_address(unsigned long shift)
{
	return 0x7fc0000000;
}
static inline long long timeval_to_ns(const struct timeval *tv)
{
	return ((long long) tv->tv_sec * UM_NSEC_PER_SEC) +
		tv->tv_usec * UM_NSEC_PER_USEC;
}
static int after_sleep_interval(struct timespec *ts)
{
	return 0;
}
static void deliver_alarm(void)
{
	alarm_handler(SIGVTALRM, NULL);
}
static unsigned long long sleep_time(unsigned long long nsecs)
{
	return nsecs;
}
static unsigned long long sleep_time(unsigned long long nsecs)
{
	return nsecs > skew ? nsecs - skew : 0;
}
static inline long long timespec_to_us(const struct timespec *ts)
{
	return ((long long) ts->tv_sec * UM_USEC_PER_SEC) +
		ts->tv_nsec / UM_NSEC_PER_USEC;
}
char *get_umid(void)
{
	return umid;
}
int sys_modify_ldt(int func, void __user *ptr, unsigned long bytecount)
{
	return do_modify_ldt_skas(func, ptr, bytecount);
}
long subarch_ptrace(struct task_struct *child, long request, long addr,
		    long data)
{
	return -EIO;
}
static inline int valid_stack_ptr(struct thread_info *tinfo, void *p)
{
	return	p > (void *)tinfo &&
		p < (void *)tinfo + THREAD_SIZE - 3;
}
long sys_arch_prctl(int code, unsigned long addr)
{
	return arch_prctl(current, code, (unsigned long __user *) addr);
}
void module_free(struct module *mod, void *module_region)
{
	vfree(module_region);
}
static int a20_test_short(void)
{
	return a20_test(A20_TEST_SHORT);
}
static int a20_test_long(void)
{
	return a20_test(A20_TEST_LONG);
}
static void enable_a20_bios(void)
{
	asm volatile("pushfl; int $0x15; popfl"
		     : : "a" ((u16)0x2401));
}
static inline int myisspace(u8 c)
{
	return c <= ' ';	/* Close enough approximation */
}
static uint16_t elf16_to_cpu(uint16_t val)
{
	return le16_to_cpu(val);
}
static uint32_t elf32_to_cpu(uint32_t val)
{
	return le32_to_cpu(val);
}
static void count_reloc(Elf32_Rel *rel, Elf32_Sym *sym)
{
	reloc_count += 1;
}
static void collect_reloc(Elf32_Rel *rel, Elf32_Sym *sym)
{
	relocs[reloc_idx++] = rel->r_offset;
}
static void usage(void)
{
	die("relocs [--abs-syms |--abs-relocs | --text] vmlinux\n");
}
static int is_amd(void)
{
	return cpu_vendor[0] == A32('A', 'u', 't', 'h') &&
	       cpu_vendor[1] == A32('e', 'n', 't', 'i') &&
	       cpu_vendor[2] == A32('c', 'A', 'M', 'D');
}
static int is_centaur(void)
{
	return cpu_vendor[0] == A32('C', 'e', 'n', 't') &&
	       cpu_vendor[1] == A32('a', 'u', 'r', 'H') &&
	       cpu_vendor[2] == A32('a', 'u', 'l', 's');
}
static int is_transmeta(void)
{
	return cpu_vendor[0] == A32('G', 'e', 'n', 'u') &&
	       cpu_vendor[1] == A32('i', 'n', 'e', 'T') &&
	       cpu_vendor[2] == A32('M', 'x', '8', '6');
}
static u32 partial_crc32_one(u8 c, u32 crc)
{
	return crctab32[(crc ^ c) & 0xff] ^ (crc >> 8);
}
static void usage(void)
{
	die("Usage: build [-b] setup system [rootdev] [> image]");
}
static int bios_set_mode(struct mode_info *mi)
{
	return set_bios_mode(mi->mode - VIDEO_FIRST_BIOS);
}
u16 vga_crtc(void)
{
	return (inb(0x3cc) & 1) ? 0x3d4 : 0x3b4;
}
static void vga_set_80x30(void)
{
	vga_set_480_scanlines(0xdf);
}
void crypto_aes_encrypt_x86(struct crypto_aes_ctx *ctx, u8 *dst, const u8 *src)
{
	aes_enc_blk(ctx, dst, src);
}
void crypto_aes_decrypt_x86(struct crypto_aes_ctx *ctx, u8 *dst, const u8 *src)
{
	aes_dec_blk(ctx, dst, src);
}
static void aes_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
{
	aes_enc_blk(crypto_tfm_ctx(tfm), dst, src);
}

static void aes_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
{
	aes_dec_blk(crypto_tfm_ctx(tfm), dst, src);
}
static int __init aes_init(void)
{
	return crypto_register_alg(&aes_alg);
}

static void __exit aes_fini(void)
{
	crypto_unregister_alg(&aes_alg);
}
static int aes_set_key(struct crypto_tfm *tfm, const u8 *in_key,
		       unsigned int key_len)
{
	return aes_set_key_common(tfm, crypto_tfm_ctx(tfm), in_key, key_len);
}
static int crc32c_intel_finup(struct shash_desc *desc, const u8 *data,
			      unsigned int len, u8 *out)
{
	return __crc32c_intel_finup(shash_desc_ctx(desc), data, len, out);
}
static int crc32c_intel_digest(struct shash_desc *desc, const u8 *data,
			       unsigned int len, u8 *out)
{
	return __crc32c_intel_finup(crypto_shash_ctx(desc->tfm), data, len,
				    out);
}
static int __init crc32c_intel_mod_init(void)
{
	if (cpu_has_xmm4_2)
		return crypto_register_shash(&alg);
	else
		return -ENODEV;
}
static void __exit crc32c_intel_mod_fini(void)
{
	crypto_unregister_shash(&alg);
}
static int __init init(void)
{
	return crypto_register_alg(&alg);
}
static void __exit fini(void)
{
	crypto_unregister_alg(&alg);
}
static void twofish_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
{
	twofish_enc_blk(tfm, dst, src);
}

static void twofish_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
{
	twofish_dec_blk(tfm, dst, src);
}
static int __init init(void)
{
	return crypto_register_alg(&alg);
}

static void __exit fini(void)
{
	crypto_unregister_alg(&alg);
}
static int dump_write(struct file *file, const void *addr, int nr)
{
	return file->f_op->write(file, addr, nr, &file->f_pos) == nr;
}
static int __init init_aout_binfmt(void)
{
	return register_binfmt(&aout_format);
}
static void __exit exit_aout_binfmt(void)
{
	unregister_binfmt(&aout_format);
}
asmlinkage long sys32_truncate64(char __user *filename,
				 unsigned long offset_low,
				 unsigned long offset_high)
{
       return sys_truncate(filename, ((loff_t) offset_high << 32) | offset_low);
}
asmlinkage long sys32_ftruncate64(unsigned int fd, unsigned long offset_low,
				  unsigned long offset_high)
{
       return sys_ftruncate(fd, ((loff_t) offset_high << 32) | offset_low);
}
asmlinkage long sys32_mprotect(unsigned long start, size_t len,
			       unsigned long prot)
{
	return sys_mprotect(start, len, prot);
}
asmlinkage long sys32_alarm(unsigned int seconds)
{
	return alarm_setitimer(seconds);
}
asmlinkage long sys32_waitpid(compat_pid_t pid, unsigned int *stat_addr,
			      int options)
{
	return compat_sys_wait4(pid, stat_addr, options, NULL);
}
asmlinkage long sys32_sysfs(int option, u32 arg1, u32 arg2)
{
	return sys_sysfs(option, arg1, arg2);
}
asmlinkage long sys32_pread(unsigned int fd, char __user *ubuf, u32 count,
			    u32 poslo, u32 poshi)
{
	return sys_pread64(fd, ubuf, count,
			 ((loff_t)AA(poshi) << 32) | AA(poslo));
}
asmlinkage long sys32_pwrite(unsigned int fd, char __user *ubuf, u32 count,
			     u32 poslo, u32 poshi)
{
	return sys_pwrite64(fd, ubuf, count,
			  ((loff_t)AA(poshi) << 32) | AA(poslo));
}
long sys32_lseek(unsigned int fd, int offset, unsigned int whence)
{
	return sys_lseek(fd, offset, whence);
}
long sys32_kill(int pid, int sig)
{
	return sys_kill(pid, sig);
}
long sys32_fadvise64_64(int fd, __u32 offset_low, __u32 offset_high,
			__u32 len_low, __u32 len_high, int advice)
{
	return sys_fadvise64_64(fd,
			       (((u64)offset_high)<<32) | offset_low,
			       (((u64)len_high)<<32) | len_low,
				advice);
}
long sys32_lookup_dcookie(u32 addr_low, u32 addr_high,
			  char __user *buf, size_t len)
{
	return sys_lookup_dcookie(((u64)addr_high << 32) | addr_low, buf, len);
}
asmlinkage ssize_t sys32_readahead(int fd, unsigned off_lo, unsigned off_hi,
				   size_t count)
{
	return sys_readahead(fd, ((u64)off_hi << 32) | off_lo, count);
}
asmlinkage long sys32_sync_file_range(int fd, unsigned off_low, unsigned off_hi,
				      unsigned n_low, unsigned n_hi,  int flags)
{
	return sys_sync_file_range(fd,
				   ((u64)off_hi << 32) | off_low,
				   ((u64)n_hi << 32) | n_low, flags);
}
asmlinkage long sys32_fadvise64(int fd, unsigned offset_lo, unsigned offset_hi,
				size_t len, int advice)
{
	return sys_fadvise64_64(fd, ((u64)offset_hi << 32) | offset_lo,
				len, advice);
}
asmlinkage long sys32_fallocate(int fd, int mode, unsigned offset_lo,
				unsigned offset_hi, unsigned len_lo,
				unsigned len_hi)
{
	return sys_fallocate(fd, mode, ((u64)offset_hi << 32) | offset_lo,
			     ((u64)len_hi << 32) | len_lo);
}
int __ref acpi_map_lsapic(acpi_handle handle, int *pcpu)
{
	return _acpi_map_lsapic(handle, pcpu);
}
int acpi_register_ioapic(acpi_handle handle, u64 phys_addr, u32 gsi_base)
{
	return -EINVAL;
}
int acpi_unregister_ioapic(acpi_handle handle, u32 gsi_base)
{
	return -EINVAL;
}
static u8 __init uniq_ioapic_id(u8 id)
{
	if ((boot_cpu_data.x86_vendor == X86_VENDOR_INTEL) &&
	    !APIC_XAPIC(apic_version[boot_cpu_physical_apicid]))
		return io_apic_get_unique_id(nr_ioapics, id);
	else
		return id;
}
static void assign_to_mp_irq(struct mpc_intsrc *m,
				    struct mpc_intsrc *mp_irq)
{
	memcpy(mp_irq, m, sizeof(struct mpc_intsrc));
}
static int mp_irq_cmp(struct mpc_intsrc *mp_irq,
				struct mpc_intsrc *m)
{
	return memcmp(mp_irq, m, sizeof(struct mpc_intsrc));
}
static inline int acpi_parse_madt_ioapic_entries(void)
{
	return -1;
}
const unsigned char *const *find_nop_table(void)
{
	if (boot_cpu_data.x86_vendor == X86_VENDOR_INTEL &&
	    boot_cpu_has(X86_FEATURE_NOPL))
		return p6_nops;
	else
		return k8_nops;
}
const unsigned char *const *find_nop_table(void)
{
	if (boot_cpu_has(X86_FEATURE_K8))
		return k8_nops;
	else if (boot_cpu_has(X86_FEATURE_K7))
		return k7_nops;
	else if (boot_cpu_has(X86_FEATURE_NOPL))
		return p6_nops;
	else
		return intel_nops;
}
static int iommu_has_npcache(struct amd_iommu *iommu)
{
	return iommu->cap & (1UL << IOMMU_CAP_NPCACHE);
}
static bool dma_ops_domain(struct protection_domain *domain)
{
	return domain->flags & PD_DMA_OPS_MASK;
}
static inline int ivhd_entry_length(u8 *ivhd)
{
	return 0x04 << (*ivhd >> 6);
}
static void __init free_command_buffer(struct amd_iommu *iommu)
{
	free_pages((unsigned long)iommu->cmd_buf,
		   get_order(iommu->cmd_buf_size));
}
static void __init free_event_buffer(struct amd_iommu *iommu)
{
	free_pages((unsigned long)iommu->evt_buf, get_order(EVT_BUFFER_SIZE));
}
static void __init set_iommu_for_device(struct amd_iommu *iommu, u16 devid)
{
	amd_iommu_rlookup_table[devid] = iommu;
}
static int amd_iommu_resume(struct sys_device *dev)
{
	return 0;
}
static int amd_iommu_suspend(struct sys_device *dev, pm_message_t state)
{
	return -EINVAL;
}
static int __init early_amd_iommu_detect(struct acpi_table_header *table)
{
	return 0;
}
static inline int lapic_get_version(void)
{
	return GET_APIC_VERSION(apic_read(APIC_LVR));
}
static inline int lapic_is_integrated(void)
{
	return 1;
}
static void x2apic_wait_icr_idle(void)
{
	return;
}
static u32 safe_x2apic_wait_icr_idle(void)
{
	return 0;
}
void x2apic_icr_write(u32 low, u32 id)
{
	wrmsrl(APIC_BASE_MSR + (APIC_ICR >> 4), ((__u64) id) << 32 | low);
}
int get_physical_broadcast(void)
{
	return modern_apic() ? 0xff : 0xf;
}
static void lapic_timer_broadcast(const struct cpumask *mask)
{
	apic->send_IPI_mask(mask, LOCAL_TIMER_VECTOR);
}
void __cpuinit setup_secondary_APIC_clock(void)
{
	setup_APIC_timer();
}
int setup_profiling_timer(unsigned int multiplier)
{
	return -EINVAL;
}
int hard_smp_processor_id(void)
{
	return read_apic_id();
}
int default_apicid_to_node(int logical_apicid)
{
	return apicid_2_node[hard_smp_processor_id()];
}
static void __cpuinit apic_pm_activate(void)
{
	apic_pm_state.active = 1;
}
static int __init setup_nolapic(char *arg)
{
	return setup_disableapic(arg);
}
static inline void apm_restore_cpus(cpumask_t mask)
{
	set_cpus_allowed(current, mask);
}
static int set_system_power_state(u_short state)
{
	return set_power_state(APM_DEVICE_ALL, state);
}
static int queue_empty(struct apm_user *as)
{
	return as->event_head == as->event_tail;
}
static int proc_apm_open(struct inode *inode, struct file *file)
{
	return single_open(file, proc_apm_show, NULL);
}
static inline unsigned bigsmp_get_apic_id(unsigned long x)
{
	return (x >> 24) & 0xFF;
}
static inline int bigsmp_apic_id_registered(void)
{
	return 1;
}
static inline const cpumask_t *bigsmp_target_cpus(void)
{
	return &cpu_online_map;
}
static inline unsigned long
bigsmp_check_apicid_used(physid_mask_t bitmap, int apicid)
{
	return 0;
}
static inline unsigned long bigsmp_check_apicid_present(int bit)
{
	return 1;
}
static inline void bigsmp_setup_apic_routing(void)
{
	printk("Enabling APIC mode:  %s.  Using %d I/O APICs\n",
		"Physflat", nr_ioapics);
}
static inline int bigsmp_apicid_to_node(int logical_apicid)
{
	return apicid_2_node[hard_smp_processor_id()];
}
static inline physid_mask_t bigsmp_apicid_to_cpu_present(int phys_apicid)
{
	return physid_mask_of_physid(phys_apicid);
}
static inline physid_mask_t bigsmp_ioapic_phys_id_map(physid_mask_t phys_map)
{
	return physids_promote(0xFFL);
}
static inline int bigsmp_check_phys_apicid_present(int boot_cpu_physical_apicid)
{
	return 1;
}
static inline unsigned int bigsmp_cpu_mask_to_apicid(const cpumask_t *cpumask)
{
	return bigsmp_cpu_to_logical_apicid(first_cpu(*cpumask));
}
static inline int bigsmp_phys_pkg_id(int cpuid_apic, int index_msb)
{
	return cpuid_apic >> index_msb;
}
static inline void bigsmp_send_IPI_mask(const struct cpumask *mask, int vector)
{
	default_send_IPI_mask_sequence_phys(mask, vector);
}
static inline void bigsmp_send_IPI_allbutself(int vector)
{
	default_send_IPI_mask_allbutself_phys(cpu_online_mask, vector);
}
static inline void bigsmp_send_IPI_all(int vector)
{
	bigsmp_send_IPI_mask(cpu_online_mask, vector);
}
int
uv_bios_mq_watchlist_free(int blade, int watchlist_num)
{
	return (int)uv_bios_call_irqsave(UV_BIOS_WATCHLIST_FREE,
				blade, watchlist_num, 0, 0, 0);
}
static int __cpuinit have_cpuid_p(void)
{
	return flag_is_changeable_p(X86_EFLAGS_ID);
}
static inline int flag_is_changeable_p(u32 flag)
{
	return 1;
}
static inline int have_cpuid_p(void)
{
	return 1;
}
static void __cpuinit detect_nopl(struct cpuinfo_x86 *c)
{
	clear_cpu_cap(c, X86_FEATURE_NOPL);
}
static int nforce2_cpu_exit(struct cpufreq_policy *policy)
{
	return 0;
}
static void __exit nforce2_exit(void)
{
	cpufreq_unregister_driver(&nforce2_driver);
}
static int eps_verify(struct cpufreq_policy *policy)
{
	return cpufreq_frequency_table_verify(policy,
			&eps_cpu[policy->cpu]->freq_table[0]);
}
static void __exit eps_exit(void)
{
	cpufreq_unregister_driver(&eps_driver);
}
static int elanfreq_verify(struct cpufreq_policy *policy)
{
	return cpufreq_frequency_table_verify(policy, &elanfreq_table[0]);
}
static void __exit elanfreq_exit(void)
{
	cpufreq_unregister_driver(&elanfreq_driver);
}
static void gx_write_byte(int reg, int value)
{
	pci_write_config_byte(gx_params->cs55x0, reg, value);
}
static int longhaul_verify(struct cpufreq_policy *policy)
{
	return cpufreq_frequency_table_verify(policy, longhaul_table);
}
static void __exit longrun_exit(void)
{
	cpufreq_unregister_driver(&longrun_driver);
}
static int cpufreq_p4_verify(struct cpufreq_policy *policy)
{
	return cpufreq_frequency_table_verify(policy, &p4clockmod_table[0]);
}
static void __exit cpufreq_p4_exit(void)
{
	cpufreq_unregister_driver(&p4clockmod_driver);
}
static int powernow_k6_verify(struct cpufreq_policy *policy)
{
	return cpufreq_frequency_table_verify(policy, &clock_ratio[0]);
}
static void invalidate_entry(unsigned int entry)
{
	powernow_table[entry].frequency = CPUFREQ_ENTRY_INVALID;
}
static int powernow_verify(struct cpufreq_policy *policy)
{
	return cpufreq_frequency_table_verify(policy, powernow_table);
}
static void __exit powernow_exit(void)
{
	cpufreq_unregister_driver(&powernow_driver);
}
static u32 find_freq_from_fid(u32 fid)
{
	return 800 + (fid * 100);
}
static u32 find_khz_freq_from_fid(u32 fid)
{
	return 1000 * find_freq_from_fid(fid);
}
static u32 find_khz_freq_from_pstate(struct cpufreq_frequency_table *data,
		u32 pstate)
{
	return data[pstate].frequency;
}
static u32 convert_fid_to_vco_fid(u32 fid)
{
	if (fid < HI_FID_TABLE_BOTTOM)
		return 8 + (2 * fid);
	else
		return fid;
}
static void invalidate_entry(struct powernow_k8_data *data, unsigned int entry)
{
	data->powernow_table[entry].frequency = CPUFREQ_ENTRY_INVALID;
}
static int sc520_freq_verify(struct cpufreq_policy *policy)
{
	return cpufreq_frequency_table_verify(policy, &sc520_freq_table[0]);
}
static inline int centrino_cpu_init_table(struct cpufreq_policy *policy)
{
	return -ENODEV;
}
static int centrino_verify (struct cpufreq_policy *policy)
{
	return cpufreq_frequency_table_verify(policy,
			per_cpu(centrino_model, policy->cpu)->op_points);
}
static void __exit centrino_exit(void)
{
	cpufreq_unregister_driver(&centrino_driver);
}
static unsigned int speedstep_get(unsigned int cpu)
{
	return _speedstep_get(cpumask_of(cpu));
}
static int speedstep_verify(struct cpufreq_policy *policy)
{
	return cpufreq_frequency_table_verify(policy, &speedstep_freqs[0]);
}
static int speedstep_verify(struct cpufreq_policy *policy)
{
	return cpufreq_frequency_table_verify(policy, &speedstep_freqs[0]);
}
static void __exit speedstep_exit(void)
{
	cpufreq_unregister_driver(&speedstep_driver);
}
static ssize_t show_##file_name						\
			(struct _cpuid4_info *this_leaf, char *buf)	\
{									\
	return sprintf (buf, "%lu\n", (unsigned long)this_leaf->object + val); \
}
static ssize_t show_size(struct _cpuid4_info *this_leaf, char *buf)
{
	return sprintf (buf, "%luK\n", this_leaf->size / 1024);
}
static inline ssize_t show_shared_cpu_map(struct _cpuid4_info *leaf, char *buf)
{
	return show_shared_cpu_map_func(leaf, 0, buf);
}
static inline ssize_t show_shared_cpu_list(struct _cpuid4_info *leaf, char *buf)
{
	return show_shared_cpu_map_func(leaf, 1, buf);
}
static struct pci_dev *get_k8_northbridge(int node)
{
	return NULL;
}
static void unexpected_machine_check(struct pt_regs *regs, long error_code)
{
	printk(KERN_ERR "CPU#%d: Unexpected int18 (Machine Check).\n", smp_processor_id());
}
static int mce_available(struct cpuinfo_x86 *c)
{
	return cpu_has(c, X86_FEATURE_MCE) && cpu_has(c, X86_FEATURE_MCA);
}
static ssize_t show_ ## name(struct threshold_block * b, char *buf) \
{                                                                   \
        return sprintf(buf, "%lx\n", (unsigned long) b->name);      \
}
static ssize_t show_error_count(struct threshold_block *b, char *buf)
{
	return sprintf(buf, "%lx\n", work_on_cpu(b->cpu, local_error_count, b));
}
void __cpuinit mce_intel_feature_init(struct cpuinfo_x86 *c)
{
	intel_init_thermal(c);
}
static __cpuinit int thermal_throttle_add_dev(struct sys_device *sys_dev)
{
	return sysfs_create_group(&sys_dev->kobj, &thermal_throttle_attr_group);
}
static __cpuinit void thermal_throttle_remove_dev(struct sys_device *sys_dev)
{
	sysfs_remove_group(&sys_dev->kobj, &thermal_throttle_attr_group);
}
int positive_have_wrcomb(void)
{
	return 1;
}
const char *mtrr_attrib_to_str(int x)
{
	return (x <= 6) ? mtrr_strings[x] : "?";
}
static inline int types_compatible(mtrr_type type1, mtrr_type type2) {
	return type1 == MTRR_TYPE_UNCACHABLE ||
	       type2 == MTRR_TYPE_UNCACHABLE ||
	       (type1 == MTRR_TYPE_WRTHROUGH && type2 == MTRR_TYPE_WRBACK) ||
	       (type1 == MTRR_TYPE_WRBACK && type2 == MTRR_TYPE_WRTHROUGH);
}
static int __init mtrr_cleanup(unsigned address_bits)
{
	return 0;
}
void mtrr_save_state(void)
{
	smp_call_function_single(0, mtrr_save_fixed_ranges, NULL, 1);
}
static void __kprobes
single_msr_rearm(struct nmi_watchdog_ctlblk *wd, unsigned nmi_hz)
{
	write_watchdog_counter(wd->perfctr_msr, NULL, nmi_hz);
}
int lapic_watchdog_ok(void)
{
	return wd_ops != NULL;
}
static void show_cpuinfo_misc(struct seq_file *m, struct cpuinfo_x86 *c)
{
	seq_printf(m,
		   "fpu\t\t: yes\n"
		   "fpu_exception\t: yes\n"
		   "cpuid level\t: %d\n"
		   "wp\t\t: yes\n",
		   c->cpuid_level);
}
static void cpuid_device_destroy(int cpu)
{
	device_destroy(cpuid_class, MKDEV(CPUID_MAJOR, cpu));
}
static inline int check_tracer(struct task_struct *task)
{
	return task ?
		(atomic_read(&tracers) >= 0) :
		(atomic_read(&tracers) <= 0);
}
void ds_exit_thread(struct task_struct *tsk)
{
	WARN_ON(tsk->thread.ds_ctx);
}
void printk_address(unsigned long address, int reliable)
{
	printk(" [<%p>] %s%pS\n", (void *) address,
			reliable ? "" : "? ", (void *) address);
}
static void print_trace_warning(void *data, char *msg)
{
	printk("%s%s\n", (char *)data, msg);
}
void show_trace(struct task_struct *task, struct pt_regs *regs,
		unsigned long *stack, unsigned long bp)
{
	show_trace_log_lvl(task, regs, stack, bp, "");
}
void show_stack(struct task_struct *task, unsigned long *sp)
{
	show_stack_log_lvl(task, NULL, sp, 0, "");
}
u64 __init e820_update_range(u64 start, u64 size, unsigned old_type,
			     unsigned new_type)
{
	return e820_update_range_map(&e820, start, size, old_type, new_type);
}
static u64 __init e820_update_range_saved(u64 start, u64 size,
					  unsigned old_type, unsigned new_type)
{
	return e820_update_range_map(&e820_saved, start, size, old_type,
				     new_type);
}
unsigned long __init e820_end_of_ram_pfn(void)
{
	return e820_end_pfn(MAX_ARCH_PFN, E820_RAM);
}
unsigned long __init e820_end_of_low_ram_pfn(void)
{
	return e820_end_pfn(1UL<<(32 - PAGE_SHIFT), E820_RAM);
}
char * __init __attribute__((weak)) memory_setup(void)
{
	return machine_specific_memory_setup();
}
static int __init nvidia_hpet_check(struct acpi_table_header *header)
{
	return 0;
}
static inline u32 dbgp_pid_update(u32 x, u32 tok)
{
	return ((x ^ DBGP_DATA_TOGGLE) & 0xffff00) | (tok & 0xff);
}
static inline u32 dbgp_len_update(u32 x, u32 len)
{
	return (x & ~0x0f) | (len & 0x0f);
}
static efi_status_t virt_efi_get_time(efi_time_t *tm, efi_time_cap_t *tc)
{
	return efi_call_virt2(get_time, tm, tc);
}
static efi_status_t virt_efi_set_time(efi_time_t *tm)
{
	return efi_call_virt1(set_time, tm);
}
static efi_status_t virt_efi_get_wakeup_time(efi_bool_t *enabled,
					     efi_bool_t *pending,
					     efi_time_t *tm)
{
	return efi_call_virt3(get_wakeup_time,
			      enabled, pending, tm);
}
static efi_status_t virt_efi_set_wakeup_time(efi_bool_t enabled, efi_time_t *tm)
{
	return efi_call_virt2(set_wakeup_time,
			      enabled, tm);
}
static efi_status_t virt_efi_get_variable(efi_char16_t *name,
					  efi_guid_t *vendor,
					  u32 *attr,
					  unsigned long *data_size,
					  void *data)
{
	return efi_call_virt5(get_variable,
			      name, vendor, attr,
			      data_size, data);
}
static efi_status_t virt_efi_get_next_variable(unsigned long *name_size,
					       efi_char16_t *name,
					       efi_guid_t *vendor)
{
	return efi_call_virt3(get_next_variable,
			      name_size, name, vendor);
}
static efi_status_t virt_efi_set_variable(efi_char16_t *name,
					  efi_guid_t *vendor,
					  unsigned long attr,
					  unsigned long data_size,
					  void *data)
{
	return efi_call_virt5(set_variable,
			      name, vendor, attr,
			      data_size, data);
}
static efi_status_t virt_efi_get_next_high_mono_count(u32 *count)
{
	return efi_call_virt1(get_next_high_mono_count, count);
}
static void virt_efi_reset_system(int reset_type,
				  efi_status_t status,
				  unsigned long data_size,
				  efi_char16_t *data)
{
	efi_call_virt4(reset_system, reset_type, status,
		       data_size, data);
}
static efi_status_t virt_efi_set_virtual_address_map(
	unsigned long memory_map_size,
	unsigned long descriptor_size,
	u32 descriptor_version,
	efi_memory_desc_t *virtual_map)
{
	return efi_call_virt4(set_virtual_address_map,
			      memory_map_size, descriptor_size,
			      descriptor_version, virtual_map);
}
static void es7000_vector_allocation_domain(int cpu, cpumask_t *retmask)
{
  *retmask = (cpumask_t){ { [0] = APIC_ALL_CPUS, } };
}
static unsigned int es7000_get_apic_id(unsigned long x)
{
	return (x >> 24) & 0xFF;
}
static void es7000_send_IPI_mask(const struct cpumask *mask, int vector)
{
	default_send_IPI_mask_sequence_phys(mask, vector);
}
static void es7000_send_IPI_allbutself(int vector)
{
	default_send_IPI_mask_allbutself_phys(cpu_online_mask, vector);
}
static void es7000_send_IPI_all(int vector)
{
	es7000_send_IPI_mask(cpu_online_mask, vector);
}
static int es7000_apic_id_registered(void)
{
	        return 1;
}
static const cpumask_t *target_cpus_cluster(void)
{
	return cpu_all_mask;
}
static const cpumask_t *es7000_target_cpus(void)
{
	return &cpumask_of_cpu(smp_processor_id());
}
static unsigned long
es7000_check_apicid_used(physid_mask_t bitmap, int apicid)
{
	return 0;
}
static unsigned long es7000_check_apicid_present(int bit)
{
	return physid_isset(bit, phys_cpu_present_map);
}
static int es7000_apicid_to_node(int logical_apicid)
{
	return 0;
}
static int es7000_cpu_present_to_apicid(int mps_cpu)
{
	if (!mps_cpu)
		return boot_cpu_physical_apicid;
	else if (mps_cpu < nr_cpu_ids)
		return (int) per_cpu(x86_bios_cpu_apicid, mps_cpu);
	else
		return BAD_APICID;
}
static physid_mask_t es7000_ioapic_phys_id_map(physid_mask_t phys_map)
{
	return physids_promote(0xff);
}
static int es7000_phys_pkg_id(int cpuid_apic, int index_msb)
{
	return cpuid_apic >> index_msb;
}
static int probe_es7000(void)
{
	return 0;
}
static int __init es7000_acpi_madt_oem_check(char *oem_id, char *oem_table_id)
{
	return 0;
}
static int ftrace_calc_offset(long ip, long addr)
{
	return (int)(addr - ip);
}
static void ftrace_mod_code(void)
{
	mod_code_status = probe_kernel_write(mod_code_ip, mod_code_newcode,
					     MCOUNT_INSN_SIZE);
}
static unsigned char *ftrace_nop_replace(void)
{
	return ftrace_nop;
}
void ftrace_nmi_enter(void)
{
	atomic_inc(&in_nmi);
}
void ftrace_nmi_exit(void)
{
	atomic_dec(&in_nmi);
}
void apic_send_IPI_self(int vector)
{
	__default_send_IPI_shortcut(APIC_DEST_SELF, vector, APIC_DEST_PHYSICAL);
}
static int flat_acpi_madt_oem_check(char *oem_id, char *oem_table_id)
{
	return 1;
}
static const struct cpumask *flat_target_cpus(void)
{
	return cpu_online_mask;
}
static int flat_apic_id_registered(void)
{
	return physid_isset(read_xapic_id(), phys_cpu_present_map);
}
static unsigned int flat_cpu_mask_to_apicid(const struct cpumask *cpumask)
{
	return cpumask_bits(cpumask)[0] & APIC_ALL_CPUS;
}
static int flat_phys_pkg_id(int initial_apic_id, int index_msb)
{
	return hard_smp_processor_id() >> index_msb;
}
static const struct cpumask *physflat_target_cpus(void)
{
	return cpu_online_mask;
}
static void physflat_send_IPI_mask(const struct cpumask *cpumask, int vector)
{
	default_send_IPI_mask_sequence_phys(cpumask, vector);
}
static void physflat_send_IPI_mask_allbutself(const struct cpumask *cpumask,
					      int vector)
{
	default_send_IPI_mask_allbutself_phys(cpumask, vector);
}
static void physflat_send_IPI_allbutself(int vector)
{
	default_send_IPI_mask_allbutself_phys(cpu_online_mask, vector);
}
static void physflat_send_IPI_all(int vector)
{
	physflat_send_IPI_mask(cpu_online_mask, vector);
}
static const struct cpumask *x2apic_target_cpus(void)
{
	return cpumask_of(0);
}
static void x2apic_send_IPI_all(int vector)
{
	x2apic_send_IPI_mask(cpu_online_mask, vector);
}
static int x2apic_apic_id_registered(void)
{
	return 1;
}
static int x2apic_cluster_phys_pkg_id(int initial_apicid, int index_msb)
{
	return current_cpu_data.initial_apicid >> index_msb;
}
static void x2apic_send_IPI_self(int vector)
{
	apic_write(APIC_SELF_IPI, vector);
}
static const struct cpumask *x2apic_target_cpus(void)
{
	return cpumask_of(0);
}
static void x2apic_send_IPI_all(int vector)
{
	x2apic_send_IPI_mask(cpu_online_mask, vector);
}
static int x2apic_apic_id_registered(void)
{
	return 1;
}
static unsigned int x2apic_phys_get_apic_id(unsigned long x)
{
	return x;
}
static unsigned long set_apic_id(unsigned int id)
{
	return id;
}
static int x2apic_phys_pkg_id(int initial_apicid, int index_msb)
{
	return current_cpu_data.initial_apicid >> index_msb;
}
static void x2apic_send_IPI_self(int vector)
{
	apic_write(APIC_SELF_IPI, vector);
}
enum uv_system_type get_uv_system_type(void)
{
	return uv_system_type;
}
int is_uv_system(void)
{
	return uv_system_type != UV_NONE;
}
static const struct cpumask *uv_target_cpus(void)
{
	return cpumask_of(0);
}
static void uv_send_IPI_all(int vector)
{
	uv_send_IPI_mask(cpu_online_mask, vector);
}
static int uv_apic_id_registered(void)
{
	return 1;
}
static unsigned int uv_read_apic_id(void)
{
	return x2apic_get_apic_id(apic_read(APIC_ID));
}
static int uv_phys_pkg_id(int initial_apicid, int index_msb)
{
	return uv_read_apic_id() >> index_msb;
}
static void uv_send_IPI_self(int vector)
{
	apic_write(APIC_SELF_IPI, vector);
}
static __cpuinit void set_x2apic_extra_bits(int pnode)
{
	__get_cpu_var(x2apic_extra_bits) = (pnode << 6);
}
static __init void uv_scir_register_cpu_notifier(void)
{
	hotcpu_notifier(uv_scir_cpu_notify, 0);
}
static void __init clear_bss(void)
{
	memset(__bss_start, 0,
	       (unsigned long) __bss_stop - (unsigned long) __bss_start);
}
unsigned long hpet_readl(unsigned long a)
{
	return readl(hpet_virt_address + a);
}
static inline void hpet_writel(unsigned long d, unsigned long a)
{
	writel(d, hpet_virt_address + a);
}
static inline int is_hpet_capable(void)
{
	return !boot_hpet_disable && hpet_address;
}
int is_hpet_enabled(void)
{
	return is_hpet_capable() && hpet_legacy_int_enabled;
}
static void hpet_resume_device(void)
{
	force_hpet_resume();
}
static void hpet_legacy_set_mode(enum clock_event_mode mode,
			struct clock_event_device *evt)
{
	hpet_set_mode(mode, evt, 0);
}
static int hpet_legacy_next_event(unsigned long delta,
			struct clock_event_device *evt)
{
	return hpet_next_event(delta, evt, 0);
}
static int hpet_setup_msi_irq(unsigned int irq)
{
	return 0;
}
static void hpet_msi_capability_lookup(unsigned int start_timer)
{
	return;
}
static void hpet_reserve_msi_timers(struct hpet_data *hd)
{
	return;
}
static int hpet_cpuhp_notify(struct notifier_block *n,
		unsigned long action, void *hcpu)
{
	return NOTIFY_OK;
}
static cycle_t read_hpet(void)
{
	return (cycle_t)hpet_readl(HPET_COUNTER);
}
static cycle_t __vsyscall_fn vread_hpet(void)
{
	return readl((const void __iomem *)fix_to_virt(VSYSCALL_HPET) + 0xf0);
}
static inline int hpet_cnt_ahead(u32 c1, u32 c2)
{
	return (s32)(c2 - c1) < 0;
}
int hpet_rtc_dropped_irq(void)
{
	return is_hpet_enabled();
}
int fpregs_active(struct task_struct *target, const struct user_regset *regset)
{
	return tsk_used_math(target) ? regset->n : 0;
}
int xfpregs_active(struct task_struct *target, const struct user_regset *regset)
{
	return (cpu_has_fxsr && tsk_used_math(target)) ? regset->n : 0;
}
static int i8237A_suspend(struct sys_device *dev, pm_message_t state)
{
	return 0;
}
static void free_irq_cfg(struct irq_cfg *old_cfg)
{
	kfree(old_cfg);
}
static struct irq_cfg *irq_cfg(unsigned int irq)
{
	return irq < nr_irqs ? irq_cfgx + irq : NULL;
}
static __attribute_const__ struct io_apic __iomem *io_apic_base(int idx)
{
	return (void __iomem *) __fix_to_virt(FIX_IO_APIC_BASE_0 + idx)
		+ (mp_ioapics[idx].apicaddr & ~PAGE_MASK);
}
static void __unmask_IO_APIC_irq(struct irq_cfg *cfg)
{
	io_apic_modify_irq(cfg, ~IO_APIC_REDIR_MASKED, 0, NULL);
}
static void __mask_IO_APIC_irq(struct irq_cfg *cfg)
{
	io_apic_modify_irq(cfg, ~0, IO_APIC_REDIR_MASKED, &io_apic_sync);
}
static void __mask_IO_APIC_irq(struct irq_cfg *cfg)
{
	io_apic_modify_irq(cfg, ~0, IO_APIC_REDIR_MASKED, NULL);
}
static void __mask_and_edge_IO_APIC_irq(struct irq_cfg *cfg)
{
	io_apic_modify_irq(cfg, ~IO_APIC_REDIR_LEVEL_TRIGGER,
			IO_APIC_REDIR_MASKED, NULL);
}
static void __unmask_and_level_IO_APIC_irq(struct irq_cfg *cfg)
{
	io_apic_modify_irq(cfg, ~IO_APIC_REDIR_MASKED,
			IO_APIC_REDIR_LEVEL_TRIGGER, NULL);
}
void reinit_intr_remapped_IO_APIC(int intr_remapping)
{
	restore_IO_APIC_setup();
}
static inline int irq_polarity(int idx)
{
	return MPBIOS_polarity(idx);
}
static inline int irq_trigger(int idx)
{
	return MPBIOS_trigger(idx);
}
void lock_vector_lock(void)
{
	spin_lock(&vector_lock);
}
void unlock_vector_lock(void)
{
	spin_unlock(&vector_lock);
}
static inline int IO_APIC_irq_trigger(int irq)
{
	return 1;
}
static void ack_x2apic_level(unsigned int irq)
{
	ack_x2APIC_irq();
}
static void ack_x2apic_edge(unsigned int irq)
{
	ack_x2APIC_irq();
}
static void ack_lapic_irq(unsigned int irq)
{
	ack_APIC_irq();
}
void arch_teardown_msi_irq(unsigned int irq)
{
	destroy_irq(irq);
}
asmlinkage long sys_iopl(unsigned int level, struct pt_regs *regs)
{
	return do_iopl(level, regs);
}
void default_send_IPI_all(int vector)
{
	__default_local_send_IPI_all(vector);
}
void default_send_IPI_self(int vector)
{
	__default_send_IPI_shortcut(APIC_DEST_SELF, vector, apic->dest_logical);
}
static inline int check_stack_overflow(void) { return 0; }
static void call_on_stack(void *func, void *stack)
{
	asm volatile("xchgl	%%ebx,%%esp	\n"
		     "call	*%%edi		\n"
		     "movl	%%ebx,%%esp	\n"
		     : "=b" (stack)
		     : "0" (stack),
		       "D"(func)
		     : "memory", "cc", "edx", "ecx", "eax");
}
void irq_ctx_exit(int cpu)
{
	hardirq_ctx[cpu] = NULL;
}
static inline int
execute_on_irq_stack(int overflow, struct irq_desc *desc, int irq) { return 0; }
void kgdb_disable_hw_debug(struct pt_regs *regs)
{
	set_debugreg(0UL, 7);
}
void kgdb_roundup_cpus(unsigned long flags)
{
	apic->send_IPI_allbutself(APIC_DM_NMI);
}
int kgdb_arch_init(void)
{
	return register_die_notifier(&kgdb_notifier);
}
void kgdb_arch_exit(void)
{
	unregister_die_notifier(&kgdb_notifier);
}
void __kprobes arch_arm_kprobe(struct kprobe *p)
{
	text_poke(p->addr, ((unsigned char []){BREAKPOINT_INSTRUCTION}), 1);
}
void __kprobes arch_disarm_kprobe(struct kprobe *p)
{
	text_poke(p->addr, &p->opcode, 1);
}
static void __used __kprobes kretprobe_trampoline_holder(void)
{
	asm volatile (
			".global kretprobe_trampoline\n"
			"kretprobe_trampoline: \n"
			"	pushq %rsp\n"
			"	pushfq\n"
			"	subq $24, %rsp\n"
			"	pushq %rdi\n"
			"	pushq %rsi\n"
			"	pushq %rdx\n"
			"	pushq %rcx\n"
			"	pushq %rax\n"
			"	pushq %r8\n"
			"	pushq %r9\n"
			"	pushq %r10\n"
			"	pushq %r11\n"
			"	pushq %rbx\n"
			"	pushq %rbp\n"
			"	pushq %r12\n"
			"	pushq %r13\n"
			"	pushq %r14\n"
			"	pushq %r15\n"
			"	movq %rsp, %rdi\n"
			"	call trampoline_handler\n"
			"	movq %rax, 152(%rsp)\n"
			"	popq %r15\n"
			"	popq %r14\n"
			"	popq %r13\n"
			"	popq %r12\n"
			"	popq %rbp\n"
			"	popq %rbx\n"
			"	popq %r11\n"
			"	popq %r10\n"
			"	popq %r9\n"
			"	popq %r8\n"
			"	popq %rax\n"
			"	popq %rcx\n"
			"	popq %rdx\n"
			"	popq %rsi\n"
			"	popq %rdi\n"
			"	addq $24, %rsp\n"
			"	popfq\n"
			"	pushf\n"
			"	subl $12, %esp\n"
			"	pushl %fs\n"
			"	pushl %ds\n"
			"	pushl %es\n"
			"	pushl %eax\n"
			"	pushl %ebp\n"
			"	pushl %edi\n"
			"	pushl %esi\n"
			"	pushl %edx\n"
			"	pushl %ecx\n"
			"	pushl %ebx\n"
			"	movl %esp, %eax\n"
			"	call trampoline_handler\n"
			"	movl 52(%esp), %edx\n"
			"	movl %edx, 48(%esp)\n"
			"	movl %eax, 52(%esp)\n"
			"	popl %ebx\n"
			"	popl %ecx\n"
			"	popl %edx\n"
			"	popl %esi\n"
			"	popl %edi\n"
			"	popl %ebp\n"
			"	popl %eax\n"
			"	addl $20, %esp\n"
			"	popf\n"
			"	ret\n");
}
int __init arch_init_kprobes(void)
{
	return 0;
}
int __kprobes arch_trampoline_kprobe(struct kprobe *p)
{
	return 0;
}
static struct kvm_para_state *kvm_para_state(void)
{
	return &per_cpu(para_state, raw_smp_processor_id());
}
static void kvm_set_pte(pte_t *ptep, pte_t pte)
{
	kvm_mmu_write(ptep, pte_val(pte));
}
static void kvm_set_pte_at(struct mm_struct *mm, unsigned long addr,
			   pte_t *ptep, pte_t pte)
{
	kvm_mmu_write(ptep, pte_val(pte));
}
static void kvm_set_pmd(pmd_t *pmdp, pmd_t pmd)
{
	kvm_mmu_write(pmdp, pmd_val(pmd));
}
static void kvm_set_pte_atomic(pte_t *ptep, pte_t pte)
{
	kvm_mmu_write(ptep, pte_val(pte));
}
static void kvm_set_pte_present(struct mm_struct *mm, unsigned long addr,
				pte_t *ptep, pte_t pte)
{
	kvm_mmu_write(ptep, pte_val(pte));
}
static void kvm_pte_clear(struct mm_struct *mm,
			  unsigned long addr, pte_t *ptep)
{
	kvm_mmu_write(ptep, 0);
}
static void kvm_pmd_clear(pmd_t *pmdp)
{
	kvm_mmu_write(pmdp, 0);
}
static void kvm_set_pud(pud_t *pudp, pud_t pud)
{
	kvm_mmu_write(pudp, pud_val(pud));
}
static void kvm_set_pgd(pgd_t *pgdp, pgd_t pgd)
{
	kvm_mmu_write(pgdp, pgd_val(pgd));
}
static int kvm_set_wallclock(unsigned long now)
{
	return -1;
}
static void load_segments(void)
{
	__asm__ __volatile__ (
		"\tljmp $"STR(__KERNEL_CS)",$1f\n"
		"\t1:\n"
		"\tmovl $"STR(__KERNEL_DS)",%%eax\n"
		"\tmovl %%eax,%%ds\n"
		"\tmovl %%eax,%%es\n"
		"\tmovl %%eax,%%fs\n"
		"\tmovl %%eax,%%gs\n"
		"\tmovl %%eax,%%ss\n"
		::: "eax", "memory");
}
static void load_segments(void)
{
	__asm__ __volatile__ (
		"\tmovl %0,%%ds\n"
		"\tmovl %0,%%es\n"
		"\tmovl %0,%%ss\n"
		"\tmovl %0,%%fs\n"
		"\tmovl %0,%%gs\n"
		: : "a" (__KERNEL_DS) : "memory"
		);
}
void machine_kexec_cleanup(struct kimage *image)
{
	free_transition_pgtable(image);
}
static int mca_dummy_transform_irq(struct mca_device *mca_dev, int irq)
{
	return irq;
}
static int mca_dummy_transform_ioport(struct mca_device *mca_dev, int port)
{
	return port;
}
static void *mca_dummy_transform_memory(struct mca_device *mca_dev, void *mem)
{
	return mem;
}
static void mfgpt_disable_timer(u16 clock)
{
	geode_mfgpt_write(clock, MFGPT_REG_SETUP, (u16) ~MFGPT_SETUP_CNTEN |
			MFGPT_SETUP_CMP1 | MFGPT_SETUP_CMP2);
}
struct microcode_ops * __init init_amd_microcode(void)
{
	return &microcode_amd_ops;
}
static void microcode_dev_exit(void)
{
	misc_deregister(&microcode_dev);
}
static inline int update_match_cpu(struct cpu_signature *csig, int sig, int pf)
{
	return (!sigmatch(sig, csig->sig, pf, csig->pf)) ? 0 : 1;
}
static inline int
update_match_revision(struct microcode_header_intel *mc_header,	int rev)
{
	return (mc_header->rev <= rev) ? 0 : 1;
}
static int get_ucode_user(void *to, const void *from, size_t n)
{
	return copy_from_user(to, from, n);
}
struct microcode_ops * __init init_intel_microcode(void)
{
	return &microcode_intel_ops;
}
void __cpuinit check_enable_amd_mmconf_dmi(void)
{
	dmi_check_system(mmconf_dmi_table);
}
void module_free(struct module *mod, void *module_region)
{
	vfree(module_region);
}
int module_frob_arch_sections(Elf_Ehdr *hdr,
			      Elf_Shdr *sechdrs,
			      char *secstrings,
			      struct module *mod)
{
	return 0;
}
void module_free(struct module *mod, void *module_region)
{
	vfree(module_region);
}
int module_frob_arch_sections(Elf_Ehdr *hdr,
			      Elf_Shdr *sechdrs,
			      char *secstrings,
			      struct module *mod)
{
	return 0;
}
static void print_MP_intsrc_info(struct mpc_intsrc *m)
{
	apic_printk(APIC_VERBOSE, "Int: type %d, pol %d, trig %d, bus %02x,"
		" IRQ %02x, APIC ID %x, APIC INT %02x\n",
		m->irqtype, m->irqflag & 3, (m->irqflag >> 2) & 3, m->srcbus,
		m->srcbusirq, m->dstapic, m->dstirq);
}
static void __init print_mp_irq_info(struct mpc_intsrc *mp_irq)
{
	apic_printk(APIC_VERBOSE, "Int: type %d, pol %d, trig %d, bus %02x,"
		" IRQ %02x, APIC ID %x, APIC INT %02x\n",
		mp_irq->irqtype, mp_irq->irqflag & 3,
		(mp_irq->irqflag >> 2) & 3, mp_irq->srcbus,
		mp_irq->srcbusirq, mp_irq->dstapic, mp_irq->dstirq);
}
static void __init MP_lintsrc_info(struct mpc_lintsrc *m)
{
	apic_printk(APIC_VERBOSE, "Lint: type %d, pol %d, trig %d, bus %02x,"
		" IRQ %02x, APIC ID %x, APIC LINT %02x\n",
		m->irqtype, m->irqflag & 3, (m->irqflag >> 2) & 3, m->srcbusid,
		m->srcbusirq, m->destapic, m->destapiclint);
}
void __init early_get_smp_config(void)
{
	__get_smp_config(1);
}
void __init get_smp_config(void)
{
	__get_smp_config(0);
}
void __init early_find_smp_config(void)
{
	__find_smp_config(0);
}
void __init find_smp_config(void)
{
	__find_smp_config(1);
}
static void msr_device_destroy(int cpu)
{
	device_destroy(msr_class, MKDEV(MSR_MAJOR, cpu));
}
static inline unsigned int get_nmi_count(int cpu)
{
	return per_cpu(irq_stat, cpu).__nmi_count;
}
static inline int mce_in_progress(void)
{
	return atomic_read(&mce_entry) > 0;
}
static inline unsigned int get_timer_irqs(int cpu)
{
	return per_cpu(irq_stat, cpu).apic_timer_irqs +
		per_cpu(irq_stat, cpu).irq0_irqs;
}
static void __acpi_nmi_disable(void *__unused)
{
	apic_write(APIC_LVT0, APIC_DM_NMI | APIC_LVT_MASKED);
}
static void __acpi_nmi_enable(void *__unused)
{
	apic_write(APIC_LVT0, APIC_DM_NMI);
}
void cpu_nmi_set_wd_enabled(void)
{
	__get_cpu_var(wd_enabled) = 1;
}
static void disable_ioapic_nmi_watchdog(void)
{
	on_each_cpu(stop_apic_nmi_watchdog, NULL, 1);
}
static inline int generate_logical_apicid(int quad, int phys_apicid)
{
	return (quad << 4) + (phys_apicid ? phys_apicid << 1 : 1);
}
static int __init numaq_setup_ioapic_ids(void)
{
	return 1;
}
static inline unsigned int numaq_get_apic_id(unsigned long x)
{
	return (x >> 24) & 0x0F;
}
static inline void numaq_send_IPI_mask(const struct cpumask *mask, int vector)
{
	default_send_IPI_mask_sequence_logical(mask, vector);
}
static inline void numaq_send_IPI_allbutself(int vector)
{
	default_send_IPI_mask_allbutself_logical(cpu_online_mask, vector);
}
static inline void numaq_send_IPI_all(int vector)
{
	numaq_send_IPI_mask(cpu_online_mask, vector);
}
static inline void numaq_smp_callin_clear_local_apic(void)
{
	clear_local_APIC();
}
static inline const cpumask_t *numaq_target_cpus(void)
{
	return cpu_all_mask;
}
static inline unsigned long
numaq_check_apicid_used(physid_mask_t bitmap, int apicid)
{
	return physid_isset(apicid, bitmap);
}
static inline unsigned long numaq_check_apicid_present(int bit)
{
	return physid_isset(bit, phys_cpu_present_map);
}
static inline int numaq_apic_id_registered(void)
{
	return 1;
}
static inline void numaq_setup_apic_routing(void)
{
	printk("Enabling APIC mode:  %s.  Using %d I/O APICs\n",
		"NUMA-Q", nr_ioapics);
}
static inline int numaq_multi_timer_check(int apic, int irq)
{
	return apic != 0 && irq == 0;
}
static inline physid_mask_t numaq_ioapic_phys_id_map(physid_mask_t phys_map)
{
	return physids_promote(0xFUL);
}
static inline int numaq_cpu_present_to_apicid(int mps_cpu)
{
	if (mps_cpu < 60)
		return ((mps_cpu >> 2) << 4) | (1 << (mps_cpu & 0x3));
	else
		return BAD_APICID;
}
static inline int numaq_apicid_to_node(int logical_apicid) 
{
	return logical_apicid >> 4;
}
static inline int numaq_check_phys_apicid_present(int boot_cpu_physical_apicid)
{
	return 1;
}
static inline unsigned int numaq_cpu_mask_to_apicid(const cpumask_t *cpumask)
{
	return 0x0F;
}
static inline unsigned int
numaq_cpu_mask_to_apicid_and(const struct cpumask *cpumask,
			     const struct cpumask *andmask)
{
	return 0x0F;
}
static inline int numaq_phys_pkg_id(int cpuid_apic, int index_msb)
{
	return cpuid_apic >> index_msb;
}
static int probe_numaq(void)
{
	return found_numaq;
}
static void numaq_vector_allocation_domain(int cpu, cpumask_t *retmask)
{
  *retmask = (cpumask_t){ { [0] = APIC_ALL_CPUS, } };
}
static inline unsigned int ibf_status(unsigned int port)
{
	return !!(inb(port) & 0x02);
}
static inline unsigned int obf_status(unsigned int port)
{
	return inb(port) & 0x01;
}
static void __init platform_detect(void)
{
	olpc_platform_info.boardrev = 0xc2;
}
static inline void
default_spin_lock_flags(raw_spinlock_t *lock, unsigned long flags)
{
	__raw_spin_lock(lock);
}
u32 _paravirt_ident_32(u32 x)
{
	return x;
}
u64 _paravirt_ident_64(u64 x)
{
	return x;
}
static void __init default_banner(void)
{
	printk(KERN_INFO "Booting paravirtualized kernel on %s\n",
	       pv_info.name);
}
char *memory_setup(void)
{
	return pv_init_ops.memory_setup();
}
unsigned paravirt_patch_nop(void)
{
	return 0;
}
unsigned paravirt_patch_ignore(unsigned len)
{
	return len;
}
void init_IRQ(void)
{
	pv_irq_ops.init_IRQ();
}
static void native_flush_tlb(void)
{
	__native_flush_tlb();
}
static void native_flush_tlb_global(void)
{
	__native_flush_tlb_global();
}
static void native_flush_tlb_single(unsigned long addr)
{
	__native_flush_tlb_single(addr);
}
int paravirt_disable_iospace(void)
{
	return request_resource(&ioport_resource, &reserve_ioports);
}
void paravirt_enter_lazy_mmu(void)
{
	enter_lazy(PARAVIRT_LAZY_MMU);
}
void paravirt_leave_lazy_mmu(void)
{
	paravirt_leave_lazy(PARAVIRT_LAZY_MMU);
}
void paravirt_enter_lazy_cpu(void)
{
	enter_lazy(PARAVIRT_LAZY_CPU);
}
void paravirt_leave_lazy_cpu(void)
{
	paravirt_leave_lazy(PARAVIRT_LAZY_CPU);
}
enum paravirt_lazy_mode paravirt_get_lazy_mode(void)
{
	return __get_cpu_var(paravirt_lazy_mode);
}
unsigned paravirt_patch_ident_32(void *insnbuf, unsigned len)
{
	return 0;
}
unsigned paravirt_patch_ident_64(void *insnbuf, unsigned len)
{
	return 0;
}
unsigned paravirt_patch_ident_32(void *insnbuf, unsigned len)
{
	return paravirt_patch_insns(insnbuf, len,
				    start__mov32, end__mov32);
}
unsigned paravirt_patch_ident_64(void *insnbuf, unsigned len)
{
	return paravirt_patch_insns(insnbuf, len,
				    start__mov64, end__mov64);
}
static inline unsigned long verify_bit_range(unsigned long* bitmap,
	int expected, unsigned long start, unsigned long end)
{
	return ~0UL;
}
static inline int translation_enabled(struct iommu_table *tbl)
{
	return (tbl != NULL);
}
static inline void __iomem * busno_to_bbar(unsigned char num)
{
	return bus_info[num].bbar;
}
static inline int busno_to_phbid(unsigned char num)
{
	return bus_info[num].phbid;
}
static inline int is_calioc2(unsigned short device)
{
	return (device == PCI_DEVICE_ID_IBM_CALIOC2);
}
static inline int is_calgary(unsigned short device)
{
	return (device == PCI_DEVICE_ID_IBM_CALGARY);
}
static inline int is_cal_pci_dev(unsigned short device)
{
	return (is_calgary(device) || is_calioc2(device));
}
void pci_iommu_shutdown(void)
{
	gart_iommu_shutdown();
}
static inline int
need_iommu(struct device *dev, unsigned long addr, size_t size)
{
	return force_iommu ||
		!is_buffer_dma_capable(*dev->dma_mask, addr, size);
}
static inline int
nonforced_iommu(struct device *dev, unsigned long addr, size_t size)
{
	return !is_buffer_dma_capable(*dev->dma_mask, addr, size);
}
static int gart_suspend(struct sys_device *dev, pm_message_t state)
{
	return 0;
}
static void nommu_free_coherent(struct device *dev, size_t size, void *vaddr,
				dma_addr_t dma_addr)
{
	free_pages((unsigned long)vaddr, get_order(size));
}
void * __init swiotlb_alloc_boot(size_t size, unsigned long nslabs)
{
	return alloc_bootmem_low_pages(size);
}
void *swiotlb_alloc(unsigned order, unsigned long nslabs)
{
	return (void *)__get_free_pages(GFP_DMA | __GFP_NOWARN, order);
}
dma_addr_t swiotlb_phys_to_bus(struct device *hwdev, phys_addr_t paddr)
{
	return paddr;
}
phys_addr_t swiotlb_bus_to_phys(dma_addr_t baddr)
{
	return baddr;
}
int __weak swiotlb_arch_range_needs_mapping(phys_addr_t paddr, size_t size)
{
	return 0;
}
static void default_vector_allocation_domain(int cpu, struct cpumask *retmask)
{
	*retmask = (cpumask_t) { { [0] = APIC_ALL_CPUS } };
}
static int probe_default(void)
{
	return 1;
}
void mca_nmi_hook(void)
{
	pr_warning("NMI generated from unknown source!\n");
}
void arch_task_cache_init(void)
{
        task_xstate_cachep =
        	kmem_cache_create("task_xstate", xstate_size,
				  __alignof__(union thread_xstate),
				  SLAB_PANIC | SLAB_NOTRACK, NULL);
}
void disable_hlt(void)
{
	hlt_counter++;
}
void enable_hlt(void)
{
	hlt_counter--;
}
static inline int hlt_use_halt(void)
{
	return (!hlt_counter && boot_cpu_data.hlt_works_ok);
}
static inline int hlt_use_halt(void)
{
	return 1;
}
void c1e_remove_cpu(int cpu)
{
	cpu_clear(cpu, c1e_mask);
}
unsigned long thread_saved_pc(struct task_struct *tsk)
{
	return ((unsigned long *)tsk->thread.sp)[3];
}
static inline void play_dead(void)
{
	BUG();
}
void prepare_to_copy(struct task_struct *tsk)
{
	unlazy_fpu(tsk);
}
static void hard_disable_TSC(void)
{
	write_cr4(read_cr4() | X86_CR4_TSD);
}
static void hard_enable_TSC(void)
{
	write_cr4(read_cr4() & ~X86_CR4_TSD);
}
asmlinkage int sys_fork(struct pt_regs regs)
{
	return do_fork(SIGCHLD, regs.sp, &regs, 0, NULL, NULL);
}
asmlinkage int sys_vfork(struct pt_regs regs)
{
	return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, regs.sp, &regs, 0, NULL, NULL);
}
void idle_notifier_register(struct notifier_block *n)
{
	atomic_notifier_chain_register(&idle_notifier, n);
}
void idle_notifier_unregister(struct notifier_block *n)
{
	atomic_notifier_chain_unregister(&idle_notifier, n);
}
static inline void play_dead(void)
{
	BUG();
}
static inline u32 read_32bit_tls(struct task_struct *t, int tls)
{
	return get_desc_base(&t->thread.tls_array[tls]);
}
void prepare_to_copy(struct task_struct *tsk)
{
	unlazy_fpu(tsk);
}
static void hard_disable_TSC(void)
{
	write_cr4(read_cr4() | X86_CR4_TSD);
}
static void hard_enable_TSC(void)
{
	write_cr4(read_cr4() & ~X86_CR4_TSD);
}
asmlinkage long sys_fork(struct pt_regs *regs)
{
	return do_fork(SIGCHLD, regs->sp, regs, 0, NULL, NULL);
}
asmlinkage long sys_vfork(struct pt_regs *regs)
{
	return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, regs->sp, regs, 0,
		    NULL, NULL);
}
long sys_arch_prctl(int code, unsigned long addr)
{
	return do_arch_prctl(current, code, addr);
}
static void hpet_print_force_info(void)
{
	printk(KERN_INFO "HPET not enabled in BIOS. "
	       "You might try hpet=force boot option\n");
}
static void vmxoff_nmi(int cpu, struct die_args *args)
{
	cpu_emergency_vmxoff();
}
void machine_power_off(void)
{
	machine_ops.power_off();
}
void machine_shutdown(void)
{
	machine_ops.shutdown();
}
void machine_emergency_restart(void)
{
	__machine_emergency_restart(1);
}
void machine_restart(char *cmd)
{
	machine_ops.restart(cmd);
}
void machine_halt(void)
{
	machine_ops.halt();
}
void machine_crash_shutdown(struct pt_regs *regs)
{
	machine_ops.crash_shutdown(regs);
}
static void smp_send_nmi_allbutself(void)
{
	apic->send_IPI_allbutself(NMI_VECTOR);
}
int update_persistent_clock(struct timespec now)
{
	return set_rtc_mmss(now.tv_sec);
}
unsigned long long native_read_tsc(void)
{
	return __native_read_tsc();
}
int default_cpu_present_to_apicid(int mps_cpu)
{
	return __default_cpu_present_to_apicid(mps_cpu);
}
int default_check_phys_apicid_present(int boot_cpu_physical_apicid)
{
	return __default_check_phys_apicid_present(boot_cpu_physical_apicid);
}
static void set_mca_bus(int x)
{
	MCA_bus = x;
}
asmlinkage long
sys_sigaltstack(const stack_t __user *uss, stack_t __user *uoss,
		struct pt_regs *regs)
{
	return do_sigaltstack(uss, uoss, regs->sp);
}
asmlinkage long sys_rt_sigreturn(struct pt_regs *regs)
{
	return do_rt_sigreturn(regs);
}
void native_send_call_func_single_ipi(int cpu)
{
	apic->send_IPI_mask(cpumask_of(cpu), CALL_FUNCTION_SINGLE_VECTOR);
}
cpumask_t cpu_coregroup_map(int cpu)
{
	return *cpu_coregroup_mask(cpu);
}
int native_cpu_disable(void)
{
	return -ENOSYS;
}
void native_cpu_die(unsigned int cpu)
{
	BUG();
}
void native_play_dead(void)
{
	BUG();
}
static int save_stack_stack(void *data, char *name)
{
	return -1;
}
void user_enable_single_step(struct task_struct *child)
{
	enable_step(child, 0);
}
void user_enable_block_step(struct task_struct *child)
{
	enable_step(child, 1);
}
static inline unsigned summit_get_apic_id(unsigned long x)
{
	return (x >> 24) & 0xFF;
}
static inline void summit_send_IPI_mask(const cpumask_t *mask, int vector)
{
	default_send_IPI_mask_sequence_logical(mask, vector);
}
static inline void summit_send_IPI_all(int vector)
{
	summit_send_IPI_mask(&cpu_online_map, vector);
}
static inline int is_WPEG(struct rio_detail *rio){
	return (rio->type == CompatWPEG || rio->type == AltWPEG ||
		rio->type == LookOutAWPEG || rio->type == LookOutBWPEG);
}
static inline const cpumask_t *summit_target_cpus(void)
{
	return &cpumask_of_cpu(0);
}
static inline unsigned long
summit_check_apicid_used(physid_mask_t bitmap, int apicid)
{
	return 0;
}
static inline unsigned long summit_check_apicid_present(int bit)
{
	return 1;
}
static inline int summit_apic_id_registered(void)
{
	return 1;
}
static inline void summit_setup_apic_routing(void)
{
	printk("Enabling APIC mode:  Summit.  Using %d I/O APICs\n",
						nr_ioapics);
}
static inline int summit_apicid_to_node(int logical_apicid)
{
	return apicid_2_node[hard_smp_processor_id()];
}
static inline int summit_cpu_present_to_apicid(int mps_cpu)
{
	if (mps_cpu < nr_cpu_ids)
		return (int)per_cpu(x86_bios_cpu_apicid, mps_cpu);
	else
		return BAD_APICID;
}
static inline physid_mask_t
summit_ioapic_phys_id_map(physid_mask_t phys_id_map)
{
	return physids_promote(0x0F);
}
static inline physid_mask_t summit_apicid_to_cpu_present(int apicid)
{
	return physid_mask_of_physid(0);
}
static inline int summit_check_phys_apicid_present(int boot_cpu_physical_apicid)
{
	return 1;
}
static inline int summit_phys_pkg_id(int cpuid_apic, int index_msb)
{
	return hard_smp_processor_id() >> index_msb;
}
static int probe_summit(void)
{
	return 0;
}
static void summit_vector_allocation_domain(int cpu, cpumask_t *retmask)
{
	*retmask = (cpumask_t){ { [0] = APIC_ALL_CPUS, } };
}
static inline unsigned int table_size_to_number_of_entries(unsigned char size)
{
	return (1 << size) << 13;
}
static int uv_ptc_proc_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &uv_ptc_seq_ops);
}
void arch_unregister_cpu(int num)
{
	unregister_cpu(&per_cpu(cpu_devices, num).cpu);
}
static int __init arch_register_cpu(int num)
{
	return register_cpu(&per_cpu(cpu_devices, num).cpu, num);
}
unsigned long long sched_clock(void)
{
	return paravirt_sched_clock();
}
int check_tsc_unstable(void)
{
	return tsc_unstable;
}
static unsigned int uv_noop_ret(unsigned int irq)
{
	return 0;
}
static void uv_ack_apic(unsigned int irq)
{
	ack_APIC_irq();
}
static ssize_t partition_id_show(struct kobject *kobj,
			struct kobj_attribute *attr, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%ld\n", sn_partition_id);
}
static ssize_t coherence_id_show(struct kobject *kobj,
			struct kobj_attribute *attr, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%ld\n", partition_coherence_id());
}
int is_visws_box(void)
{
	return visws_board_type >= 0;
}
static void visws_machine_emergency_restart(void)
{
	outb(PIIX4_RESET_VAL, PIIX4_RESET_PORT);
}
static int __init visws_get_smp_config(unsigned int early)
{
	return 1;
}
static void enable_cobalt_irq(unsigned int irq)
{
	co_apic_set(is_co_apic(irq), irq);
}
static inline void clear_IF(struct kernel_vm86_regs *regs)
{
	VEFLAGS &= ~X86_EFLAGS_VIF;
}
static inline void clear_TF(struct kernel_vm86_regs *regs)
{
	regs->pt.flags &= ~X86_EFLAGS_TF;
}
static inline void clear_AC(struct kernel_vm86_regs *regs)
{
	regs->pt.flags &= ~X86_EFLAGS_AC;
}
static inline void patch_offset(void *insnbuf,
				unsigned long ip, unsigned long dest)
{
        *(unsigned long *)(insnbuf+1) = dest-ip-5;
}
static void vmi_set_tr(void)
{
	vmi_ops.set_tr(GDT_ENTRY_TSS*sizeof(struct desc_struct));
}
static void vmi_flush_tlb_user(void)
{
	vmi_ops._flush_tlb(VMI_FLUSH_TLB);
}
static void vmi_flush_tlb_kernel(void)
{
	vmi_ops._flush_tlb(VMI_FLUSH_TLB | VMI_FLUSH_GLOBAL);
}
static void vmi_allocate_pte(struct mm_struct *mm, unsigned long pfn)
{
	vmi_ops.allocate_page(pfn, VMI_PAGE_L1, 0, 0, 0);
}
static void vmi_allocate_pmd(struct mm_struct *mm, unsigned long pfn)
{
	vmi_ops.allocate_page(pfn, VMI_PAGE_L2, 0, 0, 0);
}
static void vmi_allocate_pmd_clone(unsigned long pfn, unsigned long clonepfn, unsigned long start, unsigned long count)
{
	vmi_ops.allocate_page(pfn, VMI_PAGE_L2 | VMI_PAGE_CLONE, clonepfn, start, count);
}
static void vmi_release_pte(unsigned long pfn)
{
	vmi_ops.release_page(pfn, VMI_PAGE_L1);
}
static void vmi_release_pmd(unsigned long pfn)
{
	vmi_ops.release_page(pfn, VMI_PAGE_L2);
}
static void vmi_update_pte(struct mm_struct *mm, unsigned long addr, pte_t *ptep)
{
	vmi_ops.update_pte(ptep, vmi_flags_addr(mm, addr, VMI_PAGE_PT, 0));
}
static void vmi_update_pte_defer(struct mm_struct *mm, unsigned long addr, pte_t *ptep)
{
	vmi_ops.update_pte(ptep, vmi_flags_addr_defer(mm, addr, VMI_PAGE_PT, 0));
}
static void vmi_set_pte(pte_t *ptep, pte_t pte)
{
	vmi_ops.set_pte(pte, ptep, VMI_PAGE_PT);
}
static void vmi_set_pte_at(struct mm_struct *mm, unsigned long addr, pte_t *ptep, pte_t pte)
{
	vmi_ops.set_pte(pte, ptep, vmi_flags_addr(mm, addr, VMI_PAGE_PT, 0));
}
static void vmi_set_pte_present(struct mm_struct *mm, unsigned long addr, pte_t *ptep, pte_t pte)
{
	vmi_ops.set_pte(pte, ptep, vmi_flags_addr_defer(mm, addr, VMI_PAGE_PT, 1));
}
static inline u32 vmi_counter(u32 flags)
{
	return flags & VMI_ALARM_COUNTER_MASK;
}
int vmi_set_wallclock(unsigned long now)
{
	return 0;
}
unsigned long long vmi_sched_clock(void)
{
	return cycles_2_ns(vmi_timer_ops.get_cycle_counter(VMI_CYCLES_AVAILABLE));
}
static inline unsigned int vmi_get_timer_vector(void)
{
	return FIRST_DEVICE_VECTOR;
}
static void ack_timer_irq(unsigned int irq)
{
	ack_APIC_irq();
}
static inline int vmi_get_alarm_wiring(void)
{
	return vmi_wiring;
}
static cycle_t read_real_cycles(void)
{
	return vmi_timer_ops.get_cycle_counter(VMI_CYCLES_REAL);
}
int is_vsmp_box(void)
{
	return 0;
}
static __always_inline void do_get_tz(struct timezone * tz)
{
	*tz = __vsyscall_gtod_data.sys_tz;
}
static long __vsyscall(3) venosys_1(void)
{
	return -ENOSYS;
}
static int
vsyscall_sysctl_change(ctl_table *ctl, int write, struct file * filp,
		       void __user *buffer, size_t *lenp, loff_t *ppos)
{
	return proc_dointvec(ctl, write, filp, buffer, lenp, ppos);
}
static void __cpuinit cpu_vsyscall_init(void *arg)
{
	vsyscall_set_cpu(raw_smp_processor_id());
}
static int pit_in_range(struct kvm_io_device *this, gpa_t addr,
			int len, int is_write)
{
	return ((addr >= KVM_PIT_BASE_ADDRESS) &&
		(addr < KVM_PIT_BASE_ADDRESS + KVM_PIT_MEM_LENGTH));
}
static int speaker_in_range(struct kvm_io_device *this, gpa_t addr,
			    int len, int is_write)
{
	return (addr == KVM_SPEAKER_BASE_ADDRESS);
}
static void pic_lock(struct kvm_pic *s)
{
	spin_lock(&s->lock);
}
static inline u32 apic_get_reg(struct kvm_lapic *apic, int reg_off)
{
	return *((u32 *) (apic->regs + reg_off));
}
static inline void apic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)
{
	*((u32 *) (apic->regs + reg_off)) = val;
}
static inline int apic_test_and_set_vector(int vec, void *bitmap)
{
	return test_and_set_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));
}
static inline int apic_test_and_clear_vector(int vec, void *bitmap)
{
	return test_and_clear_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));
}
static inline void apic_set_vector(int vec, void *bitmap)
{
	set_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));
}
static inline void apic_clear_vector(int vec, void *bitmap)
{
	clear_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));
}
static inline int apic_hw_enabled(struct kvm_lapic *apic)
{
	return (apic)->vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE;
}
static inline int  apic_sw_enabled(struct kvm_lapic *apic)
{
	return apic_get_reg(apic, APIC_SPIV) & APIC_SPIV_APIC_ENABLED;
}
static inline int apic_enabled(struct kvm_lapic *apic)
{
	return apic_sw_enabled(apic) &&	apic_hw_enabled(apic);
}
static inline int kvm_apic_id(struct kvm_lapic *apic)
{
	return (apic_get_reg(apic, APIC_ID) >> 24) & 0xff;
}
static inline int apic_lvt_enabled(struct kvm_lapic *apic, int lvt_type)
{
	return !(apic_get_reg(apic, lvt_type) & APIC_LVT_MASKED);
}
static inline int apic_lvt_vector(struct kvm_lapic *apic, int lvt_type)
{
	return apic_get_reg(apic, lvt_type) & APIC_VECTOR_MASK;
}
static inline int apic_lvtt_period(struct kvm_lapic *apic)
{
	return apic_get_reg(apic, APIC_LVTT) & APIC_LVT_TIMER_PERIODIC;
}
static inline int apic_lvt_nmi_mode(u32 lvt_val)
{
	return (lvt_val & (APIC_MODE_MASK | APIC_LVT_MASKED)) == APIC_DM_NMI;
}
static inline int apic_test_and_set_irr(int vec, struct kvm_lapic *apic)
{
	return apic_test_and_set_vector(vec, apic->regs + APIC_IRR);
}
static inline void apic_clear_irr(int vec, struct kvm_lapic *apic)
{
	apic_clear_vector(vec, apic->regs + APIC_IRR);
}
int kvm_apic_match_physical_addr(struct kvm_lapic *apic, u16 dest)
{
	return kvm_apic_id(apic) == dest;
}
u64 kvm_lapic_get_base(struct kvm_vcpu *vcpu)
{
	return vcpu->arch.apic_base;
}
void kvm_mmu_set_base_ptes(u64 base_pte)
{
	shadow_base_present_pte = base_pte;
}
static int is_write_protection(struct kvm_vcpu *vcpu)
{
	return vcpu->arch.cr0 & X86_CR0_WP;
}
static int is_cpuid_PSE36(void)
{
	return 1;
}
static int is_nx(struct kvm_vcpu *vcpu)
{
	return vcpu->arch.shadow_efer & EFER_NX;
}
static int is_present_pte(unsigned long pte)
{
	return pte & PT_PRESENT_MASK;
}
static int is_shadow_present_pte(u64 pte)
{
	return pte != shadow_trap_nonpresent_pte
		&& pte != shadow_notrap_nonpresent_pte;
}
static int is_large_pte(u64 pte)
{
	return pte & PT_PAGE_SIZE_MASK;
}
static int is_writeble_pte(unsigned long pte)
{
	return pte & PT_WRITABLE_MASK;
}
static int is_dirty_pte(unsigned long pte)
{
	return pte & shadow_dirty_mask;
}
static int is_rmap_pte(u64 pte)
{
	return is_shadow_present_pte(pte);
}
static pfn_t spte_to_pfn(u64 pte)
{
	return (pte & PT64_BASE_ADDR_MASK) >> PAGE_SHIFT;
}
static struct kvm_pte_chain *mmu_alloc_pte_chain(struct kvm_vcpu *vcpu)
{
	return mmu_memory_cache_alloc(&vcpu->arch.mmu_pte_chain_cache,
				      sizeof(struct kvm_pte_chain));
}
static void mmu_free_pte_chain(struct kvm_pte_chain *pc)
{
	kfree(pc);
}
static struct kvm_rmap_desc *mmu_alloc_rmap_desc(struct kvm_vcpu *vcpu)
{
	return mmu_memory_cache_alloc(&vcpu->arch.mmu_rmap_desc_cache,
				      sizeof(struct kvm_rmap_desc));
}
static void mmu_free_rmap_desc(struct kvm_rmap_desc *rd)
{
	kfree(rd);
}
int kvm_unmap_hva(struct kvm *kvm, unsigned long hva)
{
	return kvm_handle_hva(kvm, hva, kvm_unmap_rmapp);
}
int kvm_age_hva(struct kvm *kvm, unsigned long hva)
{
	return kvm_handle_hva(kvm, hva, kvm_age_rmapp);
}
static unsigned kvm_page_table_hashfn(gfn_t gfn)
{
	return gfn & ((1 << KVM_MMU_HASH_SHIFT) - 1);
}
static int nonpaging_sync_page(struct kvm_vcpu *vcpu,
			       struct kvm_mmu_page *sp)
{
	return 1;
}
static void kvm_mmu_put_page(struct kvm_mmu_page *sp, u64 *parent_pte)
{
	mmu_page_remove_parent_pte(sp, parent_pte);
}
static gpa_t nonpaging_gva_to_gpa(struct kvm_vcpu *vcpu, gva_t vaddr)
{
	return vaddr;
}
static void nonpaging_free(struct kvm_vcpu *vcpu)
{
	mmu_free_roots(vcpu);
}
static void inject_page_fault(struct kvm_vcpu *vcpu,
			      u64 addr,
			      u32 err_code)
{
	kvm_inject_page_fault(vcpu, addr, err_code);
}
static void paging_free(struct kvm_vcpu *vcpu)
{
	nonpaging_free(vcpu);
}
static int paging64_init_context(struct kvm_vcpu *vcpu)
{
	return paging64_init_context_common(vcpu, PT64_ROOT_LEVEL);
}
static int paging32E_init_context(struct kvm_vcpu *vcpu)
{
	return paging64_init_context_common(vcpu, PT32E_ROOT_LEVEL);
}
void kvm_mmu_unload(struct kvm_vcpu *vcpu)
{
	mmu_free_roots(vcpu);
}
void kvm_enable_tdp(void)
{
	tdp_enabled = true;
}
void kvm_disable_tdp(void)
{
	tdp_enabled = false;
}
static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)
{
	return container_of(vcpu, struct vcpu_svm, vcpu);
}
static inline bool is_nested(struct vcpu_svm *svm)
{
	return svm->nested_vmcb;
}
static inline u32 svm_has(u32 feat)
{
	return svm_features & feat;
}
static inline void kvm_write_cr2(unsigned long val)
{
	asm volatile ("mov %0, %%cr2" :: "r" (val));
}
static inline void force_new_asid(struct kvm_vcpu *vcpu)
{
	to_svm(vcpu)->asid_generation--;
}
static inline void flush_guest_tlb(struct kvm_vcpu *vcpu)
{
	force_new_asid(vcpu);
}
static void svm_hardware_disable(void *garbage)
{
	cpu_svm_disable();
}
static unsigned long svm_get_rflags(struct kvm_vcpu *vcpu)
{
	return to_svm(vcpu)->vmcb->save.rflags;
}
static void svm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)
{
	to_svm(vcpu)->vmcb->save.rflags = rflags;
}
static void svm_set_vintr(struct vcpu_svm *svm)
{
	svm->vmcb->control.intercept |= 1ULL << INTERCEPT_VINTR;
}
static void svm_clear_vintr(struct vcpu_svm *svm)
{
	svm->vmcb->control.intercept &= ~(1ULL << INTERCEPT_VINTR);
}
static void load_host_msrs(struct kvm_vcpu *vcpu)
{
	wrmsrl(MSR_GS_BASE, to_svm(vcpu)->host_gs_base);
}
static void save_host_msrs(struct kvm_vcpu *vcpu)
{
	rdmsrl(MSR_GS_BASE, to_svm(vcpu)->host_gs_base);
}
static int nop_on_interception(struct vcpu_svm *svm, struct kvm_run *kvm_run)
{
	return 1;
}
static int nested_svm_vmload(struct vcpu_svm *svm, void *nested_vmcb,
			     void *arg2, void *opaque)
{
	return nested_svm_vmloadsave((struct vmcb *)nested_vmcb, svm->vmcb);
}
static int nested_svm_vmsave(struct vcpu_svm *svm, void *nested_vmcb,
			     void *arg2, void *opaque)
{
	return nested_svm_vmloadsave(svm->vmcb, (struct vmcb *)nested_vmcb);
}
static int msr_interception(struct vcpu_svm *svm, struct kvm_run *kvm_run)
{
	if (svm->vmcb->control.exit_info_1)
		return wrmsr_interception(svm, kvm_run);
	else
		return rdmsr_interception(svm, kvm_run);
}
static int svm_set_tss_addr(struct kvm *kvm, unsigned int addr)
{
	return 0;
}
static void svm_flush_tlb(struct kvm_vcpu *vcpu)
{
	force_new_asid(vcpu);
}
static void svm_check_processor_compat(void *rtn)
{
	*(int *)rtn = 0;
}
static bool svm_cpu_has_accelerated_tpr(void)
{
	return false;
}
static int get_npt_level(void)
{
	return PT64_ROOT_LEVEL;
}
static int svm_get_mt_mask_shift(void)
{
	return 0;
}
static int __init svm_init(void)
{
	return kvm_init(&svm_x86_ops, sizeof(struct vcpu_svm),
			      THIS_MODULE);
}
static void __exit svm_exit(void)
{
	kvm_exit();
}
static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)
{
	return container_of(vcpu, struct vcpu_vmx, vcpu);
}
static inline int is_page_fault(u32 intr_info)
{
	return (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VECTOR_MASK |
			     INTR_INFO_VALID_MASK)) ==
		(INTR_TYPE_HARD_EXCEPTION | PF_VECTOR | INTR_INFO_VALID_MASK);
}
static inline int is_no_device(u32 intr_info)
{
	return (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VECTOR_MASK |
			     INTR_INFO_VALID_MASK)) ==
		(INTR_TYPE_HARD_EXCEPTION | NM_VECTOR | INTR_INFO_VALID_MASK);
}
static inline int is_invalid_opcode(u32 intr_info)
{
	return (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VECTOR_MASK |
			     INTR_INFO_VALID_MASK)) ==
		(INTR_TYPE_HARD_EXCEPTION | UD_VECTOR | INTR_INFO_VALID_MASK);
}
static inline int is_external_interrupt(u32 intr_info)
{
	return (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VALID_MASK))
		== (INTR_TYPE_EXT_INTR | INTR_INFO_VALID_MASK);
}
static inline int cpu_has_vmx_msr_bitmap(void)
{
	return (vmcs_config.cpu_based_exec_ctrl & CPU_BASED_USE_MSR_BITMAPS);
}
static inline int cpu_has_vmx_tpr_shadow(void)
{
	return (vmcs_config.cpu_based_exec_ctrl & CPU_BASED_TPR_SHADOW);
}
static inline int vm_need_tpr_shadow(struct kvm *kvm)
{
	return ((cpu_has_vmx_tpr_shadow()) && (irqchip_in_kernel(kvm)));
}
static inline int cpu_has_secondary_exec_ctrls(void)
{
	return (vmcs_config.cpu_based_exec_ctrl &
		CPU_BASED_ACTIVATE_SECONDARY_CONTROLS);
}
static inline bool cpu_has_vmx_virtualize_apic_accesses(void)
{
	return flexpriority_enabled
		&& (vmcs_config.cpu_based_2nd_exec_ctrl &
		    SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES);
}
static inline int cpu_has_vmx_invept_individual_addr(void)
{
	return (!!(vmx_capability.ept & VMX_EPT_EXTENT_INDIVIDUAL_BIT));
}
static inline int cpu_has_vmx_invept_context(void)
{
	return (!!(vmx_capability.ept & VMX_EPT_EXTENT_CONTEXT_BIT));
}
static inline int cpu_has_vmx_invept_global(void)
{
	return (!!(vmx_capability.ept & VMX_EPT_EXTENT_GLOBAL_BIT));
}
static inline int cpu_has_vmx_ept(void)
{
	return (vmcs_config.cpu_based_2nd_exec_ctrl &
		SECONDARY_EXEC_ENABLE_EPT);
}
static inline int vm_need_ept(void)
{
	return (cpu_has_vmx_ept() && enable_ept);
}
static inline int vm_need_virtualize_apic_accesses(struct kvm *kvm)
{
	return ((cpu_has_vmx_virtualize_apic_accesses()) &&
		(irqchip_in_kernel(kvm)));
}
static inline int cpu_has_vmx_vpid(void)
{
	return (vmcs_config.cpu_based_2nd_exec_ctrl &
		SECONDARY_EXEC_ENABLE_VPID);
}
static inline int cpu_has_virtual_nmis(void)
{
	return vmcs_config.pin_based_exec_ctrl & PIN_BASED_VIRTUAL_NMIS;
}
static u16 vmcs_read16(unsigned long field)
{
	return vmcs_readl(field);
}
static u32 vmcs_read32(unsigned long field)
{
	return vmcs_readl(field);
}
static u64 vmcs_read64(unsigned long field)
{
	return vmcs_readl(field);
}
static void vmcs_write16(unsigned long field, u16 value)
{
	vmcs_writel(field, value);
}
static void vmcs_write32(unsigned long field, u32 value)
{
	vmcs_writel(field, value);
}
static void vmcs_clear_bits(unsigned long field, u32 mask)
{
	vmcs_writel(field, vmcs_readl(field) & ~mask);
}
static void vmcs_set_bits(unsigned long field, u32 mask)
{
	vmcs_writel(field, vmcs_readl(field) | mask);
}
static void vmx_vcpu_put(struct kvm_vcpu *vcpu)
{
	__vmx_load_host_state(to_vmx(vcpu));
}
static unsigned long vmx_get_rflags(struct kvm_vcpu *vcpu)
{
	return vmcs_readl(GUEST_RFLAGS);
}
static bool vmx_exception_injected(struct kvm_vcpu *vcpu)
{
	return false;
}
static void guest_write_tsc(u64 guest_tsc, u64 host_tsc)
{
	vmcs_write64(TSC_OFFSET, guest_tsc - host_tsc);
}
static __init int cpu_has_kvm_support(void)
{
	return cpu_has_vmx();
}
static struct vmcs *alloc_vmcs(void)
{
	return alloc_vmcs_cpu(raw_smp_processor_id());
}
static void free_vmcs(struct vmcs *vmcs)
{
	free_pages((unsigned long)vmcs, vmcs_config.order);
}
static __exit void hardware_unsetup(void)
{
	free_kvm_area();
}
static int handle_tpr_below_threshold(struct kvm_vcpu *vcpu,
				      struct kvm_run *kvm_run)
{
	return 1;
}
static int get_ept_level(void)
{
	return VMX_EPT_DEFAULT_GAW + 1;
}
static int vmx_get_mt_mask_shift(void)
{
	return VMX_EPT_MT_EPTE_SHIFT;
}
u64 kvm_get_apic_base(struct kvm_vcpu *vcpu)
{
	if (irqchip_in_kernel(vcpu->kvm))
		return vcpu->arch.apic_base;
	else
		return vcpu->arch.apic_base;
}
void kvm_inject_nmi(struct kvm_vcpu *vcpu)
{
	vcpu->arch.nmi_pending = 1;
}
static void __queue_exception(struct kvm_vcpu *vcpu)
{
	kvm_x86_ops->queue_exception(vcpu, vcpu->arch.exception.nr,
				     vcpu->arch.exception.has_error_code,
				     vcpu->arch.exception.error_code);
}
unsigned long kvm_get_cr8(struct kvm_vcpu *vcpu)
{
	if (irqchip_in_kernel(vcpu->kvm))
		return kvm_lapic_get_cr8(vcpu);
	else
		return vcpu->arch.cr8;
}
static inline u32 bit(int bitno)
{
	return 1 << (bitno & 31);
}
void kvm_enable_efer_bits(u64 mask)
{
       efer_reserved_bits &= ~mask;
}
int kvm_set_msr(struct kvm_vcpu *vcpu, u32 msr_index, u64 data)
{
	return kvm_x86_ops->set_msr(vcpu, msr_index, data);
}
static int do_set_msr(struct kvm_vcpu *vcpu, unsigned index, u64 *data)
{
	return kvm_set_msr(vcpu, index, *data);
}
int kvm_get_msr(struct kvm_vcpu *vcpu, u32 msr_index, u64 *pdata)
{
	return kvm_x86_ops->get_msr(vcpu, msr_index, pdata);
}
static int kvm_vm_ioctl_get_nr_mmu_pages(struct kvm *kvm)
{
	return kvm->arch.n_alloc_mmu_pages;
}
static unsigned long get_segment_base(struct kvm_vcpu *vcpu, int seg)
{
	return kvm_x86_ops->get_segment_base(vcpu, seg);
}
static struct kvm_io_device *vcpu_find_pio_dev(struct kvm_vcpu *vcpu,
					       gpa_t addr, int len,
					       int is_write)
{
	return kvm_io_bus_find_dev(&vcpu->kvm->pio_bus, addr, len, is_write);
}
static inline gpa_t hc_gpa(struct kvm_vcpu *vcpu, unsigned long a0,
			   unsigned long a1)
{
	if (is_long_mode(vcpu))
		return a0;
	else
		return a0 | ((gpa_t)a1 << 32);
}
static u64 mk_cr_64(u64 curr_cr, u32 new_val)
{
	return (curr_cr & ~((1ULL << 32) - 1)) | new_val;
}
static int dm_request_for_irq_injection(struct kvm_vcpu *vcpu,
					  struct kvm_run *kvm_run)
{
	return (!vcpu->arch.irq_summary &&
		kvm_run->request_interrupt_window &&
		vcpu->arch.interrupt_window_open &&
		(kvm_x86_ops->get_rflags(vcpu) & X86_EFLAGS_IF));
}
void kvm_get_segment(struct kvm_vcpu *vcpu,
		     struct kvm_segment *var, int seg)
{
	kvm_x86_ops->get_segment(vcpu, var, seg);
}
static void kvm_set_segment(struct kvm_vcpu *vcpu,
			struct kvm_segment *var, int seg)
{
	kvm_x86_ops->set_segment(vcpu, var, seg);
}
void kvm_arch_vcpu_free(struct kvm_vcpu *vcpu)
{
	kvm_x86_ops->vcpu_free(vcpu);
}
struct kvm_vcpu *kvm_arch_vcpu_create(struct kvm *kvm,
						unsigned int id)
{
	return kvm_x86_ops->vcpu_create(kvm, id);
}
void kvm_arch_hardware_enable(void *garbage)
{
	kvm_x86_ops->hardware_enable(garbage);
}
void kvm_arch_hardware_disable(void *garbage)
{
	kvm_x86_ops->hardware_disable(garbage);
}
int kvm_arch_hardware_setup(void)
{
	return kvm_x86_ops->hardware_setup();
}
void kvm_arch_hardware_unsetup(void)
{
	kvm_x86_ops->hardware_unsetup();
}
void kvm_arch_check_processor_compat(void *rtn)
{
	kvm_x86_ops->check_processor_compatibility(rtn);
}
void kvm_arch_sync_events(struct kvm *kvm)
{
	kvm_free_all_assigned_devices(kvm);
}
void kvm_arch_flush_shadow(struct kvm *kvm)
{
	kvm_mmu_zap_all(kvm);
}
int kvm_arch_vcpu_runnable(struct kvm_vcpu *vcpu)
{
	return vcpu->arch.mp_state == KVM_MP_STATE_RUNNABLE
	       || vcpu->arch.mp_state == KVM_MP_STATE_SIPI_RECEIVED
	       || vcpu->arch.nmi_pending;
}
static inline unsigned long ad_mask(struct decode_cache *c)
{
	return (1UL << (c->ad_bytes << 3)) - 1;
}
static inline unsigned long
address_mask(struct decode_cache *c, unsigned long reg)
{
	if (c->ad_bytes == sizeof(unsigned long))
		return reg;
	else
		return reg & ad_mask(c);
}
static inline unsigned long
register_address(struct decode_cache *c, unsigned long base, unsigned long reg)
{
	return base + address_mask(c, reg);
}
static inline void jmp_rel(struct decode_cache *c, int rel)
{
	register_address_increment(c, &c->eip, rel);
}
static unsigned long es_base(struct x86_emulate_ctxt *ctxt)
{
	return seg_base(ctxt, VCPU_SREG_ES);
}
static unsigned long ss_base(struct x86_emulate_ctxt *ctxt)
{
	return seg_base(ctxt, VCPU_SREG_SS);
}
static unsigned long save_fl(void)
{
	return lguest_data.irq_enabled;
}
static void restore_fl(unsigned long flags)
{
	lguest_data.irq_enabled = flags;
}
static void irq_disable(void)
{
	lguest_data.irq_enabled = 0;
}
static void irq_enable(void)
{
	lguest_data.irq_enabled = X86_EFLAGS_IF;
}
static unsigned long lguest_read_cr0(void)
{
	return current_cr0;
}
static unsigned long lguest_read_cr2(void)
{
	return lguest_data.cr2;
}
static unsigned long lguest_read_cr3(void)
{
	return lguest_data.pgdir;
}
static unsigned long lguest_read_cr4(void)
{
	return 0;
}
static void lguest_flush_tlb_single(unsigned long addr)
{
	lazy_hcall(LHCALL_SET_PTE, lguest_data.pgdir, addr, 0);
}
static void lguest_flush_tlb_user(void)
{
	lazy_hcall(LHCALL_FLUSH_TLB, 0, 0, 0);
}
static void lguest_flush_tlb_kernel(void)
{
	lazy_hcall(LHCALL_FLUSH_TLB, 1, 0, 0);
}
static void disable_lguest_irq(unsigned int irq)
{
	set_bit(irq, lguest_data.blocked_interrupts);
}
static void enable_lguest_irq(unsigned int irq)
{
	clear_bit(irq, lguest_data.blocked_interrupts);
}
static unsigned long lguest_get_wallclock(void)
{
	return lguest_data.time.tv_sec;
}
static unsigned long lguest_tsc_khz(void)
{
	return lguest_data.tsc_khz;
}
static void lguest_load_sp0(struct tss_struct *tss,
			    struct thread_struct *thread)
{
	lazy_hcall(LHCALL_SET_STACK, __KERNEL_DS|0x1, thread->sp0,
		   THREAD_SIZE/PAGE_SIZE);
}
static u32 lguest_apic_read(u32 reg)
{
	return 0;
}
static u64 lguest_apic_icr_read(void)
{
	return 0;
}
static void lguest_apic_icr_write(u32 low, u32 id)
{
	WARN_ON(1);
}
static void lguest_apic_wait_icr_idle(void)
{
	return;
}
static u32 lguest_apic_safe_wait_icr_idle(void)
{
	return 0;
}
static void lguest_safe_halt(void)
{
	hcall(LHCALL_HALT, 0, 0, 0);
}
static void lguest_power_off(void)
{
	hcall(LHCALL_SHUTDOWN, __pa("Power down"), LGUEST_SHUTDOWN_POWEROFF, 0);
}
static void lguest_restart(char *reason)
{
	hcall(LHCALL_SHUTDOWN, __pa(reason), LGUEST_SHUTDOWN_RESTART, 0);
}
__wsum csum_partial(const void *buff, int len, __wsum sum)
{
	return (__force __wsum)add32_with_carry(do_csum(buff, len),
						(__force u32)sum);
}
__sum16 ip_compute_csum(const void *buff, int len)
{
	return csum_fold(csum_partial(buff,len,0));
}
static void delay_loop(unsigned long loops)
{
	asm volatile(
		"	test %0,%0	\n"
		"	jz 3f		\n"
		"	jmp 1f		\n"

		".align 16		\n"
		"1:	jmp 2f		\n"

		".align 16		\n"
		"2:	dec %0		\n"
		"	jnz 2b		\n"
		"3:	dec %0		\n"

		: /* we don't need output */
		:"a" (loops)
	);
}
void use_tsc_delay(void)
{
	delay_fn = delay_tsc;
}
void __delay(unsigned long loops)
{
	delay_fn(loops);
}
void __udelay(unsigned long usecs)
{
	__const_udelay(usecs * 0x000010c7); /* 2**32 / 1000000 (rounded up) */
}
void __ndelay(unsigned long nsecs)
{
	__const_udelay(nsecs * 0x00005); /* 2**32 / 1000000000 (rounded up) */
}
void __memcpy_toio(unsigned long dst, const void *src, unsigned len)
{
	__inline_memcpy((void *)dst, src, len);
}
void __memcpy_fromio(void *dst, unsigned long src, unsigned len)
{
	__inline_memcpy(dst, (const void *)src, len);
}
void memset_io(volatile void __iomem *a, int b, size_t c)
{
	memset((void *)a, b, c);
}
void *memcpy(void *to, const void *from, size_t n)
{
	return __memcpy3d(to, from, n);
}
void *memset(void *s, int c, size_t count)
{
	return __memset(s, c, count);
}
void __init pre_intr_init_hook(void)
{
	init_ISA_irqs();
}
static void voyager_disable_tsc(void)
{
	setup_clear_cpu_cap(X86_FEATURE_TSC);
}
void __init pre_setup_arch_hook(void)
{
	voyager_disable_tsc();
}
void __init pre_time_init_hook(void)
{
	voyager_disable_tsc();
}
static void voyager_dump(int dummy1, struct tty_struct *dummy3)
{
	voyager_smp_dump();
}
void voyager_system_interrupt(int cpl, void *dev_id)
{
	printk("Voyager: detected system interrupt\n");
}
void machine_emergency_restart(void)
{
	machine_restart(NULL);
}
void machine_halt(void)
{
	machine_power_off();
}
int voyager_cat_readb(__u8 module, __u8 asic, int reg)
{
	return 0;
}
static inline void send_one_QIC_CPI(__u8 cpu, __u8 cpi)
{
	voyager_quad_cpi_addr[cpu]->qic_cpi[cpi].cpi =
	    (smp_processor_id() << 16) + cpi;
}
static void __init initialize_secondary(void)
{
	asm volatile ("movl %0,%%esp\n\t"
		      "jmp *%1"::"r" (current->thread.sp),
		      "r"(current->thread.ip));
}
void flush_tlb_all(void)
{
	on_each_cpu(do_flush_tlb_all, 0, 1);
}
static void voyager_smp_send_reschedule(int cpu)
{
	send_one_CPI(cpu, VIC_RESCHEDULE_CPI);
}
int safe_smp_processor_id(void)
{
	return hard_smp_processor_id();
}
static void voyager_smp_send_stop(void)
{
	smp_call_function(smp_stop_cpu_function, NULL, 1);
}
static void __init voyager_smp_prepare_cpus(unsigned int max_cpus)
{
	smp_boot_cpus();
}
static void __init voyager_smp_cpus_done(unsigned int max_cpus)
{
	zap_low_mappings();
}
void __init smp_setup_processor_id(void)
{
	current_thread_info()->cpu = hard_smp_processor_id();
}
static void voyager_send_call_func_single(int cpu)
{
	send_CPI(1 << cpu, VIC_CALL_FUNCTION_SINGLE_CPI);
}
static void __exit voyager_thread_stop(void)
{
	kthread_stop(voyager_thread);
}
void FPU_illegal(void)
{
	math_abort(FPU_info, SIGILL);
}
void finit_(void)
{
	(finit_table[FPU_rm]) ();
}
void fstsw_(void)
{
	(fstsw_table[FPU_rm]) ();
}
void fp_nop(void)
{
	(fp_nop_table[FPU_rm]) ();
}
void ffree_(void)
{
	FPU_settagi(FPU_rm, TAG_Empty);
}
void fst_i_(void)
{
	FPU_copy_to_regi(&st(0), FPU_gettag0(), FPU_rm);
}
void FPU_etc(void)
{
	(fp_etc_table[FPU_rm]) (&st(0), FPU_gettag0());
}
int FPU_gettag0(void)
{
	return (fpu_tag_word >> ((top & 7) * 2)) & 3;
}
int FPU_gettagi(int stnr)
{
	return (fpu_tag_word >> (((top + stnr) & 7) * 2)) & 3;
}
int FPU_gettag(int regnr)
{
	return (fpu_tag_word >> ((regnr & 7) * 2)) & 3;
}
int isNaN(FPU_REG const *ptr)
{
	return ((exponent(ptr) == EXP_BIAS + EXP_OVER)
		&& !((ptr->sigh == 0x80000000) && (ptr->sigl == 0)));
}
static void fcos(FPU_REG *st0_ptr, u_char st0_tag)
{
	f_cos(st0_ptr, st0_tag);
}
static void fprem(FPU_REG *st0_ptr, u_char st0_tag)
{
	do_fprem(st0_ptr, st0_tag, RC_CHOP);
}
static void fprem1(FPU_REG *st0_ptr, u_char st0_tag)
{
	do_fprem(st0_ptr, st0_tag, RC_RND);
}
void FPU_triga(void)
{
	(trig_table_a[FPU_rm]) (&st(0), FPU_gettag0());
}
void FPU_trigb(void)
{
	(trig_table_b[FPU_rm]) (&st(0), FPU_gettag0());
}
void fcom_st(void)
{
	compare_st_st(FPU_rm);
}
void fucom_(void)
{
	compare_u_st_st(FPU_rm);
}
static void fld1(int rc)
{
	fld_const(&CONST_1, 0, TAG_Valid);
}

static void fldl2t(int rc)
{
	fld_const(&CONST_L2T, (rc == RC_UP) ? 1 : 0, TAG_Valid);
}

static void fldl2e(int rc)
{
	fld_const(&CONST_L2E, DOWN_OR_CHOP(rc) ? -1 : 0, TAG_Valid);
}

static void fldpi(int rc)
{
	fld_const(&CONST_PI, DOWN_OR_CHOP(rc) ? -1 : 0, TAG_Valid);
}

static void fldlg2(int rc)
{
	fld_const(&CONST_LG2, DOWN_OR_CHOP(rc) ? -1 : 0, TAG_Valid);
}

static void fldln2(int rc)
{
	fld_const(&CONST_LN2, DOWN_OR_CHOP(rc) ? -1 : 0, TAG_Valid);
}

static void fldz(int rc)
{
	fld_const(&CONST_Z, 0, TAG_Zero);
}
void fconst(void)
{
	(constants_table[FPU_rm]) (control_word & CW_RC);
}
static unsigned long normalize_addr(unsigned long u)
{
	return (signed long)(u << 16) >> 16;
}
static int ptdump_open(struct inode *inode, struct file *filp)
{
	return single_open(filp, ptdump_show, NULL);
}
static noinline void bad_area_nosemaphore(struct pt_regs *regs,
			unsigned long error_code, unsigned long address)
{
	__bad_area_nosemaphore(regs, error_code, address, SEGV_MAPERR);
}
static noinline void bad_area(struct pt_regs *regs,
			unsigned long error_code, unsigned long address)
{
	__bad_area(regs, error_code, address, SEGV_MAPERR);
}
static noinline void bad_area_access_error(struct pt_regs *regs,
			unsigned long error_code, unsigned long address)
{
	__bad_area(regs, error_code, address, SEGV_ACCERR);
}
static int fault_in_kernel_space(unsigned long address)
{
	return address >= TASK_SIZE;
}
static inline pte_t gup_get_pte(pte_t *ptep)
{
	return *ptep;
}
void *kmap_atomic(struct page *page, enum km_type type)
{
	return kmap_atomic_prot(page, type, kmap_prot);
}
struct page *
follow_huge_addr(struct mm_struct *mm, unsigned long address, int write)
{
	return ERR_PTR(-EINVAL);
}
int pmd_huge(pmd_t pmd)
{
	return !!(pmd_val(pmd) & _PAGE_PSE);
}
int pud_huge(pud_t pud)
{
	return !!(pud_val(pud) & _PAGE_PSE);
}
static inline pte_t *kmap_get_fixmap_pte(unsigned long vaddr)
{
	return pte_offset_kernel(pmd_offset(pud_offset(pgd_offset_k(vaddr),
			vaddr), vaddr), vaddr);
}
static inline void save_pg_dir(void)
{
	memcpy(swsusp_pg_dir, swapper_pg_dir, PAGE_SIZE);
}
void free_initmem(void)
{
	free_init_pages("unused kernel memory",
			(unsigned long)(&__init_begin),
			(unsigned long)(&__init_end));
}
void free_initrd_mem(unsigned long start, unsigned long end)
{
	free_init_pages("initrd memory", start, end);
}
int __init reserve_bootmem_generic(unsigned long phys, unsigned long len,
				   int flags)
{
	return reserve_bootmem(phys, len, flags);
}
void __init init_extra_mapping_wb(unsigned long phys, unsigned long size)
{
	__init_extra_mapping(phys, size, PAGE_KERNEL_LARGE);
}
void __init init_extra_mapping_uc(unsigned long phys, unsigned long size)
{
	__init_extra_mapping(phys, size, PAGE_KERNEL_LARGE_NOCACHE);
}
int memory_add_physaddr_to_nid(u64 start)
{
	return 0;
}
void free_initmem(void)
{
	free_init_pages("unused kernel memory",
			(unsigned long)(&__init_begin),
			(unsigned long)(&__init_end));
}
void free_initrd_mem(unsigned long start, unsigned long end)
{
	free_init_pages("initrd memory", start, end);
}
int in_gate_area_no_task(unsigned long addr)
{
	return (addr >= VSYSCALL_START) && (addr < VSYSCALL_END);
}
static inline int phys_addr_valid(unsigned long addr)
{
	return addr < (1UL << boot_cpu_data.x86_phys_bits);
}
static inline int phys_addr_valid(unsigned long addr)
{
	return 1;
}
void __iomem *ioremap_wc(resource_size_t phys_addr, unsigned long size)
{
	if (pat_enabled)
		return __ioremap_caller(phys_addr, size, _PAGE_CACHE_WC,
					__builtin_return_address(0));
	else
		return ioremap_nocache(phys_addr, size);
}
void __iomem *ioremap_cache(resource_size_t phys_addr, unsigned long size)
{
	return __ioremap_caller(phys_addr, size, _PAGE_CACHE_WB,
				__builtin_return_address(0));
}
void __iomem *ioremap_prot(resource_size_t phys_addr, unsigned long size,
				unsigned long prot_val)
{
	return __ioremap_caller(phys_addr, size, (prot_val & _PAGE_CACHE_MASK),
				__builtin_return_address(0));
}
static inline pte_t * __init early_ioremap_pte(unsigned long addr)
{
	return &bm_pte[pte_index(addr)];
}
void __init early_ioremap_reset(void)
{
	after_paging_init = 1;
}
void __init __iomem *early_ioremap(unsigned long phys_addr, unsigned long size)
{
	return __early_ioremap(phys_addr, size, PAGE_KERNEL_IO);
}
void __init __iomem *early_memremap(unsigned long phys_addr, unsigned long size)
{
	return __early_ioremap(phys_addr, size, PAGE_KERNEL);
}
void __this_fixmap_does_not_exist(void)
{
	WARN_ON(1);
}
bool kmemcheck_page_is_tracked(struct page *p)
{
	return kmemcheck_pte_lookup((unsigned long) page_address(p));
}
static bool opcode_is_prefix(uint8_t b)
{
	return
		b == 0xf0 || b == 0xf2 || b == 0xf3
		|| b == 0x2e || b == 0x36 || b == 0x3e || b == 0x26
		|| b == 0x64 || b == 0x65 || b == 0x2e || b == 0x3e
		|| b == 0x66
		|| b == 0x67;
}
static bool opcode_is_rex_prefix(uint8_t b)
{
	return (b & 0xf0) == 0x40;
}
void kmemcheck_mark_unallocated(void *address, unsigned int n)
{
	mark_shadow(address, n, KMEMCHECK_SHADOW_UNALLOCATED);
}
void kmemcheck_mark_uninitialized(void *address, unsigned int n)
{
	mark_shadow(address, n, KMEMCHECK_SHADOW_UNINITIALIZED);
}
void kmemcheck_mark_initialized(void *address, unsigned int n)
{
	mark_shadow(address, n, KMEMCHECK_SHADOW_INITIALIZED);
}
void kmemcheck_mark_freed(void *address, unsigned int n)
{
	mark_shadow(address, n, KMEMCHECK_SHADOW_FREED);
}
static struct list_head *kmmio_page_list(unsigned long page)
{
	return &kmmio_page_table[hash_long(page, KMMIO_PAGE_HASH_BITS)];
}
static void arm_kmmio_fault_page(unsigned long page, unsigned int *pglevel)
{
	set_page_present(page & PAGE_MASK, false, pglevel);
}
static void disarm_kmmio_fault_page(unsigned long page, unsigned int *pglevel)
{
	set_page_present(page & PAGE_MASK, true, pglevel);
}
static int mmap_is_ia32(void)
{
	return 1;
}
static unsigned long mmap_legacy_base(void)
{
	if (mmap_is_ia32())
		return TASK_UNMAPPED_BASE;
	else
		return TASK_UNMAPPED_BASE + mmap_rnd();
}
static bool is_enabled(void)
{
	return atomic_read(&mmiotrace_enabled);
}
int early_pfn_to_nid(unsigned long pfn)
{
	return phys_to_nid(pfn << PAGE_SHIFT);
}
void __cpuinit numa_clear_node(int cpu)
{
	numa_set_node(cpu, NUMA_NO_NODE);
}
void __cpuinit numa_add_cpu(int cpu)
{
	cpu_set(cpu, node_to_cpumask_map[early_cpu_to_node(cpu)]);
}
void __cpuinit numa_remove_cpu(int cpu)
{
	cpu_clear(cpu, node_to_cpumask_map[early_cpu_to_node(cpu)]);
}
void __cpuinit numa_add_cpu(int cpu)
{
	numa_set_cpumask(cpu, 1);
}
void __cpuinit numa_remove_cpu(int cpu)
{
	numa_set_cpumask(cpu, 0);
}
static int pte_testbit(pte_t pte)
{
	return pte_flags(pte) & _PAGE_UNUSED1;
}
static inline unsigned long highmap_start_pfn(void)
{
	return __pa(_text) >> PAGE_SHIFT;
}
static inline unsigned long highmap_end_pfn(void)
{
	return __pa(roundup((unsigned long)_end, PMD_SIZE)) >> PAGE_SHIFT;
}
static inline int
within(unsigned long addr, unsigned long start, unsigned long end)
{
	return addr >= start && addr < end;
}
static void __cpa_flush_range(void *arg)
{
	__flush_tlb_all();
}
static inline int cache_attr(pgprot_t attr)
{
	return pgprot_val(attr) &
		(_PAGE_PAT | _PAGE_PAT_LARGE | _PAGE_PWT | _PAGE_PCD);
}
static inline int change_page_attr_set(unsigned long *addr, int numpages,
				       pgprot_t mask, int array)
{
	return change_page_attr_set_clr(addr, numpages, mask, __pgprot(0), 0,
		array);
}
static inline int change_page_attr_clear(unsigned long *addr, int numpages,
					 pgprot_t mask, int array)
{
	return change_page_attr_set_clr(addr, numpages, __pgprot(0), mask, 0,
		array);
}
int _set_memory_uc(unsigned long addr, int numpages)
{
	return change_page_attr_set(&addr, numpages,
				    __pgprot(_PAGE_CACHE_UC_MINUS), 0);
}
int _set_memory_wc(unsigned long addr, int numpages)
{
	return change_page_attr_set(&addr, numpages,
				    __pgprot(_PAGE_CACHE_WC), 0);
}
int _set_memory_wb(unsigned long addr, int numpages)
{
	return change_page_attr_clear(&addr, numpages,
				      __pgprot(_PAGE_CACHE_MASK), 0);
}
int set_memory_x(unsigned long addr, int numpages)
{
	return change_page_attr_clear(&addr, numpages, __pgprot(_PAGE_NX), 0);
}
int set_memory_nx(unsigned long addr, int numpages)
{
	return change_page_attr_set(&addr, numpages, __pgprot(_PAGE_NX), 0);
}
int set_memory_ro(unsigned long addr, int numpages)
{
	return change_page_attr_clear(&addr, numpages, __pgprot(_PAGE_RW), 0);
}
int set_memory_rw(unsigned long addr, int numpages)
{
	return change_page_attr_set(&addr, numpages, __pgprot(_PAGE_RW), 0);
}
int set_memory_np(unsigned long addr, int numpages)
{
	return change_page_attr_clear(&addr, numpages, __pgprot(_PAGE_PRESENT), 0);
}
int set_memory_4k(unsigned long addr, int numpages)
{
	return change_page_attr_set_clr(&addr, numpages, __pgprot(0),
					__pgprot(0), 1, 0);
}
static inline void pat_disable(const char *reason)
{
	(void)reason;
}
pgprot_t phys_mem_access_prot(struct file *file, unsigned long pfn,
				unsigned long size, pgprot_t vma_prot)
{
	return vma_prot;
}
static inline int range_is_allowed(unsigned long pfn, unsigned long size)
{
	return 1;
}
pgprot_t pgprot_writecombine(pgprot_t prot)
{
	if (pat_enabled)
		return __pgprot(pgprot_val(prot) | _PAGE_CACHE_WC);
	else
		return pgprot_noncached(prot);
}
static int memtype_seq_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &memtype_seq_ops);
}
pte_t *pte_alloc_one_kernel(struct mm_struct *mm, unsigned long address)
{
	return (pte_t *)__get_free_page(GFP_KERNEL|__GFP_REPEAT|__GFP_ZERO);
}
void native_set_fixmap(enum fixed_addresses idx, unsigned long phys, pgprot_t flags)
{
	__native_set_fixmap(idx, pfn_pte(phys >> PAGE_SHIFT, flags));
}
static __init inline int srat_disabled(void)
{
	return numa_off || acpi_numa < 0;
}
static __init int setup_node(int pxm)
{
	return acpi_map_pxm_to_node(pxm);
}
static __init inline int srat_disabled(void)
{
	return numa_off || acpi_numa < 0;
}
static int update_end_of_memory(unsigned long end) {return -1;}
static int hotadd_enough_memory(struct bootnode *nd) {return 1;}
static inline int save_add_info(void) {return 1;}
static inline int save_add_info(void) {return 0;}
static int null_slit_node_compare(int a, int b)
{
	return node_to_pxm(a) == node_to_pxm(b);
}
static int null_slit_node_compare(int a, int b)
{
	return a == b;
}
static void __exit cleanup(void)
{
	pr_debug(MODULE_NAME ": unloaded.\n");
}
void flush_tlb_all(void)
{
	on_each_cpu(do_flush_tlb_all, NULL, 1);
}
static int backtrace_stack(void *data, char *name)
{
	return 0;
}
void oprofile_arch_exit(void)
{
	op_nmi_exit();
}
static void nmi_stop(void)
{
	on_each_cpu(nmi_cpu_stop, NULL, 1);
}
static inline void apic_init_ibs_nmi_per_cpu(void *arg)
{
	ibs_eilvt_off = setup_APIC_eilvt_ibs(0, APIC_EILVT_MSG_NMI, 0);
}
static inline void apic_clear_ibs_nmi_per_cpu(void *arg)
{
	setup_APIC_eilvt_ibs(0, APIC_EILVT_MSG_FIX, 1);
}
static void op_amd_exit(void)
{
	ibs_exit();
}
static int op_amd_init(struct oprofile_operations *ops)
{
	return 0;
}
static int inline addr_increment(void)
{
	return smp_num_siblings == 2 ? 2 : 1;
}
static int __init early_fill_mp_bus_info(void) { return 0; }
static int pci_read(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 *value)
{
	return raw_pci_read(pci_domain_nr(bus), bus->number,
				 devfn, where, size, value);
}
static int pci_write(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 value)
{
	return raw_pci_write(pci_domain_nr(bus), bus->number,
				  devfn, where, size, value);
}
void __init dmi_check_skip_isa_align(void)
{
	dmi_check_system(can_skip_pciprobe_dmi_table);
}
void __init dmi_check_pciprobe(void)
{
	dmi_check_system(pciprobe_dmi_table);
}
unsigned int pcibios_assign_all_busses(void)
{
	return (pci_probe & PCI_ASSIGN_ALL_BUSSES) ? 1 : 0;
}
int pci_ext_cfg_avail(struct pci_dev *dev)
{
	if (raw_pci_ext_ops)
		return 1;
	else
		return 0;
}
struct pci_bus * __devinit pci_scan_bus_with_sysdata(int busno)
{
	return pci_scan_bus_on_node(busno, &pci_root_ops, -1);
}
int early_pci_allowed(void)
{
	return (pci_probe & (PCI_PROBE_CONF1|PCI_PROBE_NOEARLY)) ==
			PCI_PROBE_CONF1;
}
static void __devinit pci_fixup_piix4_acpi(struct pci_dev *d)
{
	d->irq = 9;
}
static int quirk_pcie_aspm_read(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 *value)
{
	return raw_pci_read(pci_domain_nr(bus), bus->number,
						devfn, where, size, value);
}
static void __devinit pci_siemens_interrupt_controller(struct pci_dev *dev)
{
	dev->resource[0].flags |= IORESOURCE_PCI_FIXED;
}
static void amd_cpu_pci_cfg_space_size(struct pci_dev *dev)
{
	dev->cfg_size = pci_cfg_space_size_ext(dev);
}
static int pirq_via_get(struct pci_dev *router, struct pci_dev *dev, int pirq)
{
	return read_config_nybble(router, 0x55, pirq == 4 ? 5 : pirq);
}
static int pirq_opti_get(struct pci_dev *router, struct pci_dev *dev, int pirq)
{
	return read_config_nybble(router, 0xb8, pirq >> 4);
}
static int pirq_cyrix_get(struct pci_dev *router, struct pci_dev *dev, int pirq)
{
	return read_config_nybble(router, 0x5C, (pirq-1)^1);
}
void __init pci_mmcfg_early_init(void)
{
	__pci_mmcfg_init(1);
}
void __init pci_mmcfg_late_init(void)
{
	__pci_mmcfg_init(0);
}
static int is_simulated(unsigned int bus, unsigned int devfn)
{
	return (!bus && ((PCI_SLOT(devfn) == NB_SLOT) ||
			(PCI_SLOT(devfn) == SB_SLOT)));
}
static int pci_visws_enable_irq(struct pci_dev *dev) { return 0; }
void __init pcibios_update_irq(struct pci_dev *dev, int irq)
{
	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq);
}
void save_processor_state(void)
{
	__save_processor_state(&saved_context);
}
static void do_fpu_end(void)
{
	kernel_fpu_end();
}
void restore_processor_state(void)
{
	__restore_processor_state(&saved_context);
}
void save_processor_state(void)
{
	__save_processor_state(&saved_context);
}
static void do_fpu_end(void)
{
	kernel_fpu_end();
}
void restore_processor_state(void)
{
	__restore_processor_state(&saved_context);
}
int in_gate_area_no_task(unsigned long addr)
{
	return 0;
}
static void xen_set_debugreg(int reg, unsigned long val)
{
	HYPERVISOR_set_debugreg(reg, val);
}
static unsigned long xen_get_debugreg(int reg)
{
	return HYPERVISOR_get_debugreg(reg);
}
static unsigned long xen_store_tr(void)
{
	return 0;
}
static u32 xen_apic_read(u32 reg)
{
	return 0;
}
static void xen_apic_write(u32 reg, u32 val)
{
	WARN_ON(1);
}
static u64 xen_apic_icr_read(void)
{
	return 0;
}
static void xen_apic_icr_write(u32 low, u32 id)
{
	WARN_ON(1);
}
static void xen_apic_wait_icr_idle(void)
{
        return;
}
static u32 xen_safe_apic_wait_icr_idle(void)
{
        return 0;
}
static void xen_restart(char *msg)
{
	xen_reboot(SHUTDOWN_reboot);
}
static void xen_emergency_restart(void)
{
	xen_reboot(SHUTDOWN_reboot);
}
static void xen_machine_halt(void)
{
	xen_reboot(SHUTDOWN_poweroff);
}
static void xen_crash_shutdown(struct pt_regs *regs)
{
	xen_reboot(SHUTDOWN_crash);
}
void arch_gnttab_unmap_shared(struct grant_entry *shared,
			      unsigned long nr_gframes)
{
	apply_to_page_range(&init_mm, (unsigned long)shared,
			    PAGE_SIZE * nr_gframes, unmap_pte_fn, NULL);
}
void xen_force_evtchn_callback(void)
{
	(void)HYPERVISOR_xen_version(0, NULL);
}
void __init xen_init_irq_ops()
{
	pv_irq_ops = xen_irq_ops;
}
static inline unsigned p2m_index(unsigned long pfn)
{
	return pfn % P2M_ENTRIES_PER_PAGE;
}
void set_pte_mfn(unsigned long vaddr, unsigned long mfn, pgprot_t flags)
{
	set_pte_vaddr(vaddr, mfn_pte(mfn, flags));
}
pte_t xen_ptep_modify_prot_start(struct mm_struct *mm,
				 unsigned long addr, pte_t *ptep)
{
	return *ptep;
}
pteval_t xen_pte_val(pte_t pte)
{
	return pte_mfn_to_pfn(pte.pte);
}
pgdval_t xen_pgd_val(pgd_t pgd)
{
	return pte_mfn_to_pfn(pgd.pgd);
}
pmdval_t xen_pmd_val(pmd_t pmd)
{
	return pte_mfn_to_pfn(pmd.pmd);
}
void xen_set_pte_atomic(pte_t *ptep, pte_t pte)
{
	set_64bit((u64 *)ptep, native_pte_val(pte));
}
void xen_pmd_clear(pmd_t *pmdp)
{
	set_pmd(pmdp, __pmd(0));
}
pudval_t xen_pud_val(pud_t pud)
{
	return pte_mfn_to_pfn(pud.pud);
}
static int xen_pgd_walk(struct mm_struct *mm,
			int (*func)(struct mm_struct *mm, struct page *,
				    enum pt_level),
			unsigned long limit)
{
	return __xen_pgd_walk(mm, mm->pgd, func, limit);
}
static void xen_pgd_pin(struct mm_struct *mm)
{
	__xen_pgd_pin(mm, mm->pgd);
}
void __init xen_mark_init_mm_pinned(void)
{
	xen_pgd_walk(&init_mm, xen_mark_pinned, FIXADDR_TOP);
}
static void xen_pgd_unpin(struct mm_struct *mm)
{
	__xen_pgd_unpin(mm, mm->pgd);
}
static __init void xen_pagetable_setup_done(pgd_t *base)
{
	xen_setup_shared_info();
}
static void xen_write_cr2(unsigned long cr2)
{
	percpu_read(xen_vcpu)->arch.cr2 = cr2;
}
static unsigned long xen_read_cr2(void)
{
	return percpu_read(xen_vcpu)->arch.cr2;
}
unsigned long xen_read_cr2_direct(void)
{
	return percpu_read(xen_vcpu_info.arch.cr2);
}
static unsigned long xen_read_cr3(void)
{
	return percpu_read(xen_cr3);
}
static void set_current_cr3(void *v)
{
	percpu_write(xen_current_cr3, (unsigned long)v);
}
static void xen_release_pte_init(unsigned long pfn)
{
	make_lowmem_page_readwrite(__va(PFN_PHYS(pfn)));
}
static void xen_alloc_pte(struct mm_struct *mm, unsigned long pfn)
{
	xen_alloc_ptpage(mm, pfn, PT_PTE);
}
static void xen_alloc_pmd(struct mm_struct *mm, unsigned long pfn)
{
	xen_alloc_ptpage(mm, pfn, PT_PMD);
}
static void xen_release_pte(unsigned long pfn)
{
	xen_release_ptpage(pfn, PT_PTE);
}
static void xen_release_pmd(unsigned long pfn)
{
	xen_release_ptpage(pfn, PT_PMD);
}
static void xen_alloc_pud(struct mm_struct *mm, unsigned long pfn)
{
	xen_alloc_ptpage(mm, pfn, PT_PUD);
}
static void xen_release_pud(unsigned long pfn)
{
	xen_release_ptpage(pfn, PT_PUD);
}
static void *__ka(phys_addr_t paddr)
{
	return (void *)(paddr + __START_KERNEL_map);
}
static void *m2v(phys_addr_t maddr)
{
	return __ka(m2p(maddr));
}
static int xen_cpu_disable(void)
{
	return -ENOSYS;
}
static void xen_cpu_die(unsigned int cpu)
{
	BUG();
}
static void xen_play_dead(void)
{
	BUG();
}
static void xen_smp_send_stop(void)
{
	smp_call_function(stop_self, NULL, 0);
}
static void xen_smp_send_reschedule(int cpu)
{
	xen_send_IPI_one(cpu, XEN_RESCHEDULE_VECTOR);
}
static void xen_smp_send_call_function_single_ipi(int cpu)
{
	xen_send_IPI_mask(cpumask_of(cpu),
			  XEN_CALL_FUNCTION_SINGLE_VECTOR);
}
static inline u64 spin_time_start(void)
{
	return xen_clocksource_read();
}
static inline u64 spin_time_start(void)
{
	return 0;
}
static void xen_spin_lock(struct raw_spinlock *lock)
{
	__xen_spin_lock(lock, false);
}
static void xen_spin_lock_flags(struct raw_spinlock *lock, unsigned long flags)
{
	__xen_spin_lock(lock, !raw_irqs_disabled_flags(flags));
}
void xen_uninit_lock_cpu(int cpu)
{
	unbind_from_irqhandler(per_cpu(lock_kicker_irq, cpu), NULL);
}
bool xen_vcpu_stolen(int vcpu)
{
	return per_cpu(runstate, vcpu).state == RUNSTATE_runnable;
}
int xen_set_wallclock(unsigned long now)
{
	return -1;
}
static s64 get_abs_timeout(unsigned long delta)
{
	return xen_clocksource_read() + delta;
}
void ack_bad_irq(unsigned int irq)
{
          printk("unexpected IRQ trap at vector %02x\n", irq);
}
static void xtensa_irq_ack(unsigned int irq)
{
	set_sr(1 << irq, INTCLEAR);
}
void module_free(struct module *mod, void *module_region)
{
	vfree(module_region);
}
int module_frob_arch_sections(Elf32_Ehdr *hdr,
    			      Elf32_Shdr *sechdrs,
			      char *secstrings,
			      struct module *mod)
{
	return 0;
}
static int
decode_calln_opcode (unsigned char *location)
{
	return (location[0] & 0xf0) == 0x50;
}
static int
decode_l32r_opcode (unsigned char *location)
{
	return (location[0] & 0xf0) == 0x10;
}
int module_finalize(const Elf_Ehdr *hdr,
    		    const Elf_Shdr *sechdrs,
		    struct module *mod)
{
	return 0;
}
char __init *pcibios_setup(char *str)
{
	return str;
}
void __init
pcibios_update_irq(struct pci_dev *dev, int irq)
{
	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq);
}
void exit_thread(void)
{
	coprocessor_release_all(current_thread_info());
}
void prepare_to_copy(struct task_struct *tsk)
{
	coprocessor_flush_all(task_thread_info(tsk));
}
int dump_fpu(void)
{
	return 0;
}
void machine_restart(char * cmd)
{
	platform_restart();
}
static void *
c_start(struct seq_file *f, loff_t *pos)
{
	return (void *) ((*pos == 0) ? (void *)1 : NULL);
}
static void *
c_next(struct seq_file *f, void *v, loff_t *pos)
{
	return NULL;
}
asmlinkage long xtensa_sigaltstack(const stack_t __user *uss, 
				   stack_t __user *uoss,
    				   long a2, long a3, long a4, long a5,
				   struct pt_regs *regs)
{
	return do_sigaltstack(uss, uoss, regs->areg[1]);
}
asmlinkage long xtensa_fadvise64_64(int fd, int advice, unsigned long long offset, unsigned long long len)
{
	return sys_fadvise64_64(fd, offset, len, advice);
}
unsigned long long sched_clock(void)
{
	return (unsigned long long)jiffies * (1000000000 / HZ);
}
void do_multihit(struct pt_regs *regs, unsigned long exccause)
{
	die("Caught multihit exception", regs, SIGKILL);
}
void dump_stack(void)
{
	show_stack(current, NULL);
}
void __init pgtable_cache_init(void)
{
	pgtable_cache = kmem_cache_create("pgd",
			PAGE_SIZE, PAGE_SIZE,
			SLAB_HWCACHE_ALIGN,
			pgd_ctor);
}
static int rs_write_room(struct tty_struct *tty)
{
	return 2 * 1024;
}
static int rs_chars_in_buffer(struct tty_struct *tty)
{
	return 0;
}
static int inline simc_open(char *file, int flags, int mode)
{
	return __simc(SYS_open, (int) file, flags, mode, 0, 0);
}
static int inline simc_close(int fd)
{
	return __simc(SYS_close, fd, 0, 0, 0, 0);
}
static int inline simc_ioctl(int fd, int request, void *arg)
{
	return __simc(SYS_ioctl, fd, request, (int) arg, 0, 0);
}
static int inline simc_read(int fd, void *buf, size_t count)
{
	return __simc(SYS_read, fd, (int) buf, count, 0, 0);
}
static int inline simc_write(int fd, void *buf, size_t count)
{
	return __simc(SYS_write, fd, (int) buf, count, 0, 0);
}
static int tuntap_read (struct iss_net_private *lp, struct sk_buff **skb)
{
	return simc_read(lp->tp.info.tuntap.fd,
			(*skb)->data, (*skb)->dev->mtu + ETH_HEADER_OTHER);
}
static int tuntap_write (struct iss_net_private *lp, struct sk_buff **skb)
{
	return simc_write(lp->tp.info.tuntap.fd, (*skb)->data, (*skb)->len);
}
unsigned short tuntap_protocol(struct sk_buff *skb)
{
	return eth_type_trans(skb, skb->dev);
}
static int tuntap_poll(struct iss_net_private *lp)
{
	return simc_poll(lp->tp.info.tuntap.fd);
}
static int iss_net_set_mac(struct net_device *dev, void *addr)
{
	return 0;
}
static int iss_net_change_mtu(struct net_device *dev, int new_mtu)
{
	return -EINVAL;
}
void platform_restart(void)
{
	__asm__ __volatile__("movi	a2, 15\n\t"
			     "wsr	a2, " __stringify(ICOUNTLEVEL) "\n\t"
			     "movi	a2, 0\n\t"
			     "wsr	a2, " __stringify(ICOUNT) "\n\t"
			     "wsr	a2, " __stringify(IBREAKENABLE) "\n\t"
			     "wsr	a2, " __stringify(LCOUNT) "\n\t"
			     "movi	a2, 0x1f\n\t"
			     "wsr	a2, " __stringify(PS) "\n\t"
			     "isync\n\t"
			     "jx	%0\n\t"
			     :
			     : "a" (XCHAL_RESET_VECTOR_VADDR)
			     : "a2");
}
void __init platform_setup(char **p_cmdline)
{
	atomic_notifier_chain_register(&panic_notifier_list, &iss_panic_block);
}
void platform_restart(void)
{
	__asm__ __volatile__ ("movi	a2, 15\n\t"
			      "wsr	a2, " __stringify(ICOUNTLEVEL) "\n\t"
			      "movi	a2, 0\n\t"
			      "wsr	a2, " __stringify(ICOUNT) "\n\t"
			      "wsr	a2, " __stringify(IBREAKENABLE) "\n\t"
			      "wsr	a2, " __stringify(LCOUNT) "\n\t"
			      "movi	a2, 0x1f\n\t"
			      "wsr	a2, " __stringify(PS) "\n\t"
			      "isync\n\t"
			      "jx	%0\n\t"
			      :
			      : "a" (XCHAL_RESET_VECTOR_VADDR)
			      : "a2"
			      );
}
void __init platform_setup(char** cmdline)
{
	led_print (0, "LINUX   ");
}
static inline void as_del_rq_rb(struct as_data *ad, struct request *rq)
{
	elv_rb_del(RQ_RB_ROOT(ad, rq), rq);
}
static ssize_t
as_var_show(unsigned int var, char *page)
{
	return sprintf(page, "%d\n", var);
}
void blk_put_queue(struct request_queue *q)
{
	kobject_put(&q->kobj);
}
struct request_queue *blk_alloc_queue(gfp_t gfp_mask)
{
	return blk_alloc_queue_node(gfp_mask, -1);
}
struct request_queue *blk_init_queue(request_fn_proc *rfn, spinlock_t *lock)
{
	return blk_init_queue_node(rfn, lock, -1);
}
static int __init setup_fail_make_request(char *str)
{
	return setup_fault_attr(&fail_make_request, str);
}
static int __init fail_make_request_debugfs(void)
{
	return init_fault_attr_dentries(&fail_make_request,
					"fail_make_request");
}
static inline int should_fail_request(struct bio *bio)
{
	return 0;
}
int blk_end_request(struct request *rq, int error, unsigned int nr_bytes)
{
	return blk_end_io(rq, error, nr_bytes, 0, NULL);
}
int blk_end_bidi_request(struct request *rq, int error, unsigned int nr_bytes,
			 unsigned int bidi_bytes)
{
	return blk_end_io(rq, error, nr_bytes, bidi_bytes, NULL);
}
int blk_end_request_callback(struct request *rq, int error,
			     unsigned int nr_bytes,
			     int (drv_callback)(struct request *))
{
	return blk_end_io(rq, error, nr_bytes, 0, drv_callback);
}
int kblockd_schedule_work(struct request_queue *q, struct work_struct *work)
{
	return queue_work(kblockd_workqueue, work);
}
static ssize_t integrity_format_show(struct blk_integrity *bi, char *page)
{
	if (bi != NULL && bi->name != NULL)
		return sprintf(page, "%s\n", bi->name);
	else
		return sprintf(page, "none\n");
}
static ssize_t integrity_tag_size_show(struct blk_integrity *bi, char *page)
{
	if (bi != NULL)
		return sprintf(page, "%u\n", bi->tag_size);
	else
		return sprintf(page, "0\n");
}
static ssize_t integrity_read_show(struct blk_integrity *bi, char *page)
{
	return sprintf(page, "%d\n", (bi->flags & INTEGRITY_FLAG_READ) != 0);
}
static ssize_t integrity_write_show(struct blk_integrity *bi, char *page)
{
	return sprintf(page, "%d\n", (bi->flags & INTEGRITY_FLAG_WRITE) != 0);
}
void blk_queue_prep_rq(struct request_queue *q, prep_rq_fn *pfn)
{
	q->prep_rq_fn = pfn;
}
void blk_queue_set_discard(struct request_queue *q, prepare_discard_fn *dfn)
{
	q->prepare_discard_fn = dfn;
}
void blk_queue_merge_bvec(struct request_queue *q, merge_bvec_fn *mbfn)
{
	q->merge_bvec_fn = mbfn;
}
void blk_queue_softirq_done(struct request_queue *q, softirq_done_fn *fn)
{
	q->softirq_done_fn = fn;
}
void blk_queue_rq_timeout(struct request_queue *q, unsigned int timeout)
{
	q->rq_timeout = timeout;
}
void blk_queue_rq_timed_out(struct request_queue *q, rq_timed_out_fn *fn)
{
	q->rq_timed_out_fn = fn;
}
void blk_queue_lld_busy(struct request_queue *q, lld_busy_fn *fn)
{
	q->lld_busy_fn = fn;
}
void blk_queue_hardsect_size(struct request_queue *q, unsigned short size)
{
	q->hardsect_size = size;
}
void blk_queue_dma_pad(struct request_queue *q, unsigned int mask)
{
	q->dma_pad_mask = mask;
}
void blk_queue_dma_alignment(struct request_queue *q, int mask)
{
	q->dma_alignment = mask;
}
static int raise_blk_irq(int cpu, struct request *rq)
{
	return 1;
}
static ssize_t
queue_var_show(unsigned int var, char *page)
{
	return sprintf(page, "%d\n", var);
}
static ssize_t queue_requests_show(struct request_queue *q, char *page)
{
	return queue_var_show(q->nr_requests, (page));
}
static ssize_t queue_hw_sector_size_show(struct request_queue *q, char *page)
{
	return queue_var_show(q->hardsect_size, page);
}
static ssize_t queue_nonrot_show(struct request_queue *q, char *page)
{
	return queue_var_show(!blk_queue_nonrot(q), page);
}
static ssize_t queue_nomerges_show(struct request_queue *q, char *page)
{
	return queue_var_show(blk_queue_nomerges(q), page);
}
static ssize_t queue_iostats_show(struct request_queue *q, char *page)
{
	return queue_var_show(blk_queue_io_stat(q), page);
}
struct request *blk_queue_find_tag(struct request_queue *q, int tag)
{
	return blk_map_queue_find_tag(q->queue_tags, tag);
}
void blk_queue_free_tags(struct request_queue *q)
{
	queue_flag_clear_unlocked(QUEUE_FLAG_QUEUED, q);
}
struct blk_queue_tag *blk_init_tags(int depth)
{
	return __blk_queue_init_tags(NULL, depth);
}
static int __init setup_fail_io_timeout(char *str)
{
	return setup_fault_attr(&fail_io_timeout, str);
}
static int __init fail_io_timeout_debugfs(void)
{
	return init_fault_attr_dentries(&fail_io_timeout, "fail_io_timeout");
}
void blk_delete_timer(struct request *req)
{
	list_del_init(&req->timeout_list);
}
static struct dentry *blk_create_buf_file_callback(const char *filename,
						   struct dentry *parent,
						   int mode,
						   struct rchan_buf *buf,
						   int *is_global)
{
	return debugfs_create_file(filename, mode, parent, buf,
					&relay_file_operations);
}
static void blk_add_trace_rq_abort(struct request_queue *q, struct request *rq)
{
	blk_add_trace_rq(q, rq, BLK_TA_ABORT);
}
static void blk_add_trace_rq_insert(struct request_queue *q, struct request *rq)
{
	blk_add_trace_rq(q, rq, BLK_TA_INSERT);
}
static void blk_add_trace_rq_issue(struct request_queue *q, struct request *rq)
{
	blk_add_trace_rq(q, rq, BLK_TA_ISSUE);
}
static void blk_add_trace_rq_requeue(struct request_queue *q,
				     struct request *rq)
{
	blk_add_trace_rq(q, rq, BLK_TA_REQUEUE);
}
static void blk_add_trace_rq_complete(struct request_queue *q,
				      struct request *rq)
{
	blk_add_trace_rq(q, rq, BLK_TA_COMPLETE);
}
static void blk_add_trace_bio_bounce(struct request_queue *q, struct bio *bio)
{
	blk_add_trace_bio(q, bio, BLK_TA_BOUNCE);
}
static void blk_add_trace_bio_complete(struct request_queue *q, struct bio *bio)
{
	blk_add_trace_bio(q, bio, BLK_TA_COMPLETE);
}
static void blk_add_trace_bio_backmerge(struct request_queue *q,
					struct bio *bio)
{
	blk_add_trace_bio(q, bio, BLK_TA_BACKMERGE);
}
static void blk_add_trace_bio_frontmerge(struct request_queue *q,
					 struct bio *bio)
{
	blk_add_trace_bio(q, bio, BLK_TA_FRONTMERGE);
}
static void blk_add_trace_bio_queue(struct request_queue *q, struct bio *bio)
{
	blk_add_trace_bio(q, bio, BLK_TA_QUEUE);
}
static inline
const struct blk_io_trace *te_blk_io_trace(const struct trace_entry *ent)
{
	return (const struct blk_io_trace *)ent;
}
static inline const void *pdu_start(const struct trace_entry *ent)
{
	return te_blk_io_trace(ent) + 1;
}
static inline u32 t_sec(const struct trace_entry *ent)
{
	return te_blk_io_trace(ent)->bytes >> 9;
}
static inline unsigned long long t_sector(const struct trace_entry *ent)
{
	return te_blk_io_trace(ent)->sector;
}
static inline __u16 t_error(const struct trace_entry *ent)
{
	return te_blk_io_trace(ent)->sector;
}
static int blk_log_plug(struct trace_seq *s, const struct trace_entry *ent)
{
	return trace_seq_printf(s, "[%s]\n", trace_find_cmdline(ent->pid));
}
static int blk_log_unplug(struct trace_seq *s, const struct trace_entry *ent)
{
	return trace_seq_printf(s, "[%s] %llu\n", trace_find_cmdline(ent->pid),
				get_pdu_int(ent));
}
static int blk_log_split(struct trace_seq *s, const struct trace_entry *ent)
{
	return trace_seq_printf(s, "%llu / %llu [%s]\n", t_sector(ent),
				get_pdu_int(ent), trace_find_cmdline(ent->pid));
}
static enum print_line_t
blk_trace_event_print_binary(struct trace_iterator *iter, int flags)
{
	return blk_trace_synthesize_old_trace(iter) ?
			TRACE_TYPE_HANDLED : TRACE_TYPE_PARTIAL_LINE;
}
static inline struct hlist_head *bsg_dev_idx_hash(int index)
{
	return &bsg_device_list[index & (BSG_LIST_ARRAY_SIZE - 1)];
}
static inline struct cfq_queue *cic_to_cfqq(struct cfq_io_context *cic,
					    int is_sync)
{
	return cic->cfqq[!!is_sync];
}
static inline void cic_set_cfqq(struct cfq_io_context *cic,
				struct cfq_queue *cfqq, int is_sync)
{
	cic->cfqq[!!is_sync] = cfqq;
}
static inline int
cfq_prio_to_slice(struct cfq_data *cfqd, struct cfq_queue *cfqq)
{
	return cfq_prio_slice(cfqd, cfq_cfqq_sync(cfqq), cfqq->ioprio);
}
static unsigned long cfq_slice_offset(struct cfq_data *cfqd,
				      struct cfq_queue *cfqq)
{
	return (cfqd->busy_queues - 1) * (cfq_prio_slice(cfqd, 1, 0) -
		       cfq_prio_slice(cfqd, cfq_cfqq_sync(cfqq), cfqq->ioprio));
}
static inline sector_t cfq_dist_from_last(struct cfq_data *cfqd,
					  struct request *rq)
{
	if (rq->sector >= cfqd->last_position)
		return rq->sector - cfqd->last_position;
	else
		return cfqd->last_position - rq->sector;
}
static int cfq_close_cooperator(struct cfq_data *cfq_data,
				struct cfq_queue *cfqq)
{
	return 0;
}
static void cfq_cic_free(struct cfq_io_context *cic)
{
	call_rcu(&cic->rcu_head, cfq_cic_free_rcu);
}
static void cfq_free_io_context(struct io_context *ioc)
{
	__call_for_each_cic(ioc, cic_free_func);
}
static void cfq_exit_io_context(struct io_context *ioc)
{
	call_for_each_cic(ioc, cfq_exit_single_io_context);
}
static ssize_t
cfq_var_show(unsigned int var, char *page)
{
	return sprintf(page, "%d\n", var);
}
static int compat_put_ushort(unsigned long arg, unsigned short val)
{
	return put_user(val, (unsigned short __user *)compat_ptr(arg));
}
static int compat_put_int(unsigned long arg, int val)
{
	return put_user(val, (compat_int_t __user *)compat_ptr(arg));
}
static int compat_put_long(unsigned long arg, long val)
{
	return put_user(val, (compat_long_t __user *)compat_ptr(arg));
}
static int compat_put_ulong(unsigned long arg, compat_ulong_t val)
{
	return put_user(val, (compat_ulong_t __user *)compat_ptr(arg));
}
static int compat_put_u64(unsigned long arg, u64 val)
{
	return put_user(val, (compat_u64 __user *)compat_ptr(arg));
}
static inline struct rb_root *
deadline_rb_root(struct deadline_data *dd, struct request *rq)
{
	return &dd->sort_list[rq_data_dir(rq)];
}
static ssize_t
deadline_var_show(int var, char *page)
{
	return sprintf(page, "%d\n", var);
}
static void __exit deadline_exit(void)
{
	elv_unregister(&iosched_deadline);
}
static void elevator_put(struct elevator_type *e)
{
	module_put(e->elevator_owner);
}
static void *elevator_init_queue(struct request_queue *q,
				 struct elevator_queue *eq)
{
	return eq->ops->elevator_init_fn(q);
}
static inline void __elv_rqhash_del(struct request *rq)
{
	hlist_del_init(&rq->hash);
}
static inline int sector_in_part(struct hd_struct *part, sector_t sector)
{
	return part->start_sect <= sector &&
		sector < part->start_sect + part->nr_sects;
}
static inline int major_to_index(int major)
{
	return major % BLKDEV_MAJOR_HASH_SIZE;
}
void blk_register_region(dev_t devt, unsigned long range, struct module *module,
			 struct kobject *(*probe)(dev_t, int *, void *),
			 int (*lock)(dev_t, void *), void *data)
{
	kobj_map(bdev_map, devt, range, module, probe, lock, data);
}
void blk_unregister_region(dev_t devt, unsigned long range)
{
	kobj_unmap(bdev_map, devt, range);
}
static int partitions_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &partitions_op);
}
static int diskstats_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &diskstats_op);
}
struct gendisk *alloc_disk(int minors)
{
	return alloc_disk_node(minors, -1);
}
void set_device_ro(struct block_device *bdev, int flag)
{
	bdev->bd_part->policy = flag;
}
static int put_ushort(unsigned long arg, unsigned short val)
{
	return put_user(val, (unsigned short __user *)arg);
}
static int put_int(unsigned long arg, int val)
{
	return put_user(val, (int __user *)arg);
}
static int put_long(unsigned long arg, long val)
{
	return put_user(val, (long __user *)arg);
}
static int put_ulong(unsigned long arg, unsigned long val)
{
	return put_user(val, (unsigned long __user *)arg);
}
static int put_u64(unsigned long arg, u64 val)
{
	return put_user(val, (u64 __user *)arg);
}
static void noop_merged_requests(struct request_queue *q, struct request *rq,
				 struct request *next)
{
	list_del_init(&next->queuelist);
}
static void __exit noop_exit(void)
{
	elv_unregister(&elevator_noop);
}
static int scsi_get_idlun(struct request_queue *q, int __user *p)
{
	return put_user(0, p);
}
static int scsi_get_bus(struct request_queue *q, int __user *p)
{
	return put_user(0, p);
}
static int sg_get_timeout(struct request_queue *q)
{
	return jiffies_to_clock_t(q->sg_timeout);
}
static int sg_emulated_host(struct request_queue *q, int __user *p)
{
	return put_user(1, p);
}
static inline int blk_send_start_stop(struct request_queue *q,
				      struct gendisk *bd_disk, int data)
{
	return __blk_send_generic(q, bd_disk, GPCMD_START_STOP_UNIT, data);
}
static unsigned int crypto_ablkcipher_ctxsize(struct crypto_alg *alg, u32 type,
					      u32 mask)
{
	return alg->cra_ctxsize;
}
int skcipher_null_givencrypt(struct skcipher_givcrypt_request *req)
{
	return crypto_ablkcipher_encrypt(&req->creq);
}
int skcipher_null_givdecrypt(struct skcipher_givcrypt_request *req)
{
	return crypto_ablkcipher_decrypt(&req->creq);
}
static int no_givdecrypt(struct skcipher_givcrypt_request *req)
{
	return -ENOSYS;
}
const char *crypto_default_geniv(const struct crypto_alg *alg)
{
	return alg->cra_flags & CRYPTO_ALG_ASYNC ? "eseqiv" : "chainiv";
}
static unsigned int crypto_aead_ctxsize(struct crypto_alg *alg, u32 type,
					u32 mask)
{
	return alg->cra_ctxsize;
}
static int no_givcrypt(struct aead_givcrypt_request *req)
{
	return -ENOSYS;
}
static int aead_null_givencrypt(struct aead_givcrypt_request *req)
{
	return crypto_aead_encrypt(&req->areq);
}
static int aead_null_givdecrypt(struct aead_givcrypt_request *req)
{
	return crypto_aead_decrypt(&req->areq);
}
void aead_geniv_exit(struct crypto_tfm *tfm)
{
	crypto_free_aead(tfm->crt_aead.base);
}
static inline u8 byte(const u32 x, const unsigned n)
{
	return x >> (n << 3);
}
static int __init aes_init(void)
{
	return crypto_register_alg(&aes_alg);
}
static void __exit aes_fini(void)
{
	crypto_unregister_alg(&aes_alg);
}
static int ahash_nosetkey(struct crypto_ahash *tfm, const u8 *key,
			  unsigned int keylen)
{
	return -ENOSYS;
}
static unsigned int crypto_ahash_ctxsize(struct crypto_alg *alg, u32 type,
					u32 mask)
{
	return alg->cra_ctxsize;
}
struct crypto_template *crypto_lookup_template(const char *name)
{
	return try_then_request_module(__crypto_lookup_template(name), name);
}
int crypto_register_notifier(struct notifier_block *nb)
{
	return blocking_notifier_chain_register(&crypto_chain, nb);
}
int crypto_unregister_notifier(struct notifier_block *nb)
{
	return blocking_notifier_chain_unregister(&crypto_chain, nb);
}
static void __exit crypto_algapi_exit(void)
{
	crypto_exit_proc();
}
static void free_prng_context(struct prng_context *ctx)
{
	crypto_free_cipher(ctx->tfm);
}
static void cprng_exit(struct crypto_tfm *tfm)
{
	free_prng_context(crypto_tfm_ctx(tfm));
}
static void __exit anubis_mod_fini(void)
{
	crypto_unregister_alg(&anubis_alg);
}
struct crypto_alg *crypto_mod_get(struct crypto_alg *alg)
{
	return try_module_get(alg->cra_module) ? crypto_alg_get(alg) : NULL;
}
static inline int crypto_is_test_larval(struct crypto_larval *larval)
{
	return larval->alg.cra_driver_name[0];
}
static int __init arc4_init(void)
{
	return crypto_register_alg(&arc4_alg);
}
static void __exit arc4_exit(void)
{
	crypto_unregister_alg(&arc4_alg);
}
static int __init async_memcpy_init(void)
{
	return 0;
}
static void __exit async_memcpy_exit(void)
{
	do { } while (0);
}
static int __init async_memset_init(void)
{
	return 0;
}
static void __exit async_memset_exit(void)
{
	do { } while (0);
}
static void __exit async_tx_exit(void)
{
	dmaengine_put();
}
static void __exit async_tx_exit(void)
{
	do { } while (0);
}
static void __exit async_xor_exit(void)
{
	do { } while (0);
}
static int __init crypto_authenc_module_init(void)
{
	return crypto_register_template(&crypto_authenc_tmpl);
}
static void __exit crypto_authenc_module_exit(void)
{
	crypto_unregister_template(&crypto_authenc_tmpl);
}
static inline void blkcipher_map_src(struct blkcipher_walk *walk)
{
	walk->src.virt.addr = scatterwalk_map(&walk->in, 0);
}
static inline void blkcipher_map_dst(struct blkcipher_walk *walk)
{
	walk->dst.virt.addr = scatterwalk_map(&walk->out, 1);
}
static inline void blkcipher_unmap_src(struct blkcipher_walk *walk)
{
	scatterwalk_unmap(walk->src.virt.addr, 0);
}
static inline void blkcipher_unmap_dst(struct blkcipher_walk *walk)
{
	scatterwalk_unmap(walk->dst.virt.addr, 1);
}
static int async_setkey(struct crypto_ablkcipher *tfm, const u8 *key,
			unsigned int keylen)
{
	return setkey(crypto_ablkcipher_tfm(tfm), key, keylen);
}
void skcipher_geniv_exit(struct crypto_tfm *tfm)
{
	crypto_free_ablkcipher(tfm->crt_ablkcipher.base);
}
static int __init blowfish_mod_init(void)
{
	return crypto_register_alg(&alg);
}
static void __exit blowfish_mod_fini(void)
{
	crypto_unregister_alg(&alg);
}
static int __init camellia_init(void)
{
	return crypto_register_alg(&camellia_alg);
}
static void __exit camellia_fini(void)
{
	crypto_unregister_alg(&camellia_alg);
}
static int __init cast5_mod_init(void)
{
	return crypto_register_alg(&alg);
}
static void __exit cast5_mod_fini(void)
{
	crypto_unregister_alg(&alg);
}
static int __init cast6_mod_init(void)
{
	return crypto_register_alg(&alg);
}
static void __exit cast6_mod_fini(void)
{
	crypto_unregister_alg(&alg);
}
static int __init crypto_cbc_module_init(void)
{
	return crypto_register_template(&crypto_cbc_tmpl);
}
static void __exit crypto_cbc_module_exit(void)
{
	crypto_unregister_template(&crypto_cbc_tmpl);
}
static int __init chainiv_module_init(void)
{
	return crypto_register_template(&chainiv_tmpl);
}
static void chainiv_module_exit(void)
{
	crypto_unregister_template(&chainiv_tmpl);
}
static int crypto_compress(struct crypto_tfm *tfm,
                            const u8 *src, unsigned int slen,
                            u8 *dst, unsigned int *dlen)
{
	return tfm->__crt_alg->cra_compress.coa_compress(tfm, src, slen, dst,
	                                                 dlen);
}
static int crypto_decompress(struct crypto_tfm *tfm,
                             const u8 *src, unsigned int slen,
                             u8 *dst, unsigned int *dlen)
{
	return tfm->__crt_alg->cra_compress.coa_decompress(tfm, src, slen, dst,
	                                                   dlen);
}
static int __init crc32c_mod_init(void)
{
	return crypto_register_shash(&alg);
}
static void __exit crc32c_mod_fini(void)
{
	crypto_unregister_shash(&alg);
}
static int cryptd_blkcipher_encrypt_enqueue(struct ablkcipher_request *req)
{
	return cryptd_blkcipher_enqueue(req, cryptd_blkcipher_encrypt);
}
static int cryptd_blkcipher_decrypt_enqueue(struct ablkcipher_request *req)
{
	return cryptd_blkcipher_enqueue(req, cryptd_blkcipher_decrypt);
}
static int cryptd_hash_init_enqueue(struct ahash_request *req)
{
	return cryptd_hash_enqueue(req, cryptd_hash_init);
}
static int cryptd_hash_update_enqueue(struct ahash_request *req)
{
	return cryptd_hash_enqueue(req, cryptd_hash_update);
}
static int cryptd_hash_final_enqueue(struct ahash_request *req)
{
	return cryptd_hash_enqueue(req, cryptd_hash_final);
}
static int cryptd_hash_digest_enqueue(struct ahash_request *req)
{
	return cryptd_hash_enqueue(req, cryptd_hash_digest);
}
void cryptd_free_ablkcipher(struct cryptd_ablkcipher *tfm)
{
	crypto_free_ablkcipher(&tfm->base);
}
static int null_init(struct shash_desc *desc)
{
	return 0;
}
static int null_update(struct shash_desc *desc, const u8 *data,
		       unsigned int len)
{
	return 0;
}
static int null_final(struct shash_desc *desc, u8 *out)
{
	return 0;
}
static int null_digest(struct shash_desc *desc, const u8 *data,
		       unsigned int len, u8 *out)
{
	return 0;
}
static int null_hash_setkey(struct crypto_shash *tfm, const u8 *key,
			    unsigned int keylen)
{ return 0; }

static int null_setkey(struct crypto_tfm *tfm, const u8 *key,
		       unsigned int keylen)
{ return 0; }
static void null_crypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
{
	memcpy(dst, src, NULL_BLOCK_SIZE);
}
static int __init crypto_cts_module_init(void)
{
	return crypto_register_template(&crypto_cts_tmpl);
}
static void __exit crypto_cts_module_exit(void)
{
	crypto_unregister_template(&crypto_cts_tmpl);
}
static int __init deflate_mod_init(void)
{
	return crypto_register_alg(&alg);
}
static void __exit deflate_mod_fini(void)
{
	crypto_unregister_alg(&alg);
}
static int __init crypto_ecb_module_init(void)
{
	return crypto_register_template(&crypto_ecb_tmpl);
}
static void __exit crypto_ecb_module_exit(void)
{
	crypto_unregister_template(&crypto_ecb_tmpl);
}
static int __init eseqiv_module_init(void)
{
	return crypto_register_template(&eseqiv_tmpl);
}
static void __exit eseqiv_module_exit(void)
{
	crypto_unregister_template(&eseqiv_tmpl);
}
static int __init fcrypt_mod_init(void)
{
	return crypto_register_alg(&fcrypt_alg);
}
static void __exit fcrypt_mod_fini(void)
{
	crypto_unregister_alg(&fcrypt_alg);
}
static unsigned int crypto_hash_ctxsize(struct crypto_alg *alg, u32 type,
					u32 mask)
{
	return alg->cra_ctxsize;
}
static inline void *align_ptr(void *p, unsigned int align)
{
	return (void *)ALIGN((unsigned long)p, align);
}
static inline struct hmac_ctx *hmac_ctx(struct crypto_hash *tfm)
{
	return align_ptr(crypto_hash_ctx_aligned(tfm) +
			 crypto_hash_blocksize(tfm) * 2 +
			 crypto_hash_digestsize(tfm), sizeof(void *));
}
static int __init hmac_module_init(void)
{
	return crypto_register_template(&hmac_tmpl);
}
static void __exit hmac_module_exit(void)
{
	crypto_unregister_template(&hmac_tmpl);
}
static void __exit khazad_mod_fini(void)
{
	crypto_unregister_alg(&khazad_alg);
}
static int krng_reset(struct crypto_rng *tfm, u8 *seed, unsigned int slen)
{
	return 0;
}
static int __init krng_mod_init(void)
{
	return crypto_register_alg(&krng_alg);
}
static inline void setbit128_bbe(void *b, int bit)
{
	__set_bit(bit ^ 0x78, b);
}
static int __init crypto_module_init(void)
{
	return crypto_register_template(&crypto_tmpl);
}
static void __exit crypto_module_exit(void)
{
	crypto_unregister_template(&crypto_tmpl);
}
static int __init lzo_mod_init(void)
{
	return crypto_register_alg(&alg);
}
static void __exit lzo_mod_fini(void)
{
	crypto_unregister_alg(&alg);
}
static inline u32 F(u32 x, u32 y, u32 z)
{
	return (x & y) | ((~x) & z);
}
static inline u32 G(u32 x, u32 y, u32 z)
{
	return (x & y) | (x & z) | (y & z);
}
static inline u32 H(u32 x, u32 y, u32 z)
{
	return x ^ y ^ z;
}
static int __init md4_mod_init(void)
{
	return crypto_register_shash(&alg);
}
static void __exit md4_mod_fini(void)
{
	crypto_unregister_shash(&alg);
}
static int __init md5_mod_init(void)
{
	return crypto_register_shash(&alg);
}
static void __exit md5_mod_fini(void)
{
	crypto_unregister_shash(&alg);
}
static inline u32 xswap(u32 val)
{
	return ((val & 0x00ff00ff) << 8) | ((val & 0xff00ff00) >> 8);
}
static int __init michael_mic_init(void)
{
	return crypto_register_shash(&alg);
}
static void __exit michael_mic_exit(void)
{
	crypto_unregister_shash(&alg);
}
static int __init crypto_pcbc_module_init(void)
{
	return crypto_register_template(&crypto_pcbc_tmpl);
}
static void __exit crypto_pcbc_module_exit(void)
{
	crypto_unregister_template(&crypto_pcbc_tmpl);
}
static void crypto_proc_fips_init(void)
{
	crypto_sysctls = register_sysctl_table(crypto_dir_table);
}
static void *c_next(struct seq_file *m, void *p, loff_t *pos)
{
	return seq_list_next(p, &crypto_alg_list, pos);
}
static void c_stop(struct seq_file *m, void *p)
{
	up_read(&crypto_alg_sem);
}
static int crypto_info_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &crypto_seq_ops);
}
static int __init rmd128_mod_init(void)
{
	return crypto_register_shash(&alg);
}
static void __exit rmd128_mod_fini(void)
{
	crypto_unregister_shash(&alg);
}
static int __init rmd160_mod_init(void)
{
	return crypto_register_shash(&alg);
}
static void __exit rmd160_mod_fini(void)
{
	crypto_unregister_shash(&alg);
}
static int __init rmd256_mod_init(void)
{
	return crypto_register_shash(&alg);
}
static void __exit rmd256_mod_fini(void)
{
	crypto_unregister_shash(&alg);
}
static int __init rmd320_mod_init(void)
{
	return crypto_register_shash(&alg);
}
static void __exit rmd320_mod_fini(void)
{
	crypto_unregister_shash(&alg);
}
static unsigned int crypto_rng_ctxsize(struct crypto_alg *alg, u32 type,
				       u32 mask)
{
	return alg->cra_ctxsize;
}
static int __init salsa20_generic_mod_init(void)
{
	return crypto_register_alg(&alg);
}
static void __exit salsa20_generic_mod_fini(void)
{
	crypto_unregister_alg(&alg);
}
void *scatterwalk_map(struct scatter_walk *walk, int out)
{
	return crypto_kmap(scatterwalk_page(walk), out) +
	       offset_in_page(walk->offset);
}
static inline u8
byte(const u32 x, const unsigned n)
{
	return x >> (n << 3);
}
static int __init seed_init(void)
{
	return crypto_register_alg(&seed_alg);
}
static void __exit seed_fini(void)
{
	crypto_unregister_alg(&seed_alg);
}
static int __init seqiv_module_init(void)
{
	return crypto_register_template(&seqiv_tmpl);
}
static void __exit seqiv_module_exit(void)
{
	crypto_unregister_template(&seqiv_tmpl);
}
static int __init sha1_generic_mod_init(void)
{
	return crypto_register_shash(&alg);
}
static void __exit sha1_generic_mod_fini(void)
{
	crypto_unregister_shash(&alg);
}
static inline u32 Ch(u32 x, u32 y, u32 z)
{
	return z ^ (x & (y ^ z));
}
static inline u32 Maj(u32 x, u32 y, u32 z)
{
	return (x & y) | (z & (x | y));
}
static inline void LOAD_OP(int I, u32 *W, const u8 *input)
{
	W[I] = __be32_to_cpu( ((__be32*)(input))[I] );
}
static inline void BLEND_OP(int I, u32 *W)
{
	W[I] = s1(W[I-2]) + W[I-7] + s0(W[I-15]) + W[I-16];
}
static inline u64 Ch(u64 x, u64 y, u64 z)
{
        return z ^ (x & (y ^ z));
}
static inline u64 Maj(u64 x, u64 y, u64 z)
{
        return (x & y) | (z & (x | y));
}
static inline u64 RORu64(u64 x, u64 y)
{
        return (x >> y) | (x << (64 - y));
}
static inline void LOAD_OP(int I, u64 *W, const u8 *input)
{
	W[I] = __be64_to_cpu( ((__be64*)(input))[I] );
}
static inline void BLEND_OP(int I, u64 *W)
{
	W[I] = s1(W[I-2]) + W[I-7] + s0(W[I-15]) + W[I-16];
}
static inline struct crypto_shash *__crypto_shash_cast(struct crypto_tfm *tfm)
{
	return container_of(tfm, struct crypto_shash, base);
}
static inline unsigned int shash_align_buffer_size(unsigned len,
						   unsigned long mask)
{
	return len + (mask & ~(__alignof__(u8 __attribute__ ((aligned))) - 1));
}
static int shash_finup_unaligned(struct shash_desc *desc, const u8 *data,
				 unsigned int len, u8 *out)
{
	return crypto_shash_update(desc, data, len) ?:
	       crypto_shash_final(desc, out);
}
static int shash_digest_unaligned(struct shash_desc *desc, const u8 *data,
				  unsigned int len, u8 *out)
{
	return crypto_shash_init(desc) ?:
	       crypto_shash_update(desc, data, len) ?:
	       crypto_shash_final(desc, out);
}
static int shash_async_final(struct ahash_request *req)
{
	return crypto_shash_final(ahash_request_ctx(req), req->result);
}
static int shash_compat_final(struct hash_desc *hdesc, u8 *out)
{
	return crypto_shash_final(crypto_hash_ctx(hdesc->tfm), out);
}
static int crypto_shash_init_tfm(struct crypto_tfm *tfm,
				 const struct crypto_type *frontend)
{
	return 0;
}
static unsigned int crypto_shash_extsize(struct crypto_alg *alg,
					 const struct crypto_type *frontend)
{
	return alg->cra_ctxsize;
}
struct crypto_shash *crypto_alloc_shash(const char *alg_name, u32 type,
					u32 mask)
{
	return __crypto_shash_cast(
		crypto_alloc_tfm(alg_name, &crypto_shash_type, type, mask));
}
int crypto_unregister_shash(struct shash_alg *alg)
{
	return crypto_unregister_alg(&alg->base);
}
static inline int tcrypt_test(const char *alg)
{
	return alg_test(alg, alg, 0, 0);
}
static void hexdump(unsigned char *buf, unsigned int len)
{
	print_hex_dump(KERN_CONT, "", DUMP_PREFIX_OFFSET,
			16, 1,
			buf, len, false);
}
static int __init twofish_mod_init(void)
{
	return crypto_register_alg(&alg);
}
static void __exit twofish_mod_fini(void)
{
	crypto_unregister_alg(&alg);
}
static int __init crypto_xcbc_module_init(void)
{
	return crypto_register_template(&crypto_xcbc_tmpl);
}
static void __exit crypto_xcbc_module_exit(void)
{
	crypto_unregister_template(&crypto_xcbc_tmpl);
}
static int __init crypto_module_init(void)
{
	return crypto_register_template(&crypto_tmpl);
}
static void __exit crypto_module_exit(void)
{
	crypto_unregister_template(&crypto_tmpl);
}
static int acpi_ac_open_fs(struct inode *inode, struct file *file)
{
	return single_open(file, acpi_ac_seq_show, PDE(inode)->data);
}
static void acpi_ex_out_string(char *title, char *value)
{
	acpi_os_printf("%20s : %s\n", title, value);
}
static void acpi_ex_out_pointer(char *title, void *value)
{
	acpi_os_printf("%20s : %p\n", title, value);
}
u8 acpi_ns_valid_root_prefix(char prefix)
{
	return ((u8) (prefix == '\\'));
}
static u8 acpi_ns_valid_path_separator(char sep)
{
	return ((u8) (sep == '.'));
}
acpi_handle acpi_ns_convert_entry_to_handle(struct acpi_namespace_node *node)
{
	return ((acpi_handle) node);
}
union acpi_parse_object *acpi_ps_get_parent_scope(struct acpi_parse_state
						  *parser_state)
{
	return (parser_state->scope->parse_scope.op);
}
u8 acpi_ps_has_completed_scope(struct acpi_parse_state * parser_state)
{
	return ((u8)
		((parser_state->aml >= parser_state->scope->parse_scope.arg_end
		  || !parser_state->scope->parse_scope.arg_count)));
}
u8 acpi_ps_is_leading_char(u32 c)
{
	return ((u8) (c == '_' || (c >= 'A' && c <= 'Z')));
}
u8 acpi_ps_is_prefix_char(u32 c)
{
	return ((u8) (c == '\\' || c == '^'));
}
static void acpi_rs_out_integer8(char *title, u8 value)
{
	acpi_os_printf("%27s : %2.2X\n", title, value);
}
static void acpi_rs_out_integer16(char *title, u16 value)
{
	acpi_os_printf("%27s : %4.4X\n", title, value);
}
static void acpi_rs_out_integer32(char *title, u32 value)
{
	acpi_os_printf("%27s : %8.8X\n", title, value);
}
static void acpi_rs_out_integer64(char *title, u64 value)
{
	acpi_os_printf("%27s : %8.8X%8.8X\n", title, ACPI_FORMAT_UINT64(value));
}
static void acpi_rs_out_title(char *title)
{
	acpi_os_printf("%27s : ", title);
}
char acpi_ut_hex_to_ascii_char(acpi_integer integer, u32 position)
{
	return (acpi_gbl_hex_to_ascii[(integer >> position) & 0xF]);
}
inline int acpi_battery_present(struct acpi_battery *battery)
{
	return battery->device->status.battery_present;
}
inline char *acpi_battery_units(struct acpi_battery *battery)
{
	return (battery->power_unit)?"mA":"mW";
}
static inline int blacklist_by_year(void)
{
	return 0;
}
void acpi_bus_private_data_handler(acpi_handle handle,
				   u32 function, void *context)
{
	return;
}
int register_acpi_bus_notifier(struct notifier_block *nb)
{
	return blocking_notifier_chain_register(&acpi_bus_notify_list, nb);
}
void unregister_acpi_bus_notifier(struct notifier_block *nb)
{
	blocking_notifier_chain_unregister(&acpi_bus_notify_list, nb);
}
static int acpi_button_info_open_fs(struct inode *inode, struct file *file)
{
	return single_open(file, acpi_button_info_seq_show, PDE(inode)->data);
}
static int acpi_button_state_open_fs(struct inode *inode, struct file *file)
{
	return single_open(file, acpi_button_state_seq_show, PDE(inode)->data);
}
static int param_get_trace_state(char *buffer, struct kernel_param *kp)
{
	if (!acpi_gbl_trace_method_name)
		return sprintf(buffer, "disable");
}
static inline void dock(struct dock_station *ds)
{
	handle_dock(ds, 1);
}
static inline void undock(struct dock_station *ds)
{
	handle_dock(ds, 0);
}
static inline void begin_dock(struct dock_station *ds)
{
	ds->flags |= DOCK_DOCKING;
}
static inline void begin_undock(struct dock_station *ds)
{
	ds->flags |= DOCK_UNDOCKING;
}
static inline void complete_undock(struct dock_station *ds)
{
	ds->flags &= ~(DOCK_UNDOCKING);
}
static int acpi_ec_info_open_fs(struct inode *inode, struct file *file)
{
	return single_open(file, acpi_ec_read_info, PDE(inode)->data);
}
int register_acpi_notifier(struct notifier_block *nb)
{
	return blocking_notifier_chain_register(&acpi_chain_head, nb);
}
int unregister_acpi_notifier(struct notifier_block *nb)
{
	return blocking_notifier_chain_unregister(&acpi_chain_head, nb);
}
int acpi_bus_generate_netlink_event(const char *device_class,
				      const char *bus_id,
				      u8 type, int data)
{
	return 0;
}
static int acpi_event_genetlink_init(void)
{
	return -ENODEV;
}
static int fan_get_max_state(struct thermal_cooling_device *cdev, char *buf)
{
	return sprintf(buf, "1\n");
}
static int acpi_fan_state_open_fs(struct inode *inode, struct file *file)
{
	return single_open(file, acpi_fan_read_state, PDE(inode)->data);
}
static int acpi_fan_add_fs(struct acpi_device *device)
{
	return 0;
}
static int acpi_fan_remove_fs(struct acpi_device *device)
{
	return 0;
}
static int __init
acpi_table_parse_srat(enum acpi_srat_type id,
		      acpi_table_entry_handler handler, unsigned int max_entries)
{
	return acpi_table_parse_entries(ACPI_SIG_SRAT,
					    sizeof(struct acpi_table_srat), id,
					    handler, max_entries);
}
acpi_status __init acpi_os_initialize(void)
{
	return AE_OK;
}
void acpi_os_sleep(acpi_integer ms)
{
	schedule_timeout_interruptible(msecs_to_jiffies(ms));
}
acpi_status acpi_os_execute(acpi_execute_type type,
			    acpi_osd_exec_callback function, void *context)
{
	return __acpi_os_execute(type, function, context, 0);
}
acpi_status acpi_os_hotplug_execute(acpi_osd_exec_callback function,
	void *context)
{
	return __acpi_os_execute(0, function, context, 1);
}
void acpi_os_delete_lock(acpi_spinlock handle)
{
	return;
}
void acpi_os_release_lock(acpi_spinlock lockp, acpi_cpu_flags flags)
{
	spin_unlock_irqrestore(lockp, flags);
}
static inline bool valid_aml_io_address(uint address, uint length) { return true; }
static void acpi_pci_data_handler(acpi_handle handle, u32 function,
				  void *context)
{
	return;
}
static inline char pin_name(int pin)
{
	return 'A' + pin - 1;
}
static int __init acpi_irq_isa(char *str)
{
	return acpi_irq_penalty_update(str, 1);
}
static int __init acpi_irq_pci(char *str)
{
	return acpi_irq_penalty_update(str, 0);
}
static void __exit
acpi_pci_slot_exit(void)
{
	acpi_pci_unregister_driver(&acpi_pci_slot_driver);
}
static int acpi_power_open_fs(struct inode *inode, struct file *file)
{
	return single_open(file, acpi_power_seq_show, PDE(inode)->data);
}
static int acpi_system_sleep_open_fs(struct inode *inode, struct file *file)
{
	return single_open(file, acpi_system_sleep_seq_show, PDE(inode)->data);
}
static int acpi_system_alarm_open_fs(struct inode *inode, struct file *file)
{
	return single_open(file, acpi_system_alarm_seq_show, PDE(inode)->data);
}
static int
acpi_system_wakeup_device_open_fs(struct inode *inode, struct file *file)
{
	return single_open(file, acpi_system_wakeup_device_seq_show,
			   PDE(inode)->data);
}
static int acpi_processor_info_open_fs(struct inode *inode, struct file *file)
{
	return single_open(file, acpi_processor_info_seq_show,
			   PDE(inode)->data);
}
static int get_cpu_id(acpi_handle handle, int type, u32 acpi_id) { return -1; }
static acpi_status acpi_processor_hotadd_init(acpi_handle handle, int *p_cpu)
{
	return AE_ERROR;
}
static int acpi_processor_handle_eject(struct acpi_processor *pr)
{
	return (-EINVAL);
}
static inline u32 ticks_elapsed(u32 t1, u32 t2)
{
	if (t2 >= t1)
		return (t2 - t1);
	else if (!(acpi_gbl_FADT.flags & ACPI_FADT_32BIT_TIMER))
		return (((0x00FFFFFF - t1) + t2) & 0x00FFFFFF);
	else
		return ((0xFFFFFFFF - t1) + t2);
}

static inline u32 ticks_elapsed_in_us(u32 t1, u32 t2)
{
	if (t2 >= t1)
		return PM_TIMER_TICKS_TO_US(t2 - t1);
	else if (!(acpi_gbl_FADT.flags & ACPI_FADT_32BIT_TIMER))
		return PM_TIMER_TICKS_TO_US(((0x00FFFFFF - t1) + t2) & 0x00FFFFFF);
	else
		return PM_TIMER_TICKS_TO_US((0xFFFFFFFF - t1) + t2);
}
static int acpi_processor_power_open_fs(struct inode *inode, struct file *file)
{
	return single_open(file, acpi_processor_power_seq_show,
			   PDE(inode)->data);
}
static int cpufreq_get_max_state(unsigned int cpu)
{
	return 0;
}
static int cpufreq_get_cur_state(unsigned int cpu)
{
	return 0;
}
static int cpufreq_set_cur_state(unsigned int cpu, int state)
{
	return 0;
}
static int acpi_thermal_cpufreq_increase(unsigned int cpu)
{
	return -ENODEV;
}
static int acpi_thermal_cpufreq_decrease(unsigned int cpu)
{
	return -ENODEV;
}
static int acpi_processor_limit_open_fs(struct inode *inode, struct file *file)
{
	return single_open(file, acpi_processor_limit_seq_show,
			   PDE(inode)->data);
}
static int acpi_processor_throttling_open_fs(struct inode *inode,
					     struct file *file)
{
	return single_open(file, acpi_processor_throttling_seq_show,
			   PDE(inode)->data);
}
static inline int acpi_battery_vscale(struct acpi_battery *battery)
{
	return battery_scale((battery->spec & 0x0f00) >> 8);
}
static inline int acpi_battery_ipscale(struct acpi_battery *battery)
{
	return battery_scale((battery->spec & 0xf000) >> 12);
}
static inline int acpi_battery_mode(struct acpi_battery *battery)
{
	return (battery->mode & 0x8000);
}
static inline int acpi_battery_scale(struct acpi_battery *battery)
{
	return (acpi_battery_mode(battery) ? 10 : 1) *
	    acpi_battery_ipscale(battery);
}
static int acpi_battery_get_alarm(struct acpi_battery *battery)
{
	return acpi_smbus_read(battery->sbs->hc, SMBUS_READ_WORD,
				 ACPI_SBS_BATTERY, 0x01,
				 (u8 *)&battery->alarm_capacity);
}
static inline char *acpi_battery_units(struct acpi_battery *battery)
{
	return acpi_battery_mode(battery) ? " mW" : " mA";
}
static int acpi_battery_info_open_fs(struct inode *inode, struct file *file)
{
	return single_open(file, acpi_battery_read_info, PDE(inode)->data);
}
static int acpi_battery_state_open_fs(struct inode *inode, struct file *file)
{
	return single_open(file, acpi_battery_read_state, PDE(inode)->data);
}
static int acpi_battery_alarm_open_fs(struct inode *inode, struct file *file)
{
	return single_open(file, acpi_battery_read_alarm, PDE(inode)->data);
}
static int acpi_ac_state_open_fs(struct inode *inode, struct file *file)
{
	return single_open(file, acpi_ac_read_state, PDE(inode)->data);
}
static inline int smb_hc_read(struct acpi_smb_hc *hc, u8 address, u8 *data)
{
	return ec_read(hc->offset + address, data);
}
static inline int smb_hc_write(struct acpi_smb_hc *hc, u8 address, u8 data)
{
	return ec_write(hc->offset + address, data);
}
int acpi_smbus_read(struct acpi_smb_hc *hc, u8 protocol, u8 address,
		    u8 command, u8 *data)
{
	return acpi_smbus_transaction(hc, protocol, address, command, data, 0);
}
int acpi_smbus_write(struct acpi_smb_hc *hc, u8 protocol, u8 address,
		     u8 command, u8 *data, u8 length)
{
	return acpi_smbus_transaction(hc, protocol, address, command, data, length);
}
static void __exit acpi_smb_hc_exit(void)
{
	acpi_bus_unregister_driver(&acpi_smb_hc_driver);
}
void acpi_bus_unregister_driver(struct acpi_driver *driver)
{
	driver_unregister(&driver->drv);
}
void acpi_bus_data_handler(acpi_handle handle, u32 function, void *context)
{
	return;
}
void __init acpi_old_suspend_ordering(void)
{
	old_suspend_ordering = true;
}
void __init acpi_s4_no_nvs(void)
{
	s4_no_nvs = true;
}
void __init acpi_no_s4_hw_signature(void)
{
	nosigcheck = true;
}
static void acpi_pm_enable_gpes(void)
{
	acpi_enable_all_runtime_gpes();
}
static int acpi_system_info_open_fs(struct inode *inode, struct file *file)
{
	return single_open(file, acpi_system_read_info, PDE(inode)->data);
}
static int acpi_system_procfs_init(void)
{
	return 0;
}
int __init
acpi_table_parse_madt(enum acpi_madt_type id,
		      acpi_table_entry_handler handler, unsigned int max_entries)
{
	return acpi_table_parse_entries(ACPI_SIG_MADT,
					    sizeof(struct acpi_table_madt), id,
					    handler, max_entries);
}
static int acpi_thermal_get_trip_points(struct acpi_thermal *tz)
{
	return acpi_thermal_trips_update(tz, ACPI_TRIPS_INIT);
}
static int
acpi_thermal_bind_cooling_device(struct thermal_zone_device *thermal,
					struct thermal_cooling_device *cdev)
{
	return acpi_thermal_cooling_device_cb(thermal, cdev,
				thermal_zone_bind_cooling_device);
}
static int
acpi_thermal_unbind_cooling_device(struct thermal_zone_device *thermal,
					struct thermal_cooling_device *cdev)
{
	return acpi_thermal_cooling_device_cb(thermal, cdev,
				thermal_zone_unbind_cooling_device);
}
static int acpi_thermal_state_open_fs(struct inode *inode, struct file *file)
{
	return single_open(file, acpi_thermal_state_seq_show, PDE(inode)->data);
}
static int acpi_thermal_temp_open_fs(struct inode *inode, struct file *file)
{
	return single_open(file, acpi_thermal_temp_seq_show, PDE(inode)->data);
}
static int acpi_thermal_trip_open_fs(struct inode *inode, struct file *file)
{
	return single_open(file, acpi_thermal_trip_seq_show, PDE(inode)->data);
}
static int acpi_thermal_cooling_open_fs(struct inode *inode, struct file *file)
{
	return single_open(file, acpi_thermal_cooling_seq_show,
			   PDE(inode)->data);
}
static int acpi_thermal_polling_open_fs(struct inode *inode, struct file *file)
{
	return single_open(file, acpi_thermal_polling_seq_show,
			   PDE(inode)->data);
}
static int
acpi_video_cmp_level(const void *a, const void *b)
{
	return *(int *)a - *(int *)b;
}
static int
acpi_video_device_info_open_fs(struct inode *inode, struct file *file)
{
	return single_open(file, acpi_video_device_info_seq_show,
			   PDE(inode)->data);
}
static int
acpi_video_device_state_open_fs(struct inode *inode, struct file *file)
{
	return single_open(file, acpi_video_device_state_seq_show,
			   PDE(inode)->data);
}
static int
acpi_video_device_brightness_open_fs(struct inode *inode, struct file *file)
{
	return single_open(file, acpi_video_device_brightness_seq_show,
			   PDE(inode)->data);
}
static int
acpi_video_device_EDID_open_fs(struct inode *inode, struct file *file)
{
	return single_open(file, acpi_video_device_EDID_seq_show,
			   PDE(inode)->data);
}
static int acpi_video_bus_info_open_fs(struct inode *inode, struct file *file)
{
	return single_open(file, acpi_video_bus_info_seq_show,
			   PDE(inode)->data);
}
static int acpi_video_bus_ROM_open_fs(struct inode *inode, struct file *file)
{
	return single_open(file, acpi_video_bus_ROM_seq_show, PDE(inode)->data);
}
static int
acpi_video_bus_POST_info_open_fs(struct inode *inode, struct file *file)
{
	return single_open(file, acpi_video_bus_POST_info_seq_show,
			   PDE(inode)->data);
}
static int acpi_video_bus_POST_open_fs(struct inode *inode, struct file *file)
{
	return single_open(file, acpi_video_bus_POST_seq_show,
			   PDE(inode)->data);
}
static int acpi_video_bus_DOS_open_fs(struct inode *inode, struct file *file)
{
	return single_open(file, acpi_video_bus_DOS_seq_show, PDE(inode)->data);
}
static int acpi_video_bus_start_devices(struct acpi_video_bus *video)
{
	return acpi_video_bus_DOS(video, 0, 0);
}
static int acpi_video_bus_stop_devices(struct acpi_video_bus *video)
{
	return acpi_video_bus_DOS(video, 0, 1);
}
static int __init amba_init(void)
{
	return bus_register(&amba_bustype);
}
void amba_driver_unregister(struct amba_driver *drv)
{
	driver_unregister(&drv->drv);
}
void amba_device_unregister(struct amba_device *dev)
{
	device_unregister(&dev->dev);
}
void amba_release_regions(struct amba_device *dev)
{
	release_mem_region(dev->res.start, SZ_4K);
}
static inline int ahci_nr_ports(u32 cap)
{
	return (cap & 0x1f) + 1;
}
static inline void __iomem *ahci_port_base(struct ata_port *ap)
{
	return __ahci_port_base(ap->host, ap->port_no);
}
static int __init ahci_init(void)
{
	return pci_register_driver(&ahci_pci_driver);
}
static void __exit ahci_exit(void)
{
	pci_unregister_driver(&ahci_pci_driver);
}
static int __init ata_generic_init(void)
{
	return pci_register_driver(&ata_generic_pci_driver);
}
static void __exit ata_generic_exit(void)
{
	pci_unregister_driver(&ata_generic_pci_driver);
}
static void piix_set_dmamode(struct ata_port *ap, struct ata_device *adev)
{
	do_pata_set_dmamode(ap, adev, 0);
}
static void ich_set_dmamode(struct ata_port *ap, struct ata_device *adev)
{
	do_pata_set_dmamode(ap, adev, 1);
}
static u8 piix_vmw_bmdma_status(struct ata_port *ap)
{
	return ata_bmdma_status(ap) & ~ATA_DMA_ERR;
}
static void __exit piix_exit(void)
{
	pci_unregister_driver(&piix_pci_driver);
}
static int is_pci_dev(struct device *dev)
{
	return (dev->bus == &pci_bus_type);
}
static void ata_acpi_ap_uevent(acpi_handle handle, u32 event, void *data)
{
	ata_acpi_uevent(data, NULL, event);
}
int ata_acpi_on_suspend(struct ata_port *ap)
{
	return 0;
}
void ata_acpi_on_disable(struct ata_device *dev)
{
	ata_acpi_clear_gtf(dev);
}
static bool ata_sstatus_online(u32 sstatus)
{
	return (sstatus & 0xf) == 0x3;
}
unsigned long ata_pack_xfermask(unsigned long pio_mask,
				unsigned long mwdma_mask,
				unsigned long udma_mask)
{
	return ((pio_mask << ATA_SHIFT_PIO) & ATA_MASK_PIO) |
		((mwdma_mask << ATA_SHIFT_MWDMA) & ATA_MASK_MWDMA) |
		((udma_mask << ATA_SHIFT_UDMA) & ATA_MASK_UDMA);
}
unsigned int ata_do_dev_read_id(struct ata_device *dev,
					struct ata_taskfile *tf, u16 *id)
{
	return ata_exec_internal(dev, tf, NULL, DMA_FROM_DEVICE,
				     id, sizeof(id[0]) * ATA_ID_WORDS, 0);
}
int ata_cable_40wire(struct ata_port *ap)
{
	return ATA_CBL_PATA40;
}
int ata_cable_80wire(struct ata_port *ap)
{
	return ATA_CBL_PATA80;
}
int ata_cable_unknown(struct ata_port *ap)
{
	return ATA_CBL_PATA_UNK;
}
int ata_cable_ignore(struct ata_port *ap)
{
	return ATA_CBL_PATA_IGN;
}
int ata_cable_sata(struct ata_port *ap)
{
	return ATA_CBL_SATA;
}
void ata_port_probe(struct ata_port *ap)
{
	ap->flags &= ~ATA_FLAG_DISABLED;
}
static unsigned int ata_dummy_qc_issue(struct ata_queued_cmd *qc)
{
	return AC_ERR_SYSTEM;
}
static void __ata_ehi_pushv_desc(struct ata_eh_info *ehi, const char *fmt,
				 va_list args)
{
	ehi->desc_len += vscnprintf(ehi->desc + ehi->desc_len,
				     ATA_EH_DESC_LEN - ehi->desc_len,
				     fmt, args);
}
static void ata_ering_clear(struct ata_ering *ering)
{
	memset(ering, 0, sizeof(*ering));
}
int ata_link_abort(struct ata_link *link)
{
	return ata_do_link_abort(link->ap, link);
}
int ata_port_abort(struct ata_port *ap)
{
	return ata_do_link_abort(ap, NULL);
}
int ata_scsi_ioctl(struct scsi_device *scsidev, int cmd, void __user *arg)
{
	return ata_sas_scsi_ioctl(ata_shost_to_port(scsidev->host),
				scsidev, cmd, arg);
}
static inline int ata_pio_use_silly(struct ata_port *ap)
{
	return (ap->flags & ATA_FLAG_PIO_DMA);
}
int ata_sas_port_start(struct ata_port *ap)
{
	return 0;
}
u8 ata_sff_check_status(struct ata_port *ap)
{
	return ioread8(ap->ioaddr.status_addr);
}
int ata_sff_wait_ready(struct ata_link *link, unsigned long deadline)
{
	return ata_wait_ready(link, deadline, ata_sff_check_ready);
}
u8 ata_bmdma_status(struct ata_port *ap)
{
	return ioread8(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
}
static int __init pacpi_init(void)
{
	return pci_register_driver(&pacpi_pci_driver);
}
static void __exit pacpi_exit(void)
{
	pci_unregister_driver(&pacpi_pci_driver);
}
static void amd33_set_piomode(struct ata_port *ap, struct ata_device *adev)
{
	timing_setup(ap, adev, 0x40, adev->pio_mode, 1);
}
static void amd66_set_piomode(struct ata_port *ap, struct ata_device *adev)
{
	timing_setup(ap, adev, 0x40, adev->pio_mode, 2);
}
static void amd100_set_piomode(struct ata_port *ap, struct ata_device *adev)
{
	timing_setup(ap, adev, 0x40, adev->pio_mode, 3);
}
static void amd133_set_piomode(struct ata_port *ap, struct ata_device *adev)
{
	timing_setup(ap, adev, 0x40, adev->pio_mode, 4);
}
static void amd33_set_dmamode(struct ata_port *ap, struct ata_device *adev)
{
	timing_setup(ap, adev, 0x40, adev->dma_mode, 1);
}
static void amd66_set_dmamode(struct ata_port *ap, struct ata_device *adev)
{
	timing_setup(ap, adev, 0x40, adev->dma_mode, 2);
}
static void amd100_set_dmamode(struct ata_port *ap, struct ata_device *adev)
{
	timing_setup(ap, adev, 0x40, adev->dma_mode, 3);
}
static void amd133_set_dmamode(struct ata_port *ap, struct ata_device *adev)
{
	timing_setup(ap, adev, 0x40, adev->dma_mode, 4);
}
static void nv100_set_piomode(struct ata_port *ap, struct ata_device *adev)
{
	timing_setup(ap, adev, 0x50, adev->pio_mode, 3);
}
static void nv133_set_piomode(struct ata_port *ap, struct ata_device *adev)
{
	timing_setup(ap, adev, 0x50, adev->pio_mode, 4);
}
static void nv100_set_dmamode(struct ata_port *ap, struct ata_device *adev)
{
	timing_setup(ap, adev, 0x50, adev->dma_mode, 3);
}
static void nv133_set_dmamode(struct ata_port *ap, struct ata_device *adev)
{
	timing_setup(ap, adev, 0x50, adev->dma_mode, 4);
}
static int __init amd_init(void)
{
	return pci_register_driver(&amd_pci_driver);
}
static void __exit amd_exit(void)
{
	pci_unregister_driver(&amd_pci_driver);
}
static int __init artop_init(void)
{
	return pci_register_driver(&artop_pci_driver);
}
static void __exit artop_exit(void)
{
	pci_unregister_driver(&artop_pci_driver);
}
static int __init pata_at32_init(void)
{
	return platform_driver_probe(&pata_at32_driver, pata_at32_probe);
}
static void __exit pata_at32_exit(void)
{
	platform_driver_unregister(&pata_at32_driver);
}
static void atiixp_set_piomode(struct ata_port *ap, struct ata_device *adev)
{
	atiixp_set_pio_timing(ap, adev, adev->pio_mode - XFER_PIO_0);
}
static int __init atiixp_init(void)
{
	return pci_register_driver(&atiixp_pci_driver);
}
static void __exit atiixp_exit(void)
{
	pci_unregister_driver(&atiixp_pci_driver);
}
static void __exit bfin_atapi_exit(void)
{
	platform_driver_unregister(&bfin_atapi_driver);
}
static int __init cmd640_init(void)
{
	return pci_register_driver(&cmd640_pci_driver);
}
static void __exit cmd640_exit(void)
{
	pci_unregister_driver(&cmd640_pci_driver);
}
static void cmd64x_set_piomode(struct ata_port *ap, struct ata_device *adev)
{
	cmd64x_set_timing(ap, adev, adev->pio_mode);
}
static void cmd646r1_bmdma_stop(struct ata_queued_cmd *qc)
{
	ata_bmdma_stop(qc);
}
static int __init cmd64x_init(void)
{
	return pci_register_driver(&cmd64x_pci_driver);
}
static void __exit cmd64x_exit(void)
{
	pci_unregister_driver(&cmd64x_pci_driver);
}
static void cs5520_set_piomode(struct ata_port *ap, struct ata_device *adev)
{
	cs5520_set_timings(ap, adev, adev->pio_mode);
}
static int __init cs5520_init(void)
{
	return pci_register_driver(&cs5520_pci_driver);
}
static void __exit cs5520_exit(void)
{
	pci_unregister_driver(&cs5520_pci_driver);
}
static int __init cs5530_init(void)
{
	return pci_register_driver(&cs5530_pci_driver);
}
static void __exit cs5530_exit(void)
{
	pci_unregister_driver(&cs5530_pci_driver);
}
static int __init cs5535_init(void)
{
	return pci_register_driver(&cs5535_pci_driver);
}
static void __exit cs5535_exit(void)
{
	pci_unregister_driver(&cs5535_pci_driver);
}
static int __init cs5536_init(void)
{
	return pci_register_driver(&cs5536_pci_driver);
}
static void __exit cs5536_exit(void)
{
	pci_unregister_driver(&cs5536_pci_driver);
}
static int __init cy82c693_init(void)
{
	return pci_register_driver(&cy82c693_pci_driver);
}
static void __exit cy82c693_exit(void)
{
	pci_unregister_driver(&cy82c693_pci_driver);
}
static int __init efar_init(void)
{
	return pci_register_driver(&efar_pci_driver);
}
static void __exit efar_exit(void)
{
	pci_unregister_driver(&efar_pci_driver);
}
static void hpt366_set_piomode(struct ata_port *ap, struct ata_device *adev)
{
	hpt366_set_mode(ap, adev, adev->pio_mode);
}
static void hpt366_set_dmamode(struct ata_port *ap, struct ata_device *adev)
{
	hpt366_set_mode(ap, adev, adev->dma_mode);
}
static int __init hpt36x_init(void)
{
	return pci_register_driver(&hpt36x_pci_driver);
}
static void __exit hpt36x_exit(void)
{
	pci_unregister_driver(&hpt36x_pci_driver);
}
static int __init hpt37x_init(void)
{
	return pci_register_driver(&hpt37x_pci_driver);
}
static void __exit hpt37x_exit(void)
{
	pci_unregister_driver(&hpt37x_pci_driver);
}
static int __init hpt3x2n_init(void)
{
	return pci_register_driver(&hpt3x2n_pci_driver);
}
static void __exit hpt3x2n_exit(void)
{
	pci_unregister_driver(&hpt3x2n_pci_driver);
}
static int hpt3x3_atapi_dma(struct ata_queued_cmd *qc)
{
	return 1;
}
static int __init hpt3x3_init(void)
{
	return pci_register_driver(&hpt3x3_pci_driver);
}
static void __exit hpt3x3_exit(void)
{
	pci_unregister_driver(&hpt3x3_pci_driver);
}
static int __init pata_icside_init(void)
{
	return ecard_register_driver(&pata_icside_driver);
}
static void __exit pata_icside_exit(void)
{
	ecard_remove_driver(&pata_icside_driver);
}
static int __init isapnp_init(void)
{
	return pnp_register_driver(&isapnp_driver);
}
static void __exit isapnp_exit(void)
{
	pnp_unregister_driver(&isapnp_driver);
}
static int __init it8213_init(void)
{
	return pci_register_driver(&it8213_pci_driver);
}
static void __exit it8213_exit(void)
{
	pci_unregister_driver(&it8213_pci_driver);
}
static int __init it821x_init(void)
{
	return pci_register_driver(&it821x_pci_driver);
}

static void __exit it821x_exit(void)
{
	pci_unregister_driver(&it821x_pci_driver);
}
static int __init ixp4xx_pata_init(void)
{
	return platform_driver_register(&ixp4xx_pata_platform_driver);
}
static void __exit ixp4xx_pata_exit(void)
{
	platform_driver_unregister(&ixp4xx_pata_platform_driver);
}
static int __init jmicron_init(void)
{
	return pci_register_driver(&jmicron_pci_driver);
}
static void __exit jmicron_exit(void)
{
	pci_unregister_driver(&jmicron_pci_driver);
}
static int __init marvell_init(void)
{
	return pci_register_driver(&marvell_pci_driver);
}
static void __exit marvell_exit(void)
{
	pci_unregister_driver(&marvell_pci_driver);
}
static void __exit
mpc52xx_ata_exit(void)
{
	of_unregister_platform_driver(&mpc52xx_ata_of_platform_driver);
}
static int __init mpiix_init(void)
{
	return pci_register_driver(&mpiix_pci_driver);
}
static void __exit mpiix_exit(void)
{
	pci_unregister_driver(&mpiix_pci_driver);
}
static int __init netcell_init(void)
{
	return pci_register_driver(&netcell_pci_driver);
}
static void __exit netcell_exit(void)
{
	pci_unregister_driver(&netcell_pci_driver);
}
static int __init ninja32_init(void)
{
	return pci_register_driver(&ninja32_pci_driver);
}
static void __exit ninja32_exit(void)
{
	pci_unregister_driver(&ninja32_pci_driver);
}
static int __init ns87410_init(void)
{
	return pci_register_driver(&ns87410_pci_driver);
}
static void __exit ns87410_exit(void)
{
	pci_unregister_driver(&ns87410_pci_driver);
}
static void ns87415_set_piomode(struct ata_port *ap, struct ata_device *adev)
{
	ns87415_set_mode(ap, adev, adev->pio_mode);
}
static int ns87415_check_atapi_dma(struct ata_queued_cmd *qc)
{
	return -EOPNOTSUPP;
}
static u8 ns87560_check_status(struct ata_port *ap)
{
	return ns87560_read_buggy(ap->ioaddr.status_addr);
}
static u8 ns87560_bmdma_status(struct ata_port *ap)
{
	return ns87560_read_buggy(ap->ioaddr.bmdma_addr + ATA_DMA_STATUS);
}
static int __init ns87415_init(void)
{
	return pci_register_driver(&ns87415_pci_driver);
}
static void __exit ns87415_exit(void)
{
	pci_unregister_driver(&ns87415_pci_driver);
}
static void octeon_cf_dev_select(struct ata_port *ap, unsigned int device)
{
	return;
}
static u8 octeon_cf_irq_on(struct ata_port *ap)
{
	return 0;
}
static void octeon_cf_irq_clear(struct ata_port *ap)
{
	return;
}
static void octeon_cf_dev_config(struct ata_device *dev)
{
	dev->max_sectors = min(dev->max_sectors, 4095U);
}
static void unreachable_qc(struct ata_queued_cmd *qc)
{
	BUG();
}
static u8 unreachable_port(struct ata_port *ap)
{
	BUG();
}
static int octeon_cf_check_atapi_dma(struct ata_queued_cmd *qc)
{
	return 0;
}
static int __init octeon_cf_init(void)
{
	return platform_driver_register(&octeon_cf_driver);
}
static int __devexit pata_of_platform_remove(struct of_device *ofdev)
{
	return __pata_platform_remove(&ofdev->dev);
}
static int __init pata_of_platform_init(void)
{
	return of_register_platform_driver(&pata_of_platform_driver);
}
static void __exit pata_of_platform_exit(void)
{
	of_unregister_platform_driver(&pata_of_platform_driver);
}
static int __init oldpiix_init(void)
{
	return pci_register_driver(&oldpiix_pci_driver);
}
static void __exit oldpiix_exit(void)
{
	pci_unregister_driver(&oldpiix_pci_driver);
}
static int __init opti_init(void)
{
	return pci_register_driver(&opti_pci_driver);
}
static void __exit opti_exit(void)
{
	pci_unregister_driver(&opti_pci_driver);
}
static void optidma_set_pio_mode(struct ata_port *ap, struct ata_device *adev)
{
	optidma_mode_setup(ap, adev, adev->pio_mode);
}
static void optidma_set_dma_mode(struct ata_port *ap, struct ata_device *adev)
{
	optidma_mode_setup(ap, adev, adev->dma_mode);
}
static void optiplus_set_pio_mode(struct ata_port *ap, struct ata_device *adev)
{
	optiplus_mode_setup(ap, adev, adev->pio_mode);
}
static void optiplus_set_dma_mode(struct ata_port *ap, struct ata_device *adev)
{
	optiplus_mode_setup(ap, adev, adev->dma_mode);
}
static int __init optidma_init(void)
{
	return pci_register_driver(&optidma_pci_driver);
}
static void __exit optidma_exit(void)
{
	pci_unregister_driver(&optidma_pci_driver);
}
static int pcmcia_set_mode_8bit(struct ata_link *link,
				struct ata_device **r_failed_dev)
{
	return 0;
}
static int __init pcmcia_init(void)
{
	return pcmcia_register_driver(&pcmcia_driver);
}
static void __exit pcmcia_exit(void)
{
	pcmcia_unregister_driver(&pcmcia_driver);
}
static inline void __iomem *port_mmio(struct ata_port *ap, unsigned int offset)
{
	return ap->host->iomap[PDC_MMIO_BAR] + ap->port_no * 0x100 + offset;
}
static inline int pdc2027x_port_enabled(struct ata_port *ap)
{
	return ioread8(port_mmio(ap, PDC_ATA_CTL)) & 0x02;
}
static int __init pdc2027x_init(void)
{
	return pci_register_driver(&pdc2027x_pci_driver);
}
static void __exit pdc2027x_exit(void)
{
	pci_unregister_driver(&pdc2027x_pci_driver);
}
static void pdc202xx_set_piomode(struct ata_port *ap, struct ata_device *adev)
{
	pdc202xx_configure_piomode(ap, adev, adev->pio_mode - XFER_PIO_0);
}
static void pdc2026x_dev_config(struct ata_device *adev)
{
	adev->max_sectors = 256;
}
static int pdc2026x_check_atapi_dma(struct ata_queued_cmd *qc)
{
	return 1;
}
static int __init pdc202xx_init(void)
{
	return pci_register_driver(&pdc202xx_pci_driver);
}
static void __exit pdc202xx_exit(void)
{
	pci_unregister_driver(&pdc202xx_pci_driver);
}
static int __devexit pata_platform_remove(struct platform_device *pdev)
{
	return __pata_platform_remove(&pdev->dev);
}
static int __init pata_platform_init(void)
{
	return platform_driver_register(&pata_platform_driver);
}
static void __exit pata_platform_exit(void)
{
	platform_driver_unregister(&pata_platform_driver);
}
static int __init radisys_init(void)
{
	return pci_register_driver(&radisys_pci_driver);
}
static void __exit radisys_exit(void)
{
	pci_unregister_driver(&radisys_pci_driver);
}
static void __exit rb532_pata_module_exit(void)
{
	platform_driver_unregister(&rb532_pata_platform_driver);
}
static int __init rz1000_init(void)
{
	return pci_register_driver(&rz1000_pci_driver);
}
static void __exit rz1000_exit(void)
{
	pci_unregister_driver(&rz1000_pci_driver);
}
static int __init sc1200_init(void)
{
	return pci_register_driver(&sc1200_pci_driver);
}
static void __exit sc1200_exit(void)
{
	pci_unregister_driver(&sc1200_pci_driver);
}
static u8 scc_check_status (struct ata_port *ap)
{
	return in_be32(ap->ioaddr.status_addr);
}
static u8 scc_check_altstatus (struct ata_port *ap)
{
	return in_be32(ap->ioaddr.altstatus_addr);
}
static void __exit scc_exit (void)
{
	pci_unregister_driver(&scc_pci_driver);
}
static int __init sch_init(void)
{
	return pci_register_driver(&sch_pci_driver);
}
static void __exit sch_exit(void)
{
	pci_unregister_driver(&sch_pci_driver);
}
static int osb4_cable(struct ata_port *ap) {
	return ATA_CBL_PATA40;
}
static int csb_cable(struct ata_port *ap) {
	return ATA_CBL_PATA_UNK;
}
static int __init serverworks_init(void)
{
	return pci_register_driver(&serverworks_pci_driver);
}
static void __exit serverworks_exit(void)
{
	pci_unregister_driver(&serverworks_pci_driver);
}
static int __init sil680_init(void)
{
	return pci_register_driver(&sil680_pci_driver);
}
static void __exit sil680_exit(void)
{
	pci_unregister_driver(&sil680_pci_driver);
}
static int sis_old_port_base(struct ata_device *adev)
{
	return  0x40 + (4 * adev->link->ap->port_no) +  (2 * adev->devno);
}
static int __init sis_init(void)
{
	return pci_register_driver(&sis_pci_driver);
}
static void __exit sis_exit(void)
{
	pci_unregister_driver(&sis_pci_driver);
}
static void sl82c105_set_piomode(struct ata_port *ap, struct ata_device *adev)
{
	sl82c105_configure_piomode(ap, adev, adev->pio_mode - XFER_PIO_0);
}
static int __init sl82c105_init(void)
{
	return pci_register_driver(&sl82c105_pci_driver);
}
static void __exit sl82c105_exit(void)
{
	pci_unregister_driver(&sl82c105_pci_driver);
}
static void triflex_set_piomode(struct ata_port *ap, struct ata_device *adev)
{
	triflex_load_timing(ap, adev, adev->pio_mode);
}
static int __init triflex_init(void)
{
	return pci_register_driver(&triflex_pci_driver);
}
static void __exit triflex_exit(void)
{
	pci_unregister_driver(&triflex_pci_driver);
}
static int __init via_init(void)
{
	return pci_register_driver(&via_pci_driver);
}
static void __exit via_exit(void)
{
	pci_unregister_driver(&via_pci_driver);
}
static int adma_check_atapi_dma(struct ata_queued_cmd *qc)
{
	return 1;	/* ATAPI DMA not yet supported */
}
static void adma_thaw(struct ata_port *ap)
{
	adma_reinit_engine(ap);
}
static void adma_port_stop(struct ata_port *ap)
{
	adma_reset_engine(ap);
}
static int __init adma_ata_init(void)
{
	return pci_register_driver(&adma_ata_pci_driver);
}
static void __exit adma_ata_exit(void)
{
	pci_unregister_driver(&adma_ata_pci_driver);
}
static int sata_fsl_prereset(struct ata_link *link, unsigned long deadline)
{
	return 0;
}
static void __exit sata_fsl_exit(void)
{
	of_unregister_platform_driver(&fsl_sata_driver);
}
static int __init inic_init(void)
{
	return pci_register_driver(&inic_pci_driver);
}
static void __exit inic_exit(void)
{
	pci_unregister_driver(&inic_pci_driver);
}
static inline unsigned int mv_hc_from_port(unsigned int port)
{
	return port >> MV_PORT_HC_SHIFT;
}
static inline unsigned int mv_hardport_from_port(unsigned int port)
{
	return port & MV_PORT_MASK;
}
static inline void __iomem *mv_hc_base(void __iomem *base, unsigned int hc)
{
	return (base + MV_SATAHC0_REG_BASE + (hc * MV_SATAHC_REG_SZ));
}
static inline void __iomem *mv_hc_base_from_port(void __iomem *base,
						 unsigned int port)
{
	return mv_hc_base(base, mv_hc_from_port(port));
}
static inline void __iomem *mv_port_base(void __iomem *base, unsigned int port)
{
	return  mv_hc_base_from_port(base, port) +
		MV_SATAHC_ARBTR_REG_SZ +
		(mv_hardport_from_port(port) * MV_PORT_REG_SZ);
}
static inline void __iomem *mv_ap_base(struct ata_port *ap)
{
	return mv_port_base(mv_host_base(ap->host), ap->port_no);
}
static inline int mv_get_hc_count(unsigned long port_flags)
{
	return ((port_flags & MV_FLAG_DUAL_HC) ? 2 : 1);
}
static void mv_sff_irq_clear(struct ata_port *ap)
{
	mv_clear_and_enable_port_irqs(ap, mv_ap_base(ap), ERR_IRQ);
}
static int mv_handle_fbs_non_ncq_dev_err(struct ata_port *ap)
{
	return 0;	/* not handled */
}
static void mv5_reset_flash(struct mv_host_priv *hpriv, void __iomem *mmio)
{
	writel(0x0fcfffff, mmio + MV_FLASH_CTL_OFS);
}
static void mv6_enable_leds(struct mv_host_priv *hpriv, void __iomem *mmio)
{
	writel(0x00000060, mmio + MV_GPIO_PORT_CTL_OFS);
}
static void mv_soc_enable_leds(struct mv_host_priv *hpriv,
				      void __iomem *mmio)
{
	return;
}
static void mv_soc_reset_flash(struct mv_host_priv *hpriv,
				      void __iomem *mmio)
{
	return;
}
static void mv_soc_reset_bus(struct ata_host *host, void __iomem *mmio)
{
	return;
}
static int __init nv_init(void)
{
	return pci_register_driver(&nv_pci_driver);
}
static void __exit nv_exit(void)
{
	pci_unregister_driver(&nv_pci_driver);
}
static int pdc_sata_cable_detect(struct ata_port *ap)
{
	return ATA_CBL_SATA;
}
static unsigned int pdc_sata_nr_ports(const struct ata_port *ap)
{
	return (ap->flags & PDC_FLAG_4_PORTS) ? 4 : 2;
}
static unsigned int pdc_sata_hotplug_offset(const struct ata_port *ap)
{
	return (ap->flags & PDC_FLAG_GEN_II) ? PDC2_SATA_PLUG_CSR : PDC_SATA_PLUG_CSR;
}
static int pdc_old_sata_check_atapi_dma(struct ata_queued_cmd *qc)
{
	return 1;
}
static int __init pdc_ata_init(void)
{
	return pci_register_driver(&pdc_ata_pci_driver);
}
static void __exit pdc_ata_exit(void)
{
	pci_unregister_driver(&pdc_ata_pci_driver);
}
static void __iomem *qs_mmio_base(struct ata_host *host)
{
	return host->iomap[QS_MMIO_BAR];
}
static int qs_check_atapi_dma(struct ata_queued_cmd *qc)
{
	return 1;	/* ATAPI DMA not supported */
}
static u8 qs_bmdma_status(struct ata_port *ap)
{
	return 0;
}
static int __init qs_ata_init(void)
{
	return pci_register_driver(&qs_ata_pci_driver);
}
static void __exit qs_ata_exit(void)
{
	pci_unregister_driver(&qs_ata_pci_driver);
}
static int __init sil_init(void)
{
	return pci_register_driver(&sil_pci_driver);
}
static void __exit sil_exit(void)
{
	pci_unregister_driver(&sil_pci_driver);
}
static unsigned long sil24_port_offset(struct ata_port *ap)
{
	return ap->port_no * PORT_REGS_SIZE;
}
static void __iomem *sil24_port_base(struct ata_port *ap)
{
	return ap->host->iomap[SIL24_PORT_BAR] + sil24_port_offset(ap);
}
static int __init sil24_init(void)
{
	return pci_register_driver(&sil24_pci_driver);
}
static void __exit sil24_exit(void)
{
	pci_unregister_driver(&sil24_pci_driver);
}
static int __init sis_init(void)
{
	return pci_register_driver(&sis_pci_driver);
}
static void __exit sis_exit(void)
{
	pci_unregister_driver(&sis_pci_driver);
}
static u8 k2_stat_check_status(struct ata_port *ap)
{
	return readl(ap->ioaddr.status_addr);
}
static int __init k2_sata_init(void)
{
	return pci_register_driver(&k2_sata_pci_driver);
}
static void __exit k2_sata_exit(void)
{
	pci_unregister_driver(&k2_sata_pci_driver);
}
static int __init pdc_sata_init(void)
{
	return pci_register_driver(&pdc_sata_pci_driver);
}
static void __exit pdc_sata_exit(void)
{
	pci_unregister_driver(&pdc_sata_pci_driver);
}
static int __init uli_init(void)
{
	return pci_register_driver(&uli_pci_driver);
}
static void __exit uli_exit(void)
{
	pci_unregister_driver(&uli_pci_driver);
}
static void __iomem *svia_scr_addr(void __iomem *addr, unsigned int port)
{
	return addr + (port * 128);
}
static void __iomem *vt6421_scr_addr(void __iomem *addr, unsigned int port)
{
	return addr + (port * 64);
}
static int __init svia_init(void)
{
	return pci_register_driver(&svia_pci_driver);
}
static void __exit svia_exit(void)
{
	pci_unregister_driver(&svia_pci_driver);
}
static int __init vsc_sata_init(void)
{
	return pci_register_driver(&vsc_sata_pci_driver);
}
static void __exit vsc_sata_exit(void)
{
	pci_unregister_driver(&vsc_sata_pci_driver);
}
static inline void __init show_version (void) {
  printk ("%s version %s\n", description_string, version_string);
}
static void interrupts_on (amb_dev * dev) {
  wr_plain (dev, offsetof(amb_mem, interrupt_control),
	    rd_plain (dev, offsetof(amb_mem, interrupt_control))
	    | AMB_INTERRUPT_BITS);
}
static void interrupts_off (amb_dev * dev) {
  wr_plain (dev, offsetof(amb_mem, interrupt_control),
	    rd_plain (dev, offsetof(amb_mem, interrupt_control))
	    &~ AMB_INTERRUPT_BITS);
}
static inline void sf (const char * msg)
{
	PRINTK (KERN_ERR, "self-test failed: %s", msg);
}
static inline __be32 bus_addr(void * addr) {
    return cpu_to_be32 (virt_to_bus (addr));
}
static int atmtcp_create_persistent(int itf)
{
	return atmtcp_create(itf,1,NULL);
}
static void __exit atmtcp_exit(void)
{
	deregister_atm_ioctl(&atmtcp_ioctl_ops);
}
static int open_tx_second(struct atm_vcc *vcc)
{
	return 0; /* nothing to do */
}
static int eni_getsockopt(struct atm_vcc *vcc,int level,int optname,
    void __user *optval,int optlen)
{
	return -EINVAL;
}
static int eni_setsockopt(struct atm_vcc *vcc,int level,int optname,
    void __user *optval,int optlen)
{
	return -EINVAL;
}
static void eni_phy_put(struct atm_dev *dev,unsigned char value,
    unsigned long addr)
{
	writel(value,ENI_DEV(dev)->phy+addr*4);
}
static unsigned char eni_phy_get(struct atm_dev *dev,unsigned long addr)
{
	return readl(ENI_DEV(dev)->phy+addr*4);
}
static inline void write_fs (struct fs_dev *dev, int offset, u32 val)
{
	writel (val, dev->base + offset);
}
static inline u32  read_fs (struct fs_dev *dev, int offset)
{
	return readl (dev->base + offset);
}
static inline struct FS_QENTRY *get_qentry (struct fs_dev *dev, struct queue *q)
{
	return bus_to_virt (read_fs (dev, Q_WP(q->offset)) & Q_ADDR_MASK);
}
static void __devinit write_phy (struct fs_dev *dev, int regnum, int val)
{
	submit_command (dev,  &dev->hp_txq, QE_CMD_PRP_WR | QE_CMD_IMM_INQ,
			regnum, val, 0);
}
static inline int nr_buffers_in_freepool (struct fs_dev *dev, struct freepool *fp)
{
	return fp->n;
}
static void __exit firestream_cleanup_module(void)
{
	pci_unregister_driver(&firestream_driver);
}
static u32 fore200e_pca_read(volatile u32 __iomem *addr)
{
    return le32_to_cpu(readl(addr));
}
static void fore200e_pca_write(u32 val, volatile u32 __iomem *addr)
{
    writel(cpu_to_le32(val), addr);
}
static void
fore200e_pca_dma_chunk_free(struct fore200e* fore200e, struct chunk* chunk)
{
    pci_free_consistent((struct pci_dev*)fore200e->bus_dev,
			chunk->alloc_size,
			chunk->alloc_addr,
			chunk->dma_addr);
}
static void
fore200e_pca_irq_ack(struct fore200e* fore200e)
{
    writel(PCA200E_HCR_CLRINTR, fore200e->regs.pca.hcr);
}
static u32 fore200e_sba_read(volatile u32 __iomem *addr)
{
    return sbus_readl(addr);
}
static void fore200e_sba_write(u32 val, volatile u32 __iomem *addr)
{
    sbus_writel(val, addr);
}
static int fore200e_sba_irq_check(struct fore200e *fore200e)
{
	return fore200e->bus->read(fore200e->regs.sba.hcr) & SBA200E_HCR_INTR_REQ;
}
static int __init he_init(void)
{
	return pci_register_driver(&he_driver);
}
static void __exit he_cleanup(void)
{
	pci_unregister_driver(&he_driver);
}
static inline void __init show_version (void) {
  printk ("%s version %s\n", description_string, version_string);
}
static inline void wr_regl (const hrz_dev * dev, unsigned char reg, u32 data) {
  outl (cpu_to_le32 (data), dev->iobase + reg);
}
static inline u32 rd_regl (const hrz_dev * dev, unsigned char reg) {
  return le32_to_cpu (inl (dev->iobase + reg));
}
static inline void wr_regw (const hrz_dev * dev, unsigned char reg, u16 data) {
  outw (cpu_to_le16 (data), dev->iobase + reg);
}
static inline u16 rd_regw (const hrz_dev * dev, unsigned char reg) {
  return le16_to_cpu (inw (dev->iobase + reg));
}
static inline void wrs_regb (const hrz_dev * dev, unsigned char reg, void * addr, u32 len) {
  outsb (dev->iobase + reg, addr, len);
}
static inline void rds_regb (const hrz_dev * dev, unsigned char reg, void * addr, u32 len) {
  insb (dev->iobase + reg, addr, len);
}
static inline u16 rx_q_entry_to_length (u32 x) {
  return x & RX_Q_ENTRY_LENGTH_MASK;
}
static inline u16 rx_q_entry_to_rx_channel (u32 x) {
  return (x>>RX_Q_ENTRY_CHANNEL_SHIFT) & RX_CHANNEL_MASK;
}
static void
clear_scd(struct idt77252_dev *card, struct scq_info *scq, int class)
{
	return;
}
static void
deinit_rsq(struct idt77252_dev *card)
{
	pci_free_consistent(card->pcidev, RSQSIZE,
			    card->rsq.base, card->rsq.paddr);
}
static void
deinit_tsq(struct idt77252_dev *card)
{
	pci_free_consistent(card->pcidev, TSQSIZE,
			    card->tsq.base, card->tsq.paddr);
}
static __inline__ int
idt77252_fbq_level(struct idt77252_dev *card, int queue)
{
	return (readl(SAR_REG_STAT) >> (16 + (queue << 2))) & 0x0f;
}
static __inline__ int
idt77252_fbq_full(struct idt77252_dev *card, int queue)
{
	return (readl(SAR_REG_STAT) >> (16 + (queue << 2))) == 0x0f;
}
static void
idt77252_phy_put(struct atm_dev *dev, unsigned char value, unsigned long addr)
{
	write_utility(dev->dev_data, 0x100 + (addr & 0x1ff), value);
}
static unsigned char
idt77252_phy_get(struct atm_dev *dev, unsigned long addr)
{
	return read_utility(dev->dev_data, 0x100 + (addr & 0x1ff));
}
static int idt77252_send(struct atm_vcc *vcc, struct sk_buff *skb)
{
	return idt77252_send_skb(vcc, skb, 0);
}

static void ia_phy_put(struct atm_dev *dev, unsigned char value,   
	unsigned long addr)  
{  
	writel(value, INPH_IA_DEV(dev)->phy+addr);  
}  
static unsigned char ia_phy_get(struct atm_dev *dev, unsigned long addr)  
{  
	return readl(INPH_IA_DEV(dev)->phy+addr);  
}  
static inline size_t lanai_buf_size(const struct lanai_buffer *buf)
{
	return ((unsigned long) buf->end) - ((unsigned long) buf->start);
}
static inline bus_addr_t reg_addr(const struct lanai_dev *lanai,
	enum lanai_register reg)
{
	return lanai->base + reg;
}
static inline void conf1_write(const struct lanai_dev *lanai)
{
	reg_write(lanai, lanai->conf1, Config1_Reg);
}
static inline void conf2_write(const struct lanai_dev *lanai)
{
	reg_write(lanai, lanai->conf2, Config2_Reg);
}
static inline bus_addr_t sram_addr(const struct lanai_dev *lanai, int offset)
{
	return lanai->base + SRAM_START + offset;
}
static inline u32 sram_read(const struct lanai_dev *lanai, int offset)
{
	return readl(sram_addr(lanai, offset));
}
static inline void sram_write(const struct lanai_dev *lanai,
	u32 val, int offset)
{
	writel(val, sram_addr(lanai, offset));
}
static inline bus_addr_t cardvcc_addr(const struct lanai_dev *lanai,
	vci_t vci)
{
	return sram_addr(lanai, vci * CARDVCC_SIZE);
}
static inline u32 eeprom_be4(const struct lanai_dev *lanai, int address)
{
	return be32_to_cpup((const u32 *) &lanai->eeprom[address]);
}
static inline const u8 *eeprom_mac(const struct lanai_dev *lanai)
{
	return &lanai->eeprom[EEPROM_MAC];
}
static inline u32 intr_pending(const struct lanai_dev *lanai)
{
	return reg_read(lanai, IntStatusMasked_Reg);
}
static inline void intr_enable(const struct lanai_dev *lanai, u32 i)
{
	reg_write(lanai, i, IntControlEna_Reg);
}
static inline void intr_disable(const struct lanai_dev *lanai, u32 i)
{
	reg_write(lanai, i, IntControlDis_Reg);
}
static void pcistatus_got(int itf, const char *name)
{
	printk(KERN_INFO DEV_LABEL "(itf %d): PCI got %s error\n", itf, name);
}
static inline int vcc_is_backlogged(const struct lanai_vcc *lvcc)
{
	return !skb_queue_empty(&lvcc->tx.backlog);
}
static void vcc_tx_unqueue_aal0(struct lanai_dev *lanai,
	struct lanai_vcc *lvcc, int endptr)
{
	printk(KERN_INFO DEV_LABEL
	    ": vcc_tx_unqueue_aal0: not implemented\n");
}
static void vcc_rx_aal0(struct lanai_dev *lanai)
{
	printk(KERN_INFO DEV_LABEL ": vcc_rx_aal0: not implemented\n");
}
static inline int lanai_setup_rx_vci_aal5(struct lanai_dev *lanai,
	struct lanai_vcc *lvcc, const struct atm_qos *qos)
{
	return lanai_get_sized_buffer(lanai, &lvcc->rx.buf,
	    qos->rxtp.max_sdu, AAL5_RX_MULTIPLIER, "RX");
}
static inline void service_buffer_deallocate(struct lanai_dev *lanai)
{
	lanai_buf_deallocate(&lanai->service, lanai->pci);
}
static inline void lanai_timed_poll_stop(struct lanai_dev *lanai)
{
	del_timer_sync(&lanai->timer);
}
static int lanai_change_qos(struct atm_vcc *atmvcc,
	/*const*/ struct atm_qos *qos, int flags)
{
	return -EBUSY;		/* TODO: need to write this */
}
static void which_list(ns_dev *card, struct sk_buff *skb)
{
	printk("skb buf_type: 0x%08x\n", NS_SKB_CB(skb)->buf_type);
}
static void poll_los(struct atm_dev *dev)
{
	dev->signal = GET(RSOP_SIS) & SUNI_RSOP_SIS_LOSV ? ATM_PHY_SIG_LOST :
	  ATM_PHY_SIG_FOUND;
}
static __init int uPD98402_module_init(void)
{
	return 0;
}
static void drain_free(struct atm_dev *dev,int pool)
{
	skb_queue_purge(&ZATM_DEV(dev)->pool[pool]);
}
static int zatm_getsockopt(struct atm_vcc *vcc,int level,int optname,
    void __user *optval,int optlen)
{
	return -EINVAL;
}
static int zatm_setsockopt(struct atm_vcc *vcc,int level,int optname,
    void __user *optval,int optlen)
{
	return -EINVAL;
}
static int __init zatm_init_module(void)
{
	return pci_register_driver(&zatm_driver);
}
unsigned int cfag12864b_getrate(void)
{
	return cfag12864b_rate;
}
static void cfag12864b_set(void)
{
	ks0108_writecontrol(cfag12864b_state);
}
static void cfag12864b_cs1(unsigned char state)
{
	cfag12864b_setbit(state, CFAG12864B_BIT_CS1);
}
static void cfag12864b_cs2(unsigned char state)
{
	cfag12864b_setbit(state, CFAG12864B_BIT_CS2);
}
static void cfag12864b_di(unsigned char state)
{
	cfag12864b_setbit(state, CFAG12864B_BIT_DI);
}
static void cfag12864b_nop(void)
{
	cfag12864b_startline(0);
}
static void cfag12864b_queue(void)
{
	queue_delayed_work(cfag12864b_workqueue, &cfag12864b_work,
		HZ / cfag12864b_rate);
}
unsigned char cfag12864b_isenabled(void)
{
	return cfag12864b_updating;
}
unsigned char cfag12864b_isinited(void)
{
	return cfag12864b_inited;
}
static int cfag12864bfb_mmap(struct fb_info *info, struct vm_area_struct *vma)
{
	return vm_insert_page(vma, vma->vm_start,
		virt_to_page(cfag12864b_buffer));
}
void ks0108_writedata(unsigned char byte)
{
	parport_write_data(ks0108_parport, byte);
}
void ks0108_displaystate(unsigned char state)
{
	ks0108_writedata((state ? bit(0) : 0) | bit(1) | bit(2) | bit(3) | bit(4) | bit(5));
}
void ks0108_startline(unsigned char startline)
{
	ks0108_writedata(min(startline,(unsigned char)63) | bit(6) | bit(7));
}
void ks0108_address(unsigned char address)
{
	ks0108_writedata(min(address,(unsigned char)63) | bit(6));
}
void ks0108_page(unsigned char page)
{
	ks0108_writedata(min(page,(unsigned char)7) | bit(3) | bit(4) | bit(5) | bit(7));
}
unsigned char ks0108_isinited(void)
{
	return ks0108_inited;
}
int
attribute_container_add_class_device_adapter(struct attribute_container *cont,
					     struct device *dev,
					     struct device *classdev)
{
	return attribute_container_add_class_device(classdev);
}
static ssize_t show_drivers_autoprobe(struct bus_type *bus, char *buf)
{
	return sprintf(buf, "%d\n", bus->p->drivers_autoprobe);
}
struct device *bus_find_device_by_name(struct bus_type *bus,
				       struct device *start, const char *name)
{
	return bus_find_device(bus, start, (void *)name, match_name);
}
static int make_deprecated_bus_links(struct device *dev)
{
	return sysfs_create_link(&dev->kobj,
				 &dev->bus->p->subsys.kobj, "bus");
}
static void remove_deprecated_bus_links(struct device *dev)
{
	sysfs_remove_link(&dev->kobj, "bus");
}
static inline int make_deprecated_bus_links(struct device *dev) { return 0; }
static inline int add_bind_files(struct device_driver *drv) { return 0; }
static inline int add_probe_files(struct bus_type *bus) { return 0; }
int bus_rescan_devices(struct bus_type *bus)
{
	return bus_for_each_dev(bus, NULL, NULL, bus_rescan_devices_helper);
}
int bus_register_notifier(struct bus_type *bus, struct notifier_block *nb)
{
	return blocking_notifier_chain_register(&bus->p->bus_notifier, nb);
}
int bus_unregister_notifier(struct bus_type *bus, struct notifier_block *nb)
{
	return blocking_notifier_chain_unregister(&bus->p->bus_notifier, nb);
}
struct kset *bus_get_kset(struct bus_type *bus)
{
	return &bus->p->subsys;
}
struct klist *bus_get_device_klist(struct bus_type *bus)
{
	return &bus->p->klist_devices;
}
void class_dev_iter_exit(struct class_dev_iter *iter)
{
	klist_iter_exit(&iter->ki);
}
static inline int device_is_not_partition(struct device *dev)
{
	return !(dev->type == &part_type);
}
static inline int device_is_not_partition(struct device *dev)
{
	return 1;
}
const char *dev_driver_string(const struct device *dev)
{
	return dev->driver ? dev->driver->name :
			(dev->bus ? dev->bus->name :
			(dev->class ? dev->class->name : ""));
}
static ssize_t show_dev(struct device *dev, struct device_attribute *attr,
			char *buf)
{
	return print_dev_t(buf, dev->devt);
}
int device_schedule_callback_owner(struct device *dev,
		void (*func)(struct device *), struct module *owner)
{
	return sysfs_schedule_callback(&dev->kobj,
			(void (*)(void *)) func, dev, owner);
}
static void cleanup_device_parent(struct device *dev)
{
	cleanup_glue_dir(dev, dev->kobj.parent);
}
struct device *get_device(struct device *dev)
{
	return dev ? to_dev(kobject_get(&dev->kobj)) : NULL;
}
static void root_device_release(struct device *dev)
{
	kfree(to_root_device(dev));
}
static void __cpuinit register_cpu_control(struct cpu *cpu)
{
	sysdev_create_file(&cpu->sysdev, &attr_online);
}
struct sys_device *get_cpu_sysdev(unsigned cpu)
{
	if (cpu < nr_cpu_ids && cpu_possible(cpu))
		return per_cpu(cpu_sys_devices, cpu);
	else
		return NULL;
}
int driver_attach(struct device_driver *drv)
{
	return bus_for_each_dev(drv->bus, NULL, drv, __driver_attach);
}
static int devm_kzalloc_match(struct device *dev, void *res, void *data)
{
	return res == data;
}
static void dmam_coherent_decl_release(struct device *dev, void *res)
{
	dma_release_declared_memory(dev);
}
void dmam_release_declared_memory(struct device *dev)
{
	WARN_ON(devres_destroy(dev, dmam_coherent_decl_release, NULL, NULL));
}
void put_driver(struct device_driver *drv)
{
	kobject_put(&drv->p->kobj);
}
static ssize_t
firmware_timeout_show(struct class *class, char *buf)
{
	return sprintf(buf, "%d\n", loading_timeout);
}
static void __exit
firmware_class_exit(void)
{
	class_unregister(&firmware_class);
}
bool iommu_found()
{
	return iommu_ops != NULL;
}
int iommu_attach_device(struct iommu_domain *domain, struct device *dev)
{
	return iommu_ops->attach_dev(domain, dev);
}
void iommu_detach_device(struct iommu_domain *domain, struct device *dev)
{
	iommu_ops->detach_dev(domain, dev);
}
int iommu_map_range(struct iommu_domain *domain, unsigned long iova,
		    phys_addr_t paddr, size_t size, int prot)
{
	return iommu_ops->map(domain, iova, paddr, size, prot);
}
void iommu_unmap_range(struct iommu_domain *domain, unsigned long iova,
		      size_t size)
{
	iommu_ops->unmap(domain, iova, size);
}
phys_addr_t iommu_iova_to_phys(struct iommu_domain *domain,
			       unsigned long iova)
{
	return iommu_ops->iova_to_phys(domain, iova);
}
static void isa_dev_release(struct device *dev)
{
	kfree(to_isa_dev(dev));
}
static const char *memory_uevent_name(struct kset *kset, struct kobject *kobj)
{
	return MEMORY_CLASS_NAME;
}
int register_memory_notifier(struct notifier_block *nb)
{
        return blocking_notifier_chain_register(&memory_chain, nb);
}
void unregister_memory_notifier(struct notifier_block *nb)
{
        blocking_notifier_chain_unregister(&memory_chain, nb);
}
int memory_notify(unsigned long val, void *v)
{
	return blocking_notifier_call_chain(&memory_chain, val, v);
}
static ssize_t
print_block_size(struct class *class, char *buf)
{
	return sprintf(buf, "%lx\n", (unsigned long)PAGES_PER_SECTION * PAGE_SIZE);
}
static int block_size_init(void)
{
	return sysfs_create_file(&memory_sysdev_class.kset.kobj,
				&class_attr_block_size_bytes.attr);
}
static int memory_probe_init(void)
{
	return sysfs_create_file(&memory_sysdev_class.kset.kobj,
				&class_attr_probe.attr);
}
static inline int memory_probe_init(void)
{
	return 0;
}
int register_new_memory(int nid, struct mem_section *section)
{
	return add_memory_block(nid, section, MEM_OFFLINE, 0, HOTPLUG);
}
static inline ssize_t node_read_cpumask(struct sys_device *dev,
				struct sysdev_attribute *attr, char *buf)
{
	return node_read_cpumap(dev, 0, buf);
}
static inline ssize_t node_read_cpulist(struct sys_device *dev,
				struct sysdev_attribute *attr, char *buf)
{
	return node_read_cpumap(dev, 1, buf);
}
static ssize_t node_read_numastat(struct sys_device * dev,
				struct sysdev_attribute *attr, char * buf)
{
	return sprintf(buf,
		       "numa_hit %lu\n"
		       "numa_miss %lu\n"
		       "numa_foreign %lu\n"
		       "interleave_hit %lu\n"
		       "local_node %lu\n"
		       "other_node %lu\n",
		       node_page_state(dev->id, NUMA_HIT),
		       node_page_state(dev->id, NUMA_MISS),
		       node_page_state(dev->id, NUMA_FOREIGN),
		       node_page_state(dev->id, NUMA_INTERLEAVE_HIT),
		       node_page_state(dev->id, NUMA_LOCAL),
		       node_page_state(dev->id, NUMA_OTHER));
}
static int link_mem_sections(int nid) { return 0; }
void unregister_one_node(int nid)
{
	unregister_node(&node_devices[nid]);
}
static ssize_t print_nodes_possible(struct sysdev_class *class, char *buf)
{
	return print_nodes_state(N_POSSIBLE, buf);
}
static ssize_t print_nodes_online(struct sysdev_class *class, char *buf)
{
	return print_nodes_state(N_ONLINE, buf);
}
static ssize_t print_nodes_has_normal_memory(struct sysdev_class *class,
						char *buf)
{
	return print_nodes_state(N_NORMAL_MEMORY, buf);
}
static ssize_t print_nodes_has_cpu(struct sysdev_class *class, char *buf)
{
	return print_nodes_state(N_CPU, buf);
}
static ssize_t print_nodes_has_high_memory(struct sysdev_class *class,
						 char *buf)
{
	return print_nodes_state(N_HIGH_MEMORY, buf);
}
static int platform_drv_probe_fail(struct device *_dev)
{
	return -ENXIO;
}
void platform_driver_unregister(struct platform_driver *drv)
{
	driver_unregister(&drv->driver);
}
void device_pm_lock(void)
{
	mutex_lock(&dpm_list_mtx);
}
void device_pm_unlock(void)
{
	mutex_unlock(&dpm_list_mtx);
}
static void pm_dev_dbg(struct device *dev, pm_message_t state, char *info)
{
	dev_dbg(dev, "%s%s%s\n", info, pm_verb(state.event),
		((state.event & PM_EVENT_SLEEP) && device_may_wakeup(dev)) ?
		", may wakeup" : "");
}
static void pm_dev_err(struct device *dev, pm_message_t state, char *info,
			int error)
{
	printk(KERN_ERR "PM: Device %s failed to %s%s: error %d\n",
		kobject_name(&dev->kobj), pm_verb(state.event), info, error);
}
static ssize_t
wake_show(struct device * dev, struct device_attribute *attr, char * buf)
{
	return sprintf(buf, "%s\n", device_can_wakeup(dev)
		? (device_may_wakeup(dev) ? enabled : disabled)
		: "");
}
int dpm_sysfs_add(struct device * dev)
{
	return sysfs_create_group(&dev->kobj, &pm_attr_group);
}
void dpm_sysfs_remove(struct device * dev)
{
	sysfs_remove_group(&dev->kobj, &pm_attr_group);
}
void set_trace_device(struct device *dev)
{
	dev_hash_value = hash_string(DEVSEED, dev_name(dev), DEVHASH);
}
int sysdev_create_file(struct sys_device * s, struct sysdev_attribute * a)
{
	return sysfs_create_file(&s->kobj, &a->attr);
}
void sysdev_remove_file(struct sys_device * s, struct sysdev_attribute * a)
{
	sysfs_remove_file(&s->kobj, &a->attr);
}
int sysdev_class_create_file(struct sysdev_class *c,
			     struct sysdev_class_attribute *a)
{
	return sysfs_create_file(&c->kset.kobj, &a->attr);
}
void sysdev_class_remove_file(struct sysdev_class *c,
			      struct sysdev_class_attribute *a)
{
	sysfs_remove_file(&c->kset.kobj, &a->attr);
}
static ssize_t show_##name(struct sys_device *dev,			\
			   struct sysdev_attribute *attr, char *buf)	\
{									\
	return show_cpumap(0, topology_##name(dev->id), buf);		\
}
static ssize_t show_##name##_list(struct sys_device *dev,		\
				  struct sysdev_attribute *attr,	\
				  char *buf)				\
{									\
	return show_cpumap(1, topology_##name(dev->id), buf);		\
}
int transport_class_register(struct transport_class *tclass)
{
	return class_register(&tclass->class);
}
void transport_class_unregister(struct transport_class *tclass)
{
	class_unregister(&tclass->class);
}
static int anon_transport_dummy_function(struct transport_container *tc,
					 struct device *dev,
					 struct device *cdev)
{
	return 0;
}
void transport_setup_device(struct device *dev)
{
	attribute_container_add_device(dev, transport_setup_classdev);
}
void transport_add_device(struct device *dev)
{
	attribute_container_device_trigger(dev, transport_add_class_device);
}
void transport_configure_device(struct device *dev)
{
	attribute_container_device_trigger(dev, transport_configure);
}
void transport_remove_device(struct device *dev)
{
	attribute_container_device_trigger(dev, transport_remove_classdev);
}
void transport_destroy_device(struct device *dev)
{
	attribute_container_remove_device(dev, transport_destroy_classdev);
}
static void DAC960_RequestFunction(struct request_queue *RequestQueue)
{
	DAC960_ProcessRequest(RequestQueue->queuedata);
}
static void DAC960_gam_cleanup(void)
{
	misc_deregister(&DAC960_gam_dev);
}
static inline ushort dos_hdr_crc (struct dos_header *hdr)
{
	return dos_crc(&(hdr->track), 0xb2, 0x30, 3); /* precomputed magic */
}
static inline ushort dos_data_crc(unsigned char *data)
{
	return dos_crc(data, 0xe2, 0x95 ,511); /* precomputed magic */
}
static void dbg(unsigned long ptr)
{
	printk("raw data @%08lx: %08lx, %08lx ,%08lx, %08lx\n", ptr,
	       ((ulong *)ptr)[0], ((ulong *)ptr)[1],
	       ((ulong *)ptr)[2], ((ulong *)ptr)[3]);
}
static void do_fd_request(struct request_queue * q)
{
	redo_fd_request();
}
static int
aoedisk_add_sysfs(struct aoedev *d)
{
	return sysfs_create_group(&disk_to_dev(d->gd)->kobj, &attr_group);
}
void
aoedisk_rm_sysfs(struct aoedev *d)
{
	sysfs_remove_group(&disk_to_dev(d->gd)->kobj, &attr_group);
}
void
aoeblk_exit(void)
{
	kmem_cache_destroy(buf_pool_cache);
}
static int
aoechr_rel(struct inode *inode, struct file *filp)
{
	return 0;
}
static void
skb_pool_put(struct aoedev *d, struct sk_buff *skb)
{
	__skb_queue_tail(&d->skbpool, skb);
}
int __init
aoedev_init(void)
{
	return 0;
}
void
aoenet_exit(void)
{
	dev_remove_pack(&aoe_pt);
}
static inline void start_check_change_timer( void )
{
	mod_timer(&fd_timer, jiffies + CHECK_CHANGE_DELAY);
}
static inline void start_timeout(void)
{
	mod_timer(&timeout_timer, jiffies + FLOPPY_TIMEOUT);
}
static inline void stop_timeout(void)
{
	del_timer(&timeout_timer);
}
static inline void set_head_settle_flag(void)
{
	HeadSettleFlag = FDCCMDADD_E;
}
static int __init ramdisk_size2(char *str)
{
	return ramdisk_size(str);
}
static inline void addQ(struct hlist_head *list, CommandList_struct *c)
{
	hlist_add_head(&c->list, list);
}
static inline ctlr_info_t *get_host(struct gendisk *disk)
{
	return disk->queue->queuedata;
}
static inline drive_info_struct *get_drv(struct gendisk *disk)
{
	return disk->private_data;
}
static inline unsigned int make_status_bytes(unsigned int scsi_status_byte,
	unsigned int msg_byte, unsigned int host_byte,
	unsigned int driver_byte)
{
	return (scsi_status_byte & 0xff) |
		((msg_byte & 0xff) << 8) |
		((host_byte & 0xff) << 16) |
		((driver_byte & 0xff) << 24);
}
static inline int interrupt_pending(ctlr_info_t *h)
{
	return (h->access.intr_pending(h)
		|| (h->scsi_rejects.ncompletions > 0));
}
static inline long interrupt_not_for_us(ctlr_info_t *h)
{
	return (((h->access.intr_pending(h) == 0) ||
		 (h->interrupts_enabled == 0))
		&& (h->scsi_rejects.ncompletions == 0));
}
static int device_is_the_same(struct cciss_scsi_dev_t *dev1,
	struct cciss_scsi_dev_t *dev2)
{
	return dev1->devtype == dev2->devtype &&
		memcmp(dev1->scsi3addr, dev2->scsi3addr,
			sizeof(dev1->scsi3addr)) == 0 &&
		memcmp(dev1->device_id, dev2->device_id,
			sizeof(dev1->device_id)) == 0 &&
		memcmp(dev1->vendor, dev2->vendor,
			sizeof(dev1->vendor)) == 0 &&
		memcmp(dev1->model, dev2->model,
			sizeof(dev1->model)) == 0 &&
		memcmp(dev1->revision, dev2->revision,
			sizeof(dev1->revision)) == 0;
}
static inline drv_info_t *get_drv(struct gendisk *disk)
{
	return disk->private_data;
}
static inline ctlr_info_t *get_host(struct gendisk *disk)
{
	return disk->queue->queuedata;
}
static int
cryptoloop_ioctl(struct loop_device *lo, int cmd, unsigned long arg)
{
	return -EINVAL;
}
static inline int fd_eject(int drive)
{
	return -EINVAL;
}
static inline void set_debugt(void)
{
	debugtimer = jiffies;
}
static inline int is_selected(int dor, int unit)
{
	return ((dor & (0x10 << unit)) && (dor & 3) == unit);
}

static void tell_sector(void)
{
	printk(": track %d, head %d, sector %d, size %d",
	       R_TRACK, R_HEAD, R_SECTOR, R_SIZECODE);
}				/* tell_sector */
static void generic_success(void)
{
	cont->done(1);
}
static void generic_failure(void)
{
	cont->done(0);
}
static void reset_intr(void)
{
	printk("weird, reset interrupt called\n");
}
static inline int fd_copyout(void __user *param, const void *address,
			     unsigned long size)
{
	return copy_to_user(param, address, size) ? -EFAULT : 0;
}
static inline int fd_copyin(void __user *param, void *address, unsigned long size)
{
	return copy_from_user(address, param, size) ? -EFAULT : 0;
}
static void floppy_rb0_complete(struct bio *bio,
			       int err)
{
	complete((struct completion *)bio->bi_private);
}
static int
lo_direct_splice_actor(struct pipe_inode_info *pipe, struct splice_desc *sd)
{
	return __splice_from_pipe(pipe, sd, lo_splice_actor);
}
static int __init aten_init(void)
{
	return paride_register(&aten);
}
static void __exit aten_exit(void)
{
	paride_unregister( &aten );
}
static int __init bpck_init(void)
{
	return paride_register(&bpck);
}
static void __exit bpck_exit(void)
{
	paride_unregister(&bpck);
}
static void bpck6_write_block( PIA *pi, char * buf, int len )
{
	ppc6_wr_port16_blk(PPCSTRUCT(pi),ATAPI_DATA,buf,(u32)len>>1); 
}
static void bpck6_read_block( PIA *pi, char * buf, int len )
{
	ppc6_rd_port16_blk(PPCSTRUCT(pi),ATAPI_DATA,buf,(u32)len>>1);
}
static void bpck6_release_proto(PIA *pi)
{
	kfree((void *)(pi->private)); 
}
static void __exit bpck6_exit(void)
{
	paride_unregister(&bpck6);
}
static int __init comm_init(void)
{
	return paride_register(&comm);
}
static void __exit comm_exit(void)
{
	paride_unregister(&comm);
}
static int __init dstr_init(void)
{
	return paride_register(&dstr);
}
static void __exit dstr_exit(void)
{
	paride_unregister(&dstr);
}
static void __exit epat_exit(void)
{
	paride_unregister(&epat);
}
static int __init epia_init(void)
{
	return paride_register(&epia);
}
static void __exit epia_exit(void)
{
	paride_unregister(&epia);
}
static void fit2_log_adapter( PIA *pi, char * scratch, int verbose )
{       printk("%s: fit2 %s, FIT 2000 adapter at 0x%x, delay %d\n",
                pi->device,FIT2_VERSION,pi->port,pi->delay);
}
static int __init fit2_init(void)
{
	return paride_register(&fit2);
}

static void __exit fit2_exit(void)
{
	paride_unregister(&fit2);
}
static int __init fit3_init(void)
{
	return paride_register(&fit3);
}
static void __exit fit3_exit(void)
{
	paride_unregister(&fit3);
}
static void friq_read_block( PIA *pi, char * buf, int count)
{	friq_read_block_int(pi,buf,count,0x08);
}
static int __init friq_init(void)
{
	return paride_register(&friq);
}
static void __exit friq_exit(void)
{
	paride_unregister(&friq);
}
static void frpw_read_block( PIA *pi, char * buf, int count)
{	frpw_read_block_int(pi,buf,count,0x08);
}
static int __init frpw_init(void)
{
	return paride_register(&frpw);
}
static void __exit frpw_exit(void)
{
	paride_unregister(&frpw);
}
static void k951_log_adapter( PIA *pi, char * scratch, int verbose )
{	kbic_log_adapter(pi,scratch,verbose,"KBIC-951A");
}
static void k971_log_adapter( PIA *pi, char * scratch, int verbose )
{       kbic_log_adapter(pi,scratch,verbose,"KBIC-971A");
}
static void ktti_log_adapter( PIA *pi, char * scratch, int verbose )
{       printk("%s: ktti %s, KT adapter at 0x%x, delay %d\n",
                pi->device,KTTI_VERSION,pi->port,pi->delay);
}
static int __init ktti_init(void)
{
	return paride_register(&ktti);
}

static void __exit ktti_exit(void)
{
	paride_unregister(&ktti);
}
static int __init on20_init(void)
{
	return paride_register(&on20);
}
static void __exit on20_exit(void)
{
	paride_unregister(&on20);
}
static int __init on26_init(void)
{
	return paride_register(&on26);
}
static void __exit on26_exit(void)
{
	paride_unregister(&on26);
}
void pi_write_regr(PIA * pi, int cont, int regr, int val)
{
	pi->proto->write_regr(pi, cont, regr, val);
}
int pi_read_regr(PIA * pi, int cont, int regr)
{
	return pi->proto->read_regr(pi, cont, regr);
}
void pi_write_block(PIA * pi, char *buf, int count)
{
	pi->proto->write_block(pi, buf, count);
}
void pi_read_block(PIA * pi, char *buf, int count)
{
	pi->proto->read_block(pi, buf, count);
}
static inline int status_reg(struct pcd_unit *cd)
{
	return pi_read_regr(cd->pi, 1, 6);
}
static inline int read_reg(struct pcd_unit *cd, int reg)
{
	return pi_read_regr(cd->pi, 0, reg);
}
static inline void write_reg(struct pcd_unit *cd, int reg, int val)
{
	pi_write_regr(cd->pi, 0, reg, val);
}
static int pcd_packet(struct cdrom_device_info *cdi, struct packet_command *cgc)
{
	return pcd_atapi(cdi->handle, cgc->cmd, cgc->buflen, cgc->buffer,
			 "generic packet");
}
static void pcd_sleep(int cs)
{
	schedule_timeout_interruptible(cs);
}
static int pcd_drive_reset(struct cdrom_device_info *cdi)
{
	return pcd_reset(cdi->handle);
}
static int pcd_ready(void)
{
	return (((status_reg(pcd_current) & (IDE_BUSY | IDE_DRQ)) == IDE_DRQ));
}
static int pf_check_media(struct gendisk *disk)
{
	return 1;
}
static inline int status_reg(struct pf_unit *pf)
{
	return pi_read_regr(pf->pi, 1, 6);
}
static inline int read_reg(struct pf_unit *pf, int reg)
{
	return pi_read_regr(pf->pi, 0, reg);
}
static inline void write_reg(struct pf_unit *pf, int reg, int val)
{
	pi_write_regr(pf->pi, 0, reg, val);
}
static void pf_sleep(int cs)
{
	schedule_timeout_interruptible(cs);
}
static int pf_ready(void)
{
	return (((status_reg(pf_current) & (STAT_BUSY | pf_mask)) == pf_mask));
}
static void do_pf_read(void)
{
	ps_set_intr(do_pf_read_start, NULL, 0, nice);
}
static void do_pf_write(void)
{
	ps_set_intr(do_pf_write_start, NULL, 0, nice);
}
static inline int status_reg(struct pg *dev)
{
	return pi_read_regr(dev->pi, 1, 6);
}
static inline int read_reg(struct pg *dev, int reg)
{
	return pi_read_regr(dev->pi, 0, reg);
}
static inline void write_reg(struct pg *dev, int reg, int val)
{
	pi_write_regr(dev->pi, 0, reg, val);
}
static inline u8 DRIVE(struct pg *dev)
{
	return 0xa0+0x10*dev->drive;
}
static void pg_sleep(int cs)
{
	schedule_timeout_interruptible(cs);
}
static void ppc6_close(Interface *ppc)
{
	ppc6_deselect(ppc);
}
static inline int status_reg(struct pi_adapter *pi)
{
	return pi_read_regr(pi, 1, 6);
}
static inline int read_reg(struct pi_adapter *pi, int reg)
{
	return pi_read_regr(pi, 0, reg);
}
static inline void write_reg(struct pi_adapter *pi, int reg, int val)
{
	pi_write_regr(pi, 0, reg, val);
}
static inline u8 DRIVE(struct pt_unit *tape)
{
	return 0xa0+0x10*tape->drive;
}
static void pt_sleep(int cs)
{
	schedule_timeout_interruptible(cs);
}
static inline struct vdc_port *to_vdc_port(struct vio_driver_state *vio)
{
	return container_of(vio, struct vdc_port, vio);
}
static inline u32 vdc_tx_dring_avail(struct vio_dring_state *dr)
{
	return vio_dring_avail(dr, VDC_TX_RING_SIZE);
}
static void vdc_handshake_complete(struct vio_driver_state *vio)
{
	vdc_finish(vio, 0, WAITING_FOR_LINK_UP);
}
static void vdc_end_request(struct request *req, int error, int num_sectors)
{
	__blk_end_request(req, error, num_sectors << 9);
}
static int vdc_nack(struct vdc_port *port, void *msgbuf)
{
	return 0;
}
static inline void *carm_ref_msg(struct carm_host *host,
				 unsigned int msg_idx)
{
	return host->msg_base + (msg_idx * CARM_MSG_SIZE);
}
static inline dma_addr_t carm_ref_msg_dma(struct carm_host *host,
					  unsigned int msg_idx)
{
	return host->msg_dma + (msg_idx * CARM_MSG_SIZE);
}
static int __init carm_init(void)
{
	return pci_register_driver(&carm_driver);
}
static void __exit carm_exit(void)
{
	pci_unregister_driver(&carm_driver);
}
static int ub_pre_reset(struct usb_interface *iface) {
	return 0;
}
static int ub_post_reset(struct usb_interface *iface) {
	return 0;
}
static void del_battery_timer(void)
{
	del_timer(&battery_timer);
}
static int mm_check_change(struct gendisk *disk)
{
	return 0;
}
static void viodasd_end_request(struct request *req, int error,
		int num_sectors)
{
	__blk_end_request(req, error, num_sectors << 9);
}
static int virtblk_ioctl(struct block_device *bdev, fmode_t mode,
			 unsigned cmd, unsigned long data)
{
	return scsi_cmd_ioctl(bdev->bd_disk->queue,
			      bdev->bd_disk, mode, cmd,
			      (void __user *)data);
}
static int index_to_minor(int index)
{
	return index << PART_BITS;
}
static void __exit xlblk_exit(void)
{
	return xenbus_unregister_driver(&blkfront);
}
static u16 ace_in_be16(struct ace_device *ace, int reg)
{
	return in_be16(ace->baseaddr + reg);
}
static void ace_out_be16(struct ace_device *ace, int reg, u16 val)
{
	out_be16(ace->baseaddr + reg, val);
}
static u16 ace_in_le16(struct ace_device *ace, int reg)
{
	return in_le16(ace->baseaddr + reg);
}
static void ace_out_le16(struct ace_device *ace, int reg, u16 val)
{
	out_le16(ace->baseaddr + reg, val);
}
static inline u16 ace_in(struct ace_device *ace, int reg)
{
	return ace->reg_ops->in(ace, reg);
}
static inline u32 ace_in32(struct ace_device *ace, int reg)
{
	return ace_in(ace, reg) | (ace_in(ace, reg + 2) << 16);
}
static inline void ace_out(struct ace_device *ace, int reg, u16 val)
{
	ace->reg_ops->out(ace, reg, val);
}
static void ace_dump_regs(struct ace_device *ace)
{
	dev_info(ace->dev, "    ctrl:  %.8x  seccnt/cmd: %.4x      ver:%.4x\n"
		 KERN_INFO "    status:%.8x  mpu_lba:%.8x  busmode:%4x\n"
		 KERN_INFO "    error: %.8x  cfg_lba:%.8x  fatstat:%.4x\n",
		 ace_in32(ace, ACE_CTRL),
		 ace_in(ace, ACE_SECCNTCMD),
		 ace_in(ace, ACE_VERSION),
		 ace_in32(ace, ACE_STATUS),
		 ace_in32(ace, ACE_MPULBA),
		 ace_in(ace, ACE_BUSMODE),
		 ace_in32(ace, ACE_ERROR),
		 ace_in32(ace, ACE_CFGLBA), ace_in(ace, ACE_FATSTAT));
}
static inline void __exit ace_of_unregister(void)
{
	of_unregister_platform_driver(&ace_of_driver);
}
static inline int __init ace_of_register(void) { return 0; }
static void __exit bcm203x_exit(void)
{
	usb_deregister(&bcm203x_driver);
}
static int bfusb_ioctl(struct hci_dev *hdev, unsigned int cmd, unsigned long arg)
{
	return -ENOIOCTLCMD;
}
static void __exit bfusb_exit(void)
{
	usb_deregister(&bfusb_driver);
}
static int bluecard_hci_ioctl(struct hci_dev *hdev, unsigned int cmd, unsigned long arg)
{
	return -ENOIOCTLCMD;
}
static int __init init_bluecard_cs(void)
{
	return pcmcia_register_driver(&bluecard_driver);
}
static void __exit exit_bluecard_cs(void)
{
	pcmcia_unregister_driver(&bluecard_driver);
}
static void __exit bpa10x_exit(void)
{
	usb_deregister(&bpa10x_driver);
}
static int bt3c_hci_ioctl(struct hci_dev *hdev, unsigned int cmd, unsigned long arg)
{
	return -ENOIOCTLCMD;
}
static int __init init_bt3c_cs(void)
{
	return pcmcia_register_driver(&bt3c_driver);
}
static void __exit exit_bt3c_cs(void)
{
	pcmcia_unregister_driver(&bt3c_driver);
}
static void __exit btsdio_exit(void)
{
	sdio_unregister_driver(&btsdio_driver);
}
static int btuart_hci_ioctl(struct hci_dev *hdev, unsigned int cmd, unsigned long arg)
{
	return -ENOIOCTLCMD;
}
static int __init init_btuart_cs(void)
{
	return pcmcia_register_driver(&btuart_driver);
}
static void __exit exit_btuart_cs(void)
{
	pcmcia_unregister_driver(&btuart_driver);
}
static void __exit btusb_exit(void)
{
	usb_deregister(&btusb_driver);
}
static int dtl1_hci_ioctl(struct hci_dev *hdev, unsigned int cmd,  unsigned long arg)
{
	return -ENOIOCTLCMD;
}
static int __init init_dtl1_cs(void)
{
	return pcmcia_register_driver(&dtl1_driver);
}
static void __exit exit_dtl1_cs(void)
{
	pcmcia_unregister_driver(&dtl1_driver);
}
static u16 bscp_get_crc(struct bcsp_struct *bcsp)
{
	return get_unaligned_be16(&bcsp->rx_skb->data[bcsp->rx_skb->len - 2]);
}
int bcsp_deinit(void)
{
	return hci_uart_unregister_proto(&bcsp);
}
int h4_deinit(void)
{
	return hci_uart_unregister_proto(&h4p);
}
static ssize_t hci_uart_tty_read(struct tty_struct *tty, struct file *file,
					unsigned char __user *buf, size_t nr)
{
	return 0;
}
static ssize_t hci_uart_tty_write(struct tty_struct *tty, struct file *file,
					const unsigned char *data, size_t count)
{
	return 0;
}
static unsigned int hci_uart_tty_poll(struct tty_struct *tty,
					struct file *filp, poll_table *wait)
{
	return 0;
}
int ll_deinit(void)
{
	return hci_uart_unregister_proto(&llp);
}
static void vhci_destruct(struct hci_dev *hdev)
{
	kfree(hdev->driver_data);
}
static int vhci_ioctl(struct inode *inode, struct file *file,
					unsigned int cmd, unsigned long arg)
{
	return -EINVAL;
}
static int cdrom_close_write(struct cdrom_device_info *cdi)
{
	return 0;
}
static bool gdrom_is_busy(void)
{
	return (ctrl_inb(GDROM_ALTSTATUS_REG) & 0x80) != 0;
}
static bool gdrom_data_request(void)
{
	return (ctrl_inb(GDROM_ALTSTATUS_REG) & 0x88) == 8;
}
static int get_entry_lba(int track)
{
	return (cpu_to_be32(track & 0xffffff00) - GD_SESSION_OFFSET);
}
static int get_entry_q_ctrl(int track)
{
	return (track & 0x000000f0) >> 4;
}
static int get_entry_track(int track)
{
	return (track & 0x0000ff00) >> 8;
}
static int gdrom_open(struct cdrom_device_info *cd_info, int purpose)
{
	return gdrom_preparedisk_cmd();
}
static int gdrom_mediachanged(struct cdrom_device_info *cd_info, int ignore)
{
	return (ctrl_inb(GDROM_ERROR_REG) & 0xF0) == 0x60;
}
static int gdrom_audio_ioctl(struct cdrom_device_info *cdi, unsigned int cmd,
			     void *arg)
{
	return -EINVAL;
}
static int gdrom_bdops_open(struct block_device *bdev, fmode_t mode)
{
	return cdrom_open(gd.cd_info, bdev, mode);
}
static int gdrom_bdops_mediachanged(struct gendisk *disk)
{
	return cdrom_media_changed(gd.cd_info);
}
static int gdrom_bdops_ioctl(struct block_device *bdev, fmode_t mode,
	unsigned cmd, unsigned long arg)
{
	return cdrom_ioctl(gd.cd_info, bdev, mode, cmd, arg);
}
static int proc_viocd_open(struct inode *inode, struct file *file)
{
	return single_open(file, proc_viocd_show, NULL);
}
static int viocd_audio_ioctl(struct cdrom_device_info *cdi, unsigned int cmd,
			     void *arg)
{
	return -EINVAL;
}
static void __exit agp_ali_cleanup(void)
{
	pci_unregister_driver(&agp_ali_pci_driver);
}
static int alpha_core_agp_fetch_size(void)
{
	return alpha_core_agp_sizes[0].size;
}
static int alpha_core_agp_create_free_gatt_table(struct agp_bridge_data *a)
{
	return 0;
}
static void __exit agp_amdk7_cleanup(void)
{
	pci_unregister_driver(&agp_amdk7_pci_driver);
}
static void amd64_tlbflush(struct agp_memory *temp)
{
	k8_flush_garts();
}
static void __exit agp_ati_cleanup(void)
{
	pci_unregister_driver(&agp_ati_pci_driver);
}
static inline unsigned long efficeon_mask_memory(unsigned long addr)
{
	return addr | 0x00000001;
}
static int agp_efficeon_suspend(struct pci_dev *dev, pm_message_t state)
{
	return 0;
}
static void __exit agp_efficeon_cleanup(void)
{
	pci_unregister_driver(&agp_efficeon_pci_driver);
}
static ssize_t agp_read(struct file *file, char __user *buf,
			size_t count, loff_t * ppos)
{
	return -EINVAL;
}
static ssize_t agp_write(struct file *file, const char __user *buf,
			 size_t count, loff_t * ppos)
{
	return -EINVAL;
}
void agp_frontend_cleanup(void)
{
	misc_deregister(&agp_miscdev);
}
struct agp_memory *agp_generic_alloc_by_type(size_t page_count, int type)
{
	return NULL;
}
static void ipi_handler(void *null)
{
	flush_agp_cache();
}
unsigned long agp_generic_mask_memory(struct agp_bridge_data *bridge,
	unsigned long addr, int type)
{
	if (bridge->driver->masks)
		return addr | bridge->driver->masks[0].mask;
	else
		return addr;
}
static unsigned long
hp_zx1_mask_memory (struct agp_bridge_data *bridge,
	unsigned long addr, int type)
{
	return HP_ZX1_PDIR_VALID_BIT | addr;
}
static void i460_tlb_flush (struct agp_memory *mem)
{
	return;
}
static int i460_insert_memory (struct agp_memory *mem,
				off_t pg_start, int type)
{
	if (I460_IO_PAGE_SHIFT <= PAGE_SHIFT)
		return i460_insert_memory_small_io_page(mem, pg_start, type);
	else
		return i460_insert_memory_large_io_page(mem, pg_start, type);
}
static int i460_remove_memory (struct agp_memory *mem,
				off_t pg_start, int type)
{
	if (I460_IO_PAGE_SHIFT <= PAGE_SHIFT)
		return i460_remove_memory_small_io_page(mem, pg_start, type);
	else
		return i460_remove_memory_large_io_page(mem, pg_start, type);
}
static unsigned long i460_mask_memory (struct agp_bridge_data *bridge,
	unsigned long addr, int type)
{
	return bridge->driver->masks[0].mask
		| (((addr & ~((1 << I460_IO_PAGE_SHIFT) - 1)) & 0xfffff000) >> 12);
}
static void __exit agp_intel_i460_cleanup(void)
{
	pci_unregister_driver(&agp_intel_i460_pci_driver);
}
static void intel_i810_tlbflush(struct agp_memory *mem)
{
	return;
}
static void intel_i810_agp_enable(struct agp_bridge_data *bridge, u32 mode)
{
	return;
}
static int intel_i830_type_to_mask_type(struct agp_bridge_data *bridge,
					int type)
{
	if (type < AGP_USER_TYPES)
		return type;
	else if (type == AGP_USER_CACHED_MEMORY)
		return INTEL_AGP_CACHED_MEMORY;
	else
		return 0;
}
static unsigned long intel_i810_mask_memory(struct agp_bridge_data *bridge,
	unsigned long addr, int type)
{
	return addr | bridge->driver->masks[type].mask;
}
static int intel_i830_free_gatt_table(struct agp_bridge_data *bridge)
{
	return 0;
}
static void intel_i830_cleanup(void)
{
	iounmap(intel_private.registers);
}
static void intel_820_tlbflush(struct agp_memory *mem)
{
	return;
}
static void __exit agp_intel_cleanup(void)
{
	pci_unregister_driver(&agp_intel_pci_driver);
}
static unsigned long
parisc_agp_mask_memory(struct agp_bridge_data *bridge,
		    unsigned long addr, int type)
{
	return SBA_PDIR_VALID_BIT | addr;
}
static void sgi_tioca_tlbflush(struct agp_memory *mem)
{
	tioca_tlbflush(mem->bridge->dev_private_data);
}
static unsigned long
sgi_tioca_mask_memory(struct agp_bridge_data *bridge,
		      unsigned long addr, int type)
{
	return tioca_physpage_to_gart(addr);
}
static void sgi_tioca_agp_enable(struct agp_bridge_data *bridge, u32 mode)
{
	tioca_fastwrite_enable(bridge->dev_private_data);
}
static int sgi_tioca_configure(void)
{
	return 0;
}
static int sgi_tioca_free_gatt_table(struct agp_bridge_data *bridge)
{
	return 0;
}
static void sis_tlbflush(struct agp_memory *mem)
{
	pci_write_config_byte(agp_bridge->dev, SIS_TLBFLUSH, 0x02);
}
static void __exit agp_sis_cleanup(void)
{
	pci_unregister_driver(&agp_sis_pci_driver);
}
static void serverworks_cleanup(void)
{
	iounmap((void __iomem *) serverworks_private.registers);
}
static void __exit agp_serverworks_cleanup(void)
{
	pci_unregister_driver(&agp_serverworks_pci_driver);
}
void null_cache_flush(void)
{
	mb();
}
static void __exit agp_uninorth_cleanup(void)
{
	pci_unregister_driver(&agp_uninorth_pci_driver);
}
static void __exit agp_via_cleanup(void)
{
	pci_unregister_driver(&agp_via_pci_driver);
}
static __inline__ void rtsdtr_ctrl(int bits)
{
    ciab.pra = ((bits & (SER_RTS | SER_DTR)) ^ (SER_RTS | SER_DTR)) | (ciab.pra & ~(SER_RTS | SER_DTR));
}
static void show_serial_version(void)
{
 	printk(KERN_INFO "%s version %s\n", serial_name, serial_version);
}
static inline int queue_empty(struct apm_queue *q)
{
	return q->event_head == q->event_tail;
}
static int proc_apm_open(struct inode *inode, struct file *file)
{
	return single_open(file, proc_apm_show, NULL);
}
static inline u32 cs5535_lowhigh_base(int reg)
{
	return (reg & 0x10) << 3;
}

static int get_default_threshold(struct cyclades_port *info,
						unsigned long __user *value)
{
	return put_user(info->default_threshold, value);
}				/* get_default_threshold */

static int get_default_timeout(struct cyclades_port *info,
					unsigned long __user *value)
{
	return put_user(info->default_timeout, value);
}				/* get_default_timeout */
static void
ds1302_wenable(void)
{
	out_byte_rtc(0x8e,0x00);
}
static void
ds1302_wdisable(void)
{
	out_byte_rtc(0x8e,0x80);
}
static inline void netwinder_ds1620_set_clk(int clk)
{
	nw_gpio_modify_op(GPIO_DSCLK, clk ? GPIO_DSCLK : 0);
}
static inline void netwinder_ds1620_set_data(int dat)
{
	nw_gpio_modify_op(GPIO_DATA, dat ? GPIO_DATA : 0);
}
static inline int netwinder_ds1620_get_data(void)
{
	return nw_gpio_read() & GPIO_DATA;
}
static inline void netwinder_ds1620_set_data_dir(int dir)
{
	nw_gpio_modify_io(GPIO_DATA, dir ? GPIO_DATA : 0);
}
static inline void netwinder_lock(unsigned long *flags)
{
	spin_lock_irqsave(&nw_gpio_lock, *flags);
}
static inline void netwinder_unlock(unsigned long *flags)
{
	spin_unlock_irqrestore(&nw_gpio_lock, *flags);
}
static inline int
compute_yday(efi_time_t *eft)
{
	return  __mon_yday[is_leap(eft->year)][eft->month-1]+ eft->day -1;
}
static int efi_rtc_close(struct inode *inode, struct file *file)
{
	return 0;
}
static void memwinon(struct board_info *b, unsigned int win)
{
	b->memwinon(b, win);
}
static void memwinoff(struct board_info *b, unsigned int win)
{
	b->memwinoff(b, win);
}
static void globalwinon(struct channel *ch)
{
	ch->board->globalwinon(ch);
}
static void rxwinon(struct channel *ch)
{
	ch->board->rxwinon(ch);
}
static void txwinon(struct channel *ch)
{
	ch->board->txwinon(ch);
}
static void memoff(struct channel *ch)
{
	ch->board->memoff(ch);
}
static void assertgwinon(struct channel *ch)
{
	ch->board->assertgwinon(ch);
}
static void assertmemoff(struct channel *ch)
{
	ch->board->assertmemoff(ch);
}
static void pcxem_memwinon(struct board_info *b, unsigned int win)
{
	outb_p(FEPWIN | win, b->port + 1);
}
static void pcxem_memwinoff(struct board_info *b, unsigned int win)
{
	outb_p(0, b->port + 1);
}
static void pcxem_globalwinon(struct channel *ch)
{
	outb_p(FEPWIN, (int)ch->board->port + 1);
}
static void pcxem_rxwinon(struct channel *ch)
{
	outb_p(ch->rxwin, (int)ch->board->port + 1);
}
static void pcxem_txwinon(struct channel *ch)
{
	outb_p(ch->txwin, (int)ch->board->port + 1);
}
static void pcxem_memoff(struct channel *ch)
{
	outb_p(0, (int)ch->board->port + 1);
}
static void pcxe_memwinon(struct board_info *b, unsigned int win)
{
	outb_p(FEPWIN | win, b->port + 1);
}
static void pcxe_globalwinon(struct channel *ch)
{
	outb_p(FEPWIN, (int)ch->board->port + 1);
}
static void pcxe_rxwinon(struct channel *ch)
{
	outb_p(ch->rxwin, (int)ch->board->port + 1);
}
static void pcxe_txwinon(struct channel *ch)
{
	outb_p(ch->txwin, (int)ch->board->port + 1);
}
static void pcxi_memwinon(struct board_info *b, unsigned int win)
{
	outb_p(inb(b->port) | FEPMEM, b->port);
}
static void pcxi_memwinoff(struct board_info *b, unsigned int win)
{
	outb_p(inb(b->port) & ~FEPMEM, b->port);
}
static void pcxi_globalwinon(struct channel *ch)
{
	outb_p(FEPMEM, ch->board->port);
}
static void pcxi_rxwinon(struct channel *ch)
{
	outb_p(FEPMEM, ch->board->port);
}
static void pcxi_txwinon(struct channel *ch)
{
	outb_p(FEPMEM, ch->board->port);
}
static void pcxi_memoff(struct channel *ch)
{
	outb_p(0, ch->board->port);
}
static void pcxi_assertgwinon(struct channel *ch)
{
	epcaassert(inb(ch->board->port) & FEPMEM, "Global memory off");
}
static void pcxi_assertmemoff(struct channel *ch)
{
	epcaassert(!(inb(ch->board->port) & FEPMEM), "Memory on");
}
static void epca_error(int line, char *msg)
{
	printk(KERN_ERR "epca_error (Digi): line = %d %s\n", line, msg);
}
static int __init epca_module_init(void)
{
	return pc_init();
}
static int info_open(struct tty_struct *tty, struct file *filp)
{
	return 0;
}
static inline unsigned int serial_in(struct esp_struct *info, int offset)
{
	return inb(info->io_port + offset);
}
static inline void serial_out(struct esp_struct *info, int offset,
			      unsigned char value)
{
	outb(value, info->io_port+offset);
}
static void show_serial_version(void)
{
	printk(KERN_INFO "%s version %s (DMA %u)\n",
		serial_name, serial_version, dma);
}
void __exit nvram_cleanup(void)
{
        misc_deregister( &nvram_dev );
}
static inline int gen_rtc_proc_init(void) { return 0; }
static inline unsigned long long monotonic_clock(void)
{
	return get_cycles();
}
static cycle_t read_hpet(void)
{
	return (cycle_t)read_counter((void __iomem *)hpet_mctr);
}
static inline unsigned long long readq(void __iomem *addr)
{
	return readl(addr) | (((unsigned long long)readl(addr + 4)) << 32LL);
}
static int hpet_acpi_remove(struct acpi_device *device, int type)
{
	return -EINVAL;
}
static void hvc_unthrottle(struct tty_struct *tty)
{
	hvc_kick();
}
void notifier_hangup_irq(struct hvc_struct *hp, int irq)
{
	notifier_del_irq(hp, irq);
}
static int __init send_open(HvLpIndex remoteLp, void *sem)
{
	return HvCallEvent_signalLpEventFast(remoteLp,
			HvLpEvent_Type_VirtualIo,
			viomajorsubtype_chario | viocharopen,
			HvLpEvent_AckInd_DoAck, HvLpEvent_AckType_ImmediateAck,
			viopath_sourceinst(remoteLp),
			viopath_targetinst(remoteLp),
			(u64)(unsigned long)sem, VIOVERSION << 16,
			0, 0, 0, 0);
}
static void __exit hvc_vio_exit(void)
{
	vio_unregister_driver(&hvc_vio_driver);
}
static	int __init hvc_iucv_config(char *val)
{
	 return strict_strtoul(val, 10, &hvc_iucv_devices);
}
static void hvc_vio_exit(void)
{
	vio_unregister_driver(&hvc_vio_driver);
}
static inline struct xencons_interface *xencons_interface(void)
{
	if (console_pfn == ~0ul)
		return mfn_to_virt(xen_start_info->console.domU.mfn);
	else
		return __va(console_pfn << PAGE_SHIFT);
}
static inline void notify_daemon(void)
{
	notify_remote_via_evtchn(xen_start_info->console.domU.evtchn);
}
void xen_raw_console_write(const char *str)
{
	raw_console_write(str, strlen(str));
}
static inline struct hvcs_struct *from_vio_dev(struct vio_dev *viod)
{
	return viod->dev.driver_data;
}
static ssize_t hvcs_rescan_show(struct device_driver *ddp, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%d\n", hvcs_rescan_status);
}
static inline int is_console(struct hvsi_struct *hp)
{
	return hp->flags & HVSI_CONSOLE;
}
static inline int is_open(struct hvsi_struct *hp)
{
	return (hp->state == HVSI_OPEN)
			|| (hp->state == HVSI_WAIT_FOR_MCTRL_RESPONSE);
}
static inline int len_packet(const uint8_t *packet)
{
	return (int)((struct hvsi_header *)packet)->len;
}
static void __exit mod_exit(void)
{
	hwrng_unregister(&amd_rng);
}
static inline int hwrng_data_read(struct hwrng *rng, u32 *data)
{
	return rng->data_read(rng, data);
}
static inline u8 hwstatus_get(void __iomem *mem)
{
	return readb(mem + INTEL_RNG_HW_STATUS);
}
static int __init n2rng_init(void)
{
	return of_register_driver(&n2rng_driver, &of_bus_type);
}
static void __exit n2rng_exit(void)
{
	of_unregister_driver(&n2rng_driver);
}
static inline u32 omap_rng_read_reg(int reg)
{
	return __raw_readl(rng_base + reg);
}
static inline void omap_rng_write_reg(int reg, u32 val)
{
	__raw_writel(val, rng_base + reg);
}
static void __exit omap_rng_exit(void)
{
	platform_driver_unregister(&omap_rng_driver);
}
static int __init rng_init(void)
{
	return of_register_platform_driver(&rng_driver);
}
static void __exit rng_exit(void)
{
	of_unregister_platform_driver(&rng_driver);
}
static void __exit mod_exit(void)
{
	hwrng_unregister(&via_rng);
}
static int i8k_open_fs(struct inode *inode, struct file *file)
{
	return single_open(file, i8k_proc_show, NULL);
}
static void __exit i8k_exit(void)
{
	remove_proc_entry("i8k", NULL);
}
static void
ii2DelayTimer(unsigned int mseconds)
{
	msleep_interruptible(mseconds);
}
static void
ii2Nop(void)
{
	return;	// no mystery here
}
static unsigned short
iiReadWord16(i2eBordStrPtr pB)
{
	return inw(pB->i2eData);
}
static void
iiWriteWord16(i2eBordStrPtr pB, unsigned short value)
{
	outw((int)value, pB->i2eData);
}
static int
iiTxMailEmptyIIEX(i2eBordStrPtr pB)
{
	return !(inb(pB->i2eStatus) & STE_OUT_MAIL);
}
static unsigned short
iiGetMailIIEX(i2eBordStrPtr pB)
{
	if (I2_HAS_MAIL(pB))
		return inb(pB->i2eXMail);
	else
		return NO_MAIL_HERE;
}
static void
iiEnableMailIrqIIEX(i2eBordStrPtr pB)
{
	outb(MX_IN_MAIL, pB->i2eXMask);
}
static void
iiWriteMaskIIEX(i2eBordStrPtr pB, unsigned char value)
{
	outb(value, pB->i2eXMask);
}
static inline int
i2Validate ( i2ChanStrPtr pCh )
{
	return ((pCh->validity & (CHANNEL_MAGIC_BITS | CHANNEL_SUPPORT)) 
			  == (CHANNEL_MAGIC | CHANNEL_SUPPORT));
}
static void __init mark_requested_irq(char irq)
{
	rirqs[iindx++] = irq;
}
static int proc_ip2mem_open(struct inode *inode, struct file *file)
{
	return single_open(file, proc_ip2mem_show, NULL);
}
static int bt_size(void)
{
	return sizeof(struct si_sm_data);
}
static inline unsigned char read_status(struct si_sm_data *kcs)
{
	return kcs->io->inputb(kcs->io, 1);
}
static inline unsigned char read_data(struct si_sm_data *kcs)
{
	return kcs->io->inputb(kcs->io, 0);
}
static inline void write_cmd(struct si_sm_data *kcs, unsigned char data)
{
	kcs->io->outputb(kcs->io, 1, data);
}
static inline void write_data(struct si_sm_data *kcs, unsigned char data)
{
	kcs->io->outputb(kcs->io, 0, data);
}
static int kcs_size(void)
{
	return sizeof(struct si_sm_data);
}
static void dummy_smi_free(struct ipmi_smi_msg *msg)
{
	atomic_dec(&dummy_count);
}
static void dummy_recv_free(struct ipmi_recv_msg *msg)
{
	atomic_dec(&dummy_count);
}
static int ipmi_cpi1_detect(ipmi_user_t user)
{
	return ((mfg_id == IPMI_CPI1_MANUFACTURER_ID)
		&& (prod_id == IPMI_CPI1_PRODUCT_ID));
}
static int ipmi_chassis_detect(ipmi_user_t user)
{
	return (capabilities & 0x80);
}
static int register_xaction_notifier(struct notifier_block *nb)
{
	return atomic_notifier_chain_register(&xaction_notifier_list, nb);
}
static unsigned char intf_mem_inb(struct si_sm_io *io, unsigned int offset)
{
	return readb((io->addr)+(offset * io->regspacing));
}
static void intf_mem_outb(struct si_sm_io *io, unsigned int offset,
		     unsigned char b)
{
	writeb(b, (io->addr)+(offset * io->regspacing));
}
static unsigned char intf_mem_inw(struct si_sm_io *io, unsigned int offset)
{
	return (readw((io->addr)+(offset * io->regspacing)) >> io->regshift)
		& 0xff;
}
static void intf_mem_outw(struct si_sm_io *io, unsigned int offset,
		     unsigned char b)
{
	writeb(b << io->regshift, (io->addr)+(offset * io->regspacing));
}
static unsigned char intf_mem_inl(struct si_sm_io *io, unsigned int offset)
{
	return (readl((io->addr)+(offset * io->regspacing)) >> io->regshift)
		& 0xff;
}
static void intf_mem_outl(struct si_sm_io *io, unsigned int offset,
		     unsigned char b)
{
	writel(b << io->regshift, (io->addr)+(offset * io->regspacing));
}
static unsigned char mem_inq(struct si_sm_io *io, unsigned int offset)
{
	return (readq((io->addr)+(offset * io->regspacing)) >> io->regshift)
		& 0xff;
}
static void mem_outq(struct si_sm_io *io, unsigned int offset,
		     unsigned char b)
{
	writeq(b << io->regshift, (io->addr)+(offset * io->regspacing));
}
static int ipmi_pci_suspend(struct pci_dev *pdev, pm_message_t state)
{
	return 0;
}
static int ipmi_pci_resume(struct pci_dev *pdev)
{
	return 0;
}
static void setup_oem_data_handler(struct smi_info *smi_info)
{
	setup_dell_poweredge_oem_data_handler(smi_info);
}
static void setup_xaction_handlers(struct smi_info *smi_info)
{
	setup_dell_poweredge_bt_xaction_handler(smi_info);
}
static inline unsigned char read_smic_flags(struct si_sm_data *smic)
{
	return smic->io->inputb(smic->io, 2);
}
static inline unsigned char read_smic_status(struct si_sm_data *smic)
{
	return smic->io->inputb(smic->io, 1);
}
static inline unsigned char read_smic_data(struct si_sm_data *smic)
{
	return smic->io->inputb(smic->io, 0);
}
static inline void write_smic_flags(struct si_sm_data *smic,
				    unsigned char   flags)
{
	smic->io->outputb(smic->io, 2, flags);
}
static inline void write_smic_control(struct si_sm_data *smic,
				      unsigned char   control)
{
	smic->io->outputb(smic->io, 1, control);
}
static inline void write_si_sm_data(struct si_sm_data *smic,
				    unsigned char   data)
{
	smic->io->outputb(smic->io, 0, data);
}
static int smic_size(void)
{
	return sizeof(struct si_sm_data);
}
static int get_param_int(char *buffer, struct kernel_param *kp)
{
	return sprintf(buffer, "%i", *((int *)kp->arg));
}
static void panic_smi_free(struct ipmi_smi_msg *msg)
{
	atomic_dec(&panic_done_count);
}
static void panic_recv_free(struct ipmi_recv_msg *msg)
{
	atomic_dec(&panic_done_count);
}
static void ipmi_new_smi(int if_num, struct device *device)
{
	ipmi_register_watchdog(if_num);
}
static void ipmi_smi_gone(int if_num)
{
	ipmi_unregister_watchdog(if_num);
}
static void unlock_card(struct isi_board *card)
{
	spin_unlock_irqrestore(&card->card_lock, card->flags);
}
static void stli_ecpenable(struct stlibrd *brdp)
{	
	outb(ECP_ATENABLE, (brdp->iobase + ECP_ATCONFR));
}
static void stli_ecpdisable(struct stlibrd *brdp)
{	
	outb(ECP_ATDISABLE, (brdp->iobase + ECP_ATCONFR));
}
static void stli_ecpintr(struct stlibrd *brdp)
{	
	outb(0x1, brdp->iobase);
}
static void stli_ecpeienable(struct stlibrd *brdp)
{	
	outb(ECP_EIENABLE, (brdp->iobase + ECP_EICONFR));
}
static void stli_ecpeidisable(struct stlibrd *brdp)
{	
	outb(ECP_EIDISABLE, (brdp->iobase + ECP_EICONFR));
}
static void stli_ecpmcenable(struct stlibrd *brdp)
{	
	outb(ECP_MCENABLE, (brdp->iobase + ECP_MCCONFR));
}
static void stli_ecpmcdisable(struct stlibrd *brdp)
{	
	outb(ECP_MCDISABLE, (brdp->iobase + ECP_MCCONFR));
}
static void stli_onbenable(struct stlibrd *brdp)
{	
	outb((brdp->enabval | ONB_ATENABLE), (brdp->iobase + ONB_ATCONFR));
}
static void stli_onbdisable(struct stlibrd *brdp)
{	
	outb((brdp->enabval | ONB_ATDISABLE), (brdp->iobase + ONB_ATCONFR));
}
static void stli_onbeenable(struct stlibrd *brdp)
{	
	outb(ONB_EIENABLE, (brdp->iobase + ONB_EICONFR));
}
static void stli_onbedisable(struct stlibrd *brdp)
{	
	outb(ONB_EIDISABLE, (brdp->iobase + ONB_EICONFR));
}
static inline int stli_findeisabrds(void) { return 0; }
int register_keyboard_notifier(struct notifier_block *nb)
{
	return atomic_notifier_chain_register(&keyboard_notifier_list, nb);
}
int unregister_keyboard_notifier(struct notifier_block *nb)
{
	return atomic_notifier_chain_unregister(&keyboard_notifier_list, nb);
}
static void fn_lastcons(struct vc_data *vc)
{
	set_console(last_console);
}
static void fn_scroll_forw(struct vc_data *vc)
{
	scrollfront(vc, 0);
}
static void fn_scroll_back(struct vc_data *vc)
{
	scrollback(vc, 0);
}
static void fn_show_mem(struct vc_data *vc)
{
	show_mem();
}
static void fn_show_state(struct vc_data *vc)
{
	show_state();
}
static void fn_boot_it(struct vc_data *vc)
{
	ctrl_alt_del();
}
static void fn_compose(struct vc_data *vc)
{
	dead_key_next = 1;
}
static void fn_null(struct vc_data *vc)
{
	compute_shiftstate();
}
static void k_lowercase(struct vc_data *vc, unsigned char value, char up_flag)
{
	printk(KERN_ERR "keyboard.c: k_lowercase was called - impossible\n");
}
static void k_self(struct vc_data *vc, unsigned char value, char up_flag)
{
	k_unicode(vc, conv_8bit_to_uni(value), up_flag);
}
static void k_dead2(struct vc_data *vc, unsigned char value, char up_flag)
{
	k_deadunicode(vc, value, up_flag);
}
unsigned char getledstate(void)
{
	return ledstate;
}
static inline void mbcs_algo_init(struct algoblock *algo_soft)
{
	memset(algo_soft, 0, sizeof(struct algoblock));
}
static void mbcs_debug_pioaddr_set(struct mbcs_soft *soft)
{
	soft->debug_addr = mbcs_pioaddr(soft, MBCS_DEBUG_START);
}
static void mbcs_gscr_pioaddr_set(struct mbcs_soft *soft)
{
	soft->gscr_addr = mbcs_pioaddr(soft, MBCS_GSCR_START);
}
static inline int uncached_access(struct file *file, unsigned long addr)
{
	return !(efi_mem_attributes(addr) & EFI_MEMORY_WB);
}
static inline int valid_mmap_phys_addr_range(unsigned long pfn, size_t size)
{
	return 1;
}
static inline int range_is_allowed(unsigned long pfn, unsigned long size)
{
	return 1;
}
int __attribute__((weak)) phys_mem_access_prot_allowed(struct file *file,
	unsigned long pfn, unsigned long size, pgprot_t *vma_prot)
{
	return 1;
}
static inline int private_mapping_ok(struct vm_area_struct *vma)
{
	return vma->vm_flags & VM_MAYSHARE;
}
static inline int private_mapping_ok(struct vm_area_struct *vma)
{
	return 1;
}
static void mmap_mem_open(struct vm_area_struct *vma)
{
	map_devmem(vma->vm_pgoff,  vma->vm_end - vma->vm_start,
			vma->vm_page_prot);
}
static void mmap_mem_close(struct vm_area_struct *vma)
{
	unmap_devmem(vma->vm_pgoff,  vma->vm_end - vma->vm_start,
			vma->vm_page_prot);
}
static ssize_t read_null(struct file * file, char __user * buf,
			 size_t count, loff_t *ppos)
{
	return 0;
}
static ssize_t write_null(struct file * file, const char __user * buf,
			  size_t count, loff_t *ppos)
{
	return count;
}
static int pipe_to_null(struct pipe_inode_info *info, struct pipe_buffer *buf,
			struct splice_desc *sd)
{
	return sd->len;
}
static ssize_t splice_write_null(struct pipe_inode_info *pipe,struct file *out,
				 loff_t *ppos, size_t len, unsigned int flags)
{
	return splice_from_pipe(pipe, out, ppos, len, flags, pipe_to_null);
}
static int mmap_zero(struct file * file, struct vm_area_struct * vma)
{
	return -ENOSYS;
}
static ssize_t write_full(struct file * file, const char __user * buf,
			  size_t count, loff_t *ppos)
{
	return -ENOSPC;
}
static loff_t null_lseek(struct file * file, loff_t offset, int orig)
{
	return file->f_pos = 0;
}
static int open_port(struct inode * inode, struct file * filp)
{
	return capable(CAP_SYS_RAWIO) ? 0 : -EPERM;
}
static void *misc_seq_next(struct seq_file *seq, void *v, loff_t *pos)
{
	return seq_list_next(v, &misc_list, pos);
}
static void misc_seq_stop(struct seq_file *seq, void *v)
{
	mutex_unlock(&misc_mtx);
}
static int misc_seq_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &misc_seq_ops);
}
static int mmtimer_int_pending(int comparator)
{
	if (HUB_L((unsigned long *)LOCAL_MMR_ADDR(SH_EVENT_OCCURRED)) &
			SH_EVENT_OCCURRED_RTC1_INT_MASK << comparator)
		return 1;
	else
		return 0;
}
static void mmtimer_clr_int_pending(int comparator)
{
	HUB_S((u64 *)LOCAL_MMR_ADDR(SH_EVENT_OCCURRED_ALIAS),
		SH_EVENT_OCCURRED_RTC1_INT_MASK << comparator);
}
static void MoxaPortTxDisable(struct moxa_port *port)
{
	moxafunc(port->tableAddr, FC_SetXoffState, Magic_code);
}
static void MoxaPortTxEnable(struct moxa_port *port)
{
	moxafunc(port->tableAddr, FC_SetXonState, Magic_code);
}
static int
fetchop_mmap(struct file *file, struct vm_area_struct *vma)
{
	return mspec_mmap(file, vma, MSPEC_FETCHOP);
}
static int
cached_mmap(struct file *file, struct vm_area_struct *vma)
{
	return mspec_mmap(file, vma, MSPEC_CACHED);
}
static int
uncached_mmap(struct file *file, struct vm_area_struct *vma)
{
	return mspec_mmap(file, vma, MSPEC_UNCACHED);
}
static void mxser_throttle(struct tty_struct *tty)
{
	mxser_stoprx(tty);
}
static void r3964_set_termios(struct tty_struct *tty, struct ktermios *old)
{
	TRACE_L("set_termios");
}
static inline int is_utf8_continuation(unsigned char c)
{
	return (c & 0xc0) == 0x80;
}
static inline int is_continuation(unsigned char c, struct tty_struct *tty)
{
	return I_IUTF8(tty) && is_utf8_continuation(c);
}
int is_ignored(int sig)
{
	return (sigismember(&current->blocked, sig) ||
		current->sighand->action[sig-1].sa.sa_handler == SIG_IGN);
}
static inline struct nozomi *get_dc_by_tty(const struct tty_struct *tty)
{
	return tty ? ndevs[tty->index / MAX_PORT] : NULL;
}
static void __exit nsc_gpio_cleanup(void)
{
	printk(KERN_DEBUG NAME " cleanup\n");
}
unsigned char __nvram_read_byte(int i)
{
	return CMOS_READ(NVRAM_FIRST_BYTE + i);
}
void __nvram_write_byte(unsigned char c, int i)
{
	CMOS_WRITE(c, NVRAM_FIRST_BYTE + i);
}
int __nvram_check_checksum(void)
{
	return mach_check_checksum();
}
static void __nvram_set_checksum(void)
{
	mach_set_checksum();
}
static int nvram_add_proc_fs(void)
{
	return 0;
}
static int nvram_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, nvram_proc_read, NULL);
}
static u32 pc8736x_gpio_configure(unsigned index, u32 mask, u32 bits)
{
	return pc8736x_gpio_configure_fn(index, mask, bits,
					 SIO_GPIO_PIN_CONFIG);
}
static void pc8736x_gpio_change(unsigned index)
{
	pc8736x_gpio_set(index, !pc8736x_gpio_current(index));
}
static inline unsigned char invert_revert(unsigned char ch)
{
	return bitrev8(~ch);
}
static void cm4040_stop_poll(struct reader_dev *dev)
{
	del_timer_sync(&dev->poll_timer);
}
static void start_timing(void)
{
	timing_stats.start_time = jiffies;
}
static int get_current_packet_priority(struct ipw_hardware *hw)
{
	return (hw->to_setup || hw->initializing
			? PRIO_SETUP + 1 : NL_NUM_OF_PRIORITIES);
}
static int is_card_present(struct ipw_hardware *hw)
{
	if (hw->hw_version == HW_VERSION_1)
		return inw(hw->base_port + IOIR) != 0xFFFF;
	else
		return readl(&hw->memory_info_regs->memreg_card_present) ==
		    CARD_PRESENT_VALUE;
}
int ipwireless_set_DTR(struct ipw_hardware *hw, unsigned int channel_idx,
		       int state)
{
	return set_DTR(hw, PRIO_CTRL, channel_idx, state);
}
int ipwireless_set_RTS(struct ipw_hardware *hw, unsigned int channel_idx,
		       int state)
{
	return set_RTS(hw, PRIO_CTRL, channel_idx, state);
}
void ipwireless_associate_network(struct ipw_hardware *hw,
				  struct ipw_network *network)
{
	hw->network = network;
}
int ipwireless_ppp_mru(const struct ipw_network *network)
{
	return network->mru;
}
static void ipw_close(struct tty_struct *linux_tty, struct file *filp)
{
	ipw_hangup(linux_tty);
}
int ipwireless_tty_is_modem(struct ipw_tty *tty)
{
	return tty->tty_type == TTYTYPE_MODEM;
}
static void* mgslpc_get_text_ptr(void)
{
	return mgslpc_get_text_ptr;
}
static void __exit synclink_cs_exit(void)
{
	synclink_cs_cleanup();
}
static void pp_attach(struct parport *port)
{
	device_create(ppdev_class, port->dev, MKDEV(PP_MAJOR, port->number),
		      NULL, "parport%d", port->number);
}
static void pp_detach(struct parport *port)
{
	device_destroy(ppdev_class, MKDEV(PP_MAJOR, port->number));
}
static int __init ps3flash_init(void)
{
	return ps3_system_bus_driver_register(&ps3flash);
}
static void __exit ps3flash_exit(void)
{
	ps3_system_bus_driver_unregister(&ps3flash);
}
static void pty_unix98_shutdown(struct tty_struct *tty)
{
	kfree(tty->termios);
}
static void pty_unix98_remove(struct tty_driver *driver, struct tty_struct *tty)
{
	pty_count--;
}
static void mix_pool_bytes(struct entropy_store *r, const void *in, int bytes)
{
       mix_pool_bytes_extract(r, in, bytes, NULL);
}
static struct timer_rand_state *get_timer_rand_state(unsigned int irq)
{
	return irq_timer_state[irq];
}
static void set_timer_rand_state(unsigned int irq,
				 struct timer_rand_state *state)
{
	irq_timer_state[irq] = state;
}
void get_random_bytes(void *buf, int nbytes)
{
	extract_entropy(&nonblocking_pool, buf, nbytes, 0, 0);
}
static ssize_t
urandom_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
{
	return extract_entropy_user(&nonblocking_pool, buf, nbytes);
}
static int random_fasync(int fd, struct file *filp, int on)
{
	return fasync_helper(fd, filp, on, &fasync);
}
unsigned int get_random_int(void)
{
	return secure_ip_id((__force __be32)(current->pid + jiffies));
}
void rio_copy_to_card(void *from, void __iomem *to, int len)
{
	rio_copy_toio(to, from, len);
}
int rio_minor(struct tty_struct *tty)
{
	return tty->index + (tty->driver == rio_driver) ? 0 : 256;
}
static int rio_set_real_termios(void *ptr)
{
	return RIOParam((struct Port *) ptr, RIOC_CONFIG, 1, 1);
}
void RIOFreeCmdBlk(struct CmdBlk *CmdBlkP)
{
	kfree(CmdBlkP);
}
static inline int board_No(struct riscom_board const *bp)
{
	return bp - rc_board;
}
static inline int port_No(struct riscom_port const *port)
{
	return RC_PORT(port - rc_port);
}
static inline struct riscom_board *port_Board(struct riscom_port const *port)
{
	return &rc_board[RC_BOARD(port - rc_port)];
}
static inline unsigned char rc_in(struct riscom_board const *bp,
							unsigned short reg)
{
	return inb(bp->base + RC_TO_ISA(reg));
}
static inline void rc_out(struct riscom_board const *bp, unsigned short reg,
			  unsigned char val)
{
	outb(val, bp->base + RC_TO_ISA(reg));
}
static void sSetInterfaceMode(CHANNEL_T * ChP, Byte_t mode)
{
	sOutB(ChP->CtlP->AiopIO[2], (mode & 0x18) | ChP->ChanNum);
}
static unsigned char GetLineNumber(int ctrl, int aiop, int ch)
{
	return lineNumbers[(ctrl << 5) | (aiop << 3) | ch];
}
static irqreturn_t hpet_rtc_interrupt(int irq, void *dev_id)
{
	return 0;
}
static void __exit cleanup_sysctl(void)
{
    unregister_sysctl_table(sysctl_header);
}
static ssize_t rtc_read(struct file *file, char __user *buf,
			size_t count, loff_t *ppos)
{
	return -EIO;
}
static int rtc_fasync(int fd, struct file *filp, int on)
{
	return fasync_helper(fd, filp, on, &rtc_async_queue);
}
int rtc_register(rtc_task_t *task)
{
	return -EIO;
}
int rtc_unregister(rtc_task_t *task)
{
	return -EIO;
}
int rtc_control(rtc_task_t *task, unsigned int cmd, unsigned long arg)
{
	return -EIO;
}
static int rtc_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, rtc_proc_show, NULL);
}
static int scx200_gpio_release(struct inode *inode, struct file *file)
{
	return 0;
}
static inline void highlight(const int s, const int e)
{
	invert_screen(sel_cons, s, e-s+2, 1);
}
static inline void highlight_pointer(const int where)
{
	complement_pos(sel_cons, where);
}
static u16
sel_pos(int n)
{
	return inverse_translate(sel_cons, screen_glyph(sel_cons, n),
				use_unicode);
}
static inline int inword(const u16 c) {
	return c > 0xff || (( inwordLut[c>>5] >> (c & 0x1F) ) & 1);
}
int sel_loadlut(char __user *p)
{
	return copy_from_user(inwordLut, (u32 __user *)(p+4), 32) ? -EFAULT : 0;
}
static inline int atedge(const int p, int size_row)
{
	return (!(p % size_row)	|| !((p + 2) % size_row));
}
static inline unsigned short limit(const unsigned short v, const unsigned short u)
{
	return (v > u) ? u : v;
}
static inline volatile struct a2232memory *a2232mem(unsigned int board)
{
	return (volatile struct a2232memory *)ZTWO_VADDR(zd_a2232[board]->resource.start);
}
static void a2232_hungup(void *ptr)
{
	a2232_close(ptr);
}
static int a2232_ioctl(	struct tty_struct *tty, struct file *file,
			unsigned int cmd, unsigned long arg)
{
	return -ENOIOCTLCMD;
}
static int
get_default_threshold(struct cyclades_port *info, unsigned long __user * value)
{
	return put_user(info->default_threshold, value);
}
static int
get_default_timeout(struct cyclades_port *info, unsigned long __user * value)
{
	return put_user(info->default_timeout, value);
}
 static void show_version(void)
{
	printk("MVME166/167 cd2401 driver\n");
}				/* show_version */
static inline int
read_status_check(struct subch_data_s *sd, int *len)
{
	return ia64_sn_irtr_recv(sd->sd_nasid, sd->sd_subch, sd->sd_rb, len);
}
static inline int
write_status_check(struct subch_data_s *sd, int count)
{
	return ia64_sn_irtr_send(sd->sd_nasid, sd->sd_subch, sd->sd_wb, count);
}
static void sonypi_set(u8 fn, u8 v)
{
	wait_on_command(0, sonypi_call3(0x90, fn, v), ITERATIONS_SHORT);
}
static int sonypi_misc_fasync(int fd, struct file *filp, int on)
{
	return fasync_helper(fd, filp, on, &sonypi_device.fifo_async);
}
static void sonypi_shutdown(struct platform_device *dev)
{
	sonypi_disable();
}
static inline int board_No(struct specialix_board *bp)
{
	return bp - sx_board;
}
static inline int port_No(struct specialix_port const *port)
{
	return SX_PORT(port - sx_port);
}
static inline struct specialix_board *port_Board(
					struct specialix_port const *port)
{
	return &sx_board[SX_BOARD(port - sx_port)];
}
static int sx_request_io_range(struct specialix_board *bp)
{
	return request_region(bp->base,
		bp->flags & SX_BOARD_IS_PCI ? SX_PCI_IO_SPACE : SX_IO_SPACE,
		"specialix IO8+") == NULL;
}
static void sx_release_io_range(struct specialix_board *bp)
{
	release_region(bp->base, bp->flags & SX_BOARD_IS_PCI ?
					SX_PCI_IO_SPACE : SX_IO_SPACE);
}
static inline void write_sx_byte(struct sx_board *board, int offset, u8 byte)
{
	writeb(byte, board->base + offset);
}
static inline u8 read_sx_byte(struct sx_board *board, int offset)
{
	return readb(board->base + offset);
}
static inline void write_sx_word(struct sx_board *board, int offset, u16 word)
{
	writew(word, board->base + offset);
}
static inline u16 read_sx_word(struct sx_board *board, int offset)
{
	return readw(board->base + offset);
}
static int mod_compat_type(int module_type)
{
	return module_type >> 4;
}
static void* mgsl_get_text_ptr(void)
{
	return mgsl_get_text_ptr;
}
static void __exit synclink_exit(void)
{
	synclink_cleanup();
}
static int num_free_tx_dma_buffers(struct mgsl_struct *info)
{
	return info->tx_buffer_count - info->tx_dma_buffers_used;
}
static int usc_loopmode_active( struct mgsl_struct * info)
{
 	return usc_InReg( info, CCSR ) & BIT7 ? 1 : 0 ;
}
static void __exit slgt_exit(void)
{
	slgt_cleanup();
}
static void reset_rbufs(struct slgt_info *info)
{
	free_rbufs(info, 0, info->rbuf_count - 1);
}
static void* synclinkmp_get_text_ptr(void) {return synclinkmp_get_text_ptr;}
static void __exit synclinkmp_exit(void)
{
	synclinkmp_cleanup();
}
static void rx_reset_buffers(SLMP_INFO *info)
{
	rx_free_frame_buffers(info, 0, info->rx_buf_count - 1);
}
int sysrq_on(void)
{
	return __sysrq_enabled || sysrq_always_enabled;
}
static inline int sysrq_on_mask(int mask)
{
	return sysrq_always_enabled || __sysrq_enabled == 1 ||
						(__sysrq_enabled & mask);
}
static void sysrq_handle_crashdump(int key, struct tty_struct *tty)
{
	crash_kexec(get_irq_regs());
}
static void sysrq_handle_sync(int key, struct tty_struct *tty)
{
	emergency_sync();
}
static void sysrq_handle_show_timers(int key, struct tty_struct *tty)
{
	sysrq_timer_list_show();
}
static void sysrq_handle_mountro(int key, struct tty_struct *tty)
{
	emergency_remount();
}
static void sysrq_handle_showlocks(int key, struct tty_struct *tty)
{
	debug_show_all_locks();
}
static void sysrq_showregs_othercpus(struct work_struct *dummy)
{
	smp_call_function(showacpu, NULL, 0);
}
static void sysrq_handle_showstate(int key, struct tty_struct *tty)
{
	show_state();
}
static void sysrq_handle_showstate_blocked(int key, struct tty_struct *tty)
{
	show_state_filter(TASK_UNINTERRUPTIBLE);
}
static void sysrq_ftrace_dump(int key, struct tty_struct *tty)
{
	ftrace_dump();
}
static void sysrq_handle_showmem(int key, struct tty_struct *tty)
{
	show_mem();
}
static void moom_callback(struct work_struct *ignored)
{
	out_of_memory(node_zonelist(0, GFP_KERNEL), GFP_KERNEL, 0);
}
static void sysrq_handle_moom(int key, struct tty_struct *tty)
{
	schedule_work(&moom_work);
}
static void sysrq_handle_unrt(int key, struct tty_struct *tty)
{
	normalize_rt_tasks();
}
int register_sysrq_key(int key, struct sysrq_key_op *op_p)
{
	return __sysrq_swap_key_ops(key, op_p, NULL);
}
int unregister_sysrq_key(int key, struct sysrq_key_op *op_p)
{
	return __sysrq_swap_key_ops(key, NULL, op_p);
}
static inline char get_led(void)
{
	return (char)tb0219_read(TB0219_LED);
}
static int tanbac_tb0219_release(struct inode *inode, struct file *file)
{
	return 0;
}
static void tb0219_restart(char *command)
{
	tb0219_write(TB0219_RESET, 0);
}
static int proc_toshiba_open(struct inode *inode, struct file *file)
{
	return single_open(file, proc_toshiba_show, NULL);
}
static void tpm_atml_cancel(struct tpm_chip *chip)
{
	iowrite8(ATML_STATUS_ABORT, chip->vendor.iobase + 1);
}
static u8 tpm_atml_status(struct tpm_chip *chip)
{
	return ioread8(chip->vendor.iobase + 1);
}
static int tpm_atml_suspend(struct platform_device *dev, pm_message_t msg)
{
	return tpm_pm_suspend(&dev->dev, msg);
}
static int tpm_atml_resume(struct platform_device *dev)
{
	return tpm_pm_resume(&dev->dev);
}
static inline unsigned char tpm_data_in(unsigned char offset)
{
	if (tpm_dev.iotype == TPM_INF_IO_PORT)
		return inb(tpm_dev.data_regs + offset);
	else
		return readb(tpm_dev.mem_base + tpm_dev.data_regs + offset);
}
static inline unsigned char tpm_config_in(unsigned char offset)
{
	if (tpm_dev.iotype == TPM_INF_IO_PORT)
		return inb(tpm_dev.config_port + offset);
	else
		return readb(tpm_dev.mem_base + tpm_dev.index_off + offset);
}
static u8 tpm_inf_status(struct tpm_chip *chip)
{
	return tpm_data_in(STAT);
}
static int __init init_inf(void)
{
	return pnp_register_driver(&tpm_inf_pnp_driver);
}
static void __exit cleanup_inf(void)
{
	pnp_unregister_driver(&tpm_inf_pnp_driver);
}
static void tpm_nsc_cancel(struct tpm_chip *chip)
{
	outb(NSC_COMMAND_CANCEL, chip->vendor.base + NSC_COMMAND);
}
static u8 tpm_nsc_status(struct tpm_chip *chip)
{
	return inb(chip->vendor.base + NSC_STATUS);
}
static int tpm_nsc_suspend(struct platform_device *dev, pm_message_t msg)
{
	return tpm_pm_suspend(&dev->dev, msg);
}
static int tpm_nsc_resume(struct platform_device *dev)
{
	return tpm_pm_resume(&dev->dev);
}
static u8 tpm_tis_status(struct tpm_chip *chip)
{
	return ioread8(chip->vendor.iobase +
		       TPM_STS(chip->vendor.locality));
}
static void tpm_tis_ready(struct tpm_chip *chip)
{
	iowrite8(TPM_STS_COMMAND_READY,
		 chip->vendor.iobase + TPM_STS(chip->vendor.locality));
}
static int tpm_tis_pnp_suspend(struct pnp_dev *dev, pm_message_t msg)
{
	return tpm_pm_suspend(&dev->dev, msg);
}
static int tpm_tis_pnp_resume(struct pnp_dev *dev)
{
	return tpm_pm_resume(&dev->dev);
}
static int tpm_tis_suspend(struct platform_device *dev, pm_message_t msg)
{
	return tpm_pm_suspend(&dev->dev, msg);
}
static int tpm_tis_resume(struct platform_device *dev)
{
	return tpm_pm_resume(&dev->dev);
}
struct tty_struct *alloc_tty_struct(void)
{
	return kzalloc(sizeof(struct tty_struct), GFP_KERNEL);
}
static ssize_t hung_up_tty_read(struct file *file, char __user *buf,
				size_t count, loff_t *ppos)
{
	return 0;
}
static ssize_t hung_up_tty_write(struct file *file, const char __user *buf,
				 size_t count, loff_t *ppos)
{
	return -EIO;
}
static unsigned int hung_up_tty_poll(struct file *filp, poll_table *wait)
{
	return POLLIN | POLLOUT | POLLERR | POLLHUP | POLLRDNORM | POLLWRNORM;
}
static long hung_up_tty_ioctl(struct file *file, unsigned int cmd,
		unsigned long arg)
{
	return cmd == TIOCSPGRP ? -ENOTTY : -EIO;
}
static long hung_up_tty_compat_ioctl(struct file *file,
				     unsigned int cmd, unsigned long arg)
{
	return cmd == TIOCSPGRP ? -ENOTTY : -EIO;
}
int tty_hung_up_p(struct file *filp)
{
	return (filp->f_op == &hung_up_tty_fops);
}
static void tty_line_name(struct tty_driver *driver, int index, char *p)
{
	sprintf(p, "%s%d", driver->name, index + driver->name_base);
}
void tty_unregister_device(struct tty_driver *driver, unsigned index)
{
	device_destroy(tty_class,
		MKDEV(driver->major, driver->minor_start) + index);
}
void tty_driver_kref_put(struct tty_driver *driver)
{
	kref_put(&driver->kref, destruct_tty_driver);
}

void tty_set_operations(struct tty_driver *driver,
			const struct tty_operations *op)
{
	driver->ops = op;
}
void put_tty_driver(struct tty_driver *d)
{
	tty_driver_kref_put(d);
}
dev_t tty_devnum(struct tty_struct *tty)
{
	return MKDEV(tty->driver->major, tty->driver->minor_start) + tty->index;
}
void tty_default_fops(struct file_operations *fops)
{
	*fops = tty_fops;
}
int tty_chars_in_buffer(struct tty_struct *tty)
{
	if (tty->ops->chars_in_buffer)
		return tty->ops->chars_in_buffer(tty);
	else
		return 0;
}
void tty_encode_baud_rate(struct tty_struct *tty, speed_t ibaud, speed_t obaud)
{
	tty_termios_encode_baud_rate(tty->termios, ibaud, obaud);
}
static void * tty_ldiscs_seq_start(struct seq_file *m, loff_t *pos)
{
	return (*pos < NR_LDISCS) ? pos : NULL;
}
static int proc_tty_ldiscs_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &tty_ldiscs_seq_ops);
}
void tty_ldisc_begin(void)
{
	(void) tty_register_ldisc(N_TTY, &tty_ldisc_N_TTY);
}
static int proc_viotape_open(struct inode *inode, struct file *file)
{
	return single_open(file, proc_viotape_show, NULL);
}
static void notifier_del_vio(struct hvc_struct *hp, int data)
{
	hp->irq_requested = 0;
}
static int __init init(void)
{
	return register_virtio_driver(&virtio_console);
}
static int scc_ioctl(struct tty_struct *tty, struct file *file,
		     unsigned int cmd, unsigned long arg)
{
	return -ENOIOCTLCMD;
}
static void ack_giuint_low(unsigned int irq)
{
	giu_write(GIUINTSTATL, 1 << GPIO_PIN_OF_IRQ(irq));
}
static void mask_giuint_low(unsigned int irq)
{
	giu_clear(GIUINTENL, 1 << GPIO_PIN_OF_IRQ(irq));
}
static void unmask_giuint_low(unsigned int irq)
{
	giu_set(GIUINTENL, 1 << GPIO_PIN_OF_IRQ(irq));
}
static void ack_giuint_high(unsigned int irq)
{
	giu_write(GIUINTSTATH, 1 << (GPIO_PIN_OF_IRQ(irq) - GIUINT_HIGH_OFFSET));
}
static void mask_giuint_high(unsigned int irq)
{
	giu_clear(GIUINTENH, 1 << (GPIO_PIN_OF_IRQ(irq) - GIUINT_HIGH_OFFSET));
}
static void unmask_giuint_high(unsigned int irq)
{
	giu_set(GIUINTENH, 1 << (GPIO_PIN_OF_IRQ(irq) - GIUINT_HIGH_OFFSET));
}
static int __init vr41xx_giu_init(void)
{
	return platform_driver_register(&giu_device_driver);
}
static void __exit vr41xx_giu_exit(void)
{
	platform_driver_unregister(&giu_device_driver);
}
int register_vt_notifier(struct notifier_block *nb)
{
	return atomic_notifier_chain_register(&vt_notifier_list, nb);
}
int unregister_vt_notifier(struct notifier_block *nb)
{
	return atomic_notifier_chain_unregister(&vt_notifier_list, nb);
}
void schedule_console_callback(void)
{
	schedule_work(&console_work);
}
int vc_cons_allocated(unsigned int i)
{
	return (i < MAX_NR_CONSOLES && vc_cons[i].d);
}
int vc_resize(struct vc_data *vc, unsigned int cols, unsigned int rows)
{
	return vc_do_resize(vc->vc_tty, vc, cols, rows);
}
static void gotoxay(struct vc_data *vc, int new_x, int new_y)
{
	gotoxy(vc, new_x, vc->vc_decom ? (vc->vc_top + new_y) : new_y);
}
static inline void status_report(struct tty_struct *tty)
{
	respond_string("\033[0n", tty);	/* Terminal ok */
}
static inline void respond_ID(struct tty_struct * tty)
{
	respond_string(VT102ID, tty);
}
int mouse_reporting(void)
{
	return vc_cons[fg_console].d->vc_report_mouse;
}
static int con_chars_in_buffer(struct tty_struct *tty)
{
	return 0;		/* we're not buffering */
}
static inline int vt_bind(struct con_driver *con)
{
	return 0;
}
static inline int vt_unbind(struct con_driver *con)
{
	return 0;
}
void give_up_console(const struct consw *csw)
{
	unregister_con_driver(csw);
}
void unblank_screen(void)
{
	do_unblank_screen(0);
}
unsigned short *screen_pos(struct vc_data *vc, int w_offset, int viewed)
{
	return screenpos(vc, 2 * w_offset, viewed);
}
u32 buffer_icap_get_status(struct hwicap_drvdata *drvdata)
{
	return in_be32(drvdata->base_address + XHI_STATUS_REG_OFFSET);
}
static inline u32 buffer_icap_get_bram(void __iomem *base_address,
		u32 offset)
{
	return in_be32(base_address + (offset << 2));
}
static inline void buffer_icap_set_size(void __iomem *base_address,
		u32 data)
{
	out_be32(base_address + XHI_SIZE_REG_OFFSET, data);
}
static inline void buffer_icap_set_offset(void __iomem *base_address,
		u32 data)
{
	out_be32(base_address + XHI_BRAM_OFFSET_REG_OFFSET, data);
}
static inline void buffer_icap_set_rnc(void __iomem *base_address,
		u32 data)
{
	out_be32(base_address + XHI_RNC_REG_OFFSET, data);
}
static inline void buffer_icap_set_bram(void __iomem *base_address,
		u32 offset, u32 data)
{
	out_be32(base_address + (offset << 2), data);
}
void buffer_icap_reset(struct hwicap_drvdata *drvdata)
{
    out_be32(drvdata->base_address + XHI_STATUS_REG_OFFSET, 0xFEFE);
}
static inline void fifo_icap_set_read_size(struct hwicap_drvdata *drvdata,
		u32 data)
{
	out_be32(drvdata->base_address + XHI_SZ_OFFSET, data);
}
static inline u32 fifo_icap_write_fifo_vacancy(
		struct hwicap_drvdata *drvdata)
{
	return in_be32(drvdata->base_address + XHI_WFV_OFFSET);
}
static inline u32 fifo_icap_read_fifo_occupancy(
		struct hwicap_drvdata *drvdata)
{
	return in_be32(drvdata->base_address + XHI_RFO_OFFSET);
}
static int __devexit hwicap_drv_remove(struct platform_device *pdev)
{
	return hwicap_remove(&pdev->dev);
}
static int __devexit hwicap_of_remove(struct of_device *op)
{
	return hwicap_remove(&op->dev);
}
static inline void __exit hwicap_of_unregister(void)
{
	of_unregister_platform_driver(&hwicap_of_driver);
}
static inline int __init hwicap_of_register(void) { return 0; }
static inline u32 read_pmtmr(void)
{
	return inl(pmtmr_ioport) & ACPI_PM_MASK;
}
static cycle_t acpi_pm_read(void)
{
	return (cycle_t)read_pmtmr();
}
static cycle_t acpi_pm_read_slow(void)
{
	return (cycle_t)acpi_pm_read_verified();
}
static cycle_t read_cyclone(void)
{
	return (cycle_t)readl(cyclone_ptr);
}
static cycle_t read_hrt(void)
{
	return (cycle_t) inl(scx200_cb_base + SCx200_TIMER_OFFSET);
}
static struct sh_cmt_priv *ced_to_sh_cmt(struct clock_event_device *ced)
{
	return container_of(ced, struct sh_cmt_priv, ced);
}
static int __devexit sh_cmt_remove(struct platform_device *pdev)
{
	return -EBUSY; /* cannot unregister clockevent and clocksource */
}
static int __init sh_cmt_init(void)
{
	return platform_driver_register(&sh_cmt_device_driver);
}
static void __exit sh_cmt_exit(void)
{
	platform_driver_unregister(&sh_cmt_device_driver);
}
static struct tc_clkevt_device *to_tc_clkevt(struct clock_event_device *clkevt)
{
	return container_of(clkevt, struct tc_clkevt_device, clkevt);
}
int cn_cb_equal(struct cb_id *i1, struct cb_id *i2)
{
	return ((i1->idx == i2->idx) && (i1->val == i2->val));
}
static int cn_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, cn_proc_show, NULL);
}
static inline void cpufreq_debug_enable_ratelimit(void) { return; }
static inline void cpufreq_debug_disable_ratelimit(void) { return; }
static inline void adjust_jiffies(unsigned long val, struct cpufreq_freqs *ci)
{
	return;
}
static ssize_t show_##file_name				\
(struct cpufreq_policy *policy, char *buf)		\
{							\
	return sprintf(buf, "%u\n", policy->object);	\
}
static ssize_t show_scaling_driver(struct cpufreq_policy *policy, char *buf)
{
	return scnprintf(buf, CPUFREQ_NAME_LEN, "%s\n", cpufreq_driver->name);
}
static ssize_t show_affected_cpus(struct cpufreq_policy *policy, char *buf)
{
	return show_cpus(policy->cpus, buf);
}
static unsigned int minimum_sampling_rate(void)
{
	return max(def_sampling_rate / 10, MIN_STAT_SAMPLING_RATE);
}
static ssize_t show_##file_name						\
(struct cpufreq_policy *unused, char *buf)				\
{									\
	return sprintf(buf, "%u\n", dbs_tuners_ins.object);		\
}
static int __init cpufreq_gov_dbs_init(void)
{
	return cpufreq_register_governor(&cpufreq_gov_conservative);
}
static unsigned int minimum_sampling_rate(void)
{
	return max(def_sampling_rate / 10, MIN_STAT_SAMPLING_RATE);
}
static ssize_t show_##file_name						\
(struct cpufreq_policy *unused, char *buf)				\
{									\
	return sprintf(buf, "%u\n", dbs_tuners_ins.object);		\
}
static int __init cpufreq_gov_performance_init(void)
{
	return cpufreq_register_governor(&cpufreq_gov_performance);
}
static void __exit cpufreq_gov_performance_exit(void)
{
	cpufreq_unregister_governor(&cpufreq_gov_performance);
}
static int __init cpufreq_gov_powersave_init(void)
{
	return cpufreq_register_governor(&cpufreq_gov_powersave);
}
static void __exit cpufreq_gov_powersave_exit(void)
{
	cpufreq_unregister_governor(&cpufreq_gov_powersave);
}
static ssize_t show_speed(struct cpufreq_policy *policy, char *buf)
{
	return sprintf(buf, "%u\n", per_cpu(cpu_cur_freq, policy->cpu));
}
static int __init cpufreq_gov_userspace_init(void)
{
	return cpufreq_register_governor(&cpufreq_gov_userspace);
}
static void __exit cpufreq_gov_userspace_exit(void)
{
	cpufreq_unregister_governor(&cpufreq_gov_userspace);
}
struct cpufreq_frequency_table *cpufreq_frequency_get_table(unsigned int cpu)
{
	return per_cpu(show_table, cpu);
}
static void cpuidle_kick_cpus(void)
{
	cpu_idle_wait();
}
static inline void latency_notifier_init(struct notifier_block *n)
{
	pm_qos_add_notifier(PM_QOS_CPU_DMA_LATENCY, n);
}
static int __init init_ladder(void)
{
	return cpuidle_register_governor(&ladder_governor);
}
static void __exit exit_ladder(void)
{
	cpuidle_unregister_governor(&ladder_governor);
}
static int __init init_menu(void)
{
	return cpuidle_register_governor(&menu_governor);
}
static void __exit exit_menu(void)
{
	cpuidle_unregister_governor(&menu_governor);
}
void cpuidle_remove_class_sysfs(struct sysdev_class *cls)
{
	sysfs_remove_group(&cls->kset.kobj, &cpuclass_attr_group);
}
static ssize_t show_state_##_name(struct cpuidle_state *state, char *buf) \
{ \
	return sprintf(buf, "%u\n", state->_name);\
}
static ssize_t show_state_##_name(struct cpuidle_state *state, char *buf) \
{ \
	return sprintf(buf, "%llu\n", state->_name);\
}
int crypto4xx_setkey_aes_cbc(struct crypto_ablkcipher *cipher,
			     const u8 *key, unsigned int keylen)
{
	return crypto4xx_setkey_aes(cipher, key, keylen, CRYPTO_MODE_CBC,
				    CRYPTO_FEEDBACK_MODE_NO_FB);
}
int crypto4xx_hash_final(struct ahash_request *req)
{
	return 0;
}
int crypto4xx_sha1_alg_init(struct crypto_tfm *tfm)
{
	return crypto4xx_hash_alg_init(tfm, SA_HASH160_LEN, SA_HASH_ALG_SHA1,
				       SA_HASH_MODE_HASH);
}
static inline void crypto4xx_destroy_gdr(struct crypto4xx_device *dev)
{
	dma_free_coherent(dev->core_dev->device,
			  sizeof(struct ce_gd) * PPC4XX_NUM_GD,
			  dev->gdr, dev->gdr_pa);
}
static u32 get_next_gd(u32 current)
{
	if (current != PPC4XX_LAST_GD)
		return current + 1;
	else
		return 0;
}
static u32 get_next_sd(u32 current)
{
	if (current != PPC4XX_LAST_SD)
		return current + 1;
	else
		return 0;
}
static int __init crypto4xx_init(void)
{
	return of_register_platform_driver(&crypto4xx_driver);
}
static void __exit crypto4xx_exit(void)
{
	of_unregister_platform_driver(&crypto4xx_driver);
}
static int __init
geode_aes_init(void)
{
	return pci_register_driver(&geode_aes_driver);
}
static void __exit
geode_aes_exit(void)
{
	pci_unregister_driver(&geode_aes_driver);
}
static inline void hifn_write_0(struct hifn_device *dev, u32 reg, u32 val)
{
	writel((__force u32)cpu_to_le32(val), dev->bar[0] + reg);
}
static inline void hifn_write_1(struct hifn_device *dev, u32 reg, u32 val)
{
	writel((__force u32)cpu_to_le32(val), dev->bar[1] + reg);
}
static void hifn_unregister_rng(struct hifn_device *dev)
{
	hwrng_unregister(&dev->rng);
}
static inline int hifn_encrypt_aes_ecb(struct ablkcipher_request *req)
{
	return hifn_setup_crypto(req, ACRYPTO_OP_ENCRYPT,
			ACRYPTO_TYPE_AES_128, ACRYPTO_MODE_ECB);
}
static inline int hifn_encrypt_aes_cbc(struct ablkcipher_request *req)
{
	return hifn_setup_crypto(req, ACRYPTO_OP_ENCRYPT,
			ACRYPTO_TYPE_AES_128, ACRYPTO_MODE_CBC);
}
static inline int hifn_encrypt_aes_cfb(struct ablkcipher_request *req)
{
	return hifn_setup_crypto(req, ACRYPTO_OP_ENCRYPT,
			ACRYPTO_TYPE_AES_128, ACRYPTO_MODE_CFB);
}
static inline int hifn_encrypt_aes_ofb(struct ablkcipher_request *req)
{
	return hifn_setup_crypto(req, ACRYPTO_OP_ENCRYPT,
			ACRYPTO_TYPE_AES_128, ACRYPTO_MODE_OFB);
}
static inline int hifn_decrypt_aes_ecb(struct ablkcipher_request *req)
{
	return hifn_setup_crypto(req, ACRYPTO_OP_DECRYPT,
			ACRYPTO_TYPE_AES_128, ACRYPTO_MODE_ECB);
}
static inline int hifn_decrypt_aes_cbc(struct ablkcipher_request *req)
{
	return hifn_setup_crypto(req, ACRYPTO_OP_DECRYPT,
			ACRYPTO_TYPE_AES_128, ACRYPTO_MODE_CBC);
}
static inline int hifn_decrypt_aes_cfb(struct ablkcipher_request *req)
{
	return hifn_setup_crypto(req, ACRYPTO_OP_DECRYPT,
			ACRYPTO_TYPE_AES_128, ACRYPTO_MODE_CFB);
}
static inline int hifn_decrypt_aes_ofb(struct ablkcipher_request *req)
{
	return hifn_setup_crypto(req, ACRYPTO_OP_DECRYPT,
			ACRYPTO_TYPE_AES_128, ACRYPTO_MODE_OFB);
}
static inline int hifn_encrypt_des_ecb(struct ablkcipher_request *req)
{
	return hifn_setup_crypto(req, ACRYPTO_OP_ENCRYPT,
			ACRYPTO_TYPE_DES, ACRYPTO_MODE_ECB);
}
static inline int hifn_encrypt_des_cbc(struct ablkcipher_request *req)
{
	return hifn_setup_crypto(req, ACRYPTO_OP_ENCRYPT,
			ACRYPTO_TYPE_DES, ACRYPTO_MODE_CBC);
}
static inline int hifn_encrypt_des_cfb(struct ablkcipher_request *req)
{
	return hifn_setup_crypto(req, ACRYPTO_OP_ENCRYPT,
			ACRYPTO_TYPE_DES, ACRYPTO_MODE_CFB);
}
static inline int hifn_encrypt_des_ofb(struct ablkcipher_request *req)
{
	return hifn_setup_crypto(req, ACRYPTO_OP_ENCRYPT,
			ACRYPTO_TYPE_DES, ACRYPTO_MODE_OFB);
}
static inline int hifn_decrypt_des_ecb(struct ablkcipher_request *req)
{
	return hifn_setup_crypto(req, ACRYPTO_OP_DECRYPT,
			ACRYPTO_TYPE_DES, ACRYPTO_MODE_ECB);
}
static inline int hifn_decrypt_des_cbc(struct ablkcipher_request *req)
{
	return hifn_setup_crypto(req, ACRYPTO_OP_DECRYPT,
			ACRYPTO_TYPE_DES, ACRYPTO_MODE_CBC);
}
static inline int hifn_decrypt_des_cfb(struct ablkcipher_request *req)
{
	return hifn_setup_crypto(req, ACRYPTO_OP_DECRYPT,
			ACRYPTO_TYPE_DES, ACRYPTO_MODE_CFB);
}
static inline int hifn_decrypt_des_ofb(struct ablkcipher_request *req)
{
	return hifn_setup_crypto(req, ACRYPTO_OP_DECRYPT,
			ACRYPTO_TYPE_DES, ACRYPTO_MODE_OFB);
}
static inline int hifn_encrypt_3des_ecb(struct ablkcipher_request *req)
{
	return hifn_setup_crypto(req, ACRYPTO_OP_ENCRYPT,
			ACRYPTO_TYPE_3DES, ACRYPTO_MODE_ECB);
}
static inline int hifn_encrypt_3des_cbc(struct ablkcipher_request *req)
{
	return hifn_setup_crypto(req, ACRYPTO_OP_ENCRYPT,
			ACRYPTO_TYPE_3DES, ACRYPTO_MODE_CBC);
}
static inline int hifn_encrypt_3des_cfb(struct ablkcipher_request *req)
{
	return hifn_setup_crypto(req, ACRYPTO_OP_ENCRYPT,
			ACRYPTO_TYPE_3DES, ACRYPTO_MODE_CFB);
}
static inline int hifn_encrypt_3des_ofb(struct ablkcipher_request *req)
{
	return hifn_setup_crypto(req, ACRYPTO_OP_ENCRYPT,
			ACRYPTO_TYPE_3DES, ACRYPTO_MODE_OFB);
}
static inline int hifn_decrypt_3des_ecb(struct ablkcipher_request *req)
{
	return hifn_setup_crypto(req, ACRYPTO_OP_DECRYPT,
			ACRYPTO_TYPE_3DES, ACRYPTO_MODE_ECB);
}
static inline int hifn_decrypt_3des_cbc(struct ablkcipher_request *req)
{
	return hifn_setup_crypto(req, ACRYPTO_OP_DECRYPT,
			ACRYPTO_TYPE_3DES, ACRYPTO_MODE_CBC);
}
static inline int hifn_decrypt_3des_cfb(struct ablkcipher_request *req)
{
	return hifn_setup_crypto(req, ACRYPTO_OP_DECRYPT,
			ACRYPTO_TYPE_3DES, ACRYPTO_MODE_CFB);
}
static inline int hifn_decrypt_3des_ofb(struct ablkcipher_request *req)
{
	return hifn_setup_crypto(req, ACRYPTO_OP_DECRYPT,
			ACRYPTO_TYPE_3DES, ACRYPTO_MODE_OFB);
}
static void dev_release(struct device *dev)
{
	return;
}
static inline dma_addr_t crypt_virt2phys(struct crypt_ctl *virt)
{
	return crypt_phys + (virt - crypt_virt) * sizeof(struct crypt_ctl);
}
static inline struct crypt_ctl *crypt_phys2virt(dma_addr_t phys)
{
	return crypt_virt + (phys - crypt_phys) / sizeof(struct crypt_ctl);
}
static inline u32 cipher_cfg_enc(struct crypto_tfm *tfm)
{
	return container_of(tfm->__crt_alg, struct ixp_alg,crypto)->cfg_enc;
}
static inline u32 cipher_cfg_dec(struct crypto_tfm *tfm)
{
	return container_of(tfm->__crt_alg, struct ixp_alg,crypto)->cfg_dec;
}
static inline const struct ix_hash_algo *ix_hash(struct crypto_tfm *tfm)
{
	return container_of(tfm->__crt_alg, struct ixp_alg, crypto)->hash;
}
static void irqhandler(void *_unused)
{
	tasklet_schedule(&crypto_done_tasklet);
}
static int ablk_encrypt(struct ablkcipher_request *req)
{
	return ablk_perform(req, 1);
}
static int ablk_decrypt(struct ablkcipher_request *req)
{
	return ablk_perform(req, 0);
}
static inline struct aes_ctx *aes_ctx(struct crypto_tfm *tfm)
{
	return aes_ctx_common(crypto_tfm_ctx(tfm));
}
static inline struct aes_ctx *blk_aes_ctx(struct crypto_blkcipher *tfm)
{
	return aes_ctx_common(crypto_blkcipher_ctx(tfm));
}
static inline void padlock_store_cword(struct cword *cword)
{
	per_cpu(last_cword, raw_smp_processor_id()) = cword;
}
static inline void padlock_xcrypt(const u8 *input, u8 *output, void *key,
				  struct cword *control_word)
{
	asm volatile (".byte 0xf3,0x0f,0xa7,0xc8"	/* rep xcryptecb */
		      : "+S"(input), "+D"(output)
		      : "d"(control_word), "b"(key), "c"(1));
}
static inline struct padlock_sha_ctx *ctx(struct crypto_tfm *tfm)
{
	return crypto_tfm_ctx(tfm);
}
static void unmap_single_talitos_ptr(struct device *dev,
				     struct talitos_ptr *talitos_ptr,
				     enum dma_data_direction dir)
{
	dma_unmap_single(dev, be32_to_cpu(talitos_ptr->ptr),
			 be16_to_cpu(talitos_ptr->len), dir);
}
static int __init talitos_init(void)
{
	return of_register_platform_driver(&talitos_driver);
}
static void __exit talitos_exit(void)
{
	of_unregister_platform_driver(&talitos_driver);
}
void free_dca_provider(struct dca_provider *dca)
{
	kfree(dca);
}
void dca_register_notify(struct notifier_block *nb)
{
	blocking_notifier_chain_register(&dca_provider_chain, nb);
}
void dca_unregister_notify(struct notifier_block *nb)
{
	blocking_notifier_chain_unregister(&dca_provider_chain, nb);
}
static void __exit dca_exit(void)
{
	dca_sysfs_exit();
}
void dca_sysfs_remove_req(struct dca_provider *dca, int slot)
{
	device_destroy(dca_class, MKDEV(0, slot + 1));
}
void dio_unregister_driver(struct dio_driver *drv)
{
	driver_unregister(&drv->driver);
}
static int __init dio_driver_init(void)
{
	return bus_register(&dio_bus_type);
}
static struct module *dma_chan_to_owner(struct dma_chan *chan)
{
	return chan->device->dev->driver->owner;
}
static bool filter(struct dma_chan *chan, void *param)
{
	if (!dmatest_match_channel(chan) || !dmatest_match_device(chan->device))
		return false;
	else
		return true;
}
static struct device *chan2dev(struct dma_chan *chan)
{
	return &chan->dev->device;
}
static struct device *chan2parent(struct dma_chan *chan)
{
	return chan->dev->device.parent;
}
static struct dw_desc *dwc_first_active(struct dw_dma_chan *dwc)
{
	return list_entry(dwc->active_list.next, struct dw_desc, desc_node);
}
static struct dw_desc *dwc_first_queued(struct dw_dma_chan *dwc)
{
	return list_entry(dwc->queue.next, struct dw_desc, desc_node);
}
static void dwc_dump_lli(struct dw_dma_chan *dwc, struct dw_lli *lli)
{
	dev_printk(KERN_CRIT, chan2dev(&dwc->chan),
			"  desc: s0x%x d0x%x l0x%x c0x%x:%x\n",
			lli->sar, lli->dar, lli->llp,
			lli->ctlhi, lli->ctllo);
}
static int __init dw_init(void)
{
	return platform_driver_probe(&dw_driver, dw_probe);
}
static void __exit dw_exit(void)
{
	platform_driver_unregister(&dw_driver);
}
static void set_sr(struct fsl_dma_chan *fsl_chan, u32 val)
{
	DMA_OUT(fsl_chan, &fsl_chan->reg_base->sr, val, 32);
}
static u32 get_sr(struct fsl_dma_chan *fsl_chan)
{
	return DMA_IN(fsl_chan, &fsl_chan->reg_base->sr, 32);
}
static void set_desc_cnt(struct fsl_dma_chan *fsl_chan,
				struct fsl_dma_ld_hw *hw, u32 count)
{
	hw->count = CPU_TO_DMA(fsl_chan, count, 32);
}
static void set_cdar(struct fsl_dma_chan *fsl_chan, dma_addr_t addr)
{
	DMA_OUT(fsl_chan, &fsl_chan->reg_base->cdar, addr | FSL_DMA_SNEN, 64);
}
static dma_addr_t get_cdar(struct fsl_dma_chan *fsl_chan)
{
	return DMA_IN(fsl_chan, &fsl_chan->reg_base->cdar, 64) & ~FSL_DMA_SNEN;
}
static void set_ndar(struct fsl_dma_chan *fsl_chan, dma_addr_t addr)
{
	DMA_OUT(fsl_chan, &fsl_chan->reg_base->ndar, addr, 64);
}
static dma_addr_t get_ndar(struct fsl_dma_chan *fsl_chan)
{
	return DMA_IN(fsl_chan, &fsl_chan->reg_base->ndar, 64);
}
static u32 get_bcr(struct fsl_dma_chan *fsl_chan)
{
	return DMA_IN(fsl_chan, &fsl_chan->reg_base->bcr, 32);
}
static void set_ld_eol(struct fsl_dma_chan *fsl_chan,
			struct fsl_desc_sw *desc)
{
	desc->hw.next_ln_addr = CPU_TO_DMA(fsl_chan,
		DMA_TO_CPU(fsl_chan, desc->hw.next_ln_addr, 64)	| FSL_DMA_EOL,
		64);
}
static void __exit of_fsl_dma_exit(void)
{
	of_unregister_platform_driver(&of_fsl_dma_driver);
}
static int __init ioat_init_module(void)
{
	return pci_register_driver(&ioat_pci_driver);
}
static void __exit ioat_exit_module(void)
{
	pci_unregister_driver(&ioat_pci_driver);
}
static inline u16 dcaid_from_pcidev(struct pci_dev *pci)
{
	return (pci->bus->number << 8) | pci->devfn;
}
static inline struct ioat_dma_chan *ioat_lookup_chan_by_index(
						struct ioatdma_device *device,
						int index)
{
	return device->idx[index];
}
static int __init iop_adma_init (void)
{
	return platform_driver_register(&iop_adma_driver);
}
static int num_pages_spanned(struct iovec *iov)
{
	return
	((PAGE_ALIGN((unsigned long)iov->iov_base + iov->iov_len) -
	((unsigned long)iov->iov_base & PAGE_MASK)) >> PAGE_SHIFT);
}
static u32 __idmac_read_icreg(struct ipu *ipu, unsigned long reg)
{
	return __raw_readl(ipu->reg_ic + reg);
}
static void __idmac_write_icreg(struct ipu *ipu, u32 value, unsigned long reg)
{
	__raw_writel(value, ipu->reg_ic + reg);
}
static u32 idmac_read_ipureg(struct ipu *ipu, unsigned long reg)
{
	return __raw_readl(ipu->reg_ipu + reg);
}
static void idmac_write_ipureg(struct ipu *ipu, u32 value, unsigned long reg)
{
	__raw_writel(value, ipu->reg_ipu + reg);
}

static void ipu_ch_param_set_burst_size(union chan_param_mem *params,
					uint16_t burst_pixels)
{
	params->pp.npb = burst_pixels - 1;
}

static void ipu_ch_param_set_rotation(union chan_param_mem *params,
				      enum ipu_rotate_mode rotate)
{
	params->pp.bam = rotate;
}
static uint32_t dma_param_addr(uint32_t dma_ch)
{
	/* Channel Parameter Memory */
	return 0x10000 | (dma_ch << 4);
}
static int __init ipu_init(void)
{
	return platform_driver_probe(&ipu_platform_driver, ipu_probe);
}
static u32 ipu_read_reg(struct ipu *ipu, unsigned long reg)
{
	return __raw_readl(ipu->reg_ipu + reg);
}
static void ipu_write_reg(struct ipu *ipu, u32 value, unsigned long reg)
{
	__raw_writel(value, ipu->reg_ipu + reg);
}
static void mv_desc_set_block_fill_val(struct mv_xor_desc_slot *desc, u32 val)
{
	desc->value = val;
}
static int mv_chan_memset_slot_count(size_t len)
{
	return 1;
}
static u32 mv_chan_get_current_desc(struct mv_xor_chan *chan)
{
	return __raw_readl(XOR_CURR_DESC(chan));
}
static void mv_chan_set_next_descriptor(struct mv_xor_chan *chan,
					u32 next_desc_addr)
{
	__raw_writel(next_desc_addr, XOR_NEXT_DESC(chan));
}
static void mv_chan_set_dest_pointer(struct mv_xor_chan *chan, u32 desc_addr)
{
	__raw_writel(desc_addr, XOR_DEST_POINTER(chan));
}
static void mv_chan_set_block_size(struct mv_xor_chan *chan, u32 block_size)
{
	__raw_writel(block_size, XOR_BLOCK_SIZE(chan));
}
static int mv_chan_xor_slot_count(size_t len, int src_cnt)
{
	return 1;
}
static int mv_xor_shared_remove(struct platform_device *pdev)
{
	return 0;
}
static void __exit amd76x_exit(void)
{
	pci_unregister_driver(&amd76x_driver);
}
static void __exit cell_edac_exit(void)
{
	platform_driver_unregister(&cell_edac_driver);
}
static inline int dual_channel_active(u16 ddrcsr)
{
	return (((ddrcsr >> 12) & 3) == 3);
}
static inline int dual_channel_active(u32 drc, int dev_idx)
{
	return (dev_idx == E7501) ? ((drc >> 22) & 0x1) : 1;
}
static inline int drb_granularity(u32 drc, int dev_idx)
{
	return (dev_idx == E7501) ? ((drc >> 18) & 0x3) : 1;
}
static void __exit e7xxx_exit(void)
{
	pci_unregister_driver(&e7xxx_driver);
}
void edac_device_free_ctl_info(struct edac_device_ctl_info *ctl_info)
{
	edac_device_unregister_sysfs_main_kobj(ctl_info);
}
static inline int edac_device_get_log_ce(struct edac_device_ctl_info *edac_dev)
{
	return edac_dev->log_ce;
}
static inline int edac_device_get_log_ue(struct edac_device_ctl_info *edac_dev)
{
	return edac_dev->log_ue;
}
static inline int edac_device_get_panic_on_ue(struct edac_device_ctl_info
					*edac_dev)
{
	return edac_dev->panic_on_ue;
}
static ssize_t edac_device_ctl_log_ue_show(struct edac_device_ctl_info
					*ctl_info, char *data)
{
	return sprintf(data, "%u\n", ctl_info->log_ue);
}
static ssize_t edac_device_ctl_log_ce_show(struct edac_device_ctl_info
					*ctl_info, char *data)
{
	return sprintf(data, "%u\n", ctl_info->log_ce);
}
static ssize_t edac_device_ctl_panic_on_ue_show(struct edac_device_ctl_info
						*ctl_info, char *data)
{
	return sprintf(data, "%u\n", ctl_info->panic_on_ue);
}
static ssize_t edac_device_ctl_poll_msec_show(struct edac_device_ctl_info
					*ctl_info, char *data)
{
	return sprintf(data, "%u\n", ctl_info->poll_msec);
}
static ssize_t instance_ue_count_show(struct edac_device_instance *instance,
				char *data)
{
	return sprintf(data, "%u\n", instance->counters.ue_count);
}
static ssize_t instance_ce_count_show(struct edac_device_instance *instance,
				char *data)
{
	return sprintf(data, "%u\n", instance->counters.ce_count);
}
void edac_mc_free(struct mem_ctl_info *mci)
{
	edac_mc_unregister_sysfs_main_kobj(mci);
}
int edac_mc_get_log_ue(void)
{
	return edac_mc_log_ue;
}
int edac_mc_get_log_ce(void)
{
	return edac_mc_log_ce;
}
int edac_mc_get_panic_on_ue(void)
{
	return edac_mc_panic_on_ue;
}
int edac_mc_get_poll_msec(void)
{
	return edac_mc_poll_msec;
}
static ssize_t csrow_ue_count_show(struct csrow_info *csrow, char *data,
				int private)
{
	return sprintf(data, "%u\n", csrow->ue_count);
}
static ssize_t csrow_ce_count_show(struct csrow_info *csrow, char *data,
				int private)
{
	return sprintf(data, "%u\n", csrow->ce_count);
}
static ssize_t csrow_size_show(struct csrow_info *csrow, char *data,
				int private)
{
	return sprintf(data, "%u\n", PAGES_TO_MiB(csrow->nr_pages));
}
static ssize_t csrow_mem_type_show(struct csrow_info *csrow, char *data,
				int private)
{
	return sprintf(data, "%s\n", mem_types[csrow->mtype]);
}
static ssize_t csrow_dev_type_show(struct csrow_info *csrow, char *data,
				int private)
{
	return sprintf(data, "%s\n", dev_types[csrow->dtype]);
}
static ssize_t csrow_edac_mode_show(struct csrow_info *csrow, char *data,
				int private)
{
	return sprintf(data, "%s\n", edac_caps[csrow->edac_mode]);
}
static ssize_t channel_ce_count_show(struct csrow_info *csrow,
				char *data, int channel)
{
	return sprintf(data, "%u\n", csrow->channels[channel].ce_count);
}
static ssize_t mci_ue_count_show(struct mem_ctl_info *mci, char *data)
{
	return sprintf(data, "%d\n", mci->ue_count);
}
static ssize_t mci_ce_count_show(struct mem_ctl_info *mci, char *data)
{
	return sprintf(data, "%d\n", mci->ce_count);
}
static ssize_t mci_ce_noinfo_show(struct mem_ctl_info *mci, char *data)
{
	return sprintf(data, "%d\n", mci->ce_noinfo_count);
}
static ssize_t mci_ue_noinfo_show(struct mem_ctl_info *mci, char *data)
{
	return sprintf(data, "%d\n", mci->ue_noinfo_count);
}
static ssize_t mci_seconds_show(struct mem_ctl_info *mci, char *data)
{
	return sprintf(data, "%ld\n", (jiffies - mci->start_time) / HZ);
}
static ssize_t mci_ctl_name_show(struct mem_ctl_info *mci, char *data)
{
	return sprintf(data, "%s\n", mci->ctl_name);
}
void edac_mc_unregister_sysfs_main_kobj(struct mem_ctl_info *mci)
{
	kobject_put(&mci->edac_mci_kobj);
}
void edac_sysfs_teardown_mc_kset(void)
{
	kset_unregister(mc_kset);
}
int edac_pci_get_check_errors(void)
{
	return check_pci_errors;
}
static int edac_pci_get_log_pe(void)
{
	return edac_pci_log_pe;
}
static int edac_pci_get_log_npe(void)
{
	return edac_pci_log_npe;
}
static int edac_pci_get_panic_on_pe(void)
{
	return edac_pci_panic_on_pe;
}
int edac_pci_get_poll_msec(void)
{
	return edac_pci_poll_msec;
}
static ssize_t instance_pe_count_show(struct edac_pci_ctl_info *pci, char *data)
{
	return sprintf(data, "%u\n", atomic_read(&pci->counters.pe_count));
}
static ssize_t instance_npe_count_show(struct edac_pci_ctl_info *pci,
				char *data)
{
	return sprintf(data, "%u\n", atomic_read(&pci->counters.npe_count));
}
void edac_pci_clear_parity_errors(void)
{
	edac_pci_dev_parity_iterator(edac_pci_dev_parity_clear);
}
void edac_atomic_assert_error(void)
{
	edac_err_assert++;
}
static inline unsigned long deap_offset(u32 deap)
{
	return deap & ~(I3000_DEAP_GRAIN - 1) & ~PAGE_MASK;
}
static inline int deap_channel(u32 deap)
{
	return deap & 1;
}
static inline unsigned char odd_rank_attrib(unsigned char dra)
{
	return (dra & 0x70) >> 4;
}
static inline unsigned char even_rank_attrib(unsigned char dra)
{
	return dra & 0x07;
}
static inline u32 i5100_mc_errdeten(u32 mc)
{
	return mc >> 5 & 1;
}
static inline u16 i5100_spddata_rdo(u16 a)
{
	return a >> 15 & 1;
}
static inline u16 i5100_spddata_sbe(u16 a)
{
	return a >> 13 & 1;
}
static inline u16 i5100_spddata_busy(u16 a)
{
	return a >> 12 & 1;
}
static inline u16 i5100_spddata_data(u16 a)
{
	return a & ((1 << 8) - 1);
}
static inline u32 i5100_spdcmd_create(u32 dti, u32 ckovrd, u32 sa, u32 ba,
				      u32 data, u32 cmd)
{
	return	((dti & ((1 << 4) - 1))  << 28) |
		((ckovrd & 1)            << 27) |
		((sa & ((1 << 3) - 1))   << 24) |
		((ba & ((1 << 8) - 1))   << 16) |
		((data & ((1 << 8) - 1)) <<  8) |
		(cmd & 1);
}
static inline u16 i5100_tolm_tolm(u16 a)
{
	return a >> 12 & ((1 << 4) - 1);
}
static inline u16 i5100_mir_limit(u16 a)
{
	return a >> 4 & ((1 << 12) - 1);
}
static inline u16 i5100_mir_way1(u16 a)
{
	return a >> 1 & 1;
}
static inline u16 i5100_mir_way0(u16 a)
{
	return a & 1;
}
static inline u32 i5100_ferr_nf_mem_chan_indx(u32 a)
{
	return a >> 28 & 1;
}
static inline u32 i5100_ferr_nf_mem_any(u32 a)
{
	return a & I5100_FERR_NF_MEM_ANY_MASK;
}
static inline u32 i5100_nerr_nf_mem_any(u32 a)
{
	return i5100_ferr_nf_mem_any(a);
}
static inline u32 i5100_dmir_limit(u32 a)
{
	return a >> 16 & ((1 << 11) - 1);
}
static inline u32 i5100_dmir_rank(u32 a, u32 i)
{
	return a >> (4 * i) & ((1 << 2) - 1);
}
static inline u16 i5100_mtr_present(u16 a)
{
	return a >> 10 & 1;
}
static inline u16 i5100_mtr_ethrottle(u16 a)
{
	return a >> 9 & 1;
}
static inline u16 i5100_mtr_width(u16 a)
{
	return a >> 8 & 1;
}
static inline u16 i5100_mtr_numbank(u16 a)
{
	return a >> 6 & 1;
}
static inline u16 i5100_mtr_numrow(u16 a)
{
	return a >> 2 & ((1 << 2) - 1);
}
static inline u16 i5100_mtr_numcol(u16 a)
{
	return a & ((1 << 2) - 1);
}
static inline u32 i5100_validlog_redmemvalid(u32 a)
{
	return a >> 2 & 1;
}
static inline u32 i5100_validlog_recmemvalid(u32 a)
{
	return a >> 1 & 1;
}
static inline u32 i5100_validlog_nrecmemvalid(u32 a)
{
	return a & 1;
}
static inline u32 i5100_nrecmema_merr(u32 a)
{
	return a >> 15 & ((1 << 5) - 1);
}
static inline u32 i5100_nrecmema_bank(u32 a)
{
	return a >> 12 & ((1 << 3) - 1);
}
static inline u32 i5100_nrecmema_rank(u32 a)
{
	return a >>  8 & ((1 << 3) - 1);
}
static inline u32 i5100_nrecmema_dm_buf_id(u32 a)
{
	return a & ((1 << 8) - 1);
}
static inline u32 i5100_nrecmemb_cas(u32 a)
{
	return a >> 16 & ((1 << 13) - 1);
}
static inline u32 i5100_nrecmemb_ras(u32 a)
{
	return a & ((1 << 16) - 1);
}
static inline u32 i5100_redmemb_ecc_locator(u32 a)
{
	return a & ((1 << 18) - 1);
}
static inline u32 i5100_recmema_merr(u32 a)
{
	return i5100_nrecmema_merr(a);
}
static inline u32 i5100_recmema_bank(u32 a)
{
	return i5100_nrecmema_bank(a);
}
static inline u32 i5100_recmema_rank(u32 a)
{
	return i5100_nrecmema_rank(a);
}
static inline u32 i5100_recmema_dm_buf_id(u32 a)
{
	return i5100_nrecmema_dm_buf_id(a);
}
static inline u32 i5100_recmemb_cas(u32 a)
{
	return i5100_nrecmemb_cas(a);
}
static inline u32 i5100_recmemb_ras(u32 a)
{
	return i5100_nrecmemb_ras(a);
}
static void __exit i5100_exit(void)
{
	pci_unregister_driver(&i5100_driver);
}
/* masks for non-fatal error register */
static inline int to_nf_mask(unsigned int mask)
{
	return (mask & EMASK_M29) | (mask >> 3);
}

static inline int from_nf_ferr(unsigned int mask)
{
	return (mask & EMASK_M29) |		/* Bit 28 */
	       (mask & ((1 << 28) - 1) << 3);	/* Bits 0 to 27 */
}
static inline int extract_fbdchan_indx(u32 x)
{
	return (x>>28) & 0x3;
}
static inline int nrec_bank(struct i5400_error_info *info)
{
	return ((info->nrecmema) >> 12) & 0x7;
}
static inline int nrec_rank(struct i5400_error_info *info)
{
	return ((info->nrecmema) >> 8) & 0xf;
}
static inline int nrec_buf_id(struct i5400_error_info *info)
{
	return ((info->nrecmema)) & 0xff;
}
static inline int nrec_rdwr(struct i5400_error_info *info)
{
	return (info->nrecmemb) >> 31;
}
static inline const char *rdwr_str(int rdwr)
{
	return rdwr ? "Write" : "Read";
}
static inline int nrec_cas(struct i5400_error_info *info)
{
	return ((info->nrecmemb) >> 16) & 0x1fff;
}
static inline int nrec_ras(struct i5400_error_info *info)
{
	return (info->nrecmemb) & 0xffff;
}
static inline int rec_bank(struct i5400_error_info *info)
{
	return ((info->recmema) >> 12) & 0x7;
}
static inline int rec_rank(struct i5400_error_info *info)
{
	return ((info->recmema) >> 8) & 0xf;
}
static inline int rec_rdwr(struct i5400_error_info *info)
{
	return (info->recmemb) >> 31;
}
static inline int rec_cas(struct i5400_error_info *info)
{
	return ((info->recmemb) >> 16) & 0x1fff;
}
static inline int rec_ras(struct i5400_error_info *info)
{
	return (info->recmemb) & 0xffff;
}
static inline int dual_channel_active(u32 drc)
{
	return (drc >> 21) & 0x1;
}
static enum dev_type i82975x_dram_type(void __iomem *mch_window, int rank)
{
	return DEV_X8;
}
static void mpc85xx_set_mc_sysfs_attributes(struct mem_ctl_info *mci)
{
	mci->mc_driver_sysfs_attributes = mpc85xx_mc_sysfs_attributes;
}
static void mpc85xx_set_l2_sysfs_attributes(struct edac_device_ctl_info
					    *edac_dev)
{
	edac_dev->sysfs_attributes = mpc85xx_l2_sysfs_attributes;
}
static void __exit mpc85xx_mc_restore_hid1(void *data)
{
	mtspr(SPRN_HID1, orig_hid1[smp_processor_id()]);
}
static void __exit pasemi_edac_exit(void)
{
	pci_unregister_driver(&pasemi_edac_driver);
}
static inline int ecc_enabled(u8 dramcr)
{
	return dramcr & BIT(5);
}
static void __exit r82600_exit(void)
{
	pci_unregister_driver(&r82600_driver);
}
static unsigned long eccerrlog_syndrome(u64 log)
{
	return (log & X38_ECCERRLOG_SYNDROME_BITS) >> 16;
}
static int eccerrlog_row(int channel, u64 log)
{
	return ((log & X38_ECCERRLOG_RANK_BITS) >> 27) |
		(channel * X38_RANKS_PER_CHANNEL);
}
static u64 x38_readq(const void __iomem *addr)
{
	return readl(addr) | (((u64)readl(addr + 4)) << 32);
}
void eisa_driver_unregister (struct eisa_driver *edrv)
{
	driver_unregister (&edrv->driver);
}
static int __init pci_eisa_init_module (void)
{
	return pci_register_driver (&pci_eisa_driver);
}
static int dummy_update_phy_reg(struct fw_card *card, int address,
				int clear_bits, int set_bits)
{
	return -ENODEV;
}
static void dummy_send_request(struct fw_card *card, struct fw_packet *packet)
{
	packet->callback(packet, card, -ENODEV);
}
static void dummy_send_response(struct fw_card *card, struct fw_packet *packet)
{
	packet->callback(packet, card, -ENODEV);
}
static int dummy_cancel_packet(struct fw_card *card, struct fw_packet *packet)
{
	return -ENOENT;
}
static int dummy_enable_phys_dma(struct fw_card *card,
				 int node_id, int generation)
{
	return -ENODEV;
}
static inline void client_get(struct client *client)
{
	kref_get(&client->kref);
}
static void client_put(struct client *client)
{
	kref_put(&client->kref, client_release);
}
static inline void __user *u64_to_uptr(__u64 value)
{
	return (void __user *)(unsigned long)value;
}
static inline __u64 uptr_to_u64(void __user *ptr)
{
	return (__u64)(unsigned long)ptr;
}
void fw_device_cdev_update(struct fw_device *device)
{
	for_each_client(device, queue_bus_reset_event);
}
static void wake_up_client(struct client *client)
{
	wake_up_interruptible(&client->wait);
}
void fw_device_cdev_remove(struct fw_device *device)
{
	for_each_client(device, wake_up_client);
}
static int is_fw_unit(struct device *dev)
{
	return dev->type == &fw_unit_type;
}
int fw_iso_context_start(struct fw_iso_context *ctx,
			 int cycle, int sync, int tags)
{
	return ctx->card->driver->start_iso(ctx, cycle, sync, tags);
}
int fw_iso_context_stop(struct fw_iso_context *ctx)
{
	return ctx->card->driver->stop_iso(ctx);
}
static inline struct fw_ohci *fw_ohci(struct fw_card *card)
{
	return container_of(card, struct fw_ohci, card);
}
static char _p(u32 *s, int shift)
{
	return port[*s >> shift & 3];
}
static inline void reg_write(const struct fw_ohci *ohci, int offset, u32 data)
{
	writel(data, ohci->registers + offset);
}
static inline u32 reg_read(const struct fw_ohci *ohci, int offset)
{
	return readl(ohci->registers + offset);
}
static inline void flush_writes(const struct fw_ohci *ohci)
{
	reg_read(ohci, OHCI1394_Version);
}
static int ohci_enable_phys_dma(struct fw_card *card,
				int node_id, int generation)
{
	return 0;
}
static int __init fw_ohci_init(void)
{
	return pci_register_driver(&fw_ohci_pci_driver);
}
static void __exit fw_ohci_cleanup(void)
{
	pci_unregister_driver(&fw_ohci_pci_driver);
}
static void complete_agent_reset_write_no_wait(struct fw_card *card,
		int rcode, void *payload, size_t length, void *data)
{
	kfree(data);
}
static inline void sbp2_allow_block(struct sbp2_logical_unit *lu)
{
	--lu->tgt->dont_block;
}
static void sbp2_target_put(struct sbp2_target *tgt)
{
	kref_put(&tgt->kref, sbp2_release_target);
}
static inline struct fw_node *fw_node(struct list_head *l)
{
	return list_entry(l, struct fw_node, link);
}
static void transmit_phy_packet_callback(struct fw_packet *packet,
					 struct fw_card *card, int status)
{
	complete(&phy_config_done);
}
static ssize_t smi_data_buf_phys_addr_show(struct device *dev,
					   struct device_attribute *attr,
					   char *buf)
{
	return sprintf(buf, "%x\n", smi_data_buf_phys_addr);
}
static ssize_t smi_data_buf_size_show(struct device *dev,
				      struct device_attribute *attr,
				      char *buf)
{
	return sprintf(buf, "%lu\n", smi_data_buf_size);
}
static ssize_t host_control_action_show(struct device *dev,
					struct device_attribute *attr,
					char *buf)
{
	return sprintf(buf, "%u\n", host_control_action);
}
static ssize_t host_control_smi_type_show(struct device *dev,
					  struct device_attribute *attr,
					  char *buf)
{
	return sprintf(buf, "%u\n", host_control_smi_type);
}
static ssize_t host_control_on_shutdown_show(struct device *dev,
					     struct device_attribute *attr,
					     char *buf)
{
	return sprintf(buf, "%u\n", host_control_on_shutdown);
}
const char *dmi_get_system_info(int field)
{
	return dmi_ident[field];
}
static int
edd_has_mbr_signature(struct edd_device *edev)
{
	return edev->index < min_t(unsigned char, edd.mbr_signature_nr, EDD_MBR_SIG_MAX);
}
static int
edd_has_edd_info(struct edd_device *edev)
{
	return edev->index < min_t(unsigned char, edd.edd_info_nr, EDDMAXNR);
}
static inline struct edd_info *
edd_dev_get_info(struct edd_device *edev)
{
	return edev->info;
}
static inline void
edd_device_unregister(struct edd_device *edev)
{
	kobject_put(&edev->kobj);
}
static inline int edd_num_devices(void)
{
	return max_t(unsigned char,
		     min_t(unsigned char, EDD_MBR_SIG_MAX, edd.mbr_signature_nr),
		     min_t(unsigned char, EDDMAXNR, edd.edd_info_nr));
}
static inline unsigned long
utf8_strsize(efi_char16_t *data, unsigned long maxlength)
{
	return utf8_strlen(data, maxlength/sizeof(efi_char16_t)) * sizeof(efi_char16_t);
}
static inline void
efivar_unregister(struct efivar_entry *var)
{
	kobject_put(&var->kobj);
}
static ssize_t sprintf_string(char *str, int len, char *buf)
{
	return sprintf(str, "%.*s\n", len, buf);
}
static ssize_t start_show(struct firmware_map_entry *entry, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "0x%llx\n",
		(unsigned long long)entry->start);
}
static ssize_t end_show(struct firmware_map_entry *entry, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "0x%llx\n",
		(unsigned long long)entry->end);
}
static ssize_t type_show(struct firmware_map_entry *entry, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%s\n", entry->type);
}
static int bt8xxgpio_init(void)
{
	return pci_register_driver(&bt8xxgpio_pci_driver);
}
static void bt8xxgpio_exit(void)
{
	pci_unregister_driver(&bt8xxgpio_pci_driver);
}
static inline void desc_set_label(struct gpio_desc *d, const char *label)
{
	d->label = label;
}
static inline struct gpio_chip *gpio_to_chip(unsigned gpio)
{
	return gpio_desc[gpio].chip;
}
static int match_export(struct device *dev, void *data)
{
	return dev_get_drvdata(dev) == data;
}
static inline int gpiochip_export(struct gpio_chip *chip)
{
	return 0;
}
static int gpiolib_open(struct inode *inode, struct file *file)
{
	return single_open(file, gpiolib_show, NULL);
}
static int __init max7301_init(void)
{
	return spi_register_driver(&max7301_driver);
}
static void __exit max7301_exit(void)
{
	spi_unregister_driver(&max7301_driver);
}
static inline int is_group_a(struct max732x_chip *chip, unsigned off)
{
	return (1u << off) & chip->mask_group_a;
}
static int __init max732x_init(void)
{
	return i2c_add_driver(&max732x_driver);
}
static void __exit max732x_exit(void)
{
	i2c_del_driver(&max732x_driver);
}
static int __init mcp23s08_init(void)
{
	return spi_register_driver(&mcp23s08_driver);
}
static void __exit mcp23s08_exit(void)
{
	spi_unregister_driver(&mcp23s08_driver);
}
static int __init pca953x_init(void)
{
	return i2c_add_driver(&pca953x_driver);
}
static void __exit pca953x_exit(void)
{
	i2c_del_driver(&pca953x_driver);
}
static void pcf857x_set8(struct gpio_chip *chip, unsigned offset, int value)
{
	pcf857x_output8(chip, offset, value);
}
static void pcf857x_set16(struct gpio_chip *chip, unsigned offset, int value)
{
	pcf857x_output16(chip, offset, value);
}
static int __init pcf857x_init(void)
{
	return i2c_add_driver(&pcf857x_driver);
}
static void __exit pcf857x_exit(void)
{
	i2c_del_driver(&pcf857x_driver);
}
static inline int gpio_twl4030_write(u8 address, u8 data)
{
	return twl4030_i2c_write_u8(TWL4030_MODULE_GPIO, data, address);
}
static int twl_direction_in(struct gpio_chip *chip, unsigned offset)
{
	return (offset < TWL4030_GPIO_MAX)
		? twl4030_set_gpio_direction(offset, 1)
		: -EINVAL;
}
static int twl_to_irq(struct gpio_chip *chip, unsigned offset)
{
	return (twl4030_gpio_irq_base && (offset < TWL4030_GPIO_MAX))
		? (twl4030_gpio_irq_base + offset)
		: -EINVAL;
}
static int __init gpio_twl4030_init(void)
{
	return platform_driver_register(&gpio_twl4030_driver);
}
static void __exit gpio_twl4030_exit(void)
{
	platform_driver_unregister(&gpio_twl4030_driver);
}
int drm_agp_acquire_ioctl(struct drm_device *dev, void *data,
			  struct drm_file *file_priv)
{
	return drm_agp_acquire((struct drm_device *) file_priv->minor->dev);
}
int drm_agp_release_ioctl(struct drm_device *dev, void *data,
			  struct drm_file *file_priv)
{
	return drm_agp_release(dev);
}
DRM_AGP_MEM *drm_agp_allocate_memory(struct agp_bridge_data * bridge,
				     size_t pages, u32 type)
{
	return agp_allocate_memory(bridge, pages, type);
}
void drm_agp_chipset_flush(struct drm_device *dev)
{
	agp_flush_chipset(dev->agp->bridge);
}
resource_size_t drm_get_resource_start(struct drm_device *dev, unsigned int resource)
{
	return pci_resource_start(dev->pdev, resource);
}
resource_size_t drm_get_resource_len(struct drm_device *dev, unsigned int resource)
{
	return pci_resource_len(dev->pdev, resource);
}
int drm_modctx(struct drm_device *dev, void *data, struct drm_file *file_priv)
{
	return 0;
}
char *drm_get_connector_status_name(enum drm_connector_status status)
{
	if (status == connector_status_connected)
		return "connected";
	else if (status == connector_status_disconnected)
		return "disconnected";
	else
		return "unknown";
}
void drm_mode_probed_add(struct drm_connector *connector,
			 struct drm_display_mode *mode)
{
	list_add(&mode->head, &connector->probed_modes);
}
struct drm_drawable_info *drm_get_drawable_info(struct drm_device *dev, drm_drawable_t id)
{
	return idr_find(&dev->drw_idr, id);
}
unsigned int drm_poll(struct file *filp, struct poll_table_struct *wait)
{
	return 0;
}
u32 drm_vblank_count(struct drm_device *dev, int crtc)
{
	return atomic_read(&dev->_vblank_count[crtc]);
}
int drm_mem_info(char *buf, char **start, off_t offset,
		 int len, int *eof, void *data)
{
	return 0;
}
DRM_AGP_MEM *drm_alloc_agp(struct drm_device * dev, int pages, u32 type)
{
	return drm_agp_allocate_memory(dev->agp->bridge, pages, type);
}
int drm_free_agp(DRM_AGP_MEM * handle, int pages)
{
	return drm_agp_free_memory(handle) ? 0 : -EINVAL;
}
int drm_bind_agp(DRM_AGP_MEM * handle, unsigned int start)
{
	return drm_agp_bind_memory(handle, start);
}
int drm_unbind_agp(DRM_AGP_MEM * handle)
{
	return drm_agp_unbind_memory(handle);
}
static inline void *agp_remap(unsigned long offset, unsigned long size,
			      struct drm_device * dev)
{
	return NULL;
}
void drm_mode_debug_printmodeline(struct drm_display_mode *mode)
{
	DRM_DEBUG("Modeline %d:\"%s\" %d %d %d %d %d %d %d %d %d %d 0x%x 0x%x\n",
		  mode->base.id, mode->name, mode->vrefresh, mode->clock,
		  mode->hdisplay, mode->hsync_start,
		  mode->hsync_end, mode->htotal,
		  mode->vdisplay, mode->vsync_start,
		  mode->vsync_end, mode->vtotal, mode->type, mode->flags);
}
void drm_mode_set_name(struct drm_display_mode *mode)
{
	snprintf(mode->name, DRM_DISPLAY_MODE_LEN, "%dx%d", mode->hdisplay,
		 mode->vdisplay);
}
int drm_mode_width(struct drm_display_mode *mode)
{
	return mode->hdisplay;
}
int drm_mode_height(struct drm_display_mode *mode)
{
	return mode->vdisplay;
}
void drm_mode_sort(struct list_head *mode_list)
{
	list_sort(mode_list, drm_mode_compare);
}
static inline void *drm_vmalloc_dma(unsigned long size)
{
	return __vmalloc(size, GFP_KERNEL, PAGE_KERNEL | _PAGE_NO_CACHE);
}
static ssize_t version_show(struct class *dev, char *buf)
{
	return sprintf(buf, "%s %d.%d.%d %s\n", CORE_NAME, CORE_MAJOR,
		       CORE_MINOR, CORE_PATCHLEVEL, CORE_DATE);
}
static void drm_sysfs_device_release(struct device *dev)
{
	return;
}
void drm_sysfs_device_remove(struct drm_minor *minor)
{
	device_unregister(&minor->kdev);
}
static int drm_do_vm_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
{
	return VM_FAULT_SIGBUS;
}
static int drm_vm_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
{
	return drm_do_vm_fault(vma, vmf);
}
static int drm_vm_shm_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
{
	return drm_do_vm_shm_fault(vma, vmf);
}
static int drm_vm_dma_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
{
	return drm_do_vm_dma_fault(vma, vmf);
}
static int drm_vm_sg_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
{
	return drm_do_vm_sg_fault(vma, vmf);
}
resource_size_t drm_core_get_map_ofs(struct drm_local_map * map)
{
	return map->offset;
}
resource_size_t drm_core_get_reg_ofs(struct drm_device *dev)
{
	return dev->hose->dense_mem_base - dev->hose->mem_space->start;
}
static int i810_copybuf(struct drm_device *dev, void *data,
			struct drm_file *file_priv)
{
	return 0;
}
static int i810_docopy(struct drm_device *dev, void *data,
			struct drm_file *file_priv)
{
	return 0;
}
void i810_driver_lastclose(struct drm_device * dev)
{
	i810_dma_cleanup(dev);
}
void i810_driver_reclaim_buffers_locked(struct drm_device * dev,
					struct drm_file *file_priv)
{
	i810_reclaim_buffers(dev, file_priv);
}
int i810_driver_device_is_agp(struct drm_device * dev)
{
	return 1;
}
static void __exit i810_exit(void)
{
	drm_exit(&driver);
}
static int i830_copybuf(struct drm_device *dev, void *data,
			struct drm_file *file_priv)
{
	return 0;
}
static int i830_docopy(struct drm_device *dev, void *data,
		       struct drm_file *file_priv)
{
	return 0;
}
void i830_driver_lastclose(struct drm_device * dev)
{
	i830_dma_cleanup(dev);
}
void i830_driver_reclaim_buffers_locked(struct drm_device * dev, struct drm_file *file_priv)
{
	i830_reclaim_buffers(dev, file_priv);
}
int i830_driver_device_is_agp(struct drm_device * dev)
{
	return 1;
}
static void __exit i830_exit(void)
{
	drm_exit(&driver);
}
static enum drm_connector_status ch7017_detect(struct intel_dvo_device *dvo)
{
	return connector_status_unknown;
}
static enum drm_connector_status ivch_detect(struct intel_dvo_device *dvo)
{
	return connector_status_connected;
}
static enum drm_mode_status sil164_mode_valid(struct intel_dvo_device *dvo,
					      struct drm_display_mode *mode)
{
	return MODE_OK;
}
static void sil164_mode_set(struct intel_dvo_device *dvo,
			    struct drm_display_mode *mode,
			    struct drm_display_mode *adjusted_mode)
{
	return;
}
static enum drm_mode_status tfp410_mode_valid(struct intel_dvo_device *dvo,
					      struct drm_display_mode *mode)
{
	return MODE_OK;
}
static void tfp410_mode_set(struct intel_dvo_device *dvo,
			    struct drm_display_mode *mode,
			    struct drm_display_mode *adjusted_mode)
{
    return;
}
int i915_driver_device_is_agp(struct drm_device * dev)
{
	return 1;
}
static int __devinit
i915_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
{
	return drm_get_dev(pdev, ent, &driver);
}
static void __exit i915_exit(void)
{
	drm_exit(&driver);
}
static int
i915_seqno_passed(uint32_t seq1, uint32_t seq2)
{
	return (int32_t)(seq1 - seq2) >= 0;
}
int
i915_gem_throttle_ioctl(struct drm_device *dev, void *data,
			struct drm_file *file_priv)
{
    return i915_gem_ring_throttle(dev, file_priv);
}
int i915_vblank_swap(struct drm_device *dev, void *data,
		     struct drm_file *file_priv)
{
	return -EINVAL;
}
static u32 asle_set_als_illum(struct drm_device *dev, u32 alsi)
{
	return 0;
}
static bool intel_crt_mode_fixup(struct drm_encoder *encoder,
				 struct drm_display_mode *mode,
				 struct drm_display_mode *adjusted_mode)
{
	return true;
}
static void intel_crt_enc_destroy(struct drm_encoder *encoder)
{
	drm_encoder_cleanup(encoder);
}
void
intel_wait_for_vblank(struct drm_device *dev)
{
	udelay(20000);
}
static bool intel_crtc_mode_fixup(struct drm_crtc *crtc,
				  struct drm_display_mode *mode,
				  struct drm_display_mode *adjusted_mode)
{
	return true;
}
void intel_modeset_cleanup(struct drm_device *dev)
{
	drm_mode_config_cleanup(dev);
}
static void intel_dvo_enc_destroy(struct drm_encoder *encoder)
{
	drm_encoder_cleanup(encoder);
}
void intelfb_restore(void)
{
	drm_crtc_helper_set_config(&kernelfb_mode);
}
static void intelfb_sysrq(int dummy1, struct tty_struct *dummy3)
{
        intelfb_restore();
}
static bool intel_hdmi_mode_fixup(struct drm_encoder *encoder,
				  struct drm_display_mode *mode,
				  struct drm_display_mode *adjusted_mode)
{
	return true;
}
static void intel_hdmi_enc_destroy(struct drm_encoder *encoder)
{
	drm_encoder_cleanup(encoder);
}
static enum drm_connector_status intel_lvds_detect(struct drm_connector *connector)
{
	return connector_status_connected;
}
static void intel_lvds_enc_destroy(struct drm_encoder *encoder)
{
	drm_encoder_cleanup(encoder);
}
static int intel_sdvo_get_pixel_multiplier(struct drm_display_mode *mode)
{
	if (mode->clock >= 100000)
		return 1;
	else if (mode->clock >= 50000)
		return 2;
	else
		return 4;
}
static void intel_sdvo_set_control_bus_switch(struct intel_output *intel_output,
					      u8 target)
{
	intel_sdvo_write_cmd(intel_output, SDVO_CMD_SET_CONTROL_BUS_SWITCH, &target, 1);
}
static bool intel_sdvo_get_input_timing(struct intel_output *intel_output,
					 struct intel_sdvo_dtd *dtd)
{
	return intel_sdvo_get_timing(intel_output,
				     SDVO_CMD_GET_INPUT_TIMINGS_PART1, dtd);
}
static bool intel_sdvo_get_output_timing(struct intel_output *intel_output,
					 struct intel_sdvo_dtd *dtd)
{
	return intel_sdvo_get_timing(intel_output,
				     SDVO_CMD_GET_OUTPUT_TIMINGS_PART1, dtd);
}
static bool intel_sdvo_set_input_timing(struct intel_output *intel_output,
					 struct intel_sdvo_dtd *dtd)
{
	return intel_sdvo_set_timing(intel_output,
				     SDVO_CMD_SET_INPUT_TIMINGS_PART1, dtd);
}
static bool intel_sdvo_set_output_timing(struct intel_output *intel_output,
					 struct intel_sdvo_dtd *dtd)
{
	return intel_sdvo_set_timing(intel_output,
				     SDVO_CMD_SET_OUTPUT_TIMINGS_PART1, dtd);
}
static void intel_sdvo_enc_destroy(struct drm_encoder *encoder)
{
	drm_encoder_cleanup(encoder);
}
static void intel_tv_enc_destroy(struct drm_encoder *encoder)
{
	drm_encoder_cleanup(encoder);
}
static int mga_do_agp_dma_bootstrap(struct drm_device * dev,
				    drm_mga_dma_bootstrap_t * dma_bs)
{
	return -EINVAL;
}
void mga_driver_lastclose(struct drm_device * dev)
{
	mga_do_cleanup_dma(dev, FULL_CLEANUP);
}
static void __exit mga_exit(void)
{
	drm_exit(&driver);
}
int r128_fullscreen(struct drm_device *dev, void *data, struct drm_file *file_priv)
{
	return -EINVAL;
}
int r128_driver_load(struct drm_device * dev, unsigned long flags)
{
	return drm_vblank_init(dev, 1);
}
static void __exit r128_exit(void)
{
	drm_exit(&driver);
}
int r128_driver_irq_postinstall(struct drm_device *dev)
{
	return 0;
}
static void r128_print_dirty(const char *msg, unsigned int flags)
{
	DRM_INFO("%s: (0x%x) %s%s%s%s%s%s%s%s%s\n",
		 msg,
		 flags,
		 (flags & R128_UPLOAD_CORE) ? "core, " : "",
		 (flags & R128_UPLOAD_CONTEXT) ? "context, " : "",
		 (flags & R128_UPLOAD_SETUP) ? "setup, " : "",
		 (flags & R128_UPLOAD_TEX0) ? "tex0, " : "",
		 (flags & R128_UPLOAD_TEX1) ? "tex1, " : "",
		 (flags & R128_UPLOAD_MASKS) ? "masks, " : "",
		 (flags & R128_UPLOAD_WINDOW) ? "window, " : "",
		 (flags & R128_UPLOAD_CLIPRECTS) ? "cliprects, " : "",
		 (flags & R128_REQUIRE_QUIESCENCE) ? "quiescence, " : "");
}
void r128_driver_lastclose(struct drm_device * dev)
{
	r128_do_cleanup_cce(dev);
}
u32 radeon_get_ring_head(drm_radeon_private_t *dev_priv)
{
	if (dev_priv->writeback_works)
		return radeon_read_ring_rptr(dev_priv, 0);
	else
		return RADEON_READ(RADEON_CP_RB_RPTR);
}
void radeon_set_ring_head(drm_radeon_private_t *dev_priv, u32 val)
{
	radeon_write_ring_rptr(dev_priv, 0, val);
}
u32 radeon_get_scratch(drm_radeon_private_t *dev_priv, int index)
{
	if (dev_priv->writeback_works)
		return radeon_read_ring_rptr(dev_priv,
					     RADEON_SCRATCHOFF(index));
	else
		return RADEON_READ(RADEON_SCRATCH_REG0 + 4*index);
}
static u32 IGP_READ_MCIND(drm_radeon_private_t *dev_priv, int addr)
{
	if (((dev_priv->flags & RADEON_FAMILY_MASK) == CHIP_RS690) ||
	    ((dev_priv->flags & RADEON_FAMILY_MASK) == CHIP_RS740))
		return RS690_READ_MCIND(dev_priv, addr);
	else
		return RS480_READ_MCIND(dev_priv, addr);
}
u32 radeon_read_fb_location(drm_radeon_private_t *dev_priv)
{
	if ((dev_priv->flags & RADEON_FAMILY_MASK) == CHIP_RV515)
		return R500_READ_MCIND(dev_priv, RV515_MC_FB_LOCATION);
	else if (((dev_priv->flags & RADEON_FAMILY_MASK) == CHIP_RS690) ||
		 ((dev_priv->flags & RADEON_FAMILY_MASK) == CHIP_RS740))
		return RS690_READ_MCIND(dev_priv, RS690_MC_FB_LOCATION);
	else if ((dev_priv->flags & RADEON_FAMILY_MASK) > CHIP_RV515)
		return R500_READ_MCIND(dev_priv, R520_MC_FB_LOCATION);
	else
		return RADEON_READ(RADEON_MC_FB_LOCATION);
}
static void radeon_do_cp_flush(drm_radeon_private_t * dev_priv)
{
	DRM_DEBUG("\n");
}
int radeon_cp_resume(struct drm_device *dev, void *data, struct drm_file *file_priv)
{
	return radeon_do_resume_cp(dev);
}
int radeon_fullscreen(struct drm_device *dev, void *data, struct drm_file *file_priv)
{
	return 0;
}
static void __exit radeon_exit(void)
{
	drm_exit(&driver);
}
static void __exit savage_exit(void)
{
	drm_exit(&driver);
}
static void __exit sis_exit(void)
{
	drm_exit(&driver);
}
static void sis_sman_mm_free(void *private, void *ref)
{
	sis_free(~((unsigned long)ref));
}
static void sis_sman_mm_destroy(void *private)
{
	;
}
static unsigned long sis_sman_mm_offset(void *private, void *ref)
{
	return ~((unsigned long)ref);
}
static int sis_fb_alloc(struct drm_device *dev, void *data,
			struct drm_file *file_priv)
{
	return sis_drm_alloc(dev, file_priv, data, VIDEO_TYPE);
}
static int sis_ioctl_agp_alloc(struct drm_device *dev, void *data,
			       struct drm_file *file_priv)
{
	return sis_drm_alloc(dev, file_priv, data, AGP_TYPE);
}
static int __init tdfx_init(void)
{
	return drm_init(&driver);
}
static void __exit tdfx_exit(void)
{
	drm_exit(&driver);
}
static inline uint32_t *via_get_dma(drm_via_private_t * dev_priv)
{
	return (uint32_t *) (dev_priv->dma_ptr + dev_priv->dma_low);
}
static void via_cmdbuf_rewind(drm_via_private_t * dev_priv)
{
	via_cmdbuf_jump(dev_priv);
}
static void via_cmdbuf_pause(drm_via_private_t * dev_priv)
{
	via_cmdbuf_flush(dev_priv, HC_HAGPBpID_PAUSE);
}
static void __exit via_exit(void)
{
	drm_exit(&driver);
}
static unsigned time_diff(struct timeval *now, struct timeval *then)
{
	return (now->tv_usec >= then->tv_usec) ?
		now->tv_usec - then->tv_usec :
		1000000 - (then->tv_usec - now->tv_usec);
}
static int a4_init(void)
{
	return hid_register_driver(&a4_driver);
}
static void a4_exit(void)
{
	hid_unregister_driver(&a4_driver);
}
static void apple_exit(void)
{
	hid_unregister_driver(&apple_driver);
}
static int belkin_init(void)
{
	return hid_register_driver(&belkin_driver);
}
static void belkin_exit(void)
{
	hid_unregister_driver(&belkin_driver);
}
static int ch_init(void)
{
	return hid_register_driver(&ch_driver);
}
static void ch_exit(void)
{
	hid_unregister_driver(&ch_driver);
}
static int ch_init(void)
{
	return hid_register_driver(&ch_driver);
}
static void ch_exit(void)
{
	hid_unregister_driver(&ch_driver);
}
static bool hid_match_one_id(struct hid_device *hdev,
		const struct hid_device_id *id)
{
	return id->bus == hdev->bus &&
		(id->vendor == HID_ANY_ID || id->vendor == hdev->vendor) &&
		(id->product == HID_ANY_ID || id->product == hdev->product);
}
static bool hid_hiddev(struct hid_device *hdev)
{
	return !!hid_match_id(hdev, hid_hiddev_list);
}
static void hid_compat_load(struct work_struct *ws)
{
	request_module("hid-dummy");
}
static int cp_init(void)
{
	return hid_register_driver(&cp_driver);
}
static void cp_exit(void)
{
	hid_unregister_driver(&cp_driver);
}
static void tab(int n) {
	printk(KERN_DEBUG "%*s", n, "");
}
static int ez_init(void)
{
	return hid_register_driver(&ez_driver);
}
static void ez_exit(void)
{
	hid_unregister_driver(&ez_driver);
}
static int __init ga_init(void)
{
	return hid_register_driver(&ga_driver);
}
static void __exit ga_exit(void)
{
	hid_unregister_driver(&ga_driver);
}
static int gyration_init(void)
{
	return hid_register_driver(&gyration_driver);
}
static void gyration_exit(void)
{
	hid_unregister_driver(&gyration_driver);
}
static int lg_init(void)
{
	return hid_register_driver(&lg_driver);
}
static void lg_exit(void)
{
	hid_unregister_driver(&lg_driver);
}
static int ms_init(void)
{
	return hid_register_driver(&ms_driver);
}
static void ms_exit(void)
{
	hid_unregister_driver(&ms_driver);
}
static int mr_init(void)
{
	return hid_register_driver(&mr_driver);
}
static void mr_exit(void)
{
	hid_unregister_driver(&mr_driver);
}
static int ntrig_init(void)
{
	return hid_register_driver(&ntrig_driver);
}
static void ntrig_exit(void)
{
	hid_unregister_driver(&ntrig_driver);
}
static int pl_init(void)
{
	return hid_register_driver(&pl_driver);
}
static void pl_exit(void)
{
	hid_unregister_driver(&pl_driver);
}
static inline int plff_init(struct hid_device *hid)
{
	return 0;
}
static int pl_init(void)
{
	return hid_register_driver(&pl_driver);
}
static void pl_exit(void)
{
	hid_unregister_driver(&pl_driver);
}
static int samsung_init(void)
{
	return hid_register_driver(&samsung_driver);
}
static void samsung_exit(void)
{
	hid_unregister_driver(&samsung_driver);
}
static int sony_init(void)
{
	return hid_register_driver(&sony_driver);
}
static void sony_exit(void)
{
	hid_unregister_driver(&sony_driver);
}
static int sp_init(void)
{
	return hid_register_driver(&sp_driver);
}
static void sp_exit(void)
{
	hid_unregister_driver(&sp_driver);
}
static int tm_init(void)
{
	return hid_register_driver(&tm_driver);
}
static void tm_exit(void)
{
	hid_unregister_driver(&tm_driver);
}
static int ts_init(void)
{
	return hid_register_driver(&ts_driver);
}
static void ts_exit(void)
{
	hid_unregister_driver(&ts_driver);
}
static int zp_init(void)
{
	return hid_register_driver(&zp_driver);
}
static void zp_exit(void)
{
	hid_unregister_driver(&zp_driver);
}
static int hid_set_idle(struct usb_device *dev, int ifnum, int report, int idle)
{
	return usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
		HID_REQ_SET_IDLE, USB_TYPE_CLASS | USB_RECIP_INTERFACE, (idle << 8) | report,
		ifnum, NULL, 0, USB_CTRL_SET_TIMEOUT);
}
static int pidff_rescale(int i, int max, struct hid_field *field)
{
	return i * (field->logical_maximum - field->logical_minimum) / max +
	    field->logical_minimum;
}
static int pidff_rescale_signed(int i, struct hid_field *field)
{
	return i == 0 ? 0 : i >
	    0 ? i * field->logical_maximum / 0x7fff : i *
	    field->logical_minimum / -0x8000;
}
static int pidff_needs_set_envelope(struct ff_envelope *envelope,
				    struct ff_envelope *old)
{
	return envelope->attack_level != old->attack_level ||
	       envelope->fade_level != old->fade_level ||
	       envelope->attack_length != old->attack_length ||
	       envelope->fade_length != old->fade_length;
}
static int pidff_needs_set_constant(struct ff_effect *effect,
				    struct ff_effect *old)
{
	return effect->u.constant.level != old->u.constant.level;
}
static int pidff_needs_set_effect(struct ff_effect *effect,
				  struct ff_effect *old)
{
	return effect->replay.length != old->replay.length ||
	       effect->trigger.interval != old->trigger.interval ||
	       effect->trigger.button != old->trigger.button ||
	       effect->direction != old->direction ||
	       effect->replay.delay != old->replay.delay;
}
static int pidff_needs_set_periodic(struct ff_effect *effect,
				    struct ff_effect *old)
{
	return effect->u.periodic.magnitude != old->u.periodic.magnitude ||
	       effect->u.periodic.offset != old->u.periodic.offset ||
	       effect->u.periodic.phase != old->u.periodic.phase ||
	       effect->u.periodic.period != old->u.periodic.period;
}
static int pidff_needs_set_ramp(struct ff_effect *effect, struct ff_effect *old)
{
	return effect->u.ramp.start_level != old->u.ramp.start_level ||
	       effect->u.ramp.end_level != old->u.ramp.end_level;
}
void usbhid_quirks_exit(void)
{
	usbhid_remove_all_dquirks();
}
static ssize_t hiddev_write(struct file * file, const char __user * buffer, size_t count, loff_t *ppos)
{
	return -EINVAL;
}
static long hiddev_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
	return hiddev_ioctl(file, cmd, (unsigned long)compat_ptr(arg));
}
static int hiddev_usbd_probe(struct usb_interface *intf,
			     const struct usb_device_id *hiddev_info)
{
	return -ENODEV;
}
int __init hiddev_init(void)
{
	return usb_register(&hiddev_driver);
}
void hiddev_exit(void)
{
	usb_deregister(&hiddev_driver);
}
static void __exit usb_kbd_exit(void)
{
	usb_deregister(&usb_kbd_driver);
}
static void __exit usb_mouse_exit(void)
{
	usb_deregister(&usb_mouse_driver);
}
static ssize_t show_name(struct device *dev,
	struct device_attribute *devattr, char *buf)
{
	return sprintf(buf, "%s\n", ABIT_UGURU_NAME);
}
static ssize_t show_name(struct device *dev,
	struct device_attribute *devattr, char *buf)
{
	return sprintf(buf, "%s\n", ABIT_UGURU3_NAME);
}
static inline int abituguru3_dmi_detect(void)
{
	return 1;
}
static inline int ad7414_temp_from_reg(s16 reg)
{
	return ((int)reg / 64) * 250;
}
static inline int ad7414_read(struct i2c_client *client, u8 reg)
{
	if (reg == AD7414_REG_TEMP) {
	} else
		return i2c_smbus_read_byte_data(client, reg);
}
static inline int ad7414_write(struct i2c_client *client, u8 reg, u8 value)
{
	return i2c_smbus_write_byte_data(client, reg, value);
}
static int __init ad7414_init(void)
{
	return i2c_add_driver(&ad7414_driver);
}
static void __exit ad7414_exit(void)
{
	i2c_del_driver(&ad7414_driver);
}
static inline int ad7418_read(struct i2c_client *client, u8 reg)
{
	return swab16(i2c_smbus_read_word_data(client, reg));
}
static inline int ad7418_write(struct i2c_client *client, u8 reg, u16 value)
{
	return i2c_smbus_write_word_data(client, reg, swab16(value));
}
static int __init ad7418_init(void)
{
	return i2c_add_driver(&ad7418_driver);
}
static void __exit ad7418_exit(void)
{
	i2c_del_driver(&ad7418_driver);
}
static ssize_t adcxx_show_min(struct device *dev,
		struct device_attribute *devattr, char *buf)
{
	return sprintf(buf, "0\n");
}
static int __devinit adcxx1s_probe(struct spi_device *spi)
{
	return adcxx_probe(spi, 1);
}
static int __devinit adcxx2s_probe(struct spi_device *spi)
{
	return adcxx_probe(spi, 2);
}
static int __devinit adcxx4s_probe(struct spi_device *spi)
{
	return adcxx_probe(spi, 4);
}
static int __devinit adcxx8s_probe(struct spi_device *spi)
{
	return adcxx_probe(spi, 8);
}
static int __init sensors_adm1021_init(void)
{
	return i2c_add_driver(&adm1021_driver);
}
static void __exit sensors_adm1021_exit(void)
{
	i2c_del_driver(&adm1021_driver);
}
static int __init sensors_adm1025_init(void)
{
	return i2c_add_driver(&adm1025_driver);
}
static void __exit sensors_adm1025_exit(void)
{
	i2c_del_driver(&adm1025_driver);
}
static ssize_t show_auto_pwm_max(struct device *dev, struct device_attribute *attr, char *buf)
{
	return sprintf(buf, "%d\n", ADM1026_PWM_MAX);
}
static int __init sm_adm1026_init(void)
{
	return i2c_add_driver(&adm1026_driver);
}
static void __exit sm_adm1026_exit(void)
{
	i2c_del_driver(&adm1026_driver);
}
static int __init sensors_adm1029_init(void)
{
	return i2c_add_driver(&adm1029_driver);
}
static void __exit sensors_adm1029_exit(void)
{
	i2c_del_driver(&adm1029_driver);
}
static inline u8 adm1031_read_value(struct i2c_client *client, u8 reg)
{
	return i2c_smbus_read_byte_data(client, reg);
}
static inline int
adm1031_write_value(struct i2c_client *client, u8 reg, unsigned int value)
{
	return i2c_smbus_write_byte_data(client, reg, value);
}
static int __init sensors_adm1031_init(void)
{
	return i2c_add_driver(&adm1031_driver);
}
static void __exit sensors_adm1031_exit(void)
{
	i2c_del_driver(&adm1031_driver);
}
static inline int SCALE(long val, int mul, int div)
{
	if (val < 0)
		return (val * mul - div / 2) / div;
	else
		return (val * mul + div / 2) / div;
}
static inline unsigned int IN_FROM_REG(u8 reg, int n)
{
	return SCALE(reg, nom_mv[n], 192);
}
static inline u8 IN_TO_REG(unsigned long val, int n)
{
	return SENSORS_LIMIT(SCALE(val, 192, nom_mv[n]), 0, 255);
}
static inline s8 TEMP_TO_REG(long val)
{
	return SENSORS_LIMIT(SCALE(val, 1, 1000), -40, 127);
}
static inline u8 AOUT_TO_REG(unsigned long val)
{
	return SENSORS_LIMIT(SCALE(val, 255, 1250), 0, 255);
}
static inline unsigned int AOUT_FROM_REG(u8 reg)
{
	return SCALE(reg, 1250, 255);
}
static int __init sensors_adm9240_init(void)
{
	return i2c_add_driver(&adm9240_driver);
}
static void __exit sensors_adm9240_exit(void)
{
	i2c_del_driver(&adm9240_driver);
}
static u16 ads7828_read_value(struct i2c_client *client, u8 reg)
{
	return swab16(i2c_smbus_read_word_data(client, reg));
}
static void __exit sensors_ads7828_exit(void)
{
	i2c_del_driver(&ads7828_driver);
}
static int fan_enabled(struct adt7462_data *data, int fan)
{
	return data->fan_enabled & (1 << fan);
}
static int __init adt7462_init(void)
{
	return i2c_add_driver(&adt7462_driver);
}
static void __exit adt7462_exit(void)
{
	i2c_del_driver(&adt7462_driver);
}
static inline int adt7470_write_word_data(struct i2c_client *client, u8 reg,
					  u16 value)
{
	return i2c_smbus_write_byte_data(client, reg, value & 0xFF)
	       && i2c_smbus_write_byte_data(client, reg + 1, value >> 8);
}
static int __init adt7470_init(void)
{
	return i2c_add_driver(&adt7470_driver);
}
static void __exit adt7470_exit(void)
{
	i2c_del_driver(&adt7470_driver);
}
static inline int adt7473_write_word_data(struct i2c_client *client, u8 reg,
					  u16 value)
{
	return i2c_smbus_write_byte_data(client, reg, value & 0xFF)
	       && i2c_smbus_write_byte_data(client, reg + 1, value >> 8);
}
static int decode_volt(int volt_index, u8 raw)
{
	return SCALE(raw, 192, adt7473_scaling[volt_index]);
}
static int decode_temp(u8 twos_complement, u8 raw)
{
	return twos_complement ? (s8)raw : raw - 64;
}
static int __init adt7473_init(void)
{
	return i2c_add_driver(&adt7473_driver);
}
static void __exit adt7473_exit(void)
{
	i2c_del_driver(&adt7473_driver);
}
static inline int reg2temp(struct adt7475_data *data, u16 reg)
{
	if (data->config5 & CONFIG5_TWOSCOMP) {
	} else
		return (reg - 256) * 250;
}
static inline int reg2vcc(u16 reg)
{
	return (4296 * reg) / 1000;
}
static inline int reg2vccp(u16 reg)
{
	return (2929 * reg) / 1000;
}
static int __init sensors_adt7475_init(void)
{
	return i2c_add_driver(&adt7475_driver);
}
static void __exit sensors_adt7475_exit(void)
{
	i2c_del_driver(&adt7475_driver);
}
static s32 ams_i2c_read(u8 reg)
{
	return i2c_smbus_read_byte_data(ams_info.i2c_client, reg);
}
static int ams_i2c_write(u8 reg, u8 value)
{
	return i2c_smbus_write_byte_data(ams_info.i2c_client, reg, value);
}
static u8 ams_i2c_get_vendor(void)
{
	return ams_i2c_read(AMS_VENDOR);
}
static void ams_i2c_exit(void)
{
	i2c_del_driver(&ams_i2c_driver);
}
static ssize_t ams_input_show_joystick(struct device *dev,
	struct device_attribute *attr, char *buf)
{
	return sprintf(buf, "%d\n", joystick);
}
static void ams_pmu_req_complete(struct adb_request *req)
{
	complete((struct completion *)req->arg);
}
static u8 ams_pmu_get_vendor(void)
{
	return ams_pmu_get_register(AMS_VENDOR);
}
static int applesmc_resume(struct platform_device *dev)
{
	return applesmc_device_init();
}
static ssize_t applesmc_name_show(struct device *dev,
				   struct device_attribute *attr, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "applesmc\n");
}
static ssize_t applesmc_calibrate_show(struct device *dev,
				struct device_attribute *attr, char *sysfsbuf)
{
	return snprintf(sysfsbuf, PAGE_SIZE, "(%d,%d)\n", rest_x, rest_y);
}
static ssize_t applesmc_key_at_index_show(struct device *dev,
				struct device_attribute *attr, char *sysfsbuf)
{
	return snprintf(sysfsbuf, PAGE_SIZE, "%d\n", key_at_index);
}
static unsigned IN_FROM_REG(u8 reg)
{
	return reg * 16;
}
static int FAN_FROM_REG(u8 val, int div)
{
	return val==0 ? -1 : val==255 ? 0 : 1350000/(val*div);
}
static int TEMP_FROM_REG(u8 reg)
{
	return (s8)reg * 1000;
}
static int ASB100_PWM_FROM_REG(u8 reg)
{
	return reg * 16;
}
static u8 DIV_TO_REG(long val)
{
	return val==8 ? 3 : val==4 ? 2 : val==1 ? 0 : 1;
}
static int __init asb100_init(void)
{
	return i2c_add_driver(&asb100_driver);
}
static void __exit asb100_exit(void)
{
	i2c_del_driver(&asb100_driver);
}

static int __init atxp1_init(void)
{
	return i2c_add_driver(&atxp1_driver);
}

static void __exit atxp1_exit(void)
{
	i2c_del_driver(&atxp1_driver);
}
static inline int IN_FROM_REG(int reg, int nominal, int res)
{
	return (reg * nominal + (3 << (res - 3))) / (3 << (res - 2));
}
static inline int IN_TO_REG(int val, int nominal)
{
	return SENSORS_LIMIT((val * 192 + nominal / 2) / nominal, 0, 255);
}
static inline int TEMP_FROM_REG(int reg, int res)
{
	return (reg * 1000) >> (res - 8);
}
static inline int TEMP_TO_REG(int val)
{
	return SENSORS_LIMIT((val < 0 ? val - 500 : val + 500) / 1000,
			     -128, 127);
}
static inline int TEMP_RANGE_FROM_REG(int reg)
{
	return TEMP_RANGE[(reg >> 4) & 0x0f];
}
static inline int TEMP_HYST_FROM_REG(int reg, int ix)
{
	return (((ix == 1) ? reg : reg >> 4) & 0x0f) * 1000;
}
static inline int FAN_TPC_FROM_REG(int reg)
{
	return (reg & 0x20) ? 0 : 60 >> (reg & 0x03);
}
static inline int PWM_FREQ_FROM_REG(int reg)
{
	return PWM_FREQ[reg & 0x0f];
}
static inline int PWM_RR_EN_FROM_REG(int reg, int ix)
{
	return PWM_RR_FROM_REG(reg, ix) ? 1 : 0;
}
static inline int PWM_OFF_FROM_REG(int reg, int ix)
{
	return (reg >> (ix + 5)) & 0x01;
}
static inline int PWM_OFF_TO_REG(int val, int ix, int reg)
{
	return (reg & ~(1 << (ix + 5))) | ((val & 0x01) << (ix + 5));
}
static inline void dme1737_sio_enter(int sio_cip)
{
	outb(0x55, sio_cip);
}
static inline void dme1737_sio_exit(int sio_cip)
{
	outb(0xaa, sio_cip);
}
static int ds1621_write_temp(struct i2c_client *client, u8 reg, u16 value)
{
	return i2c_smbus_write_word_data(client, reg, swab16(value));
}
static int __init ds1621_init(void)
{
	return i2c_add_driver(&ds1621_driver);
}
static void __exit ds1621_exit(void)
{
	i2c_del_driver(&ds1621_driver);
}
static inline void
superio_exit(int base)
{
	outb(0xaa, base);
}
static inline long in_from_reg(u8 reg)
{
	return (reg * 8);
}
static inline long in0_from_reg(u8 reg)
{
	return (reg * 16);
}
static inline int pwm_mode_from_reg(u8 reg)
{
	return !(reg & FAN_CTRL_DC_MODE);
}
static inline long temp_from_reg(u8 reg)
{
	return (reg * 1000);
}
static inline void superio_exit(int base)
{
	outb(SIO_LOCK_KEY, base);
}
static inline int fan_from_reg(u16 reg)
{
	return reg ? (1500000 / reg) : 0;
}
static inline u16 fan_to_reg(int fan)
{
	return fan ? (1500000 / fan) : 0;
}
static inline int f75375_read8(struct i2c_client *client, u8 reg)
{
	return i2c_smbus_read_byte_data(client, reg);
}
static inline u16 f75375_read16(struct i2c_client *client, u8 reg)
{
	return ((i2c_smbus_read_byte_data(client, reg) << 8)
		| i2c_smbus_read_byte_data(client, reg + 1));
}
static inline void f75375_write8(struct i2c_client *client, u8 reg,
		u8 value)
{
	i2c_smbus_write_byte_data(client, reg, value);
}
static int __init sensors_f75375_init(void)
{
	return i2c_add_driver(&f75375_driver);
}
static void __exit sensors_f75375_exit(void)
{
	i2c_del_driver(&f75375_driver);
}
static ssize_t show_fan_status(struct fscher_data *data, char *buf, int nr)
{
	return sprintf(buf, "%u\n", data->fan_status[FAN_INDEX_FROM_NUM(nr)] & 0x04);
}
static ssize_t show_pwm(struct fscher_data *data, char *buf, int nr)
{
	return sprintf(buf, "%u\n", data->fan_min[FAN_INDEX_FROM_NUM(nr)]);
}
static ssize_t show_fan_div(struct fscher_data *data, char *buf, int nr)
{
	return sprintf(buf, "%u\n", 1 << (data->fan_ripple[FAN_INDEX_FROM_NUM(nr)] & 0x03));
}
static ssize_t show_fan_input (struct fscher_data *data, char *buf, int nr)
{
	return sprintf(buf, "%u\n", RPM_FROM_REG(data->fan_act[FAN_INDEX_FROM_NUM(nr)]));
}
static ssize_t show_temp_status(struct fscher_data *data, char *buf, int nr)
{
	return sprintf(buf, "%u\n", data->temp_status[TEMP_INDEX_FROM_NUM(nr)] & 0x03);
}
static ssize_t show_temp_input(struct fscher_data *data, char *buf, int nr)
{
	return sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp_act[TEMP_INDEX_FROM_NUM(nr)]));
}
static ssize_t show_in_input(struct fscher_data *data, char *buf, int nr)
{
	return sprintf(buf, "%u\n", VOLT_FROM_REG(data->volt[nr]));
}
static ssize_t show_revision(struct fscher_data *data, char *buf, int nr)
{
	return sprintf(buf, "%u\n", data->revision);
}
static ssize_t show_alarms(struct fscher_data *data, char *buf, int nr)
{
	return sprintf(buf, "%u\n", data->global_event & 0x9b);
}
static ssize_t show_control(struct fscher_data *data, char *buf, int nr)
{
	return sprintf(buf, "%u\n", data->global_control & 0x01);
}
static ssize_t show_watchdog_control(struct fscher_data *data, char *buf, int nr)
{
	return sprintf(buf, "%u\n", data->watchdog[2] & 0xd0);
}
static ssize_t show_watchdog_status(struct fscher_data *data, char *buf, int nr)
{
	return sprintf(buf, "%u\n", data->watchdog[1] & 0x02);
}
static ssize_t show_watchdog_preset(struct fscher_data *data, char *buf, int nr)
{
	return sprintf(buf, "%u\n", data->watchdog[0]);
}
static int __init sensors_fscher_init(void)
{
	return i2c_add_driver(&fscher_driver);
}
static void __exit sensors_fscher_exit(void)
{
	i2c_del_driver(&fscher_driver);
}
static int __init fschmd_init(void)
{
	return i2c_add_driver(&fschmd_driver);
}
static void __exit fschmd_exit(void)
{
	i2c_del_driver(&fschmd_driver);
}
static ssize_t show_temp_input(struct fscpos_data *data, char *buf, int nr)
{
	return sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp_act[nr - 1]));
}
static ssize_t show_temp_status(struct fscpos_data *data, char *buf, int nr)
{
	return sprintf(buf, "%u\n", data->temp_status[nr - 1] & 0x03);
}
static ssize_t show_temp_reset(struct fscpos_data *data, char *buf, int nr)
{
	return sprintf(buf, "1\n");
}
static ssize_t show_fan_status(struct fscpos_data *data, char *buf, int nr)
{
	return sprintf(buf, "%u\n", data->fan_status[nr - 1] & 0x04);
}
static ssize_t show_fan_input(struct fscpos_data *data, char *buf, int nr)
{
	return sprintf(buf, "%u\n", RPM_FROM_REG(data->fan_act[nr - 1]));
}
static ssize_t show_fan_ripple(struct fscpos_data *data, char *buf, int nr)
{
	return sprintf(buf, "%u\n", data->fan_ripple[nr - 1] & 0x03);
}
static ssize_t show_pwm(struct fscpos_data *data, char *buf, int nr)
{
	return sprintf(buf, "%u\n", data->pwm[nr - 1]);
}
static void reset_fan_alarm(struct i2c_client *client, int nr)
{
	fscpos_write_value(client, FSCPOS_REG_FAN_STATE[nr], 4);
}
static ssize_t show_wdog_control(struct fscpos_data *data, char *buf)
{
	return sprintf(buf, "%u\n", data->wdog_control & 0xb0);
}
static ssize_t show_wdog_state(struct fscpos_data *data, char *buf)
{
	return sprintf(buf, "%u\n", data->wdog_state & 0x02);
}
static ssize_t show_wdog_preset(struct fscpos_data *data, char *buf)
{
	return sprintf(buf, "%u\n", data->wdog_preset);
}
static int __init sm_fscpos_init(void)
{
	return i2c_add_driver(&fscpos_driver);
}
static void __exit sm_fscpos_exit(void)
{
	i2c_del_driver(&fscpos_driver);
}
static int gl518_read_value(struct i2c_client *client, u8 reg)
{
	if ((reg >= 0x07) && (reg <= 0x0c))
		return swab16(i2c_smbus_read_word_data(client, reg));
	else
		return i2c_smbus_read_byte_data(client, reg);
}
static int gl518_write_value(struct i2c_client *client, u8 reg, u16 value)
{
	if ((reg >= 0x07) && (reg <= 0x0c))
		return i2c_smbus_write_word_data(client, reg, swab16(value));
	else
		return i2c_smbus_write_byte_data(client, reg, value);
}
static int __init sensors_gl518sm_init(void)
{
	return i2c_add_driver(&gl518_driver);
}
static void __exit sensors_gl518sm_exit(void)
{
	i2c_del_driver(&gl518_driver);
}
static int gl520_read_value(struct i2c_client *client, u8 reg)
{
	if ((reg >= 0x07) && (reg <= 0x0c))
		return swab16(i2c_smbus_read_word_data(client, reg));
	else
		return i2c_smbus_read_byte_data(client, reg);
}
static int gl520_write_value(struct i2c_client *client, u8 reg, u16 value)
{
	if ((reg >= 0x07) && (reg <= 0x0c))
		return i2c_smbus_write_word_data(client, reg, swab16(value));
	else
		return i2c_smbus_write_byte_data(client, reg, value);
}
static int __init sensors_gl520sm_init(void)
{
	return i2c_add_driver(&gl520_driver);
}
static void __exit sensors_gl520sm_exit(void)
{
	i2c_del_driver(&gl520_driver);
}
static inline u8 __get_latch(u16 port)
{
	return inb(port) & 0xff;
}
static int hdaps_resume(struct platform_device *dev)
{
	return hdaps_device_init();
}
static void hdaps_calibrate(void)
{
	__hdaps_read_pair(HDAPS_PORT_XPOS, HDAPS_PORT_YPOS, &rest_x, &rest_y);
}
static ssize_t hdaps_keyboard_activity_show(struct device *dev,
					    struct device_attribute *attr,
					    char *buf)
{
	return sprintf(buf, "%u\n", KEYBD_ISSET(km_activity));
}
static ssize_t hdaps_mouse_activity_show(struct device *dev,
					 struct device_attribute *attr,
					 char *buf)
{
	return sprintf(buf, "%u\n", MOUSE_ISSET(km_activity));
}
static ssize_t hdaps_calibrate_show(struct device *dev,
				    struct device_attribute *attr, char *buf)
{
	return sprintf(buf, "(%d,%d)\n", rest_x, rest_y);
}
static ssize_t hdaps_invert_show(struct device *dev,
				 struct device_attribute *attr, char *buf)
{
	return sprintf(buf, "%u\n", hdaps_invert);
}
acpi_status lis3lv02d_acpi_init(acpi_handle handle)
{
	return acpi_evaluate_object(handle, METHOD_NAME__INI, NULL, NULL);
}
static void __exit lis3lv02d_exit_module(void)
{
	acpi_bus_unregister_driver(&lis3lv02d_driver);
}
static void __exit hwmon_exit(void)
{
	class_destroy(hwmon_class);
}
static unsigned long amb_reg_temp_status(unsigned int amb)
{
	return AMB_FUNC_3_OFFSET + AMB_REG_TEMP_STATUS_ADDR +
	       AMB_CONFIG_SIZE * amb;
}
static unsigned long amb_reg_temp_min(unsigned int amb)
{
	return AMB_FUNC_3_OFFSET + AMB_REG_TEMP_MIN_ADDR +
	       AMB_CONFIG_SIZE * amb;
}
static unsigned long amb_reg_temp_mid(unsigned int amb)
{
	return AMB_FUNC_3_OFFSET + AMB_REG_TEMP_MID_ADDR +
	       AMB_CONFIG_SIZE * amb;
}
static unsigned long amb_reg_temp_max(unsigned int amb)
{
	return AMB_FUNC_3_OFFSET + AMB_REG_TEMP_MAX_ADDR +
	       AMB_CONFIG_SIZE * amb;
}
static unsigned long amb_reg_temp(unsigned int amb)
{
	return AMB_FUNC_3_OFFSET + AMB_REG_TEMP_ADDR +
	       AMB_CONFIG_SIZE * amb;
}
static unsigned long amb_num_from_reg(unsigned int byte_num, unsigned int bit)
{
	return byte_num * MAX_AMBS_PER_CHANNEL + bit;
}
static ssize_t show_name(struct device *dev, struct device_attribute *devattr,
			 char *buf)
{
	return sprintf(buf, "%s\n", DRVNAME);
}
static u8 amb_read_byte(struct i5k_amb_data *data, unsigned long offset)
{
	return ioread8(data->amb_mmio + offset);
}
static void amb_write_byte(struct i5k_amb_data *data, unsigned long offset,
			   u8 val)
{
	iowrite8(val, data->amb_mmio + offset);
}
static void update_aem_energy_one(struct aem_data *data, int which)
{
	aem_read_sensor(data, AEM_ENERGY_ELEMENT, which,
			&data->energy[which], 8);
}
static int aem1_find_sensors(struct aem_data *data)
{
	return aem_register_sensors(data, aem1_ro_sensors, aem1_rw_sensors);
}
static int aem2_find_sensors(struct aem_data *data)
{
	return aem_register_sensors(data, aem2_ro_sensors, aem2_rw_sensors);
}
static inline u16 extract_value(const char *data, int offset)
{
	return be16_to_cpup((__be16 *)&data[offset]);
}
static ssize_t show_name(struct device *dev, struct device_attribute *devattr,
			 char *buf)
{
	return sprintf(buf, "%s\n", DRVNAME);
}
static int __init ibmpex_init(void)
{
	return ipmi_smi_watcher_register(&driver_data.bmc_events);
}
static inline int has_16bit_fans(const struct it87_data *data)
{
	return (data->type == it87 && data->revision >= 0x03)
	    || (data->type == it8712 && data->revision >= 0x08)
	    || data->type == it8716
	    || data->type == it8718
	    || data->type == it8720;
}
static int __init k8temp_init(void)
{
	return pci_register_driver(&k8temp_driver);
}
static void __exit k8temp_exit(void)
{
	pci_unregister_driver(&k8temp_driver);
}
static inline int lis3lv02d_get_axis(s8 axis, int hw_values[3])
{
	if (axis > 0)
		return hw_values[axis - 1];
	else
		return -hw_values[-axis - 1];
}
static inline void lis3lv02d_calibrate_joystick(void)
{
	lis3lv02d_get_xyz(adev.device->handle, &adev.xcalib, &adev.ycalib, &adev.zcalib);
}
static ssize_t lis3lv02d_calibrate_show(struct device *dev,
				struct device_attribute *attr, char *buf)
{
	return sprintf(buf, "(%d,%d,%d)\n", adev.xcalib, adev.ycalib, adev.zcalib);
}
static int __init sensors_lm63_init(void)
{
	return i2c_add_driver(&lm63_driver);
}
static void __exit sensors_lm63_exit(void)
{
	i2c_del_driver(&lm63_driver);
}
static int lm75_write_value(struct i2c_client *client, u8 reg, u16 value)
{
	if (reg == LM75_REG_CONF)
		return i2c_smbus_write_byte_data(client, reg, value);
	else
		return i2c_smbus_write_word_data(client, reg, swab16(value));
}
static int __init sensors_lm75_init(void)
{
	return i2c_add_driver(&lm75_driver);
}
static void __exit sensors_lm75_exit(void)
{
	i2c_del_driver(&lm75_driver);
}
static inline int LM77_TEMP_FROM_REG(s16 reg)
{
	return (reg / 8) * 500;
}
static u16 lm77_read_value(struct i2c_client *client, u8 reg)
{
	if (reg == LM77_REG_CONF)
		return i2c_smbus_read_byte_data(client, reg);
	else
		return swab16(i2c_smbus_read_word_data(client, reg));
}
static int lm77_write_value(struct i2c_client *client, u8 reg, u16 value)
{
	if (reg == LM77_REG_CONF)
		return i2c_smbus_write_byte_data(client, reg, value);
	else
		return i2c_smbus_write_word_data(client, reg, swab16(value));
}
static int __init sensors_lm77_init(void)
{
	return i2c_add_driver(&lm77_driver);
}
static void __exit sensors_lm77_exit(void)
{
	i2c_del_driver(&lm77_driver);
}
static inline int FAN_FROM_REG(u8 val, int div)
{
	return val==0 ? -1 : val==255 ? 0 : 1350000/(val*div);
}
static inline int TEMP_FROM_REG(s8 val)
{
	return val * 1000;
}
static int lm80_read_value(struct i2c_client *client, u8 reg)
{
	return i2c_smbus_read_byte_data(client, reg);
}
static int lm80_write_value(struct i2c_client *client, u8 reg, u8 value)
{
	return i2c_smbus_write_byte_data(client, reg, value);
}
static int __init sensors_lm80_init(void)
{
	return i2c_add_driver(&lm80_driver);
}
static void __exit sensors_lm80_exit(void)
{
	i2c_del_driver(&lm80_driver);
}
static int __init sensors_lm83_init(void)
{
	return i2c_add_driver(&lm83_driver);
}
static void __exit sensors_lm83_exit(void)
{
	i2c_del_driver(&lm83_driver);
}
static int FREQ_FROM_REG(const int *map, u8 reg)
{
	return map[reg & 0x07];
}
static int __init sm_lm85_init(void)
{
	return i2c_add_driver(&lm85_driver);
}
static void __exit sm_lm85_exit(void)
{
	i2c_del_driver(&lm85_driver);
}
static inline int lm87_read_value(struct i2c_client *client, u8 reg)
{
	return i2c_smbus_read_byte_data(client, reg);
}
static inline int lm87_write_value(struct i2c_client *client, u8 reg, u8 value)
{
	return i2c_smbus_write_byte_data(client, reg, value);
}
static int __init sensors_lm87_init(void)
{
	return i2c_add_driver(&lm87_driver);
}
static void __exit sensors_lm87_exit(void)
{
	i2c_del_driver(&lm87_driver);
}
static inline int temp_from_s8(s8 val)
{
	return val * 1000;
}
static inline int temp_from_u8(u8 val)
{
	return val * 1000;
}
static inline int temp_from_s16(s16 val)
{
	return val / 32 * 125;
}
static inline int temp_from_u16(u16 val)
{
	return val / 32 * 125;
}
static inline int temp_from_u8_adt7461(struct lm90_data *data, u8 val)
{
	if (data->flags & LM90_FLAG_ADT7461_EXT)
		return (val - 64) * 1000;
	else
		return temp_from_s8(val);
}
static inline int temp_from_u16_adt7461(struct lm90_data *data, u16 val)
{
	if (data->flags & LM90_FLAG_ADT7461_EXT)
		return (val - 0x4000) / 64 * 250;
	else
		return temp_from_s16(val);
}
static inline s32 adm1032_write_byte(struct i2c_client *client, u8 value)
{
	return i2c_smbus_xfer(client->adapter, client->addr,
			      client->flags & ~I2C_CLIENT_PEC,
			      I2C_SMBUS_WRITE, value, I2C_SMBUS_BYTE, NULL);
}
static int __init sensors_lm90_init(void)
{
	return i2c_add_driver(&lm90_driver);
}
static void __exit sensors_lm90_exit(void)
{
	i2c_del_driver(&lm90_driver);
}
static inline int TEMP_FROM_REG(s16 reg)
{
	return reg / 8 * 625 / 10;
}
static inline u8 ALARMS_FROM_REG(s16 reg)
{
	return reg & 0x0007;
}
static int __init sensors_lm92_init(void)
{
	return i2c_add_driver(&lm92_driver);
}
static void __exit sensors_lm92_exit(void)
{
	i2c_del_driver(&lm92_driver);
}
static int LM93_VID_FROM_REG(u8 reg)
{
	return vid_from_reg((reg & 0x3f), 100);
}
static int LM93_TEMP_FROM_REG(u8 reg)
{
	return (s8)reg * 1000;
}
static int LM93_TEMP_OFFSET_MODE_FROM_REG(u8 sfc2, int nr)
{
	return sfc2 & (nr < 2 ? 0x10 : 0x20);
}
static int LM93_TEMP_OFFSET_FROM_REG(u8 reg, int mode)
{
	return (reg & 0x0f) * (mode ? 5 : 10);
}
static int LM93_TEMP_AUTO_OFFSET_FROM_REG(u8 reg, int nr, int mode)
{
	if (nr < 2)
		return LM93_TEMP_OFFSET_FROM_REG(reg & 0x0f, mode);
	else
		return LM93_TEMP_OFFSET_FROM_REG(reg >> 4 & 0x0f, mode);
}
static int LM93_PWM_FROM_REG(u8 reg, pwm_freq_t freq)
{
	return lm93_pwm_map[freq][reg & 0x0f];
}
static int LM93_PWM_FREQ_FROM_REG(u8 reg)
{
	return lm93_pwm_freq_map[reg & 0x07];
}
static int LM93_SPINUP_TIME_FROM_REG(u8 reg)
{
	return lm93_spinup_time_map[reg >> 5 & 0x07];
}
static int LM93_RAMP_FROM_REG(u8 reg)
{
	return (reg & 0x0f) * 5;
}
static int LM93_INTERVAL_FROM_REG(u8 reg)
{
	return lm93_interval_map[reg & 0x0f];
}
static unsigned LM93_GPI_FROM_REG(u8 reg)
{
	return ~reg & 0xff;
}
static int __init lm93_init(void)
{
	return i2c_add_driver(&lm93_driver);
}
static void __exit lm93_exit(void)
{
	i2c_del_driver(&lm93_driver);
}
static int __init ltc4245_init(void)
{
	return i2c_add_driver(&ltc4245_driver);
}
static void __exit ltc4245_exit(void)
{
	i2c_del_driver(&ltc4245_driver);
}
int max1111_read_channel(int channel)
{
	return max1111_read(&the_max1111->spi->dev, channel);
}
static ssize_t show_name(struct device *dev,
			 struct device_attribute *attr, char *buf)
{
	return sprintf(buf, "max1111\n");
}
static int __init max1111_init(void)
{
	return spi_register_driver(&max1111_driver);
}
static void __exit max1111_exit(void)
{
	spi_unregister_driver(&max1111_driver);
}
static int temp_from_reg(int val)
{
	return (val & 0x80 ? val-0x100 : val) * 1000;
}
static int temp_to_reg(int val)
{
	return (val < 0 ? val+0x100*1000 : val) / 1000;
}
static int __init sensors_max1619_init(void)
{
	return i2c_add_driver(&max1619_driver);
}
static void __exit sensors_max1619_exit(void)
{
	i2c_del_driver(&max1619_driver);
}
static int __init sensors_max6650_init(void)
{
	return i2c_add_driver(&max6650_driver);
}
static void __exit sensors_max6650_exit(void)
{
	i2c_del_driver(&max6650_driver);
}
static inline int pc87427_read8(struct pc87427_data *data, u8 ldi, u8 reg)
{
	return inb(data->address[ldi] + reg);
}
static inline int FAN_FROM_REG(u8 val, int div)
{
	return val==0 ? -1 : val==255 ? 0 : 1350000/(val*div);
}
static inline int TEMP_FROM_REG(s8 val)
{
	return val * 830 + 52120;
}
static inline u8 DIV_TO_REG(int val)
{
	return val==8 ? 3 : val==4 ? 2 : val==1 ? 0 : 1;
}
static int __init sm_sis5595_init(void)
{
	return pci_register_driver(&sis5595_pci_driver);
}
static inline void superio_select(int ld)
{
	superio_outb(0x07, ld);
}
static inline void superio_enter(void)
{
	outb(0x55, REG);
}
static inline void superio_exit(void)
{
	outb(0xAA, REG);
}
static int temp_from_reg(u8 reg)
{
	return (s8)reg * 1000;
}
static inline void
superio_enter(void)
{
	outb(0x55, REG);
}
static inline void
superio_exit(void)
{
	outb(0xAA, REG);
}
static inline int smsc47m1_read_value(struct smsc47m1_data *data, u8 reg)
{
	return inb_p(data->addr + reg);
}
static inline void smsc47m1_write_value(struct smsc47m1_data *data, u8 reg,
		u8 value)
{
	outb_p(value, data->addr + reg);
}
static inline int SCALE(long val, int mul, int div)
{
	if (val < 0)
		return (val * mul - div / 2) / div;
	else
		return (val * mul + div / 2) / div;
}
static inline unsigned int IN_FROM_REG(u8 reg, int n)
{
	return SCALE(reg, nom_mv[n], 192);
}
static inline u8 IN_TO_REG(unsigned long val, int n)
{
	return SENSORS_LIMIT(SCALE(val, 192, nom_mv[n]), 0, 255);
}
static inline s8 TEMP_TO_REG(int val)
{
	return SENSORS_LIMIT(SCALE(val, 1, 1000), -128000, 127000);
}
static inline int TEMP_FROM_REG(s8 val)
{
	return val * 1000;
}
static int __init smsc47m192_init(void)
{
	return i2c_add_driver(&smsc47m192_driver);
}
static void __exit smsc47m192_exit(void)
{
	i2c_del_driver(&smsc47m192_driver);
}
static ssize_t show_pwm_mode(struct device *dev, struct device_attribute *attr,
			     char *buf)
{
	return sprintf(buf, "0\n");
}
static int __init sm_thmc50_init(void)
{
	return i2c_add_driver(&thmc50_driver);
}
static void __exit sm_thmc50_exit(void)
{
	i2c_del_driver(&thmc50_driver);
}
static ssize_t show_name(struct device *dev, struct device_attribute *attr, char *buf)
{
	return sprintf(buf, "ultra45\n");
}
static int __init env_init(void)
{
	return of_register_driver(&env_driver, &of_bus_type);
}
static void __exit env_exit(void)
{
	of_unregister_driver(&env_driver);
}
static inline u8 IN_TO_REG(long val, int inNum)
{
	if (inNum <= 1)
		return (u8)
		    SENSORS_LIMIT((val * 21024 - 1205000) / 250000, 0, 255);
	else if (inNum == 2)
		return (u8)
		    SENSORS_LIMIT((val * 15737 - 1205000) / 250000, 0, 255);
	else if (inNum == 3)
		return (u8)
		    SENSORS_LIMIT((val * 10108 - 1205000) / 250000, 0, 255);
	else
		return (u8)
		    SENSORS_LIMIT((val * 41714 - 12050000) / 2500000, 0, 255);
}
static inline long IN_FROM_REG(u8 val, int inNum)
{
	if (inNum <= 1)
		return (long) ((250000 * val + 1330000 + 21024 / 2) / 21024);
	else if (inNum == 2)
		return (long) ((250000 * val + 1330000 + 15737 / 2) / 15737);
	else if (inNum == 3)
		return (long) ((250000 * val + 1330000 + 10108 / 2) / 10108);
	else
		return (long) ((2500000 * val + 13300000 + 41714 / 2) / 41714);
}
static inline u8 TEMP_TO_REG(long val)
{
	return viaLUT[val <= -50000 ? 0 : val >= 110000 ? 160 :
		      (val < 0 ? val - 500 : val + 500) / 1000 + 50];
}
static inline int via686a_read_value(struct via686a_data *data, u8 reg)
{
	return inb_p(data->addr + reg);
}
static inline void via686a_write_value(struct via686a_data *data, u8 reg,
				       u8 value)
{
	outb_p(value, data->addr + reg);
}
static int __init sm_via686a_init(void)
{
	return pci_register_driver(&via686a_pci_driver);
}
static inline void superio_exit(int sio_cip)
{
	outb(0xaa, sio_cip);
}
static inline u8 vt1211_read8(struct vt1211_data *data, u8 reg)
{
	return inb(data->addr + reg);
}
static inline void vt1211_write8(struct vt1211_data *data, u8 reg, u8 val)
{
	outb(val, data->addr + reg);
}
static inline int vt8231_read_value(struct vt8231_data *data, u8 reg)
{
	return inb_p(data->addr + reg);
}
static inline void vt8231_write_value(struct vt8231_data *data, u8 reg,
					u8 value)
{
	outb_p(value, data->addr + reg);
}
static int __init sm_vt8231_init(void)
{
	return pci_register_driver(&vt8231_pci_driver);
}
static inline unsigned int step_time_from_reg(u8 reg, u8 mode)
{
	return mode ? 100 * reg : 400 * reg;
}
static inline u8 step_time_to_reg(unsigned int msec, u8 mode)
{
	return SENSORS_LIMIT((mode ? (msec + 50) / 100 :
						(msec + 200) / 400), 1, 255);
}
static inline unsigned int
div_from_reg(u8 reg)
{
	return 1 << reg;
}
static inline int
temp1_from_reg(s8 reg)
{
	return reg * 1000;
}
static inline long in_from_reg(u8 reg, u8 nr)
{
	return reg * scale_in[nr];
}
static inline u8 in_to_reg(u32 val, u8 nr)
{
	return SENSORS_LIMIT(((val + (scale_in[nr] / 2)) / scale_in[nr]), 0, 255);
}
static inline int is_word_sized(u16 reg)
{
	return (((reg & 0xff00) == 0x100
	      || (reg & 0xff00) == 0x200)
	     && ((reg & 0x00ff) == 0x50
	      || (reg & 0x00ff) == 0x53
	      || (reg & 0x00ff) == 0x55));
}
static inline void
superio_exit(void)
{
	outb(0xAA, REG);
}
static int TEMP_FROM_REG(u8 reg)
{
        return (s8)reg * 1000;
}
static struct w83781d_data *w83781d_data_if_isa(void)
{
	return pdev ? platform_get_drvdata(pdev) : NULL;
}
static struct w83781d_data *w83781d_data_if_isa(void)
{
	return NULL;
}
static int
w83781d_alias_detect(struct i2c_client *client, u8 chipid)
{
	return 0;
}
static int __init
w83781d_isa_register(void)
{
	return 0;
}
static inline int w83791d_read(struct i2c_client *client, u8 reg)
{
	return i2c_smbus_read_byte_data(client, reg);
}
static inline int w83791d_write(struct i2c_client *client, u8 reg, u8 value)
{
	return i2c_smbus_write_byte_data(client, reg, value);
}
static int __init sensors_w83791d_init(void)
{
	return i2c_add_driver(&w83791d_driver);
}
static void __exit sensors_w83791d_exit(void)
{
	i2c_del_driver(&w83791d_driver);
}
static inline long in_count_from_reg(int nr, struct w83792d_data *data)
{
	return ((data->in[nr] << 2) | ((data->low_bits >> (2 * nr)) & 0x03));
}
static inline int w83792d_read_value(struct i2c_client *client, u8 reg)
{
	return i2c_smbus_read_byte_data(client, reg);
}
static inline int
w83792d_write_value(struct i2c_client *client, u8 reg, u8 value)
{
	return i2c_smbus_write_byte_data(client, reg, value);
}
static int __init
sensors_w83792d_init(void)
{
	return i2c_add_driver(&w83792d_driver);
}
static void __exit
sensors_w83792d_exit(void)
{
	i2c_del_driver(&w83792d_driver);
}
static inline unsigned long TIME_FROM_REG(u8 reg)
{
	return (reg * 100);
}
static inline u8 TIME_TO_REG(unsigned long val)
{
	return SENSORS_LIMIT((val + 50) / 100, 0, 0xff);
}
static inline long TEMP_FROM_REG(s8 reg)
{
	return (reg * 1000);
}
static inline s8 TEMP_TO_REG(long val, s8 min, s8 max)
{
	return SENSORS_LIMIT((val + (val < 0 ? -500 : 500)) / 1000, min, max);
}
static int __init sensors_w83793_init(void)
{
	return i2c_add_driver(&w83793_driver);
}
static void __exit sensors_w83793_exit(void)
{
	i2c_del_driver(&w83793_driver);
}
static int __init sensors_w83l785ts_init(void)
{
	return i2c_add_driver(&w83l785ts_driver);
}
static void __exit sensors_w83l785ts_exit(void)
{
	i2c_del_driver(&w83l785ts_driver);
}
static u8
w83l786ng_read_value(struct i2c_client *client, u8 reg)
{
	return i2c_smbus_read_byte_data(client, reg);
}
static int
w83l786ng_write_value(struct i2c_client *client, u8 reg, u8 value)
{
	return i2c_smbus_write_byte_data(client, reg, value);
}
static int __init
sensors_w83l786ng_init(void)
{
	return i2c_add_driver(&w83l786ng_driver);
}
static void __exit
sensors_w83l786ng_exit(void)
{
	i2c_del_driver(&w83l786ng_driver);
}
static u32 bit_func(struct i2c_adapter *adap)
{
	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL |
	       I2C_FUNC_SMBUS_READ_BLOCK_DATA |
	       I2C_FUNC_SMBUS_BLOCK_PROC_CALL |
	       I2C_FUNC_10BIT_ADDR | I2C_FUNC_PROTOCOL_MANGLING;
}
static u32 pca_func(struct i2c_adapter *adap)
{
        return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
}
static u32 pcf_func(struct i2c_adapter *adap)
{
	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL |
	       I2C_FUNC_PROTOCOL_MANGLING;
}
static u32 sgi_func(struct i2c_adapter *adap)
{
	return I2C_FUNC_SMBUS_EMUL;
}
static int ioc_getscl(void *data)
{
	return (ioc_readb(IOC_CONTROL) & SCL) != 0;
}
static int ioc_getsda(void *data)
{
	return (ioc_readb(IOC_CONTROL) & SDA) != 0;
}
static u32 ali1535_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |
	    I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |
	    I2C_FUNC_SMBUS_BLOCK_DATA;
}
static int __init i2c_ali1535_init(void)
{
	return pci_register_driver(&ali1535_driver);
}
static void __exit i2c_ali1535_exit(void)
{
	pci_unregister_driver(&ali1535_driver);
}
static u32 ali1563_func(struct i2c_adapter * a)
{
	return I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |
	    I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |
	    I2C_FUNC_SMBUS_BLOCK_DATA;
}
static void ali1563_shutdown(struct pci_dev *dev)
{
	release_region(ali1563_smba,ALI1563_SMB_IOSIZE);
}
static int __init ali1563_init(void)
{
	return pci_register_driver(&ali1563_pci_driver);
}
static void __exit ali1563_exit(void)
{
	pci_unregister_driver(&ali1563_pci_driver);
}
static u32 ali15x3_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |
	    I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |
	    I2C_FUNC_SMBUS_BLOCK_DATA;
}
static int __init i2c_ali15x3_init(void)
{
	return pci_register_driver(&ali15x3_driver);
}
static void __exit i2c_ali15x3_exit(void)
{
	pci_unregister_driver(&ali15x3_driver);
}
static s32 amd756_access_virt1(struct i2c_adapter * adap, u16 addr,
			       unsigned short flags, char read_write,
			       u8 command, int size,
			       union i2c_smbus_data * data)
{
	return amd756_access_channel(adap, addr, flags, read_write, command,
				     size, data, 0x03);
}
static s32 amd756_access_virt2(struct i2c_adapter * adap, u16 addr,
			       unsigned short flags, char read_write,
			       u8 command, int size,
			       union i2c_smbus_data * data)
{
	return amd756_access_channel(adap, addr, flags, read_write, command,
				     size, data, 0x24);
}
static s32 amd756_access_virt3(struct i2c_adapter * adap, u16 addr,
			       unsigned short flags, char read_write,
			       u8 command, int size,
			       union i2c_smbus_data * data)
{
	return amd756_access_channel(adap, addr, flags, read_write, command,
				     size, data, 0x48);
}
static s32 amd756_access_virt4(struct i2c_adapter * adap, u16 addr,
			       unsigned short flags, char read_write,
			       u8 command, int size,
			       union i2c_smbus_data * data)
{
	return amd756_access_channel(adap, addr, flags, read_write, command,
				     size, data, 0x90);
}
static u32 amd756_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |
	    I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |
	    I2C_FUNC_SMBUS_BLOCK_DATA;
}
static int __init amd756_init(void)
{
	return pci_register_driver(&amd756_driver);
}
static void __exit amd756_exit(void)
{
	pci_unregister_driver(&amd756_driver);
}
static u32 amd8111_func(struct i2c_adapter *adapter)
{
	return	I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |
		I2C_FUNC_SMBUS_BYTE_DATA |
		I2C_FUNC_SMBUS_WORD_DATA | I2C_FUNC_SMBUS_BLOCK_DATA |
		I2C_FUNC_SMBUS_PROC_CALL | I2C_FUNC_SMBUS_BLOCK_PROC_CALL |
		I2C_FUNC_SMBUS_I2C_BLOCK | I2C_FUNC_SMBUS_PEC;
}
static int __init i2c_amd8111_init(void)
{
	return pci_register_driver(&amd8111_driver);
}
static void __exit i2c_amd8111_exit(void)
{
	pci_unregister_driver(&amd8111_driver);
}
static u32 at91_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
}
static int at91_i2c_resume(struct platform_device *pdev)
{
	return clk_enable(twi_clk);
}
static int __init at91_i2c_init(void)
{
	return platform_driver_register(&at91_i2c_driver);
}
static void __exit at91_i2c_exit(void)
{
	platform_driver_unregister(&at91_i2c_driver);
}
static u32
au1550_func(struct i2c_adapter *adap)
{
	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
}
static int __init
i2c_au1550_init(void)
{
	return platform_driver_register(&au1xpsc_smbus_driver);
}
static void __exit
i2c_au1550_exit(void)
{
	platform_driver_unregister(&au1xpsc_smbus_driver);
}
static u32 bfin_twi_functionality(struct i2c_adapter *adap)
{
	return I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |
	       I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |
	       I2C_FUNC_SMBUS_BLOCK_DATA | I2C_FUNC_SMBUS_PROC_CALL |
	       I2C_FUNC_I2C;
}
static int __init i2c_bfin_twi_init(void)
{
	return platform_driver_register(&i2c_bfin_twi_driver);
}
static void __exit i2c_bfin_twi_exit(void)
{
	platform_driver_unregister(&i2c_bfin_twi_driver);
}
static u32 cpm_i2c_func(struct i2c_adapter *adap)
{
	return I2C_FUNC_I2C | (I2C_FUNC_SMBUS_EMUL & ~I2C_FUNC_SMBUS_QUICK);
}
static int __init cpm_i2c_init(void)
{
	return of_register_platform_driver(&cpm_i2c_driver);
}
static void __exit cpm_i2c_exit(void)
{
	of_unregister_platform_driver(&cpm_i2c_driver);
}
static inline void davinci_i2c_write_reg(struct davinci_i2c_dev *i2c_dev,
					 int reg, u16 val)
{
	__raw_writew(val, i2c_dev->base + reg);
}
static inline u16 davinci_i2c_read_reg(struct davinci_i2c_dev *i2c_dev, int reg)
{
	return __raw_readw(i2c_dev->base + reg);
}
static u32 i2c_davinci_func(struct i2c_adapter *adap)
{
	return I2C_FUNC_I2C | (I2C_FUNC_SMBUS_EMUL & ~I2C_FUNC_SMBUS_QUICK);
}
static int __init davinci_i2c_init_driver(void)
{
	return platform_driver_register(&davinci_i2c_driver);
}
static void __exit davinci_i2c_exit_driver(void)
{
	platform_driver_unregister(&davinci_i2c_driver);
}
static int pcf_isa_getown(void *data)
{
	return (own);
}
static int pcf_isa_getclock(void *data)
{
	return (clock);
}
static int __init i2c_pcfisa_init(void)
{
	return isa_register_driver(&i2c_elektor_driver, 1);
}
static void __exit i2c_pcfisa_exit(void)
{
	isa_unregister_driver(&i2c_elektor_driver);
}
static void __exit i2c_gpio_exit(void)
{
	platform_driver_unregister(&i2c_gpio_driver);
}
static inline void highlander_i2c_irq_enable(struct highlander_i2c_dev *dev)
{
	iowrite16(ioread16(dev->base + SMCR) | SMCR_IEIC, dev->base + SMCR);
}
static inline void highlander_i2c_irq_disable(struct highlander_i2c_dev *dev)
{
	iowrite16(ioread16(dev->base + SMCR) & ~SMCR_IEIC, dev->base + SMCR);
}
static inline void highlander_i2c_start(struct highlander_i2c_dev *dev)
{
	iowrite16(ioread16(dev->base + SMCR) | SMCR_START, dev->base + SMCR);
}
static inline void highlander_i2c_done(struct highlander_i2c_dev *dev)
{
	iowrite16(ioread16(dev->base + SMCR) | SMCR_IRIC, dev->base + SMCR);
}
static u32 highlander_i2c_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_I2C_BLOCK;
}
static int __init highlander_i2c_init(void)
{
	return platform_driver_register(&highlander_i2c_driver);
}
static void __exit highlander_i2c_exit(void)
{
	platform_driver_unregister(&highlander_i2c_driver);
}
static int hydra_bit_getscl(void *data)
{
	return (pdregr(data) & HYDRA_SCLK) != 0;
}
static int hydra_bit_getsda(void *data)
{
	return (pdregr(data) & HYDRA_SDAT) != 0;
}
static int __init i2c_hydra_init(void)
{
	return pci_register_driver(&hydra_driver);
}
static void __exit i2c_hydra_exit(void)
{
	pci_unregister_driver(&hydra_driver);
}
static u32 i801_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |
	       I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |
	       I2C_FUNC_SMBUS_BLOCK_DATA | I2C_FUNC_SMBUS_WRITE_I2C_BLOCK |
	       ((i801_features & FEATURE_SMBUS_PEC) ? I2C_FUNC_SMBUS_PEC : 0) |
	       ((i801_features & FEATURE_I2C_BLOCK_READ) ?
		I2C_FUNC_SMBUS_READ_I2C_BLOCK : 0);
}
static void __exit i2c_i801_exit(void)
{
	pci_unregister_driver(&i801_driver);
}
static inline void iic_interrupt_mode(struct ibm_iic_private* dev, int enable)
{
	out_8(&dev->vaddr->intmsk, enable ? INTRMSK_EIMTC : 0);
}
static inline int iic_invalid_address(const struct i2c_msg* p)
{
	return (p->addr > 0x3ff) || (!(p->flags & I2C_M_TEN) && (p->addr > 0x7f));
}
static inline int iic_address_neq(const struct i2c_msg* p1,
				  const struct i2c_msg* p2)
{
	return (p1->addr != p2->addr)
		|| ((p1->flags & I2C_M_TEN) != (p2->flags & I2C_M_TEN));
}
static u32 iic_func(struct i2c_adapter *adap)
{
	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_10BIT_ADDR;
}
static int __init iic_init(void)
{
	return of_register_platform_driver(&ibm_iic_driver);
}
static void __exit iic_exit(void)
{
	of_unregister_platform_driver(&ibm_iic_driver);
}
static int 
all_bits_clear(unsigned test, unsigned mask)
{
	return (test & mask) == 0;
}
static int 
any_bits_set(unsigned test, unsigned mask)
{
	return (test & mask) != 0;
}
static int 
iop3xx_i2c_wait_tx_done(struct i2c_algo_iop3xx_data *iop3xx_adap, int *status)
{
	return iop3xx_i2c_wait_event( 
		iop3xx_adap, 
	        IOP3XX_ISR_TXEMPTY | IOP3XX_ISR_ALD | IOP3XX_ISR_BERRD,
		status, any_bits_set);
}
static int 
iop3xx_i2c_wait_rx_done(struct i2c_algo_iop3xx_data *iop3xx_adap, int *status)
{
	return iop3xx_i2c_wait_event( 
		iop3xx_adap, 
		IOP3XX_ISR_RXFULL | IOP3XX_ISR_ALD | IOP3XX_ISR_BERRD,
		status,	any_bits_set);
}
static int 
iop3xx_i2c_wait_idle(struct i2c_algo_iop3xx_data *iop3xx_adap, int *status)
{
	return iop3xx_i2c_wait_event( 
		iop3xx_adap, IOP3XX_ISR_UNITBUSY, status, all_bits_clear);
}
static u32 
iop3xx_i2c_func(struct i2c_adapter *adap)
{
	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
}
static int __init 
i2c_iop3xx_init (void)
{
	return platform_driver_register(&iop3xx_i2c_driver);
}
static u32 sch_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |
	    I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |
	    I2C_FUNC_SMBUS_BLOCK_DATA;
}
static int __init i2c_sch_init(void)
{
	return pci_register_driver(&sch_driver);
}
static void __exit i2c_sch_exit(void)
{
	pci_unregister_driver(&sch_driver);
}
static inline int ixp2000_scl_pin(void *data)
{
	return ((struct ixp2000_i2c_pins*)data)->scl_pin;
}
static inline int ixp2000_sda_pin(void *data)
{
	return ((struct ixp2000_i2c_pins*)data)->sda_pin;
}
static int ixp2000_bit_getscl(void *data)
{
	return gpio_line_get(ixp2000_scl_pin(data));
}
static int ixp2000_bit_getsda(void *data)
{
	return gpio_line_get(ixp2000_sda_pin(data));
}
static int __init ixp2000_i2c_init(void)
{
	return platform_driver_register(&ixp2000_i2c_driver);
}
static void __exit ixp2000_i2c_exit(void)
{
	platform_driver_unregister(&ixp2000_i2c_driver);
}
static __inline__ void writeccr(struct mpc_i2c *i2c, u32 x)
{
	writeb(x, i2c->base + MPC_I2C_CR);
}
static void mpc_i2c_stop(struct mpc_i2c *i2c)
{
	writeccr(i2c, CCR_MEN);
}
static u32 mpc_functionality(struct i2c_adapter *adap)
{
	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
}
static void __exit fsl_i2c_exit(void)
{
	of_unregister_platform_driver(&mpc_i2c_driver);
}
static u32
mv64xxx_i2c_functionality(struct i2c_adapter *adap)
{
	return I2C_FUNC_I2C | I2C_FUNC_10BIT_ADDR | I2C_FUNC_SMBUS_EMUL;
}
static int __init
mv64xxx_i2c_init(void)
{
	return platform_driver_register(&mv64xxx_i2c_driver);
}
static void __exit
mv64xxx_i2c_exit(void)
{
	platform_driver_unregister(&mv64xxx_i2c_driver);
}
static s32 nforce2_access_virt1(struct i2c_adapter *adap, u16 addr,
				unsigned short flags, char read_write,
				u8 command, int size,
				union i2c_smbus_data *data)
{
	return nforce2_access_channel(adap, addr, flags, read_write, command,
				      size, data, 0x02);
}
static s32 nforce2_access_virt2(struct i2c_adapter *adap, u16 addr,
				unsigned short flags, char read_write,
				u8 command, int size,
				union i2c_smbus_data *data)
{
	return nforce2_access_channel(adap, addr, flags, read_write, command,
				      size, data, 0x04);
}
static s32 nforce2_access_virt3(struct i2c_adapter *adap, u16 addr,
				unsigned short flags, char read_write,
				u8 command, int size,
				union i2c_smbus_data *data)
{
	return nforce2_access_channel(adap, addr, flags, read_write, command,
				      size, data, 0x08);
}
static s32 nforce2_access_virt4(struct i2c_adapter *adap, u16 addr,
				unsigned short flags, char read_write,
				u8 command, int size,
				union i2c_smbus_data *data)
{
	return nforce2_access_channel(adap, addr, flags, read_write, command,
				      size, data, 0x10);
}
static void nforce2_set_reference(struct i2c_adapter *adap)
{
	nforce2_smbus = adap;
}
static u32 nforce2_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |
	       I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |
	       I2C_FUNC_SMBUS_PEC |
	       (((struct nforce2_smbus*)adapter->algo_data)->blockops ?
		I2C_FUNC_SMBUS_BLOCK_DATA : 0);
}
static int __init nforce2_init(void)
{
	return pci_register_driver(&nforce2_driver);
}
static void __exit nforce2_exit(void)
{
	pci_unregister_driver(&nforce2_driver);
}
static inline void oc_setreg(struct ocores_i2c *i2c, int reg, u8 value)
{
	iowrite8(value, i2c->base + reg * i2c->regstep);
}
static inline u8 oc_getreg(struct ocores_i2c *i2c, int reg)
{
	return ioread8(i2c->base + reg * i2c->regstep);
}
static u32 ocores_func(struct i2c_adapter *adap)
{
	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
}
static int __init ocores_i2c_init(void)
{
	return platform_driver_register(&ocores_i2c_driver);
}
static void __exit ocores_i2c_exit(void)
{
	platform_driver_unregister(&ocores_i2c_driver);
}
static inline void omap_i2c_write_reg(struct omap_i2c_dev *i2c_dev,
				      int reg, u16 val)
{
	__raw_writew(val, i2c_dev->base + reg);
}
static inline u16 omap_i2c_read_reg(struct omap_i2c_dev *i2c_dev, int reg)
{
	return __raw_readw(i2c_dev->base + reg);
}
static u32
omap_i2c_func(struct i2c_adapter *adap)
{
	return I2C_FUNC_I2C | (I2C_FUNC_SMBUS_EMUL & ~I2C_FUNC_SMBUS_QUICK);
}
static inline void
omap_i2c_ack_stat(struct omap_i2c_dev *dev, u16 stat)
{
	omap_i2c_write_reg(dev, OMAP_I2C_STAT_REG, stat);
}
static int __init
omap_i2c_init_driver(void)
{
	return platform_driver_register(&omap_i2c_driver);
}
static void __exit omap_i2c_exit_driver(void)
{
	platform_driver_unregister(&omap_i2c_driver);
}
static inline void port_write(unsigned char p, unsigned char d)
{
	outb(d, base+p);
}
static inline unsigned char port_read(unsigned char p)
{
	return inb(base+p);
}
static void parport_setscl(void *data, int state)
{
	line_set(state, &adapter_parm[type].setscl);
}
static void parport_setsda(void *data, int state)
{
	line_set(state, &adapter_parm[type].setsda);
}
static int parport_getscl(void *data)
{
	return line_get(&adapter_parm[type].getscl);
}
static int parport_getsda(void *data)
{
	return line_get(&adapter_parm[type].getsda);
}
static void port_write_data(struct parport *p, unsigned char d)
{
	parport_write_data(p, d);
}
static void port_write_control(struct parport *p, unsigned char d)
{
	parport_write_control(p, d);
}
static unsigned char port_read_data(struct parport *p)
{
	return parport_read_data(p);
}
static unsigned char port_read_status(struct parport *p)
{
	return parport_read_status(p);
}
static unsigned char port_read_control(struct parport *p)
{
	return parport_read_control(p);
}
static void parport_setscl(void *data, int state)
{
	line_set((struct parport *) data, state, &adapter_parm[type].setscl);
}
static void parport_setsda(void *data, int state)
{
	line_set((struct parport *) data, state, &adapter_parm[type].setsda);
}
static int parport_getscl(void *data)
{
	return line_get((struct parport *) data, &adapter_parm[type].getscl);
}
static int parport_getsda(void *data)
{
	return line_get((struct parport *) data, &adapter_parm[type].getsda);
}
static void __exit i2c_parport_exit(void)
{
	parport_unregister_driver(&i2c_parport_driver);
}
static u32 pasemi_smb_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |
	       I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |
	       I2C_FUNC_SMBUS_BLOCK_DATA | I2C_FUNC_SMBUS_PROC_CALL |
	       I2C_FUNC_SMBUS_BLOCK_PROC_CALL | I2C_FUNC_I2C;
}
static int __init pasemi_smb_init(void)
{
	return pci_register_driver(&pasemi_smb_driver);
}
static void __exit pasemi_smb_exit(void)
{
	pci_unregister_driver(&pasemi_smb_driver);
}
static void pca_isa_resetchip(void *pd)
{
	printk(KERN_WARNING DRIVER ": Haven't figured out how to do a reset yet\n");
}
static int __init pca_isa_init(void)
{
	return isa_register_driver(&pca_isa_driver, 1);
}
static void __exit pca_isa_exit(void)
{
	isa_unregister_driver(&pca_isa_driver);
}
static int __init i2c_pca_pf_init(void)
{
	return platform_driver_register(&i2c_pca_pf_driver);
}
static void __exit i2c_pca_pf_exit(void)
{
	platform_driver_unregister(&i2c_pca_pf_driver);
}
static u32 piix4_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |
	    I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |
	    I2C_FUNC_SMBUS_BLOCK_DATA;
}
static int __init i2c_piix4_init(void)
{
	return pci_register_driver(&piix4_driver);
}
static void __exit i2c_piix4_exit(void)
{
	pci_unregister_driver(&piix4_driver);
}
static inline u32 pmcmsptwi_clock_to_reg(
			const struct pmcmsptwi_clock *clock)
{
	return ((clock->filter & 0xf) << 12) | (clock->clock & 0x03ff);
}
static inline u32 pmcmsptwi_cfg_to_reg(const struct pmcmsptwi_cfg *cfg)
{
	return ((cfg->arbf & 0xf) << 12) |
		((cfg->nak & 0xf) << 8) |
		((cfg->add10 & 0x1) << 7) |
		((cfg->mst_code & 0x7) << 4) |
		((cfg->arb & 0x1) << 1) |
		(cfg->highspeed & 0x1);
}
static inline u32 pmcmsptwi_cmd_to_reg(const struct pmcmsptwi_cmd *cmd)
{
	return ((cmd->type & 0x3) << 8) |
		(((cmd->write_len - 1) & 0x7) << 4) |
		((cmd->read_len - 1) & 0x7);
}
static u32 pmcmsptwi_i2c_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_I2C | I2C_FUNC_10BIT_ADDR |
		I2C_FUNC_SMBUS_BYTE | I2C_FUNC_SMBUS_BYTE_DATA |
		I2C_FUNC_SMBUS_WORD_DATA | I2C_FUNC_SMBUS_PROC_CALL;
}
static int __init pmcmsptwi_init(void)
{
	return platform_driver_register(&pmcmsptwi_driver);
}
static void __exit pmcmsptwi_exit(void)
{
	platform_driver_unregister(&pmcmsptwi_driver);
}
static u32 i2c_pnx_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
}
static int __init i2c_adap_pnx_init(void)
{
	return platform_driver_register(&i2c_pnx_driver);
}
static void __exit i2c_adap_pnx_exit(void)
{
	platform_driver_unregister(&i2c_pnx_driver);
}
static u32 i2c_powermac_func(struct i2c_adapter * adapter)
{
	return I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |
		I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |
		I2C_FUNC_SMBUS_BLOCK_DATA | I2C_FUNC_I2C;
}
static void __exit i2c_powermac_cleanup(void)
{
	platform_driver_unregister(&i2c_powermac_driver);
}
static void i2c_pxa_show_state(struct pxa_i2c *i2c, int lno, const char *fname)
{
	dev_dbg(&i2c->adap.dev, "state:%s:%d: ISR=%08x, ICR=%08x, IBMR=%02x\n", fname, lno,
		readl(_ISR(i2c)), readl(_ICR(i2c)), readl(_IBMR(i2c)));
}
static inline int i2c_pxa_is_slavemode(struct pxa_i2c *i2c)
{
	return !(readl(_ICR(i2c)) & ICR_SCLE);
}
static void i2c_pxa_slave_rxfull(struct pxa_i2c *i2c, u32 isr)
{
	writel(readl(_ICR(i2c)) | ICR_TB | ICR_ACKNAK, _ICR(i2c));
}
static u32 i2c_pxa_functionality(struct i2c_adapter *adap)
{
	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
}
static int __init i2c_adap_pxa_init(void)
{
	return platform_driver_register(&i2c_pxa_driver);
}
static void __exit i2c_adap_pxa_exit(void)
{
	platform_driver_unregister(&i2c_pxa_driver);
}
static inline int is_lastmsg(struct s3c24xx_i2c *i2c)
{
	return i2c->msg_idx >= (i2c->msg_num - 1);
}
static inline int is_msglast(struct s3c24xx_i2c *i2c)
{
	return i2c->msg_ptr == i2c->msg->len-1;
}
static inline int is_msgend(struct s3c24xx_i2c *i2c)
{
	return i2c->msg_ptr >= i2c->msg->len;
}
static u32 s3c24xx_i2c_func(struct i2c_adapter *adap)
{
	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_PROTOCOL_MANGLING;
}
static inline void s3c24xx_i2c_deregister_cpufreq(struct s3c24xx_i2c *i2c)
{
	cpufreq_unregister_notifier(&i2c->freq_transition,
				    CPUFREQ_TRANSITION_NOTIFIER);
}
static inline int s3c24xx_i2c_register_cpufreq(struct s3c24xx_i2c *i2c)
{
	return 0;
}
static inline void OUT32(struct cami2c *cam, int reg, unsigned long val)
{
	ctrl_outl(val, (unsigned long)cam->iobase + reg);
}
static inline unsigned long IN32(struct cami2c *cam, int reg)
{
	return ctrl_inl((unsigned long)cam->iobase + reg);
}
static inline int sh7760_i2c_busy_check(struct cami2c *id)
{
	return (IN32(id, I2CMCR) & MCR_FSDA);
}
static u32 sh7760_i2c_func(struct i2c_adapter *adap)
{
	return I2C_FUNC_I2C | (I2C_FUNC_SMBUS_EMUL & ~I2C_FUNC_SMBUS_QUICK);
}
static int __init sh7760_i2c_init(void)
{
	return platform_driver_register(&sh7760_i2c_drv);
}
static void __exit sh7760_i2c_exit(void)
{
	platform_driver_unregister(&sh7760_i2c_drv);
}
static u32 sh_mobile_i2c_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
}
static int __init sh_mobile_i2c_adap_init(void)
{
	return platform_driver_register(&sh_mobile_i2c_driver);
}
static void __exit sh_mobile_i2c_adap_exit(void)
{
	platform_driver_unregister(&sh_mobile_i2c_driver);
}
static u32 bit_func(struct i2c_adapter *adap)
{
	return (I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |
		I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA);
}
static int __init i2c_adap_simtec_init(void)
{
	return platform_driver_register(&simtec_i2c_driver);
}
static void __exit i2c_adap_simtec_exit(void)
{
	platform_driver_unregister(&simtec_i2c_driver);
}
static u32 sis5595_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |
	    I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |
	    I2C_FUNC_SMBUS_PROC_CALL;
}
static int __init i2c_sis5595_init(void)
{
	return pci_register_driver(&sis5595_driver);
}
static inline u8 sis630_read(u8 reg)
{
	return inb(acpi_base + reg);
}
static inline void sis630_write(u8 reg, u8 data)
{
	outb(data, acpi_base + reg);
}
static u32 sis630_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE | I2C_FUNC_SMBUS_BYTE_DATA |
		I2C_FUNC_SMBUS_WORD_DATA | I2C_FUNC_SMBUS_PROC_CALL |
		I2C_FUNC_SMBUS_BLOCK_DATA;
}
static int __init i2c_sis630_init(void)
{
	return pci_register_driver(&sis630_driver);
}
static void __exit i2c_sis630_exit(void)
{
	pci_unregister_driver(&sis630_driver);
}
static inline u8 sis96x_read(u8 reg)
{
	return inb(sis96x_smbus_base + reg) ;
}
static inline void sis96x_write(u8 reg, u8 data)
{
	outb(data, sis96x_smbus_base + reg) ;
}
static u32 sis96x_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |
	    I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |
	    I2C_FUNC_SMBUS_PROC_CALL;
}
static int __init i2c_sis96x_init(void)
{
	return pci_register_driver(&sis96x_driver);
}
static void __exit i2c_sis96x_exit(void)
{
	pci_unregister_driver(&sis96x_driver);
}
static u32 stub_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |
		I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA;
}
static u32 taos_smbus_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_SMBUS_BYTE | I2C_FUNC_SMBUS_BYTE_DATA;
}
static int __init taos_init(void)
{
	return serio_register_driver(&taos_drv);
}
static void __exit taos_exit(void)
{
	serio_unregister_driver(&taos_drv);
}
static int __init usb_i2c_tiny_usb_init(void)
{
	return usb_register(&i2c_tiny_usb_driver);
}
static void __exit usb_i2c_tiny_usb_exit(void)
{
	usb_deregister(&i2c_tiny_usb_driver);
}
static int __init i2c_versatile_init(void)
{
	return platform_driver_register(&i2c_versatile_driver);
}
static void __exit i2c_versatile_exit(void)
{
	platform_driver_unregister(&i2c_versatile_driver);
}
static void bit_via_setscl(void *data, int state)
{
	outb(state ? inb(I2C_DIR) & ~I2C_SCL : inb(I2C_DIR) | I2C_SCL, I2C_DIR);
}
static void bit_via_setsda(void *data, int state)
{
	outb(state ? inb(I2C_DIR) & ~I2C_SDA : inb(I2C_DIR) | I2C_SDA, I2C_DIR);
}
static int bit_via_getscl(void *data)
{
	return (0 != (inb(I2C_IN) & I2C_SCL));
}
static int bit_via_getsda(void *data)
{
	return (0 != (inb(I2C_IN) & I2C_SDA));
}
static int __init i2c_vt586b_init(void)
{
	return pci_register_driver(&vt586b_driver);
}
static void __exit i2c_vt586b_exit(void)
{
	pci_unregister_driver(&vt586b_driver);
}
static int __init i2c_vt596_init(void)
{
	return pci_register_driver(&vt596_driver);
}
static int bit_vooi2c_getscl(void *data)
{
	return (0 != (readl(ioaddr + REG) & I2C_SCL_IN));
}
static int bit_vooi2c_getsda(void *data)
{
	return (0 != (readl(ioaddr + REG) & I2C_SDA_IN));
}
static int bit_vooddc_getscl(void *data)
{
	return (0 != (readl(ioaddr + REG) & DDC_SCL_IN));
}
static int bit_vooddc_getsda(void *data)
{
	return (0 != (readl(ioaddr + REG) & DDC_SDA_IN));
}
static int __init i2c_voodoo3_init(void)
{
	return pci_register_driver(&voodoo3_driver);
}
static void __exit i2c_voodoo3_exit(void)
{
	pci_unregister_driver(&voodoo3_driver);
}
static u32 scx200_acb_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |
	       I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |
	       I2C_FUNC_SMBUS_I2C_BLOCK;
}
static void scx200_i2c_setscl(void *data, int state)
{
	scx200_gpio_set(scl, state);
}
static void scx200_i2c_setsda(void *data, int state)
{
	scx200_gpio_set(sda, state);
} 

static int scx200_i2c_getscl(void *data)
{
	return scx200_gpio_get(scl);
}
static int scx200_i2c_getsda(void *data)
{
	return scx200_gpio_get(sda);
}
static void scx200_i2c_cleanup(void)
{
	i2c_del_adapter(&scx200_i2c_ops);
}
static int __init ds1682_init(void)
{
	return i2c_add_driver(&ds1682_driver);
}
static void __exit ds1682_exit(void)
{
	i2c_del_driver(&ds1682_driver);
}
static int __init max6875_init(void)
{
	return i2c_add_driver(&max6875_driver);
}
static void __exit max6875_exit(void)
{
	i2c_del_driver(&max6875_driver);
}
static int pca9539_probe(struct i2c_client *client,
			 const struct i2c_device_id *id)
{
	return sysfs_create_group(&client->dev.kobj,
				  &pca9539_defattr_group);
}
static int __init pca9539_init(void)
{
	return i2c_add_driver(&pca9539_driver);
}
static void __exit pca9539_exit(void)
{
	i2c_del_driver(&pca9539_driver);
}
static int __init pcf8574_init(void)
{
	return i2c_add_driver(&pcf8574_driver);
}
static void __exit pcf8574_exit(void)
{
	i2c_del_driver(&pcf8574_driver);
}
static int __init pcf8575_init(void)
{
	return i2c_add_driver(&pcf8575_driver);
}
static void __exit pcf8575_exit(void)
{
	i2c_del_driver(&pcf8575_driver);
}
static void __exit pcf8591_exit(void)
{
	i2c_del_driver(&pcf8591_driver);
}
static int tsl2550_suspend(struct i2c_client *client, pm_message_t mesg)
{
	return tsl2550_set_power_state(client, 0);
}

static int tsl2550_resume(struct i2c_client *client)
{
	return tsl2550_set_power_state(client, 1);
}
static int __init tsl2550_init(void)
{
	return i2c_add_driver(&tsl2550_driver);
}

static void __exit tsl2550_exit(void)
{
	i2c_del_driver(&tsl2550_driver);
}
static void i2c_client_dev_release(struct device *dev)
{
	kfree(to_i2c_client(dev));
}
struct i2c_client *i2c_verify_client(struct device *dev)
{
	return (dev->bus == &i2c_bus_type)
			? to_i2c_client(dev)
			: NULL;
}
static int dummy_probe(struct i2c_client *client,
		       const struct i2c_device_id *id)
{
	return 0;
}
static int dummy_remove(struct i2c_client *client)
{
	return 0;
}
static int i2c_check_addr(struct i2c_adapter *adapter, int addr)
{
	return device_for_each_child(&adapter->dev, &addr, __i2c_check_addr);
}
void i2c_put_adapter(struct i2c_adapter *adap)
{
	module_put(adap->owner);
}
s32 i2c_smbus_write_byte(struct i2c_client *client, u8 value)
{
	return i2c_smbus_xfer(client->adapter,client->addr,client->flags,
	                      I2C_SMBUS_WRITE, value, I2C_SMBUS_BYTE, NULL);
}
static int i2cdev_check_addr(struct i2c_adapter *adapter, unsigned int addr)
{
	return device_for_each_child(&adapter->dev, &addr, i2cdev_check);
}
static void aec_set_pio_mode(ide_drive_t *drive, const u8 pio)
{
	drive->hwif->port_ops->set_dma_mode(drive, pio + XFER_PIO_0);
}
static int __init aec62xx_ide_init(void)
{
	return ide_pci_register_driver(&aec62xx_pci_driver);
}
static void __exit aec62xx_ide_exit(void)
{
	pci_unregister_driver(&aec62xx_pci_driver);
}
static int __init ali15x3_ide_init(void)
{
	return ide_pci_register_driver(&alim15x3_pci_driver);
}
static void __exit ali15x3_ide_exit(void)
{
	pci_unregister_driver(&alim15x3_pci_driver);
}
static inline u8 amd_offset(struct pci_dev *dev)
{
	return (dev->vendor == PCI_VENDOR_ID_NVIDIA) ? 0x10 : 0;
}
static void amd_set_pio_mode(ide_drive_t *drive, const u8 pio)
{
	amd_set_drive(drive, XFER_PIO_0 + pio);
}
static void amd7409_cable_detect(struct pci_dev *dev)
{
	amd_80w = 0x03;
}
static u8 amd_cable_detect(ide_hwif_t *hwif)
{
	if ((amd_80w >> hwif->channel) & 1)
		return ATA_CBL_PATA80;
	else
		return ATA_CBL_PATA40;
}
static int __init amd74xx_ide_init(void)
{
	return ide_pci_register_driver(&amd74xx_pci_driver);
}
static void __exit amd74xx_ide_exit(void)
{
	pci_unregister_driver(&amd74xx_pci_driver);
}
static int __devinit atiixp_init_one(struct pci_dev *dev, const struct pci_device_id *id)
{
	return ide_pci_init_one(dev, &atiixp_pci_info[id->driver_data], NULL);
}
static int __init atiixp_ide_init(void)
{
	return ide_pci_register_driver(&atiixp_pci_driver);
}

static void __exit atiixp_ide_exit(void)
{
	pci_unregister_driver(&atiixp_pci_driver);
}
static void au1xxx_input_data(ide_drive_t *drive, struct ide_cmd *cmd,
			      void *buf, unsigned int len)
{
	auide_insw(drive->hwif->io_ports.data_addr, buf, (len + 1) / 2);
}
static void au1xxx_output_data(ide_drive_t *drive, struct ide_cmd *cmd,
			       void *buf, unsigned int len)
{
	auide_outsw(drive->hwif->io_ports.data_addr, buf, (len + 1) / 2);
}
static int __init au_ide_init(void)
{
	return platform_driver_register(&au1200_ide_driver);
}
static void __exit au_ide_exit(void)
{
	platform_driver_unregister(&au1200_ide_driver);
}
static inline u8 pack_nibbles(u8 upper, u8 lower)
{
	return ((upper & 0x0f) << 4) | (lower & 0x0f);
}
static u8 quantize_timing(int timing, int quant)
{
	return (timing + quant - 1) / quant;
}
static int __init cmd64x_ide_init(void)
{
	return ide_pci_register_driver(&cmd64x_pci_driver);
}
static void __exit cmd64x_ide_exit(void)
{
	pci_unregister_driver(&cmd64x_pci_driver);
}
static int __init cs5520_ide_init(void)
{
	return ide_pci_register_driver(&cs5520_pci_driver);
}
static int __devinit cs5530_init_one(struct pci_dev *dev, const struct pci_device_id *id)
{
	return ide_pci_init_one(dev, &cs5530_chipset, NULL);
}
static int __init cs5530_ide_init(void)
{
	return ide_pci_register_driver(&cs5530_pci_driver);
}

static void __exit cs5530_ide_exit(void)
{
	pci_unregister_driver(&cs5530_pci_driver);
}
static void cs5535_set_dma_mode(ide_drive_t *drive, const u8 speed)
{
	cs5535_set_speed(drive, speed);
}
static void cs5535_set_pio_mode(ide_drive_t *drive, const u8 pio)
{
	cs5535_set_speed(drive, XFER_PIO_0 + pio);
}
static int __devinit cs5535_init_one(struct pci_dev *dev,
					const struct pci_device_id *id)
{
	return ide_pci_init_one(dev, &cs5535_chipset, NULL);
}
static int __init cs5535_ide_init(void)
{
	return ide_pci_register_driver(&cs5535_pci_driver);
}
static void __exit cs5535_ide_exit(void)
{
	pci_unregister_driver(&cs5535_pci_driver);
}
static int __init cs5536_init(void)
{
	return pci_register_driver(&cs5536_pci_driver);
}
static void __exit cs5536_exit(void)
{
	pci_unregister_driver(&cs5536_pci_driver);
}
static int __init cy82c693_ide_init(void)
{
	return ide_pci_register_driver(&cy82c693_pci_driver);
}
static void __exit cy82c693_ide_exit(void)
{
	pci_unregister_driver(&cy82c693_pci_driver);
}
static int __init delkin_cb_init(void)
{
	return pci_register_driver(&delkin_cb_pci_driver);
}
static void __exit delkin_cb_exit(void)
{
	pci_unregister_driver(&delkin_cb_pci_driver);
}
static void hpt3xx_set_pio_mode(ide_drive_t *drive, const u8 pio)
{
	hpt3xx_set_mode(drive, XFER_PIO_0 + pio);
}
static void hpt3xxn_rw_disk(ide_drive_t *drive, struct request *rq)
{
	hpt3xxn_set_clock(drive->hwif, rq_data_dir(rq) ? 0x23 : 0x21);
}
static int __init hpt366_ide_init(void)
{
	return ide_pci_register_driver(&hpt366_pci_driver);
}
static void __exit hpt366_ide_exit(void)
{
	pci_unregister_driver(&hpt366_pci_driver);
}
static int icside_dma_off_init(ide_hwif_t *hwif, const struct ide_port_info *d)
{
	return -EOPNOTSUPP;
}
static int __init icside_init(void)
{
	return ecard_register_driver(&icside_driver);
}
static void __exit icside_exit(void)
{
	ecard_remove_driver(&icside_driver);
}
static inline int dev_is_idecd(ide_drive_t *drive)
{
	return drive->media == ide_cdrom || drive->media == ide_optical;
}
int ide_cd_get_xferlen(struct request *rq)
{
	if (blk_fs_request(rq))
		return 32768;
	else if (blk_sense_request(rq) || blk_pc_request(rq) ||
			 rq->cmd_type == REQ_TYPE_ATA_PC)
		return rq->data_len;
	else
		return 0;
}
static int cdrom_newpc_intr_dummy_cb(struct request *rq)
{
	return 1;
}
static ide_proc_entry_t *ide_cd_proc_entries(ide_drive_t *drive)
{
	return idecd_proc;
}
static const struct ide_proc_devset *ide_cd_proc_devsets(ide_drive_t *drive)
{
	return NULL;
}
static void __exit ide_cdrom_exit(void)
{
	driver_unregister(&ide_cdrom_driver.gen_driver);
}
int ide_cdrom_open_real(struct cdrom_device_info *cdi, int purpose)
{
	return 0;
}
static int __init init_ide_cs(void)
{
	return pcmcia_register_driver(&ide_cs_driver);
}
static void __exit exit_ide_cs(void)
{
	pcmcia_unregister_driver(&ide_cs_driver);
}
static int ide_disk_check(ide_drive_t *drive, const char *s)
{
	return 1;
}
static int ide_disk_init_media(ide_drive_t *drive, struct gendisk *disk)
{
	return 0;
}
static int proc_idedisk_read_sv
	(char *page, char **start, off_t off, int count, int *eof, void *data)
{
	return proc_idedisk_read_smart(page, start, off, count, eof, data,
				       ATA_SMART_READ_VALUES);
}
static int proc_idedisk_read_st
	(char *page, char **start, off_t off, int count, int *eof, void *data)
{
	return proc_idedisk_read_smart(page, start, off, count, eof, data,
				       ATA_SMART_READ_THRESHOLDS);
}
int ide_dma_good_drive(ide_drive_t *drive)
{
	return ide_in_drive_list(drive->id, drive_whitelist);
}
void ide_dma_lost_irq(ide_drive_t *drive)
{
	printk(KERN_ERR "%s: DMA interrupt recovery\n", drive->name);
}
ide_startstop_t ide_do_reset(ide_drive_t *drive)
{
	return do_reset1(drive, 0);
}
sector_t ide_gd_capacity(ide_drive_t *drive)
{
	return drive->capacity64;
}
static ide_proc_entry_t *ide_disk_proc_entries(ide_drive_t *drive)
{
	return (drive->media == ide_disk) ? ide_disk_proc : ide_floppy_proc;
}
static const struct ide_proc_devset *ide_disk_proc_devsets(ide_drive_t *drive)
{
	return (drive->media == ide_disk) ? ide_disk_settings
					  : ide_floppy_settings;
}
static ide_startstop_t ide_gd_do_request(ide_drive_t *drive,
					 struct request *rq, sector_t sector)
{
	return drive->disk_ops->do_request(drive, rq, sector);
}
static void __exit ide_gd_exit(void)
{
	driver_unregister(&ide_gd_driver.gen_driver);
}
static void ide_generic_class_release(struct class *cls)
{
	kfree(cls);
}
static void mm_outw(u16 d, unsigned long a)
{
	__asm__("mov.b %w0,r2h\n\t"
		"mov.b %x0,r2l\n\t"
		"mov.w r2,@%1"
		:
		:"r"(d),"r"(a)
		:"er2");
}
static void h8300_input_data(ide_drive_t *drive, struct ide_cmd *cmd,
			     void *buf, unsigned int len)
{
	mm_insw(drive->hwif->io_ports.data_addr, buf, (len + 1) / 2);
}
static void h8300_output_data(ide_drive_t *drive, struct ide_cmd *cmd,
			      void *buf, unsigned int len)
{
	mm_outsw(drive->hwif->io_ports.data_addr, buf, (len + 1) / 2);
}
static u8 ide_inb(unsigned long port)
{
	return (u8) inb(port);
}
static void ide_outb(u8 val, unsigned long port)
{
	outb(val, port);
}
static u8 ide_mm_inb(unsigned long port)
{
	return (u8) readb((void __iomem *) port);
}
static void ide_mm_outb(u8 value, unsigned long port)
{
	writeb(value, (void __iomem *) port);
}
u8 ide_read_status(ide_hwif_t *hwif)
{
	if (hwif->host_flags & IDE_HFLAG_MMIO)
		return readb((void __iomem *)hwif->io_ports.status_addr);
	else
		return inb(hwif->io_ports.status_addr);
}
u8 ide_read_altstatus(ide_hwif_t *hwif)
{
	if (hwif->host_flags & IDE_HFLAG_MMIO)
		return readb((void __iomem *)hwif->io_ports.ctl_addr);
	else
		return inb(hwif->io_ports.ctl_addr);
}
unsigned int ide_rq_bytes(struct request *rq)
{
	if (blk_pc_request(rq))
		return rq->data_len;
	else
		return rq->hard_cur_sectors << 9;
}
static inline void ide_unlock_port(ide_hwif_t *hwif)
{
	hwif->busy = 0;
}
static int ide_get_nice_ioctl(ide_drive_t *drive, unsigned long arg)
{
	return put_user((!!(drive->dev_flags & IDE_DFLAG_DSC_OVERLAP)
			 << IDE_NICE_DSC_OVERLAP) |
			(!!(drive->dev_flags & IDE_DFLAG_NICE1)
			 << IDE_NICE_1), (long __user *)arg);
}
static int __init generic_ide_init(void)
{
	return ide_pci_register_driver(&generic_pci_driver);
}
static void __exit generic_ide_exit(void)
{
	pci_unregister_driver(&generic_pci_driver);
}
static int __init pnpide_init(void)
{
	return pnp_register_driver(&idepnp_driver);
}
static void __exit pnpide_exit(void)
{
	pnp_unregister_driver(&idepnp_driver);
}
static int ata_lock(dev_t dev, void *data)
{
	return 0;
}
void ide_register_region(struct gendisk *disk)
{
	blk_register_region(MKDEV(disk->major, disk->first_minor),
			    disk->minors, NULL, exact_match, exact_lock, disk);
}
void ide_unregister_region(struct gendisk *disk)
{
	blk_unregister_region(MKDEV(disk->major, disk->first_minor),
			      disk->minors);
}
static int ide_drivers_open(struct inode *inode, struct file *file)
{
	return single_open(file, &ide_drivers_show, NULL);
}
static int mulf_tdsc(ide_drive_t *drive)	{ return 1000; }
static int divf_tdsc(ide_drive_t *drive)	{ return   HZ; }
static int divf_buffer(ide_drive_t *drive)	{ return    2; }
static int divf_buffer_size(ide_drive_t *drive)	{ return 1024; }
static ide_proc_entry_t *ide_tape_proc_entries(ide_drive_t *drive)
{
	return idetape_proc;
}
static const struct ide_proc_devset *ide_tape_proc_devsets(ide_drive_t *drive)
{
	return idetape_settings;
}
static int ide_bus_match(struct device *dev, struct device_driver *drv)
{
	return 1;
}
static int __init platform_ide_init(void)
{
	return platform_driver_register(&platform_ide_driver);
}
static void __exit platform_ide_exit(void)
{
	platform_driver_unregister(&platform_ide_driver);
}
static int __init it8172_ide_init(void)
{
	return ide_pci_register_driver(&it8172_pci_driver);
}
static void __exit it8172_ide_exit(void)
{
	pci_unregister_driver(&it8172_pci_driver);
}
static int __devinit it8213_init_one(struct pci_dev *dev, const struct pci_device_id *id)
{
	return ide_pci_init_one(dev, &it8213_chipset, NULL);
}
static int __init it8213_ide_init(void)
{
	return ide_pci_register_driver(&it8213_pci_driver);
}

static void __exit it8213_ide_exit(void)
{
	pci_unregister_driver(&it8213_pci_driver);
}
static u8 it821x_cable_detect(ide_hwif_t *hwif)
{
	return ATA_CBL_PATA80;
}
static int __init it821x_ide_init(void)
{
	return ide_pci_register_driver(&it821x_pci_driver);
}
static void __exit it821x_ide_exit(void)
{
	pci_unregister_driver(&it821x_pci_driver);
}
static int __devinit jmicron_init_one(struct pci_dev *dev, const struct pci_device_id *id)
{
	return ide_pci_init_one(dev, &jmicron_chipset, NULL);
}
static int __init jmicron_ide_init(void)
{
	return ide_pci_register_driver(&jmicron_pci_driver);
}

static void __exit jmicron_ide_exit(void)
{
	pci_unregister_driver(&jmicron_pci_driver);
}
static u8 superio_read_status(ide_hwif_t *hwif)
{
	return superio_ide_inb(hwif->io_ports.status_addr);
}
static u8 superio_dma_sff_read_status(ide_hwif_t *hwif)
{
	return superio_ide_inb(hwif->dma_base + ATA_DMA_STATUS);
}
static void ns87415_selectproc (ide_drive_t *drive)
{
	ns87415_prepare_drive(drive,
			      !!(drive->dev_flags & IDE_DFLAG_USING_DMA));
}
static int __init ns87415_ide_init(void)
{
	return ide_pci_register_driver(&ns87415_pci_driver);
}
static void __exit ns87415_ide_exit(void)
{
	pci_unregister_driver(&ns87415_pci_driver);
}
static int __devinit opti621_init_one(struct pci_dev *dev, const struct pci_device_id *id)
{
	return ide_pci_init_one(dev, &opti621_chipset, NULL);
}
static int __init opti621_ide_init(void)
{
	return ide_pci_register_driver(&opti621_pci_driver);
}

static void __exit opti621_ide_exit(void)
{
	pci_unregister_driver(&opti621_pci_driver);
}
static u8 palm_bk3710_cable_detect(ide_hwif_t *hwif)
{
	return ATA_CBL_PATA80;
}
static int __init palm_bk3710_init(void)
{
	return platform_driver_probe(&platform_bk_driver, palm_bk3710_probe);
}
static u8 pdcnew_cable_detect(ide_hwif_t *hwif)
{
	if (get_indexed_reg(hwif, 0x0b) & 0x04)
		return ATA_CBL_PATA40;
	else
		return ATA_CBL_PATA80;
}
static void pdcnew_reset(ide_drive_t *drive)
{
	printk(KERN_WARNING "pdc202xx_new: %s channel reset.\n",
		drive->hwif->channel ? "Secondary" : "Primary");
}
static int __init pdc202new_ide_init(void)
{
	return ide_pci_register_driver(&pdc202new_pci_driver);
}
static void __exit pdc202new_ide_exit(void)
{
	pci_unregister_driver(&pdc202new_pci_driver);
}
static void pdc202xx_set_pio_mode(ide_drive_t *drive, const u8 pio)
{
	pdc202xx_set_mode(drive, XFER_PIO_0 + pio);
}
static int __init pdc202xx_ide_init(void)
{
	return ide_pci_register_driver(&pdc202xx_pci_driver);
}
static void __exit pdc202xx_ide_exit(void)
{
	pci_unregister_driver(&pdc202xx_pci_driver);
}
static int __devinit piix_init_one(struct pci_dev *dev, const struct pci_device_id *id)
{
	return ide_pci_init_one(dev, &piix_pci_info[id->driver_data], NULL);
}
static void __exit piix_ide_exit(void)
{
	pci_unregister_driver(&piix_pci_driver);
}
static int __init rapide_init(void)
{
	return ecard_register_driver(&rapide_driver);
}
static void __exit rapide_exit(void)
{
	ecard_remove_driver(&rapide_driver);
}
static int __init rz1000_ide_init(void)
{
	return ide_pci_register_driver(&rz1000_pci_driver);
}
static void __exit rz1000_ide_exit(void)
{
	pci_unregister_driver(&rz1000_pci_driver);
}
static int __init sc1200_ide_init(void)
{
	return ide_pci_register_driver(&sc1200_pci_driver);
}
static void __exit sc1200_ide_exit(void)
{
	pci_unregister_driver(&sc1200_pci_driver);
}
static u8 scc_read_status(ide_hwif_t *hwif)
{
	return (u8)in_be32((void *)hwif->io_ports.status_addr);
}
static u8 scc_read_altstatus(ide_hwif_t *hwif)
{
	return (u8)in_be32((void *)hwif->io_ports.ctl_addr);
}
static u8 scc_dma_sff_read_status(ide_hwif_t *hwif)
{
	return (u8)in_be32((void *)(hwif->dma_base + 4));
}
static void scc_ide_outb(u8 addr, unsigned long port)
{
	out_be32((void*)port, addr);
}
static int __devinit scc_init_dma(ide_hwif_t *hwif,
				  const struct ide_port_info *d)
{
	return ide_allocate_dma_engine(hwif);
}
static u8 scc_cable_detect(ide_hwif_t *hwif)
{
	return ATA_CBL_PATA80;
}
static int __devinit scc_init_one(struct pci_dev *dev, const struct pci_device_id *id)
{
	return init_setup_scc(dev, &scc_chipset);
}
static int scc_ide_init(void)
{
	return ide_pci_register_driver(&scc_pci_driver);
}
static u8 ata66_svwks_svwks(ide_hwif_t *hwif)
{
	return ATA_CBL_PATA80;
}
static int __init svwks_ide_init(void)
{
	return ide_pci_register_driver(&svwks_pci_driver);
}
static void __exit svwks_ide_exit(void)
{
	pci_unregister_driver(&svwks_pci_driver);
}
void ide_setup_pci_noise(struct pci_dev *dev, const struct ide_port_info *d)
{
	printk(KERN_INFO "%s %s: IDE controller (0x%04x:0x%04x rev 0x%02x)\n",
		d->name, pci_name(dev),
		dev->vendor, dev->device, dev->revision);
}
static int sgiioc4_dma_test_irq(ide_drive_t *drive)
{
	return sgiioc4_checkirq(drive->hwif);
}
static int __init ioc4_ide_init(void)
{
	return ioc4_register_submodule(&ioc4_ide_submodule);
}
static inline int is_sata(ide_hwif_t *hwif)
{
	return pdev_is_sata(to_pci_dev(hwif->dev));
}
static int siimage_dma_test_irq(ide_drive_t *drive)
{
	if (drive->hwif->host_flags & IDE_HFLAG_MMIO)
		return siimage_mmio_dma_test_irq(drive);
	else
		return siimage_io_dma_test_irq(drive);
}
static int __init siimage_ide_init(void)
{
	return ide_pci_register_driver(&siimage_pci_driver);
}
static void __exit siimage_ide_exit(void)
{
	pci_unregister_driver(&siimage_pci_driver);
}
static int __init sis5513_ide_init(void)
{
	return ide_pci_register_driver(&sis5513_pci_driver);
}
static void __exit sis5513_ide_exit(void)
{
	pci_unregister_driver(&sis5513_pci_driver);
}
static int __init sl82c105_ide_init(void)
{
	return ide_pci_register_driver(&sl82c105_pci_driver);
}
static void __exit sl82c105_ide_exit(void)
{
	pci_unregister_driver(&sl82c105_pci_driver);
}
static int __devinit slc90e66_init_one(struct pci_dev *dev, const struct pci_device_id *id)
{
	return ide_pci_init_one(dev, &slc90e66_chipset, NULL);
}
static int __init slc90e66_ide_init(void)
{
	return ide_pci_register_driver(&slc90e66_pci_driver);
}

static void __exit slc90e66_ide_exit(void)
{
	pci_unregister_driver(&slc90e66_pci_driver);
}
static void tc86c001_set_pio_mode(ide_drive_t *drive, const u8 pio)
{
	tc86c001_set_mode(drive, XFER_PIO_0 + pio);
}
static int __init tc86c001_ide_init(void)
{
	return ide_pci_register_driver(&tc86c001_pci_driver);
}
static void __exit tc86c001_ide_exit(void)
{
	pci_unregister_driver(&tc86c001_pci_driver);
}
static void triflex_set_pio_mode(ide_drive_t *drive, const u8 pio)
{
	triflex_set_mode(drive, XFER_PIO_0 + pio);
}
static int __devinit triflex_init_one(struct pci_dev *dev, 
		const struct pci_device_id *id)
{
	return ide_pci_init_one(dev, &triflex_device, NULL);
}
static int __init triflex_ide_init(void)
{
	return ide_pci_register_driver(&triflex_pci_driver);
}
static void __exit triflex_ide_exit(void)
{
	pci_unregister_driver(&triflex_pci_driver);
}
static void trm290_selectproc (ide_drive_t *drive)
{
	trm290_prepare_drive(drive, !!(drive->dev_flags & IDE_DFLAG_USING_DMA));
}
static int __devinit trm290_init_one(struct pci_dev *dev, const struct pci_device_id *id)
{
	return ide_pci_init_one(dev, &trm290_chipset, NULL);
}
static int __init trm290_ide_init(void)
{
	return ide_pci_register_driver(&trm290_pci_driver);
}
static void __exit trm290_ide_exit(void)
{
	pci_unregister_driver(&trm290_pci_driver);
}
static u8 tx4938ide_inb(unsigned long port)
{
	return __raw_readb((void __iomem *)port);
}
static void tx4938ide_outb(u8 value, unsigned long port)
{
	__raw_writeb(value, (void __iomem *)port);
}
static int __init tx4938ide_init(void)
{
	return platform_driver_probe(&tx4938ide_driver, tx4938ide_probe);
}
static void __exit tx4938ide_exit(void)
{
	platform_driver_unregister(&tx4938ide_driver);
}
static u16 tx4939ide_readw(void __iomem *base, u32 reg)
{
	return __raw_readw(base + tx4939ide_swizzlew(reg));
}
static u8 tx4939ide_readb(void __iomem *base, u32 reg)
{
	return __raw_readb(base + tx4939ide_swizzleb(reg));
}
static void tx4939ide_writel(u32 val, void __iomem *base, u32 reg)
{
	__raw_writel(val, base + tx4939ide_swizzlel(reg));
}
static void tx4939ide_writew(u16 val, void __iomem *base, u32 reg)
{
	__raw_writew(val, base + tx4939ide_swizzlew(reg));
}
static void tx4939ide_writeb(u8 val, void __iomem *base, u32 reg)
{
	__raw_writeb(val, base + tx4939ide_swizzleb(reg));
}
static u8 tx4939ide_inb(unsigned long port)
{
	return __raw_readb((void __iomem *)port);
}
static void tx4939ide_outb(u8 value, unsigned long port)
{
	__raw_writeb(value, (void __iomem *)port);
}
static int __init tx4939ide_init(void)
{
	return platform_driver_probe(&tx4939ide_driver, tx4939ide_probe);
}
static void __exit tx4939ide_exit(void)
{
	platform_driver_unregister(&tx4939ide_driver);
}
static void via_set_pio_mode(ide_drive_t *drive, const u8 pio)
{
	via_set_drive(drive, XFER_PIO_0 + pio);
}
static int __init via_ide_init(void)
{
	return ide_pci_register_driver(&via_pci_driver);
}
static void __exit via_ide_exit(void)
{
	pci_unregister_driver(&via_pci_driver);
}
int csr1212_attach_keyval_to_directory(struct csr1212_keyval *dir,
				       struct csr1212_keyval *kv)
{
	return __csr1212_attach_keyval_to_directory(dir, kv, true);
}
int dma_region_mmap(struct dma_region *dma, struct file *file,
		    struct vm_area_struct *vma)
{
	return -EINVAL;
}
static inline struct video_card* file_to_video_card(struct file *file)
{
	return (struct video_card*) file->private_data;
}
static inline int ether1394_max_mtu(struct hpsb_host* host)
{
	return (1 << (host->csr.max_rec + 1))
			- sizeof(union eth1394_hdr) - ETHER1394_GASP_OVERHEAD;
}
static void ether1394_header_cache_update(struct hh_cache *hh,
					  const struct net_device *dev,
					  const unsigned char * haddr)
{
	memcpy((u8 *)hh->hh_data + 16 - ETH1394_HLEN, haddr, dev->addr_len);
}
static int dummy_transmit_packet(struct hpsb_host *h, struct hpsb_packet *p)
{
	return 0;
}
static int dummy_devctl(struct hpsb_host *h, enum devctl_cmd c, int arg)
{
	return -1;
}
static int dummy_isoctl(struct hpsb_iso *iso, enum isoctl_cmd command,
			unsigned long arg)
{
	return -1;
}
static void complete_packet(void *data)
{
	complete((struct completion *) data);
}
static void host_cls_release(struct device *dev)
{
	put_device(&container_of((dev), struct hpsb_host, host_dev)->device);
}
static void ne_cls_release(struct device *dev)
{
	put_device(&container_of((dev), struct node_entry, node_dev)->device);
}
static void ud_cls_release(struct device *dev)
{
	put_device(&container_of((dev), struct unit_directory, unit_dev)->device);
}
static ssize_t fw_get_rescan(struct bus_type *bus, char *buf)
{
	return sprintf(buf, "You can force a rescan of the bus for "
			"drivers by writing a 1 to this file\n");
}
static ssize_t fw_get_ignore_drivers(struct bus_type *bus, char *buf)
{
	return sprintf(buf, "%d\n", ignore_drivers);
}
static int nodemgr_uevent(struct device *dev, struct kobj_uevent_env *env)
{
	return -ENODEV;
}
static void nodemgr_update_pdrv(struct node_entry *ne)
{
	class_for_each_device(&nodemgr_ud_class, NULL, ne, update_pdrv);
}
static void nodemgr_remove_nodes_in_limbo(struct hpsb_host *host)
{
	device_for_each_child(&host->device, NULL, remove_nodes_in_limbo);
}
static void __exit ohci1394_cleanup (void)
{
	pci_unregister_driver(&ohci1394_pci_driver);
}
static int __init ohci1394_init(void)
{
	return pci_register_driver(&ohci1394_pci_driver);
}
static int bit_getscl(void *data)
{
	return reg_read((struct ti_lynx *) data, SERIAL_EEPROM_CONTROL) & 0x00000040;
}
static int bit_getsda(void *data)
{
	return reg_read((struct ti_lynx *) data, SERIAL_EEPROM_CONTROL) & 0x00000010;
}
static void __exit pcilynx_cleanup(void)
{
        pci_unregister_driver(&lynx_pci_driver);
}
static inline struct pending_request *alloc_pending_request(void)
{
	return __alloc_pending_request(GFP_KERNEL);
}
static inline int sbp2util_node_is_available(struct sbp2_lu *lu)
{
	return lu && lu->ne && !lu->ne->in_limbo;
}

static int video1394_queue_buf32(struct file *file, unsigned int cmd, unsigned long arg)
{
        return -EFAULT;   /* ??? was there before. */
}
static int addr6_resolve_remote(struct sockaddr_in6 *src_in,
			       struct sockaddr_in6 *dst_in,
			       struct rdma_dev_addr *addr)
{
	return -EADDRNOTAVAIL;
}
static int addr_resolve_remote(struct sockaddr *src_in,
				struct sockaddr *dst_in,
				struct rdma_dev_addr *addr)
{
	if (src_in->sa_family == AF_INET) {
	} else
		return addr6_resolve_remote((struct sockaddr_in6 *) src_in,
			(struct sockaddr_in6 *) dst_in, addr);
}
static inline int start_port(struct ib_device *device)
{
	return (device->node_type == RDMA_NODE_IB_SWITCH) ? 0 : 1;
}
static inline int end_port(struct ib_device *device)
{
	return (device->node_type == RDMA_NODE_IB_SWITCH) ?
		0 : device->phys_port_cnt;
}
int __init ib_cache_setup(void)
{
	return ib_register_client(&cache_client);
}
void __exit ib_cache_cleanup(void)
{
	ib_unregister_client(&cache_client);
}
static int be32_lt(__be32 a, __be32 b)
{
	return (__force u32) a < (__force u32) b;
}
static int be32_gt(__be32 a, __be32 b)
{
	return (__force u32) a > (__force u32) b;
}
static int be64_lt(__be64 a, __be64 b)
{
	return (__force u64) a < (__force u64) b;
}
static int be64_gt(__be64 a, __be64 b)
{
	return (__force u64) a > (__force u64) b;
}
static inline int cm_convert_to_ms(int iba_time)
{
	return 1 << max(iba_time - 8, 0);
}
void ib_destroy_cm_id(struct ib_cm_id *cm_id)
{
	cm_destroy_id(cm_id, 0);
}
static inline int cm_is_active_peer(__be64 local_ca_guid, __be64 remote_ca_guid,
				    __be32 local_qpn, __be32 remote_qpn)
{
	return (be64_to_cpu(local_ca_guid) > be64_to_cpu(remote_ca_guid) ||
		((local_ca_guid == remote_ca_guid) &&
		 (be32_to_cpu(local_qpn) > be32_to_cpu(remote_qpn))));
}
static inline u8 cma_get_ip_ver(struct cma_hdr *hdr)
{
	return hdr->ip_version >> 4;
}
static inline void cma_set_ip_ver(struct cma_hdr *hdr, u8 ip_ver)
{
	hdr->ip_version = (ip_ver << 4) | (hdr->ip_version & 0xF);
}
static inline u8 sdp_get_majv(u8 sdp_version)
{
	return sdp_version >> 4;
}
static inline u8 sdp_get_ip_ver(struct sdp_hh *hh)
{
	return hh->ip_version >> 4;
}
static inline void sdp_set_ip_ver(struct sdp_hh *hh, u8 ip_ver)
{
	hh->ip_version = (ip_ver << 4) | (hh->ip_version & 0xF);
}
static inline int cma_is_ud_ps(enum rdma_port_space ps)
{
	return (ps == RDMA_PS_UDP || ps == RDMA_PS_IPOIB);
}
static int cma_has_cm_dev(struct rdma_id_private *id_priv)
{
	return (id_priv->id.device && id_priv->cm_id.ib);
}
static inline int cma_loopback_addr(struct sockaddr *addr)
{
	if (addr->sa_family == AF_INET)
		return ipv4_is_loopback(
			((struct sockaddr_in *) addr)->sin_addr.s_addr);
	else
		return ipv6_addr_loopback(
			&((struct sockaddr_in6 *) addr)->sin6_addr);
}
static inline int cma_any_addr(struct sockaddr *addr)
{
	return cma_zero_addr(addr) || cma_loopback_addr(addr);
}
static inline __be16 cma_port(struct sockaddr *addr)
{
	if (addr->sa_family == AF_INET)
		return ((struct sockaddr_in *) addr)->sin_port;
	else
		return ((struct sockaddr_in6 *) addr)->sin6_port;
}
static inline int cma_any_port(struct sockaddr *addr)
{
	return !cma_port(addr);
}
static __be64 cma_get_service_id(enum rdma_port_space ps, struct sockaddr *addr)
{
	return cpu_to_be64(((u64)ps << 16) + be16_to_cpu(cma_port(addr)));
}
static int cma_bind_addr(struct rdma_cm_id *id, struct sockaddr *src_addr,
			 struct sockaddr *dst_addr)
{
	if (src_addr && src_addr->sa_family)
		return rdma_bind_addr(id, src_addr);
	else
		return cma_bind_any(id, dst_addr->sa_family);
}
static int start_port(struct ib_device *device)
{
	return (device->node_type == RDMA_NODE_IB_SWITCH) ? 0 : 1;
}
static int end_port(struct ib_device *device)
{
	return (device->node_type == RDMA_NODE_IB_SWITCH) ?
		0 : device->phys_port_cnt;
}
int ib_query_device(struct ib_device *device,
		    struct ib_device_attr *device_attr)
{
	return device->query_device(device, device_attr);
}
int ib_query_gid(struct ib_device *device,
		 u8 port_num, int index, union ib_gid *gid)
{
	return device->query_gid(device, port_num, index, gid);
}
int ib_query_pkey(struct ib_device *device,
		  u8 port_num, u16 index, u16 *pkey)
{
	return device->query_pkey(device, port_num, index, pkey);
}
int ib_modify_device(struct ib_device *device,
		     int device_modify_mask,
		     struct ib_device_modify *device_modify)
{
	return device->modify_device(device, device_modify_mask,
				     device_modify);
}
static inline u32 ib_fmr_hash(u64 first_page)
{
	return jhash_2words((u32) first_page, (u32) (first_page >> 32), 0) &
		(IB_FMR_HASH_SIZE - 1);
}
static void put_work(struct iwcm_work *work)
{
	list_add(&work->free_list, &work->cm_id->work_free_list);
}
static void __exit iw_cm_cleanup(void)
{
	destroy_workqueue(iwcm_wq);
}
static inline u8 convert_mgmt_class(u8 mgmt_class)
{
	return mgmt_class == IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE ?
		0 : mgmt_class;
}
static int vendor_class_index(u8 mgmt_class)
{
	return mgmt_class - IB_MGMT_CLASS_VENDOR_RANGE2_START;
}
int ib_response_mad(struct ib_mad *mad)
{
	return ((mad->mad_hdr.method & IB_MGMT_METHOD_RESP) ||
		(mad->mad_hdr.method == IB_MGMT_METHOD_TRAP_REPRESS) ||
		((mad->mad_hdr.mgmt_class == IB_MGMT_CLASS_BM) &&
		 (mad->mad_hdr.attr_mod & IB_BM_ATTR_MOD_RESP)));
}
static inline int is_snooping_sends(int mad_snoop_flags)
{
	return (mad_snoop_flags &
		(/*IB_MAD_SNOOP_POSTED_SENDS |
		 IB_MAD_SNOOP_RMPP_SENDS |*/
		 IB_MAD_SNOOP_SEND_COMPLETIONS /*|
		 IB_MAD_SNOOP_RMPP_SEND_COMPLETIONS*/));
}
static inline int is_snooping_recvs(int mad_snoop_flags)
{
	return (mad_snoop_flags &
		(IB_MAD_SNOOP_RECVS /*|
		 IB_MAD_SNOOP_RMPP_RECVS*/));
}
int ib_get_mad_data_offset(u8 mgmt_class)
{
	if (mgmt_class == IB_MGMT_CLASS_SUBN_ADM)
		return IB_MGMT_SA_HDR;
	else if ((mgmt_class == IB_MGMT_CLASS_DEVICE_MGMT) ||
		 (mgmt_class == IB_MGMT_CLASS_DEVICE_ADM) ||
		 (mgmt_class == IB_MGMT_CLASS_BIS))
		return IB_MGMT_DEVICE_HDR;
	else if ((mgmt_class >= IB_MGMT_CLASS_VENDOR_RANGE2_START) &&
		 (mgmt_class <= IB_MGMT_CLASS_VENDOR_RANGE2_END))
		return IB_MGMT_VENDOR_HDR;
	else
		return IB_MGMT_MAD_HDR;
}
static inline void *ib_get_payload(struct ib_mad_send_wr_private *mad_send_wr)
{
	if (mad_send_wr->send_buf.seg_count)
		return ib_get_rmpp_segment(&mad_send_wr->send_buf,
					   mad_send_wr->seg_num);
	else
		return mad_send_wr->send_buf.mad +
		       mad_send_wr->send_buf.hdr_len;
}
struct ib_mad_agent *ib_redirect_mad_qp(struct ib_qp *qp,
					u8 rmpp_version,
					ib_mad_send_handler send_handler,
					ib_mad_recv_handler recv_handler,
					void *context)
{
	return ERR_PTR(-EINVAL);	/* XXX: for now */
}
static inline int rcv_has_same_class(struct ib_mad_send_wr_private *wr,
				     struct ib_mad_recv_wc *rwc)
{
	return ((struct ib_mad *)(wr->send_buf.mad))->mad_hdr.mgmt_class ==
		rwc->recv_buf.mad->mad_hdr.mgmt_class;
}
static inline int is_direct(u8 class)
{
	return (class == IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE);
}
void ib_cancel_mad(struct ib_mad_agent *mad_agent,
		   struct ib_mad_send_buf *send_buf)
{
	ib_modify_mad(mad_agent, send_buf, 0);
}
static inline int window_size(struct ib_mad_agent_private *agent)
{
	return max(agent->qp_info->recv_queue.max_active >> 3, 1);
}
static void ib_sa_path_rec_release(struct ib_sa_query *sa_query)
{
	kfree(container_of(sa_query, struct ib_sa_path_query, sa_query));
}
static void ib_sa_service_rec_release(struct ib_sa_query *sa_query)
{
	kfree(container_of(sa_query, struct ib_sa_service_query, sa_query));
}
static void ib_sa_mcmember_rec_release(struct ib_sa_query *sa_query)
{
	kfree(container_of(sa_query, struct ib_sa_mcmember_query, sa_query));
}
int smi_get_fwd_port(struct ib_smp *smp)
{
	return (!ib_get_smp_direction(smp) ? smp->initial_path[smp->hop_ptr+1] :
		smp->return_path[smp->hop_ptr-1]);
}
static inline int ibdev_is_alive(const struct ib_device *dev)
{
	return dev->reg_state == IB_DEV_REGISTERED;
}
int ib_sysfs_setup(void)
{
	return class_register(&ib_class);
}
void ib_sysfs_cleanup(void)
{
	class_unregister(&ib_class);
}
static inline int ib_ucm_new_cm_id(int event)
{
	return event == IB_CM_REQ_RECEIVED || event == IB_CM_SIDR_REQ_RECEIVED;
}
static ssize_t ib_ucm_send_rtu(struct ib_ucm_file *file,
			       const char __user *inbuf,
			       int in_len, int out_len)
{
	return ib_ucm_send_private_data(file, inbuf, in_len, ib_send_cm_rtu);
}
static ssize_t ib_ucm_send_dreq(struct ib_ucm_file *file,
				const char __user *inbuf,
				int in_len, int out_len)
{
	return ib_ucm_send_private_data(file, inbuf, in_len, ib_send_cm_dreq);
}
static ssize_t ib_ucm_send_drep(struct ib_ucm_file *file,
				const char __user *inbuf,
				int in_len, int out_len)
{
	return ib_ucm_send_private_data(file, inbuf, in_len, ib_send_cm_drep);
}
static ssize_t ib_ucm_send_rej(struct ib_ucm_file *file,
			       const char __user *inbuf,
			       int in_len, int out_len)
{
	return ib_ucm_send_info(file, inbuf, in_len, (void *)ib_send_cm_rej);
}
static ssize_t ib_ucm_send_apr(struct ib_ucm_file *file,
			       const char __user *inbuf,
			       int in_len, int out_len)
{
	return ib_ucm_send_info(file, inbuf, in_len, (void *)ib_send_cm_apr);
}
static ssize_t show_abi_version(struct class *class, char *buf)
{
	return sprintf(buf, "%d\n", IB_USER_CM_ABI_VERSION);
}
static ssize_t show_abi_version(struct device *dev,
				struct device_attribute *attr,
				char *buf)
{
	return sprintf(buf, "%d\n", RDMA_USER_CM_ABI_VERSION);
}
static int hdr_size(struct ib_umad_file *file)
{
	return file->use_pkey_index ? sizeof (struct ib_user_mad_hdr) :
		sizeof (struct ib_user_mad_hdr_old);
}
static struct ib_mad_agent *__get_agent(struct ib_umad_file *file, int id)
{
	return file->agents_dead ? NULL : file->agent[id];
}
static ssize_t show_abi_version(struct class *class, char *buf)
{
	return sprintf(buf, "%d\n", IB_USER_MAD_ABI_VERSION);
}
static void release_uobj(struct kref *kref)
{
	kfree(container_of(kref, struct ib_uobject, ref));
}
static void put_uobj(struct ib_uobject *uobj)
{
	kref_put(&uobj->ref, release_uobj);
}
static struct ib_pd *idr_read_pd(int pd_handle, struct ib_ucontext *context)
{
	return idr_read_obj(&ib_uverbs_pd_idr, pd_handle, context, 0);
}
static void put_pd_read(struct ib_pd *pd)
{
	put_uobj_read(pd->uobject);
}
static struct ib_cq *idr_read_cq(int cq_handle, struct ib_ucontext *context, int nested)
{
	return idr_read_obj(&ib_uverbs_cq_idr, cq_handle, context, nested);
}
static void put_cq_read(struct ib_cq *cq)
{
	put_uobj_read(cq->uobject);
}
static struct ib_ah *idr_read_ah(int ah_handle, struct ib_ucontext *context)
{
	return idr_read_obj(&ib_uverbs_ah_idr, ah_handle, context, 0);
}
static void put_ah_read(struct ib_ah *ah)
{
	put_uobj_read(ah->uobject);
}
static struct ib_qp *idr_read_qp(int qp_handle, struct ib_ucontext *context)
{
	return idr_read_obj(&ib_uverbs_qp_idr, qp_handle, context, 0);
}
static void put_qp_read(struct ib_qp *qp)
{
	put_uobj_read(qp->uobject);
}
static struct ib_srq *idr_read_srq(int srq_handle, struct ib_ucontext *context)
{
	return idr_read_obj(&ib_uverbs_srq_idr, srq_handle, context, 0);
}
static void put_srq_read(struct ib_srq *srq)
{
	put_uobj_read(srq->uobject);
}
static ssize_t show_abi_version(struct class *class, char *buf)
{
	return sprintf(buf, "%d\n", IB_USER_VERBS_ABI_VERSION);
}
static int uverbs_event_get_sb(struct file_system_type *fs_type, int flags,
			       const char *dev_name, void *data,
			       struct vfsmount *mnt)
{
	return get_sb_pseudo(fs_type, "infinibandevent:", NULL,
			     INFINIBANDEVENTFS_MAGIC, mnt);
}
int ib_modify_ah(struct ib_ah *ah, struct ib_ah_attr *ah_attr)
{
	return ah->device->modify_ah ?
		ah->device->modify_ah(ah, ah_attr) :
		-ENOSYS;
}
int ib_query_ah(struct ib_ah *ah, struct ib_ah_attr *ah_attr)
{
	return ah->device->query_ah ?
		ah->device->query_ah(ah, ah_attr) :
		-ENOSYS;
}
int ib_modify_srq(struct ib_srq *srq,
		  struct ib_srq_attr *srq_attr,
		  enum ib_srq_attr_mask srq_attr_mask)
{
	return srq->device->modify_srq ?
		srq->device->modify_srq(srq, srq_attr, srq_attr_mask, NULL) :
		-ENOSYS;
}
int ib_query_srq(struct ib_srq *srq,
		 struct ib_srq_attr *srq_attr)
{
	return srq->device->query_srq ?
		srq->device->query_srq(srq, srq_attr) : -ENOSYS;
}
int ib_modify_qp(struct ib_qp *qp,
		 struct ib_qp_attr *qp_attr,
		 int qp_attr_mask)
{
	return qp->device->modify_qp(qp, qp_attr, qp_attr_mask, NULL);
}
int ib_query_qp(struct ib_qp *qp,
		struct ib_qp_attr *qp_attr,
		int qp_attr_mask,
		struct ib_qp_init_attr *qp_init_attr)
{
	return qp->device->query_qp ?
		qp->device->query_qp(qp, qp_attr, qp_attr_mask, qp_init_attr) :
		-ENOSYS;
}
int ib_modify_cq(struct ib_cq *cq, u16 cq_count, u16 cq_period)
{
	return cq->device->modify_cq ?
		cq->device->modify_cq(cq, cq_count, cq_period) : -ENOSYS;
}
int ib_resize_cq(struct ib_cq *cq, int cqe)
{
	return cq->device->resize_cq ?
		cq->device->resize_cq(cq, cqe, NULL) : -ENOSYS;
}
int ib_query_mr(struct ib_mr *mr, struct ib_mr_attr *mr_attr)
{
	return mr->device->query_mr ?
		mr->device->query_mr(mr, mr_attr) : -ENOSYS;
}
void ib_free_fast_reg_page_list(struct ib_fast_reg_page_list *page_list)
{
	page_list->device->free_fast_reg_page_list(page_list);
}
static void c2_print_macaddr(struct net_device *netdev)
{
	pr_debug("%s: MAC %02X:%02X:%02X:%02X:%02X:%02X, "
		"IRQ %u\n", netdev->name,
		netdev->dev_addr[0], netdev->dev_addr[1], netdev->dev_addr[2],
		netdev->dev_addr[3], netdev->dev_addr[4], netdev->dev_addr[5],
		netdev->irq);
}
static int __init c2_init_module(void)
{
	return pci_register_driver(&c2_pci_driver);
}
static void __exit c2_exit_module(void)
{
	pci_unregister_driver(&c2_pci_driver);
}
int c2_init_mqsp_pool(struct c2_dev *c2dev, gfp_t gfp_mask,
		      struct sp_chunk **root)
{
	return c2_alloc_mqsp_chunk(c2dev, gfp_mask, root);
}
static void c2_free_cq_buf(struct c2_dev *c2dev, struct c2_mq *mq)
{
	dma_free_coherent(&c2dev->pcidev->dev, mq->q_size * mq->msg_size,
			  mq->msg_pool.host, pci_unmap_addr(mq, mapping));
}
void __devexit c2_cleanup_pd_table(struct c2_dev *c2dev)
{
	kfree(c2dev->pd_table.table);
}
static inline u32 c2_convert_access(int acc)
{
	return (acc & IB_ACCESS_REMOTE_WRITE ? C2_ACF_REMOTE_WRITE : 0) |
	    (acc & IB_ACCESS_REMOTE_READ ? C2_ACF_REMOTE_READ : 0) |
	    (acc & IB_ACCESS_LOCAL_WRITE ? C2_ACF_LOCAL_WRITE : 0) |
	    C2_ACF_LOCAL_READ | C2_ACF_WINDOW_BIND;
}
void __devexit c2_cleanup_qp_table(struct c2_dev *c2dev)
{
	idr_destroy(&c2dev->qp_table.idr);
}
void vq_term(struct c2_dev *c2dev)
{
	kmem_cache_destroy(c2dev->host_msg_cache);
}
void vq_req_get(struct c2_dev *c2dev, struct c2_vq_req *r)
{
	atomic_inc(&r->refcnt);
}
void *vq_repbuf_alloc(struct c2_dev *c2dev)
{
	return kmem_cache_alloc(c2dev->host_msg_cache, GFP_ATOMIC);
}
void vq_repbuf_free(struct c2_dev *c2dev, void *reply)
{
	kmem_cache_free(c2dev->host_msg_cache, reply);
}
int cxio_reregister_phys_mem(struct cxio_rdev *rdev_p, u32 *stag, u32 pdid,
			   enum tpt_mem_perm perm, u32 zbva, u64 to, u32 len,
			   u8 page_size, u32 pbl_size, u32 pbl_addr)
{
	return __cxio_tpt_op(rdev_p, 0, stag, 1, pdid, TPT_NON_SHARED_MR, perm,
			     zbva, to, len, page_size, pbl_size, pbl_addr);
}
int cxio_dereg_mem(struct cxio_rdev *rdev_p, u32 stag, u32 pbl_size,
		   u32 pbl_addr)
{
	return __cxio_tpt_op(rdev_p, 1, &stag, 0, 0, 0, 0, 0, 0ULL, 0, 0,
			     pbl_size, pbl_addr);
}
int cxio_deallocate_window(struct cxio_rdev *rdev_p, u32 stag)
{
	return __cxio_tpt_op(rdev_p, 1, &stag, 0, 0, 0, 0, 0, 0ULL, 0, 0,
			     0, 0);
}
void cxio_register_ev_cb(cxio_hal_ev_callback_func_t ev_cb)
{
	cxio_ev_cb = ev_cb;
}
void cxio_unregister_ev_cb(cxio_hal_ev_callback_func_t ev_cb)
{
	cxio_ev_cb = NULL;
}
static int cxio_init_resource_fifo(struct kfifo **fifo, spinlock_t * fifo_lock,
				   u32 nr, u32 skip_low, u32 skip_high)
{
	return (__cxio_init_resource_fifo(fifo, fifo_lock, nr, skip_low,
					  skip_high, 0));
}
static int cxio_init_resource_fifo_random(struct kfifo **fifo,
				   spinlock_t * fifo_lock,
				   u32 nr, u32 skip_low, u32 skip_high)
{
	return (__cxio_init_resource_fifo(fifo, fifo_lock, nr, skip_low,
					  skip_high, 1));
}
int cxio_hal_init_rhdl_resource(u32 nr_rhdl)
{
	return cxio_init_resource_fifo(&rhdl_fifo, &rhdl_fifo_lock, nr_rhdl, 1,
				       0);
}
void cxio_hal_destroy_rhdl_resource(void)
{
	kfifo_free(rhdl_fifo);
}
static void cxio_hal_put_resource(struct kfifo *fifo, u32 entry)
{
	BUG_ON(kfifo_put(fifo, (unsigned char *) &entry, sizeof(u32)) == 0);
}
u32 cxio_hal_get_stag(struct cxio_hal_resource *rscp)
{
	return cxio_hal_get_resource(rscp->tpt_fifo);
}
void cxio_hal_put_stag(struct cxio_hal_resource *rscp, u32 stag)
{
	cxio_hal_put_resource(rscp->tpt_fifo, stag);
}
u32 cxio_hal_get_cqid(struct cxio_hal_resource *rscp)
{
	return cxio_hal_get_resource(rscp->cqid_fifo);
}
void cxio_hal_put_cqid(struct cxio_hal_resource *rscp, u32 cqid)
{
	cxio_hal_put_resource(rscp->cqid_fifo, cqid);
}
u32 cxio_hal_get_pdid(struct cxio_hal_resource *rscp)
{
	return cxio_hal_get_resource(rscp->pdid_fifo);
}
void cxio_hal_put_pdid(struct cxio_hal_resource *rscp, u32 pdid)
{
	cxio_hal_put_resource(rscp->pdid_fifo, pdid);
}
void cxio_hal_pblpool_destroy(struct cxio_rdev *rdev_p)
{
	gen_pool_destroy(rdev_p->pbl_pool);
}
void cxio_hal_rqtpool_destroy(struct cxio_rdev *rdev_p)
{
	gen_pool_destroy(rdev_p->rqt_pool);
}
static void __state_set(struct iwch_ep_common *epc, enum iwch_ep_state new)
{
	epc->state = new;
}
static inline int act_open_has_tid(int status)
{
	return status != CPL_ERR_TCAM_FULL && status != CPL_ERR_CONN_EXIST &&
	       status != CPL_ERR_ARP_MISS;
}
static int is_neg_adv_abort(unsigned int status)
{
	return status == CPL_ERR_RTX_NEG_ADVICE ||
	       status == CPL_ERR_PERSIST_NEG_ADVICE;
}
void iwch_free_pbl(struct iwch_mr *mhp)
{
	cxio_hal_pblpool_free(&mhp->rhp->rdev, mhp->attr.pbl_addr,
			      mhp->attr.pbl_size << 3);
}
int iwch_write_pbl(struct iwch_mr *mhp, __be64 *pages, int npages, int offset)
{
	return cxio_write_pbl(&mhp->rhp->rdev, pages,
			      mhp->attr.pbl_addr + (offset << 3), npages);
}
static int iwch_modify_port(struct ib_device *ibdev,
			    u8 port, int port_modify_mask,
			    struct ib_port_modify *props)
{
	return -ENOSYS;
}
static struct ib_ah *iwch_ah_create(struct ib_pd *pd,
				    struct ib_ah_attr *ah_attr)
{
	return ERR_PTR(-ENOSYS);
}
static int iwch_ah_destroy(struct ib_ah *ah)
{
	return -ENOSYS;
}
static int iwch_multicast_attach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)
{
	return -ENOSYS;
}
static int iwch_multicast_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)
{
	return -ENOSYS;
}
static int iwch_process_mad(struct ib_device *ibdev,
			    int mad_flags,
			    u8 port_num,
			    struct ib_wc *in_wc,
			    struct ib_grh *in_grh,
			    struct ib_mad *in_mad, struct ib_mad *out_mad)
{
	return -ENOSYS;
}
static void iwch_free_fastreg_pbl(struct ib_fast_reg_page_list *page_list)
{
	kfree(page_list);
}
static unsigned int limit_uint(unsigned int value)
{
	return min_t(unsigned int, value, INT_MAX);
}
void ehca_tasklet_eq(unsigned long data)
{
	ehca_process_eq((struct ehca_shca*)data, 1);
}
static ssize_t ehca_show_debug_level(struct device_driver *ddp, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%d\n", ehca_debug_level);
}
static u64 ehca_get_max_hwpage_size(struct ehca_shca *shca)
{
	return 1UL << ilog2(shca->hca_cap_mr_pgsize);
}
static void ehca_mr_delete(struct ehca_mr *me)
{
	kmem_cache_free(mr_cache, me);
}
static void ehca_mw_delete(struct ehca_mw *me)
{
	kmem_cache_free(mw_cache, me);
}
/* sets page size in hipz access control for MR/MW. */
void ehca_mrmw_set_pgsize_hipz_acl(u32 pgsize, u32 *hipz_acl) /*INOUT*/
{
	*hipz_acl |= (ehca_encode_hwpage_size(pgsize) << 24);
} /* end ehca_mrmw_set_pgsize_hipz_acl() */
static inline int ehca_calc_wqe_size(int act_nr_sge, int is_llqp)
{
	if (is_llqp)
		return 128 << act_nr_sge;
	else
		return offsetof(struct ehca_wqe,
				u.nud.sg_list[act_nr_sge]);
}
int ehca_destroy_qp(struct ib_qp *qp)
{
	return internal_destroy_qp(qp->device,
				   container_of(qp, struct ehca_qp, ib_qp),
				   qp->uobject);
}
int ehca_destroy_srq(struct ib_srq *srq)
{
	return internal_destroy_qp(srq->device,
				   container_of(srq, struct ehca_qp, ib_srq),
				   srq->uobject);
}
static u16 get_app_wr_id(u64 wr_id)
{
	return wr_id & QMAP_IDX_MASK;
}
int ehca_post_srq_recv(struct ib_srq *srq,
		       struct ib_recv_wr *recv_wr,
		       struct ib_recv_wr **bad_recv_wr)
{
	return internal_post_recv(container_of(srq, struct ehca_qp, ib_srq),
				  srq->device, recv_wr, bad_recv_wr);
}
u64 hipz_h_reset_event(const struct ipz_adapter_handle adapter_handle,
		       struct ipz_eq_handle eq_handle,
		       const u64 event_mask)
{
	return ehca_plpar_hcall_norets(H_RESET_EVENTS,
				       adapter_handle.handle, /* r4 */
				       eq_handle.handle,      /* r5 */
				       event_mask,	      /* r6 */
				       0, 0, 0, 0);
}
u64 hipz_h_register_rpage(const struct ipz_adapter_handle adapter_handle,
			  const u8 pagesize,
			  const u8 queue_type,
			  const u64 resource_handle,
			  const u64 logical_address_of_page,
			  u64 count)
{
	return ehca_plpar_hcall_norets(H_REGISTER_RPAGES,
				       adapter_handle.handle,      /* r4  */
				       (u64)queue_type | ((u64)pagesize) << 8,
				       resource_handle,	           /* r6  */
				       logical_address_of_page,    /* r7  */
				       count,	                   /* r8  */
				       0, 0);
}
u64 hipz_h_query_qp(const struct ipz_adapter_handle adapter_handle,
		    const struct ipz_qp_handle qp_handle,
		    struct ehca_pfqp *pfqp,
		    struct hcp_modify_qp_control_block *qqpcb,
		    struct h_galpa gal)
{
	return ehca_plpar_hcall_norets(H_QUERY_QP,
				       adapter_handle.handle, /* r4 */
				       qp_handle.handle,      /* r5 */
				       virt_to_abs(qqpcb),    /* r6 */
				       0, 0, 0, 0);
}
u64 hipz_h_define_aqp0(const struct ipz_adapter_handle adapter_handle,
		       const struct ipz_qp_handle qp_handle,
		       struct h_galpa gal,
		       u32 port)
{
	return ehca_plpar_hcall_norets(H_DEFINE_AQP0,
				       adapter_handle.handle, /* r4 */
				       qp_handle.handle,      /* r5 */
				       port,                  /* r6 */
				       0, 0, 0, 0);
}
u64 hipz_h_detach_mcqp(const struct ipz_adapter_handle adapter_handle,
		       const struct ipz_qp_handle qp_handle,
		       struct h_galpa gal,
		       u16 mcg_dlid,
		       u64 subnet_prefix, u64 interface_id)
{
	return ehca_plpar_hcall_norets(H_DETACH_MCQP,
				       adapter_handle.handle, /* r4 */
				       qp_handle.handle,      /* r5 */
				       mcg_dlid,              /* r6 */
				       interface_id,          /* r7 */
				       subnet_prefix,         /* r8 */
				       0, 0);
}
u64 hipz_h_free_resource_mr(const struct ipz_adapter_handle adapter_handle,
			    const struct ehca_mr *mr)
{
	return ehca_plpar_hcall_norets(H_FREE_RESOURCE,
				       adapter_handle.handle,    /* r4 */
				       mr->ipz_mr_handle.handle, /* r5 */
				       0, 0, 0, 0, 0);
}
u64 hipz_h_free_resource_mw(const struct ipz_adapter_handle adapter_handle,
			    const struct ehca_mw *mw)
{
	return ehca_plpar_hcall_norets(H_FREE_RESOURCE,
				       adapter_handle.handle,    /* r4 */
				       mw->ipz_mw_handle.handle, /* r5 */
				       0, 0, 0, 0, 0);
}
void ehca_cleanup_small_qp_cache(void)
{
	kmem_cache_destroy(small_qp_cache);
}
static int ipath_mapping_error(struct ib_device *dev, u64 dma_addr)
{
	return dma_addr == BAD_DMA_ADDRESS;
}
static void ipath_dma_unmap_single(struct ib_device *dev,
				   u64 addr, size_t size,
				   enum dma_data_direction direction)
{
	BUG_ON(!valid_dma_direction(direction));
}
static void ipath_dma_unmap_page(struct ib_device *dev,
				 u64 addr, size_t size,
				 enum dma_data_direction direction)
{
	BUG_ON(!valid_dma_direction(direction));
}
static void ipath_unmap_sg(struct ib_device *dev,
			   struct scatterlist *sg, int nents,
			   enum dma_data_direction direction)
{
	BUG_ON(!valid_dma_direction(direction));
}
static unsigned int ipath_sg_dma_len(struct ib_device *dev,
				     struct scatterlist *sg)
{
	return sg->length;
}
static void ipath_dma_free_coherent(struct ib_device *dev, size_t size,
				    void *cpu_addr, u64 dma_handle)
{
	free_pages((unsigned long) cpu_addr, get_order(size));
}
static inline struct ipath_devdata *__ipath_lookup(int unit)
{
	return idr_find(&unit_table, unit);
}
int __attribute__((weak)) ipath_enable_wc(struct ipath_devdata *dd)
{
	return -EOPNOTSUPP;
}
static inline void *ipath_get_egrbuf(struct ipath_devdata *dd, u32 bufnum)
{
	return dd->ipath_port0_skbinfo ?
		(void *) dd->ipath_port0_skbinfo[bufnum].skb->data : NULL;
}
static int ipath_supports_subports(int user_swmajor, int user_swminor)
{
	return (user_swmajor > 1) || (user_swminor >= 3);
}
static inline int usable(struct ipath_devdata *dd)
{
	return dd &&
		(dd->ipath_flags & IPATH_PRESENT) &&
		dd->ipath_kregbase &&
		dd->ipath_lid &&
		!(dd->ipath_flags & (IPATH_LINKDOWN | IPATH_DISABLED
				     | IPATH_LINKUNK));
}
int ipath_cdev_init(int minor, char *name, const struct file_operations *fops,
		    struct cdev **cdevp, struct device **devp)
{
	return init_cdev(minor, name, fops, cdevp, devp);
}
void ipath_cdev_cleanup(struct cdev **cdevp,
			struct device **devp)
{
	cleanup_cdev(cdevp, devp);
}
static ssize_t atomic_stats_read(struct file *file, char __user *buf,
				 size_t count, loff_t *ppos)
{
	return simple_read_from_buffer(buf, count, ppos, &ipath_stats,
				       sizeof ipath_stats);
}
int __init ipath_init_ipathfs(void)
{
	return register_filesystem(&ipathfs_fs_type);
}
void __exit ipath_exit_ipathfs(void)
{
	unregister_filesystem(&ipathfs_fs_type);
}
static struct ipath_message_header *
ipath_ht_get_msgheader(struct ipath_devdata *dd, __le32 *rhf_addr)
{
	return (struct ipath_message_header *)
		&rhf_addr[sizeof(u64) / sizeof(u32)];
}
static int ipath_ht_nointr_fallback(struct ipath_devdata *dd)
{
	return 0;
}
int __attribute__((weak)) ipath_unordered_wc(void)
{
	return 0;
}
static struct ipath_message_header *
ipath_pe_get_msgheader(struct ipath_devdata *dd, __le32 *rhf_addr)
{
	return (struct ipath_message_header *)
		&rhf_addr[sizeof(u64) / sizeof(u32)];
}
static int ipath_pe_nointr_fallback(struct ipath_devdata *dd)
{
	return 0;
}
static inline u32 port_egrtid_idx(struct ipath_devdata *dd, unsigned port)
{
	 return port ? dd->ipath_p0_rcvegrcnt +
		 (port-1) * dd->ipath_rcvegrcnt : 0;
}
static void ipath_setup_7220_cleanup(struct ipath_devdata *dd)
{
	ipath_7220_nomsi(dd);
}
static void set_link_width_enabled(struct ipath_devdata *dd, u32 w)
{
	(void) dd->ipath_f_set_ib_cfg(dd, IPATH_IB_CFG_LWID_ENB, w);
}
static void set_link_speed_enabled(struct ipath_devdata *dd, u32 s)
{
	(void) dd->ipath_f_set_ib_cfg(dd, IPATH_IB_CFG_SPD_ENB, s);
}
static int get_overrunthreshold(struct ipath_devdata *dd)
{
	return (dd->ipath_ibcctrl >>
		INFINIPATH_IBCC_OVERRUNTHRESHOLD_SHIFT) &
		INFINIPATH_IBCC_OVERRUNTHRESHOLD_MASK;
}
static int get_phyerrthreshold(struct ipath_devdata *dd)
{
	return (dd->ipath_ibcctrl >>
		INFINIPATH_IBCC_PHYERRTHRESHOLD_SHIFT) &
		INFINIPATH_IBCC_PHYERRTHRESHOLD_MASK;
}
static int get_linkdowndefaultstate(struct ipath_devdata *dd)
{
	return !!(dd->ipath_ibcctrl & INFINIPATH_IBCC_LINKDOWNDEFAULTSTATE);
}
static int recv_subn_set_guidinfo(struct ib_smp *smp,
				  struct ib_device *ibdev)
{
	return recv_subn_get_guidinfo(smp, ibdev);
}
static inline struct ipath_fmr *to_ifmr(struct ib_fmr *ibfmr)
{
	return container_of(ibfmr, struct ipath_fmr, ibfmr);
}
static inline void update_last_psn(struct ipath_qp *qp, u32 psn)
{
	qp->s_last_psn = psn;
}
static int ipath_sd_trimself(struct ipath_devdata *dd, int val)
{
	return ibsd_sto_noisy(dd, CMUCTRL5, val, 0xFF);
}
int ipath_sd7220_ib_load(struct ipath_devdata *dd)
{
	return ipath_sd7220_prog_ld(dd, IB_7220_SERDES, ipath_sd7220_ib_img,
		sizeof(ipath_sd7220_ib_img), 0);
}
int ipath_sd7220_ib_vfy(struct ipath_devdata *dd)
{
	return ipath_sd7220_prog_vfy(dd, IB_7220_SERDES, ipath_sd7220_ib_img,
		sizeof(ipath_sd7220_ib_img), 0);
}
static ssize_t show_version(struct device_driver *dev, char *buf)
{
	return scnprintf(buf, PAGE_SIZE, "%s", ib_ipath_version);
}
static ssize_t show_num_units(struct device_driver *dev, char *buf)
{
	return scnprintf(buf, PAGE_SIZE, "%d\n",
			 ipath_count_units(NULL, NULL, NULL));
}
static void ipath_user_sdma_set_complete_counter(struct ipath_user_sdma_queue *pq,
						 u32 c)
{
	pq->sent_counter = c;
}
static inline __le64 ipath_sdma_make_desc0(struct ipath_devdata *dd,
					   u64 addr, u64 dwlen, u64 dwoffset)
{
	return cpu_to_le64(/* SDmaPhyAddr[31:0] */
			   ((addr & 0xfffffffcULL) << 32) |
			   ((dd->ipath_sdma_generation & 3ULL) << 30) |
			   ((dwlen & 0x7ffULL) << 16) |
			   (dwoffset & 0x7ffULL));
}
static inline __le64 ipath_sdma_make_first_desc0(__le64 descq)
{
	return descq | cpu_to_le64(1ULL << 12);
}
static inline __le64 ipath_sdma_make_last_desc0(__le64 descq)
{
	return descq | cpu_to_le64(1ULL << 11 | 1ULL << 13);
}
static inline __le64 ipath_sdma_make_desc1(u64 addr)
{
	return cpu_to_le64(addr >> 32);
}
u32 ipath_user_sdma_complete_counter(const struct ipath_user_sdma_queue *pq)
{
	return pq->sent_counter;
}
u32 ipath_user_sdma_inflight_counter(struct ipath_user_sdma_queue *pq)
{
	return pq->counter;
}
static inline struct ipath_ucontext *to_iucontext(struct ib_ucontext
						  *ibucontext)
{
	return container_of(ibucontext, struct ipath_ucontext, ibucontext);
}
static inline u32 get_upper_bits(u32 data, u32 shift)
{
	return data >> shift;
}
static inline u32 set_upper_bits(u32 data, u32 shift)
{
	return data << shift;
}
static inline u32 get_upper_bits(u32 data, u32 shift)
{
	return data << shift;
}
static inline u32 set_upper_bits(u32 data, u32 shift)
{
	return data >> shift;
}
static inline unsigned ipath_pkt_delay(u32 plen, u8 snd_mult, u8 rcv_mult)
{
	return (rcv_mult > snd_mult) ?
		(plen * (rcv_mult - snd_mult) + 1) >> 1 : 0;
}
u32 ipath_get_cr_errpkey(struct ipath_devdata *dd)
{
	return ipath_read_creg32(dd, dd->ipath_cregs->cr_errpkey);
}
unsigned ipath_get_npkeys(struct ipath_devdata *dd)
{
	return ARRAY_SIZE(dd->ipath_pd[0]->port_pkeys);
}
int ipath_mcast_tree_empty(void)
{
	return mcast_tree.rb_node == NULL;
}
int ipath_enable_wc(struct ipath_devdata *dd)
{
	return 0;
}
int ipath_unordered_wc(void)
{
	return 1;
}
int ipath_unordered_wc(void)
{
	return boot_cpu_data.x86_vendor != X86_VENDOR_AMD;
}
static void *get_cqe_from_buf(struct mlx4_ib_cq_buf *buf, int n)
{
	return mlx4_buf_offset(&buf->buf, n * sizeof (struct mlx4_cqe));
}
static void *get_cqe(struct mlx4_ib_cq *cq, int n)
{
	return get_cqe_from_buf(&cq->buf, n);
}
static struct mlx4_cqe *next_cqe_sw(struct mlx4_ib_cq *cq)
{
	return get_sw_cqe(cq, cq->mcq.cons_index);
}
static void mlx4_ib_free_cq_buf(struct mlx4_ib_dev *dev, struct mlx4_ib_cq_buf *buf, int cqe)
{
	mlx4_buf_free(dev->dev, (cqe + 1) * sizeof(struct mlx4_cqe), &buf->buf);
}
static int mlx4_ib_ipoib_csum_ok(__be16 status, __be16 checksum)
{
	return ((status & cpu_to_be16(MLX4_CQE_STATUS_IPV4      |
				      MLX4_CQE_STATUS_IPV4F     |
				      MLX4_CQE_STATUS_IPV4OPT   |
				      MLX4_CQE_STATUS_IPV6      |
				      MLX4_CQE_STATUS_IPOK)) ==
		cpu_to_be16(MLX4_CQE_STATUS_IPV4        |
			    MLX4_CQE_STATUS_IPOK))              &&
		(status & cpu_to_be16(MLX4_CQE_STATUS_UDP       |
				      MLX4_CQE_STATUS_TCP))     &&
		checksum == cpu_to_be16(0xffff);
}
static void send_handler(struct ib_mad_agent *agent,
			 struct ib_mad_send_wc *mad_send_wc)
{
	ib_free_send_mad(mad_send_wc->send_buf);
}
static int mlx4_ib_mcg_attach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)
{
	return mlx4_multicast_attach(to_mdev(ibqp->device)->dev,
				     &to_mqp(ibqp)->mqp, gid->raw,
				     !!(to_mqp(ibqp)->flags &
					MLX4_IB_QP_BLOCK_MULTICAST_LOOPBACK));
}
static int mlx4_ib_mcg_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)
{
	return mlx4_multicast_detach(to_mdev(ibqp->device)->dev,
				     &to_mqp(ibqp)->mqp, gid->raw);
}
static int __init mlx4_ib_init(void)
{
	return mlx4_register_interface(&mlx4_ib_interface);
}
static void __exit mlx4_ib_cleanup(void)
{
	mlx4_unregister_interface(&mlx4_ib_interface);
}
static u32 convert_access(int acc)
{
	return (acc & IB_ACCESS_REMOTE_ATOMIC ? MLX4_PERM_ATOMIC       : 0) |
	       (acc & IB_ACCESS_REMOTE_WRITE  ? MLX4_PERM_REMOTE_WRITE : 0) |
	       (acc & IB_ACCESS_REMOTE_READ   ? MLX4_PERM_REMOTE_READ  : 0) |
	       (acc & IB_ACCESS_LOCAL_WRITE   ? MLX4_PERM_LOCAL_WRITE  : 0) |
	       MLX4_PERM_LOCAL_READ;
}
static struct mlx4_ib_sqp *to_msqp(struct mlx4_ib_qp *mqp)
{
	return container_of(mqp, struct mlx4_ib_sqp, qp);
}
static int is_sqp(struct mlx4_ib_dev *dev, struct mlx4_ib_qp *qp)
{
	return qp->mqp.qpn >= dev->dev->caps.sqp_start &&
		qp->mqp.qpn <= dev->dev->caps.sqp_start + 3;
}
static int is_qp0(struct mlx4_ib_dev *dev, struct mlx4_ib_qp *qp)
{
	return qp->mqp.qpn >= dev->dev->caps.sqp_start &&
		qp->mqp.qpn <= dev->dev->caps.sqp_start + 1;
}
static void *get_wqe(struct mlx4_ib_qp *qp, int offset)
{
	return mlx4_buf_offset(&qp->buf, offset);
}
static void *get_recv_wqe(struct mlx4_ib_qp *qp, int n)
{
	return get_wqe(qp, qp->rq.offset + (n << qp->rq.wqe_shift));
}
static void *get_send_wqe(struct mlx4_ib_qp *qp, int n)
{
	return get_wqe(qp, qp->sq.offset + (n << qp->sq.wqe_shift));
}
static void mlx4_set_sched(struct mlx4_qp_path *path, u8 port)
{
	path->sched_queue = (path->sched_queue & 0xbf) | ((port - 1) << 6);
}
static __be32 convert_access(int acc)
{
	return (acc & IB_ACCESS_REMOTE_ATOMIC ? cpu_to_be32(MLX4_WQE_FMR_PERM_ATOMIC)       : 0) |
	       (acc & IB_ACCESS_REMOTE_WRITE  ? cpu_to_be32(MLX4_WQE_FMR_PERM_REMOTE_WRITE) : 0) |
	       (acc & IB_ACCESS_REMOTE_READ   ? cpu_to_be32(MLX4_WQE_FMR_PERM_REMOTE_READ)  : 0) |
	       (acc & IB_ACCESS_LOCAL_WRITE   ? cpu_to_be32(MLX4_WQE_FMR_PERM_LOCAL_WRITE)  : 0) |
		cpu_to_be32(MLX4_WQE_FMR_PERM_LOCAL_READ);
}
static void *get_wqe(struct mlx4_ib_srq *srq, int n)
{
	return mlx4_buf_offset(&srq->buf, n << srq->msrq.wqe_shift);
}
void mthca_alloc_cleanup(struct mthca_alloc *alloc)
{
	kfree(alloc->table);
}
int mthca_ah_grh_present(struct mthca_ah *ah)
{
	return !!(ah->av->g_slid & 0x80);
}
void mthca_catas_cleanup(void)
{
	destroy_workqueue(catas_wq);
}
static inline int go_bit(struct mthca_dev *dev)
{
	return readl(dev->hcr + HCR_STATUS_OFFSET) &
		swab32(1 << HCR_GO_BIT);
}
static int mthca_cmd_box(struct mthca_dev *dev,
			 u64 in_param,
			 u64 out_param,
			 u32 in_modifier,
			 u8 op_modifier,
			 u16 op,
			 unsigned long timeout,
			 u8 *status)
{
	if (dev->cmd.flags & MTHCA_CMD_USE_EVENTS)
		return mthca_cmd_wait(dev, in_param, &out_param, 0,
				      in_modifier, op_modifier, op,
				      timeout, status);
	else
		return mthca_cmd_poll(dev, in_param, &out_param, 0,
				      in_modifier, op_modifier, op,
				      timeout, status);
}
static int mthca_cmd(struct mthca_dev *dev,
		     u64 in_param,
		     u32 in_modifier,
		     u8 op_modifier,
		     u16 op,
		     unsigned long timeout,
		     u8 *status)
{
	return mthca_cmd_box(dev, in_param, 0, in_modifier,
			     op_modifier, op, timeout, status);
}
static int mthca_cmd_imm(struct mthca_dev *dev,
			 u64 in_param,
			 u64 *out_param,
			 u32 in_modifier,
			 u8 op_modifier,
			 u16 op,
			 unsigned long timeout,
			 u8 *status)
{
	if (dev->cmd.flags & MTHCA_CMD_USE_EVENTS)
		return mthca_cmd_wait(dev, in_param, out_param, 1,
				      in_modifier, op_modifier, op,
				      timeout, status);
	else
		return mthca_cmd_poll(dev, in_param, out_param, 1,
				      in_modifier, op_modifier, op,
				      timeout, status);
}
int mthca_SYS_DIS(struct mthca_dev *dev, u8 *status)
{
	return mthca_cmd(dev, 0, 0, 0, CMD_SYS_DIS, HZ, status);
}
int mthca_MAP_FA(struct mthca_dev *dev, struct mthca_icm *icm, u8 *status)
{
	return mthca_map_cmd(dev, CMD_MAP_FA, icm, -1, status);
}
int mthca_UNMAP_FA(struct mthca_dev *dev, u8 *status)
{
	return mthca_cmd(dev, 0, 0, 0, CMD_UNMAP_FA, CMD_TIME_CLASS_B, status);
}
int mthca_RUN_FW(struct mthca_dev *dev, u8 *status)
{
	return mthca_cmd(dev, 0, 0, 0, CMD_RUN_FW, CMD_TIME_CLASS_A, status);
}
int mthca_DISABLE_LAM(struct mthca_dev *dev, u8 *status)
{
	return mthca_cmd(dev, 0, 0, 0, CMD_SYS_DIS, CMD_TIME_CLASS_C, status);
}
int mthca_CLOSE_IB(struct mthca_dev *dev, int port, u8 *status)
{
	return mthca_cmd(dev, 0, port, 0, CMD_CLOSE_IB, HZ, status);
}
int mthca_CLOSE_HCA(struct mthca_dev *dev, int panic, u8 *status)
{
	return mthca_cmd(dev, 0, 0, panic, CMD_CLOSE_HCA, HZ, status);
}
int mthca_MAP_ICM(struct mthca_dev *dev, struct mthca_icm *icm, u64 virt, u8 *status)
{
	return mthca_map_cmd(dev, CMD_MAP_ICM, icm, virt, status);
}
int mthca_MAP_ICM_AUX(struct mthca_dev *dev, struct mthca_icm *icm, u8 *status)
{
	return mthca_map_cmd(dev, CMD_MAP_ICM_AUX, icm, -1, status);
}
int mthca_UNMAP_ICM_AUX(struct mthca_dev *dev, u8 *status)
{
	return mthca_cmd(dev, 0, 0, 0, CMD_UNMAP_ICM_AUX, CMD_TIME_CLASS_B, status);
}
int mthca_SW2HW_MPT(struct mthca_dev *dev, struct mthca_mailbox *mailbox,
		    int mpt_index, u8 *status)
{
	return mthca_cmd(dev, mailbox->dma, mpt_index, 0, CMD_SW2HW_MPT,
			 CMD_TIME_CLASS_B, status);
}
int mthca_HW2SW_MPT(struct mthca_dev *dev, struct mthca_mailbox *mailbox,
		    int mpt_index, u8 *status)
{
	return mthca_cmd_box(dev, 0, mailbox ? mailbox->dma : 0, mpt_index,
			     !mailbox, CMD_HW2SW_MPT,
			     CMD_TIME_CLASS_B, status);
}
int mthca_WRITE_MTT(struct mthca_dev *dev, struct mthca_mailbox *mailbox,
		    int num_mtt, u8 *status)
{
	return mthca_cmd(dev, mailbox->dma, num_mtt, 0, CMD_WRITE_MTT,
			 CMD_TIME_CLASS_B, status);
}
int mthca_SYNC_TPT(struct mthca_dev *dev, u8 *status)
{
	return mthca_cmd(dev, 0, 0, 0, CMD_SYNC_TPT, CMD_TIME_CLASS_B, status);
}
int mthca_SW2HW_EQ(struct mthca_dev *dev, struct mthca_mailbox *mailbox,
		   int eq_num, u8 *status)
{
	return mthca_cmd(dev, mailbox->dma, eq_num, 0, CMD_SW2HW_EQ,
			 CMD_TIME_CLASS_A, status);
}
int mthca_HW2SW_EQ(struct mthca_dev *dev, struct mthca_mailbox *mailbox,
		   int eq_num, u8 *status)
{
	return mthca_cmd_box(dev, 0, mailbox->dma, eq_num, 0,
			     CMD_HW2SW_EQ,
			     CMD_TIME_CLASS_A, status);
}
int mthca_SW2HW_CQ(struct mthca_dev *dev, struct mthca_mailbox *mailbox,
		   int cq_num, u8 *status)
{
	return mthca_cmd(dev, mailbox->dma, cq_num, 0, CMD_SW2HW_CQ,
			CMD_TIME_CLASS_A, status);
}
int mthca_HW2SW_CQ(struct mthca_dev *dev, struct mthca_mailbox *mailbox,
		   int cq_num, u8 *status)
{
	return mthca_cmd_box(dev, 0, mailbox->dma, cq_num, 0,
			     CMD_HW2SW_CQ,
			     CMD_TIME_CLASS_A, status);
}
int mthca_SW2HW_SRQ(struct mthca_dev *dev, struct mthca_mailbox *mailbox,
		    int srq_num, u8 *status)
{
	return mthca_cmd(dev, mailbox->dma, srq_num, 0, CMD_SW2HW_SRQ,
			CMD_TIME_CLASS_A, status);
}
int mthca_HW2SW_SRQ(struct mthca_dev *dev, struct mthca_mailbox *mailbox,
		    int srq_num, u8 *status)
{
	return mthca_cmd_box(dev, 0, mailbox->dma, srq_num, 0,
			     CMD_HW2SW_SRQ,
			     CMD_TIME_CLASS_A, status);
}
int mthca_QUERY_SRQ(struct mthca_dev *dev, u32 num,
		    struct mthca_mailbox *mailbox, u8 *status)
{
	return mthca_cmd_box(dev, 0, mailbox->dma, num, 0,
			     CMD_QUERY_SRQ, CMD_TIME_CLASS_A, status);
}
int mthca_ARM_SRQ(struct mthca_dev *dev, int srq_num, int limit, u8 *status)
{
	return mthca_cmd(dev, limit, srq_num, 0, CMD_ARM_SRQ,
			 CMD_TIME_CLASS_B, status);
}
int mthca_QUERY_QP(struct mthca_dev *dev, u32 num, int is_ee,
		   struct mthca_mailbox *mailbox, u8 *status)
{
	return mthca_cmd_box(dev, 0, mailbox->dma, (!!is_ee << 24) | num, 0,
			     CMD_QUERY_QPEE, CMD_TIME_CLASS_A, status);
}
int mthca_READ_MGM(struct mthca_dev *dev, int index,
		   struct mthca_mailbox *mailbox, u8 *status)
{
	return mthca_cmd_box(dev, 0, mailbox->dma, index, 0,
			     CMD_READ_MGM, CMD_TIME_CLASS_A, status);
}
int mthca_WRITE_MGM(struct mthca_dev *dev, int index,
		    struct mthca_mailbox *mailbox, u8 *status)
{
	return mthca_cmd(dev, mailbox->dma, index, 0, CMD_WRITE_MGM,
			 CMD_TIME_CLASS_A, status);
}
int mthca_NOP(struct mthca_dev *dev, u8 *status)
{
	return mthca_cmd(dev, 0, 0x1f, 0, CMD_NOP, msecs_to_jiffies(100), status);
}
static inline struct mthca_cqe *get_cqe_from_buf(struct mthca_cq_buf *buf,
						 int entry)
{
	if (buf->is_direct)
		return buf->queue.direct.buf + (entry * MTHCA_CQ_ENTRY_SIZE);
	else
		return buf->queue.page_list[entry * MTHCA_CQ_ENTRY_SIZE / PAGE_SIZE].buf
			+ (entry * MTHCA_CQ_ENTRY_SIZE) % PAGE_SIZE;
}
static inline struct mthca_cqe *get_cqe(struct mthca_cq *cq, int entry)
{
	return get_cqe_from_buf(&cq->buf, entry);
}
static inline struct mthca_cqe *cqe_sw(struct mthca_cqe *cqe)
{
	return MTHCA_CQ_ENTRY_OWNER_HW & cqe->owner ? NULL : cqe;
}
static inline struct mthca_cqe *next_cqe_sw(struct mthca_cq *cq)
{
	return cqe_sw(get_cqe(cq, cq->cons_index & cq->ibcq.cqe));
}
static inline void set_cqe_hw(struct mthca_cqe *cqe)
{
	cqe->owner = MTHCA_CQ_ENTRY_OWNER_HW;
}
static inline int is_recv_cqe(struct mthca_cqe *cqe)
{
	if ((cqe->opcode & MTHCA_ERROR_CQE_OPCODE_MASK) ==
	    MTHCA_ERROR_CQE_OPCODE_MASK)
		return !(cqe->opcode & 0x01);
	else
		return !(cqe->is_send & 0x80);
}
void mthca_free_cq_buf(struct mthca_dev *dev, struct mthca_cq_buf *buf, int cqe)
{
	mthca_buf_free(dev, (cqe + 1) * MTHCA_CQ_ENTRY_SIZE, &buf->queue,
		       buf->is_direct, &buf->mr);
}
static inline u64 async_mask(struct mthca_dev *dev)
{
	return dev->mthca_flags & MTHCA_FLAG_SRQ ?
		MTHCA_ASYNC_EVENT_MASK | MTHCA_SRQ_EVENT_MASK :
		MTHCA_ASYNC_EVENT_MASK;
}
static inline void tavor_eq_req_not(struct mthca_dev *dev, int eqn)
{
	mthca_write64(MTHCA_EQ_DB_REQ_NOT | eqn, 0,
		      dev->kar + MTHCA_EQ_DOORBELL,
		      MTHCA_GET_DOORBELL_LOCK(&dev->doorbell_lock));
}
static inline void arbel_eq_req_not(struct mthca_dev *dev, u32 eqn_mask)
{
	writel(eqn_mask, dev->eq_regs.arbel.eq_arm);
}
static inline void set_eqe_hw(struct mthca_eqe *eqe)
{
	eqe->owner =  MTHCA_EQ_ENTRY_OWNER_HW;
}
static void send_handler(struct ib_mad_agent *agent,
			 struct ib_mad_send_wc *mad_send_wc)
{
	ib_free_send_mad(mad_send_wc->send_buf);
}
void mthca_cleanup_mcg_table(struct mthca_dev *dev)
{
	mthca_alloc_cleanup(&dev->mcg_table.alloc);
}
static u64 mthca_uarc_virt(struct mthca_dev *dev, struct mthca_uar *uar, int page)
{
	return dev->uar_table.uarc_base +
		uar->index * dev->uar_table.uarc_size +
		page * MTHCA_ICM_PAGE_SIZE;
}
struct mthca_mtt *mthca_alloc_mtt(struct mthca_dev *dev, int size)
{
	return __mthca_alloc_mtt(dev, size, &dev->mr_table.mtt_buddy);
}
static inline u32 tavor_hw_index_to_key(u32 ind)
{
	return ind;
}
static inline u32 tavor_key_to_hw_index(u32 key)
{
	return key;
}
static inline u32 arbel_hw_index_to_key(u32 ind)
{
	return (ind >> 24) | (ind << 8);
}
static inline u32 arbel_key_to_hw_index(u32 key)
{
	return (key << 24) | (key >> 8);
}
static inline u32 hw_index_to_key(struct mthca_dev *dev, u32 ind)
{
	if (mthca_is_memfree(dev))
		return arbel_hw_index_to_key(ind);
	else
		return tavor_hw_index_to_key(ind);
}
static inline u32 key_to_hw_index(struct mthca_dev *dev, u32 key)
{
	if (mthca_is_memfree(dev))
		return arbel_key_to_hw_index(key);
	else
		return tavor_key_to_hw_index(key);
}
static inline u32 adjust_key(struct mthca_dev *dev, u32 key)
{
	if (dev->mthca_flags & MTHCA_FLAG_SINAI_OPT)
		return ((key << 20) & 0x800000) | (key & 0x7fffff);
	else
		return key;
}
int mthca_init_pd_table(struct mthca_dev *dev)
{
	return mthca_alloc_init(&dev->pd_table.alloc,
				dev->limits.num_pds,
				(1 << 24) - 1,
				dev->limits.reserved_pds);
}
void mthca_cleanup_pd_table(struct mthca_dev *dev)
{
	mthca_alloc_cleanup(&dev->pd_table.alloc);
}
static inline u32 convert_access(int acc)
{
	return (acc & IB_ACCESS_REMOTE_ATOMIC ? MTHCA_MPT_FLAG_ATOMIC       : 0) |
	       (acc & IB_ACCESS_REMOTE_WRITE  ? MTHCA_MPT_FLAG_REMOTE_WRITE : 0) |
	       (acc & IB_ACCESS_REMOTE_READ   ? MTHCA_MPT_FLAG_REMOTE_READ  : 0) |
	       (acc & IB_ACCESS_LOCAL_WRITE   ? MTHCA_MPT_FLAG_LOCAL_WRITE  : 0) |
	       MTHCA_MPT_FLAG_LOCAL_READ;
}
static int is_sqp(struct mthca_dev *dev, struct mthca_qp *qp)
{
	return qp->qpn >= dev->qp_table.sqp_start &&
		qp->qpn <= dev->qp_table.sqp_start + 3;
}
static int is_qp0(struct mthca_dev *dev, struct mthca_qp *qp)
{
	return qp->qpn >= dev->qp_table.sqp_start &&
		qp->qpn <= dev->qp_table.sqp_start + 1;
}
static void *get_recv_wqe(struct mthca_qp *qp, int n)
{
	if (qp->is_direct)
		return qp->queue.direct.buf + (n << qp->rq.wqe_shift);
	else
		return qp->queue.page_list[(n << qp->rq.wqe_shift) >> PAGE_SHIFT].buf +
			((n << qp->rq.wqe_shift) & (PAGE_SIZE - 1));
}
static void *get_send_wqe(struct mthca_qp *qp, int n)
{
	if (qp->is_direct)
		return qp->queue.direct.buf + qp->send_wqe_offset +
			(n << qp->sq.wqe_shift);
	else
		return qp->queue.page_list[(qp->send_wqe_offset +
					    (n << qp->sq.wqe_shift)) >>
					   PAGE_SHIFT].buf +
			((qp->send_wqe_offset + (n << qp->sq.wqe_shift)) &
			 (PAGE_SIZE - 1));
}
static inline int mthca_max_inline_data(struct mthca_pd *pd, int max_data_size)
{
	return pd->ibpd.uobject ? max_data_size - MTHCA_INLINE_HEADER_SIZE : 0;
}
static void *get_wqe(struct mthca_srq *srq, int n)
{
	if (srq->is_direct)
		return srq->queue.direct.buf + (n << srq->wqe_shift);
	else
		return srq->queue.page_list[(n << srq->wqe_shift) >> PAGE_SHIFT].buf +
			((n << srq->wqe_shift) & (PAGE_SIZE - 1));
}
static inline int *wqe_to_link(void *wqe)
{
	return (int *) (wqe + offsetof(struct mthca_next_seg, imm));
}
void mthca_uar_free(struct mthca_dev *dev, struct mthca_uar *uar)
{
	mthca_free(&dev->uar_table.alloc, uar->index);
}
static void nes_print_macaddr(struct net_device *netdev)
{
	nes_debug(NES_DBG_INIT, "%s: %pM, IRQ %u\n",
		  netdev->name, netdev->dev_addr, netdev->irq);
}
static ssize_t nes_show_nonidx_addr(struct device_driver *ddp, char *buf)
{
	return  snprintf(buf, PAGE_SIZE, "0x%x\n", sysfs_nonidx_addr);
}
static ssize_t nes_show_idx_addr(struct device_driver *ddp, char *buf)
{
	return  snprintf(buf, PAGE_SIZE, "0x%x\n", sysfs_idx_addr);
}
static int mini_cm_accept(struct nes_cm_core *cm_core,
	struct ietf_mpa_frame *mpa_frame, struct nes_cm_node *cm_node)
{
	return 0;
}
static int mini_cm_get(struct nes_cm_core *cm_core)
{
	return cm_core->state;
}
static int nes_netdev_get_stats_count(struct net_device *netdev)
{
	return NES_ETHTOOL_STAT_COUNT;
}
static int nes_map_phys_fmr(struct ib_fmr *ibfmr, u64 *page_list,
		int list_len, u64 iova)
{
	return 0;
}
static int nes_unmap_fmr(struct list_head *ibfmr_list)
{
	return 0;
}
static int nes_modify_port(struct ib_device *ibdev, u8 port,
		int port_modify_mask, struct ib_port_modify *props)
{
	return 0;
}
static struct ib_ah *nes_create_ah(struct ib_pd *pd, struct ib_ah_attr *ah_attr)
{
	return ERR_PTR(-ENOSYS);
}
static int nes_destroy_ah(struct ib_ah *ah)
{
	return -ENOSYS;
}
static void ipoib_cm_rx_reap(struct work_struct *work)
{
	ipoib_cm_free_rx_reap_list(container_of(work, struct ipoib_dev_priv,
						cm.rx_reap_task)->dev);
}
int ipoib_cm_add_mode_attr(struct net_device *dev)
{
	return device_create_file(&dev->dev, &dev_attr_mode);
}
static void ipoib_get_drvinfo(struct net_device *netdev,
			      struct ethtool_drvinfo *drvinfo)
{
	strncpy(drvinfo->driver, "ipoib", sizeof(drvinfo->driver) - 1);
}
void ipoib_set_ethtool_ops(struct net_device *dev)
{
	SET_ETHTOOL_OPS(dev, &ipoib_ethtool_ops);
}
void ipoib_unregister_debugfs(void)
{
	debugfs_remove(ipoib_root);
}
static void ipoib_ib_tx_timer_func(unsigned long ctx)
{
	drain_tx_cq((struct net_device *)ctx);
}
void ipoib_path_iter_read(struct ipoib_path_iter *iter,
			  struct ipoib_path *path)
{
	*path = iter->path;
}
int ipoib_add_umcast_attr(struct net_device *dev)
{
	return device_create_file(&dev->dev, &dev_attr_umcast);
}
int ipoib_add_pkey_attr(struct net_device *dev)
{
	return device_create_file(&dev->dev, &dev_attr_pkey);
}
static void iser_cq_event_callback(struct ib_event *cause, void *context)
{
	iser_err("got cq event %d \n", cause->event);
}
static void iser_qp_event_callback(struct ib_event *cause, void *context)
{
	iser_err("got qp event %d\n",cause->event);
}
void iser_conn_get(struct iser_conn *ib_conn)
{
	atomic_inc(&ib_conn->refcount);
}
static inline struct srp_target_port *host_to_target(struct Scsi_Host *host)
{
	return (struct srp_target_port *) host->hostdata;
}
static const char *srp_target_info(struct Scsi_Host *host)
{
	return host_to_target(host)->target_name;
}
static void srp_qp_event(struct ib_event *event, void *context)
{
	printk(KERN_ERR PFX "QP event %d\n", event->event);
}
static int __init apmpower_init(void)
{
	return input_register_handler(&apmpower_handler);
}
static void __exit apmpower_exit(void)
{
	input_unregister_handler(&apmpower_handler);
}
static void evbug_event(struct input_handle *handle, unsigned int type, unsigned int code, int value)
{
	printk(KERN_DEBUG "evbug.c: Event. Dev: %s, Type: %d, Code: %d, Value: %d\n",
		dev_name(&handle->dev->dev), type, code, value);
}
static int __init evbug_init(void)
{
	return input_register_handler(&evbug_handler);
}
static void __exit evbug_exit(void)
{
	input_unregister_handler(&evbug_handler);
}
static long evdev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
	return evdev_ioctl_handler(file, cmd, (void __user *)arg, 0);
}
static long evdev_ioctl_compat(struct file *file,
				unsigned int cmd, unsigned long arg)
{
	return evdev_ioctl_handler(file, cmd, compat_ptr(arg), 1);
}
static int __init evdev_init(void)
{
	return input_register_handler(&evdev_handler);
}
static void __exit evdev_exit(void)
{
	input_unregister_handler(&evdev_handler);
}
static inline int check_effects_compatible(struct ff_effect *e1,
					   struct ff_effect *e2)
{
	return e1->type == e2->type &&
	       (e1->type != FF_PERIODIC ||
		e1->u.periodic.waveform == e2->u.periodic.waveform);
}
static int __init emu_init(void)
{
	return pci_register_driver(&emu_driver);
}
static void __exit emu_exit(void)
{
	pci_unregister_driver(&emu_driver);
}
static int __init fm801_gp_init(void)
{
	return pci_register_driver(&fm801_gp_driver);
}
static void __exit fm801_gp_exit(void)
{
	pci_unregister_driver(&fm801_gp_driver);
}
static inline int is_event_supported(unsigned int code,
				     unsigned long *bm, unsigned int max)
{
	return code <= max && test_bit(code, bm);
}
static void input_stop_autorepeat(struct input_dev *dev)
{
	del_timer(&dev->timer);
}
static void *input_devices_seq_next(struct seq_file *seq, void *v, loff_t *pos)
{
	return seq_list_next(v, &input_dev_list, pos);
}
static void input_devices_seq_stop(struct seq_file *seq, void *v)
{
	mutex_unlock(&input_mutex);
}
static int input_proc_devices_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &input_devices_seq_ops);
}
static void input_handlers_seq_stop(struct seq_file *seq, void *v)
{
	mutex_unlock(&input_mutex);
}
static int input_proc_handlers_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &input_handlers_seq_ops);
}
static inline int input_proc_init(void) { return 0; }
static int __init joydev_init(void)
{
	return input_register_handler(&joydev_handler);
}
static void __exit joydev_exit(void)
{
	input_unregister_handler(&joydev_handler);
}
static int __init a3d_init(void)
{
	return gameport_register_driver(&a3d_drv);
}
static void __exit a3d_exit(void)
{
	gameport_unregister_driver(&a3d_drv);
}
static int __init adi_init(void)
{
	return gameport_register_driver(&adi_drv);
}
static void __exit adi_exit(void)
{
	gameport_unregister_driver(&adi_drv);
}
static void __exit analog_exit(void)
{
	gameport_unregister_driver(&analog_drv);
}
static int __init cobra_init(void)
{
	return gameport_register_driver(&cobra_drv);
}
static void __exit cobra_exit(void)
{
	gameport_unregister_driver(&cobra_drv);
}
static int __init gf2k_init(void)
{
	return gameport_register_driver(&gf2k_drv);
}
static void __exit gf2k_exit(void)
{
	gameport_unregister_driver(&gf2k_drv);
}
static int __init grip_init(void)
{
	return gameport_register_driver(&grip_drv);
}
static void __exit grip_exit(void)
{
	gameport_unregister_driver(&grip_drv);
}
static int __init grip_init(void)
{
	return gameport_register_driver(&grip_drv);
}
static void __exit grip_exit(void)
{
	gameport_unregister_driver(&grip_drv);
}
static int __init guillemot_init(void)
{
	return gameport_register_driver(&guillemot_drv);
}
static void __exit guillemot_exit(void)
{
	gameport_unregister_driver(&guillemot_drv);
}
static int __init interact_init(void)
{
	return gameport_register_driver(&interact_drv);
}
static void __exit interact_exit(void)
{
	gameport_unregister_driver(&interact_drv);
}
static void joydump_disconnect(struct gameport *gameport)
{
	gameport_close(gameport);
}
static int __init joydump_init(void)
{
	return gameport_register_driver(&joydump_drv);
}
static void __exit joydump_exit(void)
{
	gameport_unregister_driver(&joydump_drv);
}
static int __init magellan_init(void)
{
	return serio_register_driver(&magellan_drv);
}
static void __exit magellan_exit(void)
{
	serio_unregister_driver(&magellan_drv);
}
static int __init dc_pad_init(void)
{
	return maple_driver_register(&dc_pad_driver);
}
static void __exit dc_pad_exit(void)
{
	maple_driver_unregister(&dc_pad_driver);
}
static int __init sw_init(void)
{
	return gameport_register_driver(&sw_drv);
}
static void __exit sw_exit(void)
{
	gameport_unregister_driver(&sw_drv);
}
static int __init spaceball_init(void)
{
	return serio_register_driver(&spaceball_drv);
}
static void __exit spaceball_exit(void)
{
	serio_unregister_driver(&spaceball_drv);
}
static int __init spaceorb_init(void)
{
	return serio_register_driver(&spaceorb_drv);
}
static void __exit spaceorb_exit(void)
{
	serio_unregister_driver(&spaceorb_drv);
}
static int __init stinger_init(void)
{
	return serio_register_driver(&stinger_drv);
}
static void __exit stinger_exit(void)
{
	serio_unregister_driver(&stinger_drv);
}
static int __init tmdc_init(void)
{
	return gameport_register_driver(&tmdc_drv);
}
static void __exit tmdc_exit(void)
{
	gameport_unregister_driver(&tmdc_drv);
}
static int __init twidjoy_init(void)
{
	return serio_register_driver(&twidjoy_drv);
}
static void __exit twidjoy_exit(void)
{
	serio_unregister_driver(&twidjoy_drv);
}
static inline int read_ack(struct pardevice *p)
{
	return parport_read_status(p->port) & 0x40;
}
static int __init walkera0701_init(void)
{
	return walkera0701_connect(&w_dev, walkera0701_pp_no);
}
static void __exit walkera0701_exit(void)
{
	walkera0701_disconnect(&w_dev);
}
static int __init warrior_init(void)
{
	return serio_register_driver(&warrior_drv);
}
static void __exit warrior_exit(void)
{
	serio_unregister_driver(&warrior_drv);
}
static int xpad_init_output(struct usb_interface *intf, struct usb_xpad *xpad) { return 0; }
static int xpad_init_ff(struct usb_xpad *xpad) { return 0; }
static int xpad_led_probe(struct usb_xpad *xpad) { return 0; }
static void __exit usb_xpad_exit(void)
{
	usb_deregister(&xpad_driver);
}
static int __init zhenhua_init(void)
{
	return serio_register_driver(&zhenhua_drv);
}
static void __exit zhenhua_exit(void)
{
	serio_unregister_driver(&zhenhua_drv);
}
static int __init aaedkbd_init(void)
{
	return platform_driver_register(&aaedkbd_driver);
}
static void __exit aaedkbd_exit(void)
{
	platform_driver_unregister(&aaedkbd_driver);
}
static ssize_t atkbd_show_extra(struct atkbd *atkbd, char *buf)
{
	return sprintf(buf, "%d\n", atkbd->extra ? 1 : 0);
}
static ssize_t atkbd_show_scroll(struct atkbd *atkbd, char *buf)
{
	return sprintf(buf, "%d\n", atkbd->scroll ? 1 : 0);
}
static ssize_t atkbd_show_set(struct atkbd *atkbd, char *buf)
{
	return sprintf(buf, "%d\n", atkbd->set);
}
static ssize_t atkbd_show_softrepeat(struct atkbd *atkbd, char *buf)
{
	return sprintf(buf, "%d\n", atkbd->softrepeat ? 1 : 0);
}
static ssize_t atkbd_show_softraw(struct atkbd *atkbd, char *buf)
{
	return sprintf(buf, "%d\n", atkbd->softraw ? 1 : 0);
}
static ssize_t atkbd_show_err_count(struct atkbd *atkbd, char *buf)
{
	return sprintf(buf, "%lu\n", atkbd->err_count);
}
static void __exit atkbd_exit(void)
{
	serio_unregister_driver(&atkbd_drv);
}
static inline u16 bfin_kpad_get_keypressed(struct bf54x_kpad *bf54x_kpad)
{
	return (bfin_read_KPAD_STAT() & KPAD_PRESSED);
}
static int __init bfin_kpad_init(void)
{
	return platform_driver_register(&bfin_kpad_device_driver);
}
static void __exit bfin_kpad_exit(void)
{
	platform_driver_unregister(&bfin_kpad_device_driver);
}
static int __init corgikbd_init(void)
{
	return platform_driver_register(&corgikbd_driver);
}
static void __exit corgikbd_exit(void)
{
	platform_driver_unregister(&corgikbd_driver);
}
static int __init gpio_keys_init(void)
{
	return platform_driver_register(&gpio_keys_device_driver);
}
static void __exit gpio_keys_exit(void)
{
	platform_driver_unregister(&gpio_keys_device_driver);
}
static int __init hil_kbd_init(void)
{
	return serio_register_driver(&hil_kbd_serio_drv);
}
static void __exit hil_kbd_exit(void)
{
	serio_unregister_driver(&hil_kbd_serio_drv);
}
static int __init hil_init(void)
{
	return register_parisc_driver(&hil_driver);
}
static int __init jornada680kbd_init(void)
{
	return platform_driver_register(&jornada680kbd_driver);
}
static void __exit jornada680kbd_exit(void)
{
	platform_driver_unregister(&jornada680kbd_driver);
}
static int __init jornada720_kbd_init(void)
{
	return platform_driver_register(&jornada720_kbd_driver);
}
static void __exit jornada720_kbd_exit(void)
{
	platform_driver_unregister(&jornada720_kbd_driver);
}
static int __init
lkkbd_init (void)
{
	return serio_register_driver(&lkkbd_drv);
}
static void __exit
lkkbd_exit (void)
{
	serio_unregister_driver(&lkkbd_drv);
}
static inline void locomokbd_charge_all(unsigned long membase)
{
	locomo_writel(0x00FF, membase + LOCOMO_KSC);
}
static int __init locomokbd_init(void)
{
	return locomo_driver_register(&keyboard_driver);
}
static void __exit locomokbd_exit(void)
{
	locomo_driver_unregister(&keyboard_driver);
}
static int __init dc_kbd_init(void)
{
	return maple_driver_register(&dc_kbd_driver);
}
static void __exit dc_kbd_exit(void)
{
	maple_driver_unregister(&dc_kbd_driver);
}
static int __init nkbd_init(void)
{
	return serio_register_driver(&nkbd_drv);
}
static void __exit nkbd_exit(void)
{
	serio_unregister_driver(&nkbd_drv);
}
static void omap_kp_timer(unsigned long data)
{
	tasklet_schedule(&kp_tasklet);
}
static ssize_t omap_kp_enable_show(struct device *dev,
				   struct device_attribute *attr, char *buf)
{
	return sprintf(buf, "%u\n", kp_enable);
}
static int omap_kp_suspend(struct platform_device *dev, pm_message_t state)
{
	return 0;
}
static int omap_kp_resume(struct platform_device *dev)
{
	return 0;
}
static void __exit omap_kp_exit(void)
{
	platform_driver_unregister(&omap_kp_driver);
}
static inline unsigned int lookup_matrix_keycode(
		struct pxa27x_keypad *keypad, int row, int col)
{
	return keypad->matrix_keycodes[(row << 3) + col];
}
static inline int rotary_delta(uint32_t kprec)
{
	if (kprec & KPREC_OF0)
		return (kprec & 0xff) + 0x7f;
	else if (kprec & KPREC_UF0)
		return (kprec & 0xff) - 0x7f - 0xff;
	else
		return (kprec & 0xff) - 0x7f;
}
static int __init pxa27x_keypad_init(void)
{
	return platform_driver_register(&pxa27x_keypad_driver);
}
static void __exit pxa27x_keypad_exit(void)
{
	platform_driver_unregister(&pxa27x_keypad_driver);
}
static int __init pxa930_rotary_init(void)
{
	return platform_driver_register(&pxa930_rotary_driver);
}
static void __exit pxa930_rotary_exit(void)
{
	platform_driver_unregister(&pxa930_rotary_driver);
}
static int __init sh_keysc_init(void)
{
	return platform_driver_register(&sh_keysc_device_driver);
}
static void __exit sh_keysc_exit(void)
{
	platform_driver_unregister(&sh_keysc_device_driver);
}
static inline int spitzkbd_get_row_status(int col)
{
	return ((GPLR0 >> 12) & 0x01) | ((GPLR0 >> 16) & 0x02)
		| ((GPLR2 >> 25) & 0x04) | ((GPLR1 << 1) & 0x08)
		| ((GPLR1 >> 0) & 0x10) | ((GPLR1 >> 1) & 0x60);
}
static int __init spitzkbd_init(void)
{
	return platform_driver_register(&spitzkbd_driver);
}
static void __exit spitzkbd_exit(void)
{
	platform_driver_unregister(&spitzkbd_driver);
}
static int __init skbd_init(void)
{
	return serio_register_driver(&skbd_drv);
}
static void __exit skbd_exit(void)
{
	serio_unregister_driver(&skbd_drv);
}
static int __init sunkbd_init(void)
{
	return serio_register_driver(&sunkbd_drv);
}
static void __exit sunkbd_exit(void)
{
	serio_unregister_driver(&sunkbd_drv);
}
static int __devinit tosakbd_init(void)
{
	return platform_driver_register(&tosakbd_driver);
}
static void __exit tosakbd_exit(void)
{
	platform_driver_unregister(&tosakbd_driver);
}
static int __init xtkbd_init(void)
{
	return serio_register_driver(&xtkbd_drv);
}
static void __exit xtkbd_exit(void)
{
	serio_unregister_driver(&xtkbd_drv);
}
static void apanel_shutdown(struct i2c_client *client)
{
	apanel_remove(client);
}
static void __exit apanel_cleanup(void)
{
	i2c_del_driver(&apanel_driver);
}
static void __exit ati_remote_exit(void)
{
	usb_deregister(&ati_remote_driver);
}
static void __exit ati_remote2_exit(void)
{
	usb_deregister(&ati_remote2_driver);
}
static void __exit atlas_acpi_exit(void)
{
	acpi_bus_unregister_driver(&atlas_acpi_driver);
}
static void __exit cm109_exit(void)
{
	usb_deregister(&cm109_driver);
}
static int __init cobalt_buttons_init(void)
{
	return platform_driver_register(&cobalt_buttons_driver);
}
static void __exit cobalt_buttons_exit(void)
{
	platform_driver_unregister(&cobalt_buttons_driver);
}
static void hp_sdc_rtc_isr (int irq, void *dev_id, 
			    uint8_t status, uint8_t data) 
{
	return;
}
static int hp_sdc_rtc_fasync (int fd, struct file *filp, int on)
{
        return fasync_helper (fd, filp, on, &hp_sdc_rtc_async_queue);
}
static int hp_sdc_rtc_ioctl(struct inode *inode, struct file *file, 
			    unsigned int cmd, unsigned long arg)
{
	return -EINVAL;
}
static int __init ixp4xx_spkr_init(void)
{
	return platform_driver_register(&ixp4xx_spkr_platform_driver);
}
static void __exit ixp4xx_spkr_exit(void)
{
	platform_driver_unregister(&ixp4xx_spkr_platform_driver);
}
static void __exit usb_keyspan_exit(void)
{
	usb_deregister(&keyspan_driver);
}
static void m68kspkr_shutdown(struct platform_device *dev)
{
	m68kspkr_event(NULL, EV_SND, SND_BELL, 0);
}
static int __init pcf50633_input_init(void)
{
	return platform_driver_register(&pcf50633_input_driver);
}
static void __exit pcf50633_input_exit(void)
{
	platform_driver_unregister(&pcf50633_input_driver);
}
static void pcspkr_shutdown(struct platform_device *dev)
{
	pcspkr_event(NULL, EV_SND, SND_BELL, 0);
}
static int __init pcspkr_init(void)
{
	return platform_driver_register(&pcspkr_platform_driver);
}
static void __exit pcspkr_exit(void)
{
	platform_driver_unregister(&pcspkr_platform_driver);
}
static int __init powermate_init(void)
{
	return usb_register(&powermate_driver);
}
static void __exit powermate_cleanup(void)
{
	usb_deregister(&powermate_driver);
}
static int __init sgi_buttons_init(void)
{
	return platform_driver_register(&sgi_buttons_driver);
}
static void __exit sgi_buttons_exit(void)
{
	platform_driver_unregister(&sgi_buttons_driver);
}
static inline int uinput_request_reserve_slot(struct uinput_device *udev, struct uinput_request *request)
{
	return wait_event_interruptible(udev->requests_waitq,
					!uinput_request_alloc_id(udev, request));
}
static void uinput_dev_set_gain(struct input_dev *dev, u16 gain)
{
	uinput_dev_event(dev, EV_FF, FF_GAIN, gain);
}
static void uinput_dev_set_autocenter(struct input_dev *dev, u16 magnitude)
{
	uinput_dev_event(dev, EV_FF, FF_AUTOCENTER, magnitude);
}
static int uinput_dev_playback(struct input_dev *dev, int effect_id, int value)
{
	return uinput_dev_event(dev, EV_FF, effect_id, value);
}
static long uinput_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
	return uinput_ioctl_handler(file, cmd, arg, (void __user *)arg);
}
static long uinput_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
	return uinput_ioctl_handler(file, cmd, arg, compat_ptr(arg));
}
static int __init uinput_init(void)
{
	return misc_register(&uinput_misc);
}
static void __exit uinput_exit(void)
{
	misc_deregister(&uinput_misc);
}
static void wistron_mail_led_set(struct led_classdev *led_cdev,
				enum led_brightness value)
{
	bios_set_state(MAIL_LED, (value != LED_OFF) ? 1 : 0);
}
static void wistron_wifi_led_set(struct led_classdev *led_cdev,
				enum led_brightness value)
{
	bios_set_state(WIFI, (value != LED_OFF) ? 1 : 0);
}
static void wistron_flush(struct input_polled_dev *dev)
{
	poll_bios(true);
}
static ssize_t show_line1(struct device *dev, struct device_attribute *attr,
			char *buf)
{
	return show_line(dev, buf, LCD_LINE1_OFFSET, LCD_LINE2_OFFSET);
}
static ssize_t show_line2(struct device *dev, struct device_attribute *attr,
			char *buf)
{
	return show_line(dev, buf, LCD_LINE2_OFFSET, LCD_LINE3_OFFSET);
}
static ssize_t show_line3(struct device *dev, struct device_attribute *attr,
			char *buf)
{
	return show_line(dev, buf, LCD_LINE3_OFFSET, LCD_LINE4_OFFSET);
}
static ssize_t store_line1(struct device *dev, struct device_attribute *attr,
				const char *buf, size_t count)
{
	return store_line(dev, buf, count, LCD_LINE1_OFFSET, LCD_LINE1_SIZE);
}
static ssize_t store_line2(struct device *dev, struct device_attribute *attr,
				const char *buf, size_t count)
{
	return store_line(dev, buf, count, LCD_LINE2_OFFSET, LCD_LINE2_SIZE);
}
static ssize_t store_line3(struct device *dev, struct device_attribute *attr,
				const char *buf, size_t count)
{
	return store_line(dev, buf, count, LCD_LINE3_OFFSET, LCD_LINE3_SIZE);
}
static ssize_t show_icon(struct device *dev, struct device_attribute *attr,
		const char *buf, size_t count)
{
	return set_icon(dev, buf, count, buf[0]);
}
static ssize_t hide_icon(struct device *dev, struct device_attribute *attr,
		const char *buf, size_t count)
{
	return set_icon(dev, buf, count, ' ');
}
static void __exit yealink_dev_exit(void)
{
	usb_deregister(&yealink_driver);
}
static void amimouse_close(struct input_dev *dev)
{
	free_irq(IRQ_AMIGA_VERTB, amimouse_interrupt);
}
static void __exit amimouse_exit(void)
{
        input_unregister_device(amimouse_dev);
}
static int __init atp_init(void)
{
	return usb_register(&atp_driver);
}
static void __exit atp_exit(void)
{
	usb_deregister(&atp_driver);
}
static void __exit atamouse_exit(void)
{
	input_unregister_device(atamouse_dev);
}
static inline int raw2int(__le16 x)
{
	return (signed short)le16_to_cpu(x);
}
static inline int int2scale(const struct bcm5974_param *p, int x)
{
	return x * p->dim / (p->devmax - p->devmin);
}
static int __init bcm5974_init(void)
{
	return usb_register(&bcm5974_driver);
}
static void __exit bcm5974_exit(void)
{
	usb_deregister(&bcm5974_driver);
}
static int __init gpio_mouse_init(void)
{
	return platform_driver_probe(&gpio_mouse_device_driver,
			gpio_mouse_probe);
}
static void __exit gpio_mouse_exit(void)
{
	platform_driver_unregister(&gpio_mouse_device_driver);
}
static int hgpk_validate_byte(unsigned char *packet)
{
	return (packet[0] & 0x0C) != 0x08;
}
static int hgpk_poll(struct psmouse *psmouse)
{
	return -1;
}
static int __init hil_ptr_init(void)
{
	return serio_register_driver(&hil_ptr_serio_driver);
}
static void __exit hil_ptr_exit(void)
{
	serio_unregister_driver(&hil_ptr_serio_driver);
}
static ssize_t ps2pp_attr_show_smartscroll(struct psmouse *psmouse, void *data, char *buf)
{
	return sprintf(buf, "%d\n", psmouse->smartscroll ? 1 : 0);
}
static void ps2pp_disconnect(struct psmouse *psmouse)
{
	device_remove_file(&psmouse->ps2dev.serio->dev, &psmouse_attr_smartscroll.dattr);
}
static int __init dc_mouse_init(void)
{
	return maple_driver_register(&dc_mouse_driver);
}
static void __exit dc_mouse_exit(void)
{
	maple_driver_unregister(&dc_mouse_driver);
}
static void pc110pad_close(struct input_dev *dev)
{
	outb(PC110PAD_OFF, pc110pad_io + 2);
}
void psmouse_queue_work(struct psmouse *psmouse, struct delayed_work *work,
		unsigned long delay)
{
	queue_delayed_work(kpsmoused_wq, work, delay);
}
static int psmouse_poll(struct psmouse *psmouse)
{
	return ps2_command(&psmouse->ps2dev, psmouse->packet,
			   PSMOUSE_CMD_POLL | (psmouse->pktsize << 8));
}
static ssize_t psmouse_attr_show_protocol(struct psmouse *psmouse, void *data, char *buf)
{
	return sprintf(buf, "%s\n", psmouse_protocol_by_type(psmouse->type)->name);
}
static int __init pxa930_trkball_init(void)
{
	return platform_driver_register(&pxa930_trkball_driver);
}
static void __exit pxa930_trkball_exit(void)
{
	platform_driver_unregister(&pxa930_trkball_driver);
}
static int __init sermouse_init(void)
{
	return serio_register_driver(&sermouse_drv);
}
static void __exit sermouse_exit(void)
{
	serio_unregister_driver(&sermouse_drv);
}
void synaptics_reset(struct psmouse *psmouse)
{
	synaptics_mode_cmd(psmouse, 0);
}
static inline int synaptics_is_pt_packet(unsigned char *buf)
{
	return (buf[0] & 0xFC) == 0x84 && (buf[3] & 0xCC) == 0xC4;
}
int synaptics_init(struct psmouse *psmouse)
{
	return -ENOSYS;
}
static __inline__ int
vsxxxaa_smells_like_packet (struct vsxxxaa *mouse, unsigned char type, size_t len)
{
	return (mouse->count >= len) && MATCH_PACKET_TYPE (mouse->buf[0], type);
}
static int __init
vsxxxaa_init (void)
{
	return serio_register_driver(&vsxxxaa_drv);
}
static void __exit
vsxxxaa_exit (void)
{
	serio_unregister_driver(&vsxxxaa_drv);
}
static inline int mousedev_limit_delta(int delta, int limit)
{
	return delta > limit ? limit : (delta < -limit ? -limit : delta);
}
static int __init amba_kmi_init(void)
{
	return amba_driver_register(&ambakmi_driver);
}
static void __exit amba_kmi_exit(void)
{
	amba_driver_unregister(&ambakmi_driver);
}
static int __init psif_init(void)
{
	return platform_driver_probe(&psif_driver, psif_probe);
}
static void __exit psif_exit(void)
{
	platform_driver_unregister(&psif_driver);
}
static irqreturn_t ct82c710_interrupt(int cpl, void *dev_id)
{
	return serio_interrupt(ct82c710_port, inb(CT82C710_DATA), 0);
}
static void __exit gscps2_exit(void)
{
	unregister_parisc_driver(&parisc_ps2_driver);
}
static void hil_mlc_clear_di_scratch(hil_mlc *mlc)
{
	memset(&mlc->di_scratch, 0, sizeof(mlc->di_scratch));
}
static void hil_mlc_copy_di_scratch(hil_mlc *mlc, int idx)
{
	memcpy(&mlc->di[idx], &mlc->di_scratch, sizeof(mlc->di_scratch));
}
static int hilse_inc_lcv(hil_mlc *mlc, int lim)
{
	return mlc->lcv++ >= lim ? -1 : 0;
}
static inline uint8_t hp_sdc_data_in8(void)
{
	return sdc_readb(hp_sdc.data_io);
}
static void i8042_shutdown(struct platform_device *dev)
{
	i8042_controller_reset();
}
static int parkbd_readlines(void)
{
	return (parport_read_status(parkbd_dev->port) >> 6) ^ 2;
}
static void parkbd_writelines(int data)
{
	parport_write_control(parkbd_dev->port, (~data & 3) | 0x10);
}
static int __init pcips2_init(void)
{
	return pci_register_driver(&pcips2_driver);
}
static void __exit pcips2_exit(void)
{
	pci_unregister_driver(&pcips2_driver);
}
static irqreturn_t rpckbd_tx(int irq, void *dev_id)
{
	return IRQ_HANDLED;
}
static int __init rpckbd_init(void)
{
	return platform_driver_register(&rpckbd_driver);
}
static void __exit rpckbd_exit(void)
{
	platform_driver_unregister(&rpckbd_driver);
}
static int __init ps2_init(void)
{
	return sa1111_driver_register(&ps2_driver);
}
static void __exit ps2_exit(void)
{
	sa1111_driver_unregister(&ps2_driver);
}
void serio_rescan(struct serio *serio)
{
	serio_queue_event(serio, NULL, SERIO_RESCAN_PORT);
}
void serio_reconnect(struct serio *serio)
{
	serio_queue_event(serio, NULL, SERIO_RECONNECT_CHAIN);
}
static int serio_uevent(struct device *dev, struct kobj_uevent_env *env)
{
	return -ENODEV;
}
static int __init serio_raw_init(void)
{
	return serio_register_driver(&serio_raw_drv);
}
static void __exit serio_raw_exit(void)
{
	serio_unregister_driver(&serio_raw_drv);
}
static void __exit serport_exit(void)
{
	tty_unregister_ldisc(N_MOUSE);
}
static int __init xps2_init(void)
{
	return of_register_platform_driver(&xps2_of_driver);
}
static void __exit xps2_cleanup(void)
{
	of_unregister_platform_driver(&xps2_of_driver);
}
static void __exit usb_acecad_exit(void)
{
	usb_deregister(&usb_acecad_driver);
}
static int
aiptek_set_report(struct aiptek *aiptek,
		  unsigned char report_type,
		  unsigned char report_id, void *buffer, int size)
{
	return usb_control_msg(aiptek->usbdev,
			       usb_sndctrlpipe(aiptek->usbdev, 0),
			       USB_REQ_SET_REPORT,
			       USB_TYPE_CLASS | USB_RECIP_INTERFACE |
			       USB_DIR_OUT, (report_type << 8) + report_id,
			       aiptek->ifnum, buffer, size, 5000);
}
static int
aiptek_get_report(struct aiptek *aiptek,
		  unsigned char report_type,
		  unsigned char report_id, void *buffer, int size)
{
	return usb_control_msg(aiptek->usbdev,
			       usb_rcvctrlpipe(aiptek->usbdev, 0),
			       USB_REQ_GET_REPORT,
			       USB_TYPE_CLASS | USB_RECIP_INTERFACE |
			       USB_DIR_IN, (report_type << 8) + report_id,
			       aiptek->ifnum, buffer, size, 5000);
}
static ssize_t show_tabletExecute(struct device *dev, struct device_attribute *attr, char *buf)
{
	return snprintf(buf, PAGE_SIZE,
			"Write anything to this file to program your tablet.\n");
}
static void __exit aiptek_exit(void)
{
	usb_deregister(&aiptek_driver);
}
static void __exit gtco_exit(void)
{
	usb_deregister(&gtco_driverinfo_table);
}
static void __exit kbtab_exit(void)
{
	usb_deregister(&kbtab_driver);
}
static int usb_get_report(struct usb_interface *intf, unsigned char type,
				unsigned char id, void *buf, int size)
{
	return usb_control_msg(interface_to_usbdev(intf),
		usb_rcvctrlpipe(interface_to_usbdev(intf), 0),
		USB_REQ_GET_REPORT, USB_TYPE_CLASS | USB_RECIP_INTERFACE,
		(type << 8) + id, intf->altsetting[0].desc.bInterfaceNumber,
		buf, size, 100);
}
static int usb_set_report(struct usb_interface *intf, unsigned char type,
				unsigned char id, void *buf, int size)
{
	return usb_control_msg(interface_to_usbdev(intf),
		usb_sndctrlpipe(interface_to_usbdev(intf), 0),
                USB_REQ_SET_REPORT, USB_TYPE_CLASS | USB_RECIP_INTERFACE,
                (type << 8) + id, intf->altsetting[0].desc.bInterfaceNumber,
		buf, size, 1000);
}
static struct input_dev * get_input_dev(struct wacom_combo *wcombo)
{
	return wcombo->wacom->dev;
}
void wacom_report_key(void *wcombo, unsigned int key_type, int key_data)
{
	input_report_key(get_input_dev((struct wacom_combo *)wcombo), key_type, key_data);
}
void wacom_report_abs(void *wcombo, unsigned int abs_type, int abs_data)
{
	input_report_abs(get_input_dev((struct wacom_combo *)wcombo), abs_type, abs_data);
}
void wacom_report_rel(void *wcombo, unsigned int rel_type, int rel_data)
{
	input_report_rel(get_input_dev((struct wacom_combo *)wcombo), rel_type, rel_data);
}
void wacom_input_event(void *wcombo, unsigned int type, unsigned int code, int value)
{
	input_event(get_input_dev((struct wacom_combo *)wcombo), type, code, value);
}
void wacom_input_sync(void *wcombo)
{
	input_sync(get_input_dev((struct wacom_combo *)wcombo));
}
void input_dev_bee(struct input_dev *input_dev, struct wacom_wac *wacom_wac)
{
	input_dev->keybit[BIT_WORD(BTN_MISC)] |= BIT_MASK(BTN_8) | BIT_MASK(BTN_9);
}
void input_dev_pl(struct input_dev *input_dev, struct wacom_wac *wacom_wac)
{
	input_dev->keybit[BIT_WORD(BTN_DIGI)] |= BIT_MASK(BTN_STYLUS2);
}
void input_dev_pt(struct input_dev *input_dev, struct wacom_wac *wacom_wac)
{
	input_dev->keybit[BIT_WORD(BTN_DIGI)] |= BIT_MASK(BTN_TOOL_RUBBER);
}
static int wacom_reset_resume(struct usb_interface *intf)
{
	return wacom_resume(intf);
}
static void __exit wacom_exit(void)
{
	usb_deregister(&wacom_driver);
}
static inline unsigned null_adjust(struct ads7846 *ts, ssize_t v)
{
	return v;
}
static inline int ads784x_hwmon_register(struct spi_device *spi,
					 struct ads7846 *ts)
{
	return 0;
}
static ssize_t ads7846_pen_down_show(struct device *dev,
				     struct device_attribute *attr, char *buf)
{
	return sprintf(buf, "%u\n", is_pen_down(dev));
}
static int ads7846_no_filter(void *ads, int data_idx, int *val)
{
	return ADS7846_FILTER_OK;
}
static int __init ads7846_init(void)
{
	return spi_register_driver(&ads7846_driver);
}
static void __exit ads7846_exit(void)
{
	spi_unregister_driver(&ads7846_driver);
}
static int __init atmel_tsadcc_init(void)
{
	return platform_driver_register(&atmel_tsadcc_driver);
}

static void __exit atmel_tsadcc_exit(void)
{
	platform_driver_unregister(&atmel_tsadcc_driver);
}
static int __init corgits_init(void)
{
	return platform_driver_register(&corgits_driver);
}
static void __exit corgits_exit(void)
{
	platform_driver_unregister(&corgits_driver);
}
static inline int is_pen_down(struct da9034_touch *touch)
{
	return da903x_query_status(touch->da9034_dev, DA9034_STATUS_PEN_DOWN);
}
static inline int detect_pen_down(struct da9034_touch *touch, int on)
{
	if (on)
		return da903x_set_bits(touch->da9034_dev,
				DA9034_AUTO_CTRL2, DA9034_PEN_DETECT);
	else
		return da903x_clr_bits(touch->da9034_dev,
				DA9034_AUTO_CTRL2, DA9034_PEN_DETECT);
}
static inline int start_tsi(struct da9034_touch *touch)
{
	return da903x_set_bits(touch->da9034_dev,
			DA9034_AUTO_CTRL2, DA9034_AUTO_TSI_EN);
}
static inline int stop_tsi(struct da9034_touch *touch)
{
	return da903x_clr_bits(touch->da9034_dev,
			DA9034_AUTO_CTRL2, DA9034_AUTO_TSI_EN);
}
static int __init da9034_touch_init(void)
{
	return platform_driver_register(&da9034_touch_driver);
}
static void __exit da9034_touch_exit(void)
{
	platform_driver_unregister(&da9034_touch_driver);
}
static int __init elo_init(void)
{
	return serio_register_driver(&elo_drv);
}
static void __exit elo_exit(void)
{
	serio_unregister_driver(&elo_drv);
}
static int __init fujitsu_init(void)
{
	return serio_register_driver(&fujitsu_drv);
}
static void __exit fujitsu_exit(void)
{
	serio_unregister_driver(&fujitsu_drv);
}
static int __init gunze_init(void)
{
	return serio_register_driver(&gunze_drv);
}
static void __exit gunze_exit(void)
{
	serio_unregister_driver(&gunze_drv);
}
static int h3600ts_event(struct input_dev *dev, unsigned int type,
			 unsigned int code, int value)
{
	return 0;
}
static int __init h3600ts_init(void)
{
	return serio_register_driver(&h3600ts_drv);
}
static void __exit h3600ts_exit(void)
{
	serio_unregister_driver(&h3600ts_drv);
}
static void __exit htcpen_isa_exit(void)
{
	isa_unregister_driver(&htcpen_isa_driver);
}
static int __init inexio_init(void)
{
	return serio_register_driver(&inexio_drv);
}
static void __exit inexio_exit(void)
{
	serio_unregister_driver(&inexio_drv);
}
static int __init jornada720_ts_init(void)
{
	return platform_driver_register(&jornada720_ts_driver);
}
static void __exit jornada720_ts_exit(void)
{
	platform_driver_unregister(&jornada720_ts_driver);
}
static int __init mainstone_wm97xx_init(void)
{
	return platform_driver_register(&mainstone_wm97xx_driver);
}
static void __exit mainstone_wm97xx_exit(void)
{
	platform_driver_unregister(&mainstone_wm97xx_driver);
}
static int __init migor_ts_init(void)
{
	return i2c_add_driver(&migor_ts_driver);
}
static void __exit migor_ts_exit(void)
{
	i2c_del_driver(&migor_ts_driver);
}
static int __init mtouch_init(void)
{
	return serio_register_driver(&mtouch_drv);
}
static void __exit mtouch_exit(void)
{
	serio_unregister_driver(&mtouch_drv);
}
static int __init pm_init(void)
{
	return serio_register_driver(&pm_drv);
}
static void __exit pm_exit(void)
{
	serio_unregister_driver(&pm_drv);
}
static int __init touchit213_init(void)
{
	return serio_register_driver(&touchit213_drv);
}
static void __exit touchit213_exit(void)
{
	serio_unregister_driver(&touchit213_drv);
}
static int __init tr_init(void)
{
	return serio_register_driver(&tr_drv);
}
static void __exit tr_exit(void)
{
	serio_unregister_driver(&tr_drv);
}
static int __init tw_init(void)
{
	return serio_register_driver(&tw_drv);
}
static void __exit tw_exit(void)
{
	serio_unregister_driver(&tw_drv);
}
static int __init tsc2007_init(void)
{
	return i2c_add_driver(&tsc2007_driver);
}
static void __exit tsc2007_exit(void)
{
	i2c_del_driver(&tsc2007_driver);
}
static inline void ucb1400_ts_mode_int(struct snd_ac97 *ac97)
{
	ucb1400_reg_write(ac97, UCB_TS_CR,
			UCB_TS_CR_TSMX_POW | UCB_TS_CR_TSPX_POW |
			UCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_GND |
			UCB_TS_CR_MODE_INT);
}
static inline void ucb1400_ts_irq_disable(struct snd_ac97 *ac97)
{
	ucb1400_reg_write(ac97, UCB_IE_FAL, 0);
}
static int __init ucb1400_ts_init(void)
{
	return platform_driver_register(&ucb1400_ts_driver);
}
static void __exit ucb1400_ts_exit(void)
{
	platform_driver_unregister(&ucb1400_ts_driver);
}
static int __init usbtouch_init(void)
{
	return usb_register(&usbtouch_driver);
}
static void __exit usbtouch_cleanup(void)
{
	usb_deregister(&usbtouch_driver);
}
static int __init w8001_init(void)
{
	return serio_register_driver(&w8001_drv);
}
static void __exit w8001_exit(void)
{
	serio_unregister_driver(&w8001_drv);
}
static inline void poll_delay(int d)
{
	udelay(3 * AC97_LINK_FRAME + delay_table[d]);
}
static inline int is_pden(struct wm97xx *wm)
{
	return wm->dig[2] & WM9705_PDEN;
}
static inline void poll_delay(int d)
{
	udelay(3 * AC97_LINK_FRAME + delay_table[d]);
}
static inline int is_pden(struct wm97xx *wm)
{
	return wm->dig[2] & WM9712_PDEN;
}
static inline void poll_delay(int d)
{
	udelay(3 * AC97_LINK_FRAME + delay_table[d]);
}
static inline int is_pden(struct wm97xx *wm)
{
	return wm->dig[2] & WM9713_PDEN;
}
int wm97xx_reg_read(struct wm97xx *wm, u16 reg)
{
	if (wm->ac97)
		return wm->ac97->bus->ops->read(wm->ac97, reg);
	else
		return -1;
}
static int __init wm97xx_init(void)
{
	return driver_register(&wm97xx_driver);
}
static void __exit wm97xx_exit(void)
{
	driver_unregister(&wm97xx_driver);
}
static void __exit xenkbd_cleanup(void)
{
	xenbus_unregister_driver(&xenkbd_driver);
}
static void capinc_tty_set_termios(struct tty_struct *tty, struct ktermios * old)
{
	printk(KERN_DEBUG "capinc_tty_set_termios\n");
}
static void capinc_tty_hangup(struct tty_struct *tty)
{
	printk(KERN_DEBUG "capinc_tty_hangup\n");
}
static void capinc_tty_flush_buffer(struct tty_struct *tty)
{
	printk(KERN_DEBUG "capinc_tty_flush_buffer\n");
}
static void capinc_tty_set_ldisc(struct tty_struct *tty)
{
	printk(KERN_DEBUG "capinc_tty_set_ldisc\n");
}
static void capinc_tty_send_xchar(struct tty_struct *tty, char ch)
{
	printk(KERN_DEBUG "capinc_tty_send_xchar(%d)\n", ch);
}
static int capinc_tty_read_proc(char *page, char **start, off_t off,
				int count, int *eof, void *data)
{
	return 0;
}
static int capifs_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_single(fs_type, flags, data, capifs_fill_super, mnt);
}
static inline void
capi_ctr_put(struct capi_ctr *card)
{
	module_put(card->owner);
}
void capi20_set_callback(struct capi20_appl *ap,
			 void (*callback) (unsigned int cmd, __u32 contr, void *data))
{
	ap->callback = callback;
}
static int seq_controller_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &seq_controller_ops);
}
static int seq_contrstats_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &seq_contrstats_ops);
}
static int
seq_applications_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &seq_applications_ops);
}
static int
seq_applstats_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &seq_applstats_ops);
}
static void *capi_driver_next(struct seq_file *seq, void *v, loff_t *pos)
{
	return seq_list_next(v, &capi_drivers, pos);
}
static void capi_driver_stop(struct seq_file *seq, void *v)
{
	read_unlock(&capi_drivers_list_lock);
}
/**********************************/
static ssize_t
isdn_divert_write(struct file *file, const char __user *buf, size_t count, loff_t * off)
{
	return (-ENODEV);
}				/* isdn_divert_write */
static int gigaset_set_modem_ctrl(struct cardstate *cs, unsigned old_state,
				  unsigned new_state)
{
	return -EINVAL;
}
static int gigaset_baud_rate(struct cardstate *cs, unsigned cflag)
{
	return -EINVAL;
}
static int gigaset_set_line_ctrl(struct cardstate *cs, unsigned cflag)
{
	return -EINVAL;
}
static int gigaset_write_room(struct cardstate *cs)
{
	return IF_WRITEBUF;
}
static int gigaset_chars_in_buffer(struct cardstate *cs)
{
	return cs->cmdbytes;
}
static int gigaset_brkchars(struct cardstate *cs, const unsigned char buf[6])
{
	return -EINVAL;
}
static int gigaset_pre_reset(struct usb_interface *intf)
{
	return gigaset_suspend(intf, PMSG_ON);
}
static int gigaset_post_reset(struct usb_interface *intf)
{
	return gigaset_resume(intf);
}
static void clear_at_state(struct at_state_t *at_state)
{
	free_strings(at_state);
}
static void free_cs(struct cardstate *cs)
{
	cs->flags = 0;
}
void gigaset_blockdriver(struct gigaset_driver *drv)
{
	drv->blocked = 1;
}
static int gigaset_chars_in_buffer(struct cardstate *cs)
{
	return cs->cmdbytes;
}
static int gigaset_brkchars(struct cardstate *cs, const unsigned char buf[6])
{
	return -EINVAL;
}
static int gigaset_freebcshw(struct bc_state *bcs)
{
	return 1;
}
static int gigaset_baud_rate(struct cardstate *cs, unsigned cflag)
{
	return -EINVAL;
}
static int gigaset_set_line_ctrl(struct cardstate *cs, unsigned cflag)
{
	return -EINVAL;
}
static ssize_t
gigaset_tty_read(struct tty_struct *tty, struct file *file,
		 unsigned char __user *buf, size_t count)
{
	return -EAGAIN;
}
static ssize_t
gigaset_tty_write(struct tty_struct *tty, struct file *file,
		  const unsigned char *buf, size_t count)
{
	return -EAGAIN;
}
static inline unsigned tiocm_to_gigaset(unsigned state)
{
	return ((state & TIOCM_DTR) ? 1 : 0) | ((state & TIOCM_RTS) ? 2 : 0);
}
static int gigaset_set_modem_ctrl(struct cardstate *cs, unsigned old_state,
				  unsigned new_state)
{
	return -EINVAL;
}
static int gigaset_set_line_ctrl(struct cardstate *cs, unsigned cflag)
{
	return -EINVAL;
}
static int gigaset_baud_rate(struct cardstate *cs, unsigned cflag)
{
	return -EINVAL;
}
static int gigaset_chars_in_buffer(struct cardstate *cs)
{
	return cs->cmdbytes;
}
static int gigaset_freebcshw(struct bc_state *bcs)
{
	return 1;
}
static int gigaset_pre_reset(struct usb_interface *intf)
{
	return gigaset_suspend(intf, PMSG_ON);
}
static int __init avmcs_init(void)
{
	return pcmcia_register_driver(&avmcs_driver);
}
static void __exit avmcs_exit(void)
{
	pcmcia_unregister_driver(&avmcs_driver);
}
static inline void b1dma_writel(avmcard *card, u32 value, int off)
{
	writel(value, card->mbase + off);
}
static inline u32 b1dma_readl(avmcard *card, int off)
{
	return readl(card->mbase + off);
}
static inline int b1dma_tx_empty(unsigned int port)
{
	return inb(port + 0x03) & 0x1;
}
static inline int b1dma_rx_full(unsigned int port)
{
	return inb(port + 0x02) & 0x1;
}
int b1pcmcia_addcard_b1(unsigned int port, unsigned irq)
{
	return b1pcmcia_add_card(port, irq, avm_b1pcmcia);
}
int b1pcmcia_addcard_m1(unsigned int port, unsigned irq)
{
	return b1pcmcia_add_card(port, irq, avm_m1);
}
int b1pcmcia_addcard_m2(unsigned int port, unsigned irq)
{
	return b1pcmcia_add_card(port, irq, avm_m2);
}
static void __exit b1pcmcia_exit(void)
{
	unregister_capi_driver(&capi_driver_b1pcmcia);
}
static char *diva_procinfo(struct capi_ctr *ctrl)
{
	return (ctrl->serial);
}
void *ReceiveBufferGet(APPL * appl, int Num)
{
	return &appl->ReceiveBuffer[Num * appl->MaxDataLength];
}
int fax_head_line_time(char *buffer)
{
	return (0);
}
void diva_os_free_message_buffer(diva_os_message_buffer_s * dmb)
{
	kfree_skb(dmb);
}
void diva_didd_load_time_finit (void) {
 diva_os_destroy_spin_lock (&didd_spin, "didd");
}
void IDI_CALL_LINK_T DIVA_DIDD_Read (void IDI_CALL_ENTITY_T * buffer,
                   int length) {
 diva_didd_read_adapter_array (buffer, length);
}
dword diva_dbg_q_length (void) {
	return (dbg_queue ? queueCount(dbg_queue)	: 0);
}
static void DI_format_locked (unsigned short id,
                       int type,
                       char *format,
                       va_list argument_list) {
  DI_format (1, id, type, format, argument_list);
}
int SuperTraceCloseAdapter  (void* AdapterHandle) {
  return (0);
}
static void single_p (byte * P, word * PLength, byte Id) {
  P[(*PLength)++] = Id;
}
static void diva_maint_error (void* user_context,
                              diva_strace_library_interface_t* hLib,
                              int Adapter,
                              int error,
                              const char* file,
                              int line) {
	diva_mnt_internal_dprintf (0, DLI_ERR,
                             "Trace library error(%d) A(%d) %s %d", error, Adapter, file, line);
}
void
DbgSetLevel (unsigned long dbgMask)
{
 myDriverDebugHandle.dbgMask = dbgMask | (DL_EVL | DL_FTL | DL_LOG) ;
}
byte scom_test_int(ADAPTER * a)
{
  return a->ram_in(a,(void *)0x3fe);
}
void scom_clear_int(ADAPTER * a)
{
  a->ram_out(a,(void *)0x3fe,0);
}
static void xdi_xlog (byte *msg, word code, int length) {
  xdi_dbg_xlog ("\x00\x02", msg, code, length);
}
void diva_free_dma_map_entry (struct _diva_dma_map_entry* pmap, int nr) {
  pmap[nr].busy = 0;
}
void* diva_get_entry_handle (struct _diva_dma_map_entry* pmap, int nr) {
  return (pmap[nr].addr_handle);
}
int diva_os_copy_to_user(void *os_handle, void __user *dst, const void *src,
			 int length)
{
	return (copy_to_user(dst, src, length));
}
int diva_os_copy_from_user(void *os_handle, void *dst, const void __user *src,
			   int length)
{
	return (copy_from_user(dst, src, length));
}
static ssize_t divas_maint_write(struct file *file, const char __user *buf,
				 size_t count, loff_t * ppos)
{
	return (maint_read_write((char __user *) buf, (int) count));
}
static ssize_t divas_maint_read(struct file *file, char __user *buf,
				size_t count, loff_t * ppos)
{
	return (maint_read_write(buf, (int) count));
}
static void divas_maint_unregister_chrdev(void)
{
	unregister_chrdev(major, DEVNAME);
}
void diva_maint_wakeup_read(void)
{
	wake_up_interruptible(&msgwaitq);
}
static void divas_idi_unregister_chrdev(void)
{
	unregister_chrdev(major, DEVNAME);
}
int diva_os_get_context_size(void)
{
	return (sizeof(diva_um_idi_os_context_t));
}
byte __inline__ inpp(void __iomem *addr)
{
	return (inb((unsigned long) addr));
}
word __inline__ inppw(void __iomem *addr)
{
	return (inw((unsigned long) addr));
}
void __inline__ inppw_buffer(void __iomem *addr, void *P, int length)
{
	insw((unsigned long) addr, (word *) P, length >> 1);
}
void __inline__ outppw_buffer(void __iomem *addr, void *P, int length)
{
	outsw((unsigned long) addr, (word *) P, length >> 1);
}
void __inline__ outppw(void __iomem *addr, word w)
{
	outw(w, (unsigned long) addr);
}
void __inline__ outpp(void __iomem *addr, word p)
{
	outb(p, (unsigned long) addr);
}
void diva_os_remove_irq(void *context, byte irq)
{
	free_irq(irq, context);
}
int diva_os_cancel_soft_isr(diva_os_soft_isr_t * psoft_isr)
{
	return (0);
}
static void divas_unregister_chrdev(void)
{
	unregister_chrdev(major, DEVNAME);
}
static ssize_t
divas_write(struct file *file, const char __user *buf, size_t count, loff_t * off)
{
	return (-ENODEV);
}
static unsigned int divas_poll(struct file *file, poll_table * wait)
{
	return (POLLERR);
}
static int divas_open(struct inode *inode, struct file *file)
{
	return nonseekable_open(inode, file);
}
static int divas_close(struct inode *inode, struct file *file)
{
	return (0);
}
int diva_data_q_get_max_length(const diva_um_idi_data_queue_t * q)
{
	return (q->max_length);
}
int diva_data_q_get_segment_length(const diva_um_idi_data_queue_t * q)
{
	return (q->length[q->read]);
}
void * PTR_X(ADAPTER * a, ENTITY * e)
{
  return ((void *) e->X);
}
void * PTR_R(ADAPTER * a, ENTITY * e)
{
  return ((void *) e->R);
}
void * PTR_P(ADAPTER * a, ENTITY * e, void * P)
{
  return P;
}
void diva_xdi_provide_istream_info (ADAPTER* a,
                  diva_xdi_stream_interface_t* pi) {
  pi->provided_service = 0;
}
static int load_qBri_hardware (PISDN_ADAPTER IoAdapter) {
	return (0);
}
static int load_bri_hardware (PISDN_ADAPTER IoAdapter) {
 return (0);
}
static dword pri_ram_offset (ADAPTER* a) {
 return ((dword)MP_SHARED_RAM_OFFSET);
}
static int load_pri_hardware (PISDN_ADAPTER IoAdapter) {
 return (0);
}
void *diva_um_id_get_os_context(void *entity)
{
	return (((divas_um_idi_entity_t *) entity)->os_context);
}
static void
HFC_outb_pcimem(struct hfc_multi *hc, u_char reg, u_char val,
		const char *function, int line)
{
	writeb(val, (hc->pci_membase)+reg);
}
static u_char
HFC_inb_pcimem(struct hfc_multi *hc, u_char reg, const char *function, int line)
{
	return readb((hc->pci_membase)+reg);
}
static u_short
HFC_inw_pcimem(struct hfc_multi *hc, u_char reg, const char *function, int line)
{
	return readw((hc->pci_membase)+reg);
}
inline void
enablepcibridge(struct hfc_multi *c)
{
	HFC_outb(c, R_BRG_PCM_CFG, (0x0 << 6) | 0x3); /* was _io before */
}
inline void
disablepcibridge(struct hfc_multi *c)
{
	HFC_outb(c, R_BRG_PCM_CFG, (0x0 << 6) | 0x2); /* was _io before */
}
inline void
cpld_set_reg(struct hfc_multi *hc, unsigned char reg)
{
	HFC_outb(hc, R_GPIO_OUT1, reg);
}
static void
hfcpci_Timer(struct hfc_pci *hc)
{
	hc->hw.timer.expires = jiffies + 75;
}
static struct bchannel *
Sel_BCS(struct hfc_pci *hc, int channel)
{
	if (test_bit(FLG_ACTIVE, &hc->bch[0].Flags) &&
		(hc->bch[0].nr & channel))
		return &hc->bch[0];
	else if (test_bit(FLG_ACTIVE, &hc->bch[1].Flags) &&
		(hc->bch[1].nr & channel))
		return &hc->bch[1];
	else
		return NULL;
}
static void
arcofi_timer(struct IsdnCardState *cs) {
	arcofi_fsm(cs, ARCOFI_TIMEOUT, NULL);
}
static u_char
ReadISAC(struct IsdnCardState *cs, u_char offset)
{
	return (readreg(cs->hw.asus.adr, cs->hw.asus.isac, offset));
}
static void
WriteISAC(struct IsdnCardState *cs, u_char offset, u_char value)
{
	writereg(cs->hw.asus.adr, cs->hw.asus.isac, offset, value);
}
static void
ReadISACfifo(struct IsdnCardState *cs, u_char * data, int size)
{
	readfifo(cs->hw.asus.adr, cs->hw.asus.isac, 0, data, size);
}
static void
WriteISACfifo(struct IsdnCardState *cs, u_char * data, int size)
{
	writefifo(cs->hw.asus.adr, cs->hw.asus.isac, 0, data, size);
}
static u_char
ReadISAC_IPAC(struct IsdnCardState *cs, u_char offset)
{
	return (readreg(cs->hw.asus.adr, cs->hw.asus.isac, offset|0x80));
}
static void
WriteISAC_IPAC(struct IsdnCardState *cs, u_char offset, u_char value)
{
	writereg(cs->hw.asus.adr, cs->hw.asus.isac, offset|0x80, value);
}
static void
ReadISACfifo_IPAC(struct IsdnCardState *cs, u_char * data, int size)
{
	readfifo(cs->hw.asus.adr, cs->hw.asus.isac, 0x80, data, size);
}
static void
WriteISACfifo_IPAC(struct IsdnCardState *cs, u_char * data, int size)
{
	writefifo(cs->hw.asus.adr, cs->hw.asus.isac, 0x80, data, size);
}
static u_char
ReadHSCX(struct IsdnCardState *cs, int hscx, u_char offset)
{
	return (readreg(cs->hw.asus.adr,
			cs->hw.asus.hscx, offset + (hscx ? 0x40 : 0)));
}
static void
WriteHSCX(struct IsdnCardState *cs, int hscx, u_char offset, u_char value)
{
	writereg(cs->hw.asus.adr,
		 cs->hw.asus.hscx, offset + (hscx ? 0x40 : 0), value);
}
static inline u_char
readreg(unsigned int adr, u_char off)
{
	return (bytein(adr + off));
}
static inline void
writereg(unsigned int adr, u_char off, u_char data)
{
	byteout(adr + off, data);
}
static inline void
read_fifo(unsigned int adr, u_char * data, int size)
{
	insb(adr, data, size);
}
static void
write_fifo(unsigned int adr, u_char * data, int size)
{
	outsb(adr, data, size);
}
static u_char
ReadISAC(struct IsdnCardState *cs, u_char offset)
{
	return (readreg(cs->hw.avm.isac, offset));
}
static void
WriteISAC(struct IsdnCardState *cs, u_char offset, u_char value)
{
	writereg(cs->hw.avm.isac, offset, value);
}
static void
ReadISACfifo(struct IsdnCardState *cs, u_char * data, int size)
{
	read_fifo(cs->hw.avm.isacfifo, data, size);
}
static void
WriteISACfifo(struct IsdnCardState *cs, u_char * data, int size)
{
	write_fifo(cs->hw.avm.isacfifo, data, size);
}
static u_char
ReadHSCX(struct IsdnCardState *cs, int hscx, u_char offset)
{
	return (readreg(cs->hw.avm.hscx[hscx], offset));
}
static void
WriteHSCX(struct IsdnCardState *cs, int hscx, u_char offset, u_char value)
{
	writereg(cs->hw.avm.hscx[hscx], offset, value);
}
static u_char
ReadHDLC_s(struct IsdnCardState *cs, int chan, u_char offset)
{
	return(0xff & ReadHDLCPCI(cs, chan, offset));
}
static void
WriteHDLC_s(struct IsdnCardState *cs, int chan, u_char offset, u_char value)
{
	WriteHDLCPCI(cs, chan, offset, value);
}
static inline
struct BCState *Sel_BCS(struct IsdnCardState *cs, int channel)
{
	if (cs->bcs[0].mode && (cs->bcs[0].channel == channel))
		return(&cs->bcs[0]);
	else if (cs->bcs[1].mode && (cs->bcs[1].channel == channel))
		return(&cs->bcs[1]);
	else
		return(NULL);
}
static int __devinit avm_pnp_setup(struct IsdnCardState *cs)
{
	return(1);	/* no-op: success */
}
static int __devinit avm_pci_setup(struct IsdnCardState *cs)
{
	return(1);	/* no-op: success */
}
static int __init init_avma1_cs(void)
{
	return(pcmcia_register_driver(&avma1cs_driver));
}
static void __exit exit_avma1_cs(void)
{
	pcmcia_unregister_driver(&avma1cs_driver);
}
static u_char
ReadISAC(struct IsdnCardState *cs, u_char offset)
{
	return (readreg(cs->hw.ax.isac_ale, cs->hw.ax.isac_adr, offset));
}
static void
WriteISAC(struct IsdnCardState *cs, u_char offset, u_char value)
{
	writereg(cs->hw.ax.isac_ale, cs->hw.ax.isac_adr, offset, value);
}
static void
ReadISACfifo(struct IsdnCardState *cs, u_char * data, int size)
{
	readfifo(cs->hw.ax.isac_ale, cs->hw.ax.isac_adr, 0, data, size);
}
static void
WriteISACfifo(struct IsdnCardState *cs, u_char * data, int size)
{
	writefifo(cs->hw.ax.isac_ale, cs->hw.ax.isac_adr, 0, data, size);
}
static u_char
ReadJADE(struct IsdnCardState *cs, int jade, u_char offset)
{
	return (readreg(cs->hw.ax.jade_ale, cs->hw.ax.jade_adr, offset + (jade == -1 ? 0 : (jade ? 0xC0 : 0x80))));
}
static void
WriteJADE(struct IsdnCardState *cs, int jade, u_char offset, u_char value)
{
	writereg(cs->hw.ax.jade_ale, cs->hw.ax.jade_adr, offset + (jade == -1 ? 0 : (jade ? 0xC0 : 0x80)), value);
}
static u_char
ReadISAC(struct IsdnCardState *cs, u_char offset)
{
	return (readreg(cs->hw.ax.base, cs->hw.ax.data_adr, offset | 0x80));
}
static void
WriteISAC(struct IsdnCardState *cs, u_char offset, u_char value)
{
	writereg(cs->hw.ax.base, cs->hw.ax.data_adr, offset | 0x80, value);
}
static void
ReadISACfifo(struct IsdnCardState *cs, u_char * data, int size)
{
	readfifo(cs->hw.ax.base, cs->hw.ax.data_adr, 0x80, data, size);
}
static void
WriteISACfifo(struct IsdnCardState *cs, u_char * data, int size)
{
	writefifo(cs->hw.ax.base, cs->hw.ax.data_adr, 0x80, data, size);
}
static u_char
ReadHSCX(struct IsdnCardState *cs, int hscx, u_char offset)
{
	return (readreg(cs->hw.ax.base, cs->hw.ax.data_adr, offset + (hscx ? 0x40 : 0)));
}
static void
WriteHSCX(struct IsdnCardState *cs, int hscx, u_char offset, u_char value)
{
	writereg(cs->hw.ax.base, cs->hw.ax.data_adr, offset + (hscx ? 0x40 : 0), value);
}
static void
set_ipac_active(struct IsdnCardState *cs, u_int active)
{
	writereg(cs->hw.ax.base, cs->hw.ax.data_adr, IPAC_MASK,
		active ? 0xc0 : 0xff);
}
static void
lli_error(struct FsmInst *fi, int event, void *arg)
{
	FsmChangeState(fi, ST_WAIT_DRELEASE);
}
void
CallcFree(void)
{
	FsmFree(&callcfsm);
}
static void
dummy_pstack(struct PStack *st, int pr, void *arg) {
	printk(KERN_WARNING"call to dummy_pstack pr=%04x arg %lx\n", pr, (long)arg);
}
static int hisax_setup_card_dynamic(struct IsdnCard *card)
{
	return 2;
}
static int hisax_cardmsg(struct IsdnCardState *cs, int mt, void *arg)
{
	return 0;
}
static inline u_char
memreadreg(unsigned long adr, u_char off)
{
	return(*((unsigned char *)
		(((unsigned int *)adr) + off)));
}
static u_char
ReadISAC(struct IsdnCardState *cs, u_char offset)
{
	return(readreg(cs->hw.diva.isac_adr, cs->hw.diva.isac, offset));
}
static void
WriteISAC(struct IsdnCardState *cs, u_char offset, u_char value)
{
	writereg(cs->hw.diva.isac_adr, cs->hw.diva.isac, offset, value);
}
static void
ReadISACfifo(struct IsdnCardState *cs, u_char *data, int size)
{
	readfifo(cs->hw.diva.isac_adr, cs->hw.diva.isac, 0, data, size);
}
static void
WriteISACfifo(struct IsdnCardState *cs, u_char *data, int size)
{
	writefifo(cs->hw.diva.isac_adr, cs->hw.diva.isac, 0, data, size);
}
static u_char
ReadISAC_IPAC(struct IsdnCardState *cs, u_char offset)
{
	return (readreg(cs->hw.diva.isac_adr, cs->hw.diva.isac, offset+0x80));
}
static void
WriteISAC_IPAC(struct IsdnCardState *cs, u_char offset, u_char value)
{
	writereg(cs->hw.diva.isac_adr, cs->hw.diva.isac, offset|0x80, value);
}
static void
ReadISACfifo_IPAC(struct IsdnCardState *cs, u_char * data, int size)
{
	readfifo(cs->hw.diva.isac_adr, cs->hw.diva.isac, 0x80, data, size);
}
static void
WriteISACfifo_IPAC(struct IsdnCardState *cs, u_char * data, int size)
{
	writefifo(cs->hw.diva.isac_adr, cs->hw.diva.isac, 0x80, data, size);
}
static u_char
ReadHSCX(struct IsdnCardState *cs, int hscx, u_char offset)
{
	return(readreg(cs->hw.diva.hscx_adr,
		cs->hw.diva.hscx, offset + (hscx ? 0x40 : 0)));
}
static void
WriteHSCX(struct IsdnCardState *cs, int hscx, u_char offset, u_char value)
{
	writereg(cs->hw.diva.hscx_adr,
		cs->hw.diva.hscx, offset + (hscx ? 0x40 : 0), value);
}
static u_char
MemReadISAC_IPAC(struct IsdnCardState *cs, u_char offset)
{
	return (memreadreg(cs->hw.diva.cfg_reg, offset+0x80));
}
static void
MemWriteISAC_IPAC(struct IsdnCardState *cs, u_char offset, u_char value)
{
	memwritereg(cs->hw.diva.cfg_reg, offset|0x80, value);
}
static u_char
MemReadHSCX(struct IsdnCardState *cs, int hscx, u_char offset)
{
	return(memreadreg(cs->hw.diva.cfg_reg, offset + (hscx ? 0x40 : 0)));
}
static void
MemWriteHSCX(struct IsdnCardState *cs, int hscx, u_char offset, u_char value)
{
	memwritereg(cs->hw.diva.cfg_reg, offset + (hscx ? 0x40 : 0), value);
}
static u_char
MemReadISAC_IPACX(struct IsdnCardState *cs, u_char offset)
{
	return (memreadreg(cs->hw.diva.cfg_reg, offset));
}
static void
MemWriteISAC_IPACX(struct IsdnCardState *cs, u_char offset, u_char value)
{
	memwritereg(cs->hw.diva.cfg_reg, offset, value);
}
static u_char
MemReadHSCX_IPACX(struct IsdnCardState *cs, int hscx, u_char offset)
{
	return(memreadreg(cs->hw.diva.cfg_reg, offset + 
                    (hscx ? IPACX_OFF_B2 : IPACX_OFF_B1)));
}
static void
MemWriteHSCX_IPACX(struct IsdnCardState *cs, int hscx, u_char offset, u_char value)
{
	memwritereg(cs->hw.diva.cfg_reg, offset + 
              (hscx ? IPACX_OFF_B2 : IPACX_OFF_B1), value);
}
static int __devinit setup_diva_isa(struct IsdnCard *card)
{
	return (-1);	/* card not found; continue search */
}
static int __devinit setup_diva_isapnp(struct IsdnCard *card)
{
	return (-1);	/* card not found; continue search */
}
static int __devinit setup_diva_pci(struct IsdnCard *card)
{
	return (-1);	/* card not found; continue search */
}
static u_char
ReadISAC(struct IsdnCardState *cs, u_char offset)
{
	return (readreg(cs->hw.elsa.ale, cs->hw.elsa.isac, offset));
}
static void
WriteISAC(struct IsdnCardState *cs, u_char offset, u_char value)
{
	writereg(cs->hw.elsa.ale, cs->hw.elsa.isac, offset, value);
}
static void
ReadISACfifo(struct IsdnCardState *cs, u_char * data, int size)
{
	readfifo(cs->hw.elsa.ale, cs->hw.elsa.isac, 0, data, size);
}
static void
WriteISACfifo(struct IsdnCardState *cs, u_char * data, int size)
{
	writefifo(cs->hw.elsa.ale, cs->hw.elsa.isac, 0, data, size);
}
static u_char
ReadISAC_IPAC(struct IsdnCardState *cs, u_char offset)
{
	return (readreg(cs->hw.elsa.ale, cs->hw.elsa.isac, offset+0x80));
}
static void
WriteISAC_IPAC(struct IsdnCardState *cs, u_char offset, u_char value)
{
	writereg(cs->hw.elsa.ale, cs->hw.elsa.isac, offset|0x80, value);
}
static void
ReadISACfifo_IPAC(struct IsdnCardState *cs, u_char * data, int size)
{
	readfifo(cs->hw.elsa.ale, cs->hw.elsa.isac, 0x80, data, size);
}
static void
WriteISACfifo_IPAC(struct IsdnCardState *cs, u_char * data, int size)
{
	writefifo(cs->hw.elsa.ale, cs->hw.elsa.isac, 0x80, data, size);
}
static u_char
ReadHSCX(struct IsdnCardState *cs, int hscx, u_char offset)
{
	return (readreg(cs->hw.elsa.ale,
			cs->hw.elsa.hscx, offset + (hscx ? 0x40 : 0)));
}
static void
WriteHSCX(struct IsdnCardState *cs, int hscx, u_char offset, u_char value)
{
	writereg(cs->hw.elsa.ale,
		 cs->hw.elsa.hscx, offset + (hscx ? 0x40 : 0), value);
}
static int __devinit
setup_elsa_pci(struct IsdnCard *card)
{
	return (1);
}
static int __init init_elsa_cs(void)
{
	return pcmcia_register_driver(&elsa_cs_driver);
}
static void __exit exit_elsa_cs(void)
{
	pcmcia_unregister_driver(&elsa_cs_driver);
}
static unsigned char dummyrr(struct IsdnCardState *cs, int chan, unsigned char off)
{
        return(5);
}
void
FsmFree(struct Fsm *fsm)
{
	kfree((void *) fsm->jumpmatrix);
}
static inline u_char
readreg(unsigned int adr, u_short off)
{
	return bytein(adr + off);
}
static inline void
writereg(unsigned int adr, u_short off, u_char data)
{
	byteout(adr + off, data);
}
static inline void
read_fifo(unsigned int adr, u_char * data, int size)
{
	insb(adr, data, size);
}
static void
write_fifo(unsigned int adr, u_char * data, int size)
{
	outsb(adr, data, size);
}
static inline void
SetRegAddr(hfc4s8s_hw * a, u_char b)
{
	outb(b, (a->iobase) + 4);
}
static inline u_char
GetRegAddr(hfc4s8s_hw * a)
{
	return (inb((volatile u_int) (a->iobase + 4)));
}
static inline void
fWrite_hfc8(hfc4s8s_hw * a, u_char c)
{
	outb(c, a->iobase);
}
static inline void
fWrite_hfc32(hfc4s8s_hw * a, u_long c)
{
	outl(c, a->iobase);
}
static inline u_char
fRead_hfc8(hfc4s8s_hw * a)
{
	return (inb((volatile u_int) a->iobase));
}
static inline u_long
fRead_hfc32(hfc4s8s_hw * a)
{
	return (inl((volatile u_int) a->iobase));
}
static void
dummyf(struct IsdnCardState *cs, u_char * data, int size)
{
	printk(KERN_WARNING "HiSax: hfcd dummy fifo called\n");
}
static u_char
readreghfcd(struct IsdnCardState *cs, u_char offset)
{
	return(ReadReg(cs, HFCD_DATA, offset));
}
static void
writereghfcd(struct IsdnCardState *cs, u_char offset, u_char value)
{
	WriteReg(cs, HFCD_DATA, offset, value);
}
static 
struct BCState *Sel_BCS(struct IsdnCardState *cs, int channel)
{
	if (cs->bcs[0].mode && (cs->bcs[0].channel == channel))
		return(&cs->bcs[0]);
	else if (cs->bcs[1].mode && (cs->bcs[1].channel == channel))
		return(&cs->bcs[1]);
	else
		return(NULL);
}
static void
setstack_hfcd(struct PStack *st, struct IsdnCardState *cs)
{
	st->l1.l1hw = HFCD_l1hw;
}
static void
hfcpci_Timer(struct IsdnCardState *cs)
{
	cs->hw.hfcpci.timer.expires = jiffies + 75;
}
static
struct BCState *
Sel_BCS(struct IsdnCardState *cs, int channel)
{
	if (cs->bcs[0].mode && (cs->bcs[0].channel == channel))
		return (&cs->bcs[0]);
	else if (cs->bcs[1].mode && (cs->bcs[1].channel == channel))
		return (&cs->bcs[1]);
	else
		return (NULL);
}
static void
setstack_hfcpci(struct PStack *st, struct IsdnCardState *cs)
{
	st->l1.l1hw = HFCPCI_l1hw;
}
static void
hfcsx_Timer(struct IsdnCardState *cs)
{
	cs->hw.hfcsx.timer.expires = jiffies + 75;
}
static
struct BCState *
Sel_BCS(struct IsdnCardState *cs, int channel)
{
	if (cs->bcs[0].mode && (cs->bcs[0].channel == channel))
		return (&cs->bcs[0]);
	else if (cs->bcs[1].mode && (cs->bcs[1].channel == channel))
		return (&cs->bcs[1]);
	else
		return (NULL);
}
static void
setstack_hfcsx(struct PStack *st, struct IsdnCardState *cs)
{
	st->l1.l1hw = HFCSX_l1hw;
}
static void
hfcs_Timer(struct IsdnCardState *cs)
{
	cs->hw.hfcD.timer.expires = jiffies + 75;
}
static void l1_go_f3pdown(struct FsmInst *fi, int event, void *arg)
{
	FsmChangeState(fi, ST_L1_F3_PDOWN);
}
static void l1_go_f4(struct FsmInst *fi, int event, void *arg)
{
	FsmChangeState(fi, ST_L1_F4);
}
static void l1_go_f5(struct FsmInst *fi, int event, void *arg)
{
	FsmChangeState(fi, ST_L1_F5);
}
static void l1_go_f6(struct FsmInst *fi, int event, void *arg)
{
	FsmChangeState(fi, ST_L1_F6);
}
static void l1_go_f8(struct FsmInst *fi, int event, void *arg)
{
	FsmChangeState(fi, ST_L1_F8);
}
static void __exit hisax_isac_exit(void)
{
	FsmFree(&l1fsm);
}
static void
dch_setstack(struct PStack *st, struct IsdnCardState *cs)
{
	st->l1.l1hw = dch_l2l1;
}
static void
setstack_isac(struct PStack *st, struct IsdnCardState *cs)
{
	st->l1.l1hw = ISAC_l1hw;
}
static void
l1_reset(struct FsmInst *fi, int event, void *arg)
{
	FsmChangeState(fi, ST_L1_F3);
}
static void
l1_go_F5(struct FsmInst *fi, int event, void *arg)
{
	FsmChangeState(fi, ST_L1_F5);
}
static void
l1_go_F8(struct FsmInst *fi, int event, void *arg)
{
	FsmChangeState(fi, ST_L1_F8);
}
static void
l1_info0_ind(struct FsmInst *fi, int event, void *arg)
{
	FsmChangeState(fi, ST_L1_DEACT);
}
static inline void
freewin(struct PStack *st)
{
	freewin1(&st->l2);
}
static inline int
l2headersize(struct Layer2 *l2, int ui)
{
	return (((test_bit(FLG_MOD128, &l2->flag) && (!ui)) ? 2 : 1) +
		(test_bit(FLG_LAPD, &l2->flag) ? 2 : 1));
}
inline int
l2addrsize(struct Layer2 *l2)
{
	return (test_bit(FLG_LAPD, &l2->flag) ? 2 : 1);
}
static inline int
IsUI(u_char * data)
{
	return ((data[0] & 0xef) == UI);
}
static inline int
IsUA(u_char * data)
{
	return ((data[0] & 0xef) == UA);
}
static inline int
IsDM(u_char * data)
{
	return ((data[0] & 0xef) == DM);
}
static inline int
IsDISC(u_char * data)
{
	return ((data[0] & 0xef) == DISC);
}
static inline int
IsREJ(u_char * data, struct PStack *st)
{
	return (test_bit(FLG_MOD128, &st->l2.flag) ? data[0] == REJ : (data[0] & 0xf) == REJ);
}
static inline int
IsFRMR(u_char * data)
{
	return ((data[0] & 0xef) == FRMR);
}
static inline int
IsRNR(u_char * data, struct PStack *st)
{
	return (test_bit(FLG_MOD128, &st->l2.flag) ? data[0] == RNR : (data[0] & 0xf) == RNR);
}
static inline u_char
get_PollFlag(struct PStack * st, struct sk_buff * skb)
{
	return (skb->data[l2addrsize(&(st->l2))] & 0x10);
}
static void
l2_go_st3(struct FsmInst *fi, int event, void *arg)
{
	FsmChangeState(fi, ST_L2_3); 
}
void
setstack_transl2(struct PStack *st)
{
	st->l3.l3l2 = transl2_l3l2;
}
void
Isdnl2Free(void)
{
	FsmFree(&l2fsm);
}
static void
L3ExpireTimer(struct L3Timer *t)
{
	t->pc->st->lli.l4l3(t->pc->st, t->event, t->pc);
}
void
L3DelTimer(struct L3Timer *t)
{
	del_timer(&t->tl);
}
void
StopAllL3Timer(struct l3_process *pc)
{
	L3DelTimer(&pc->timer);
}
static void
isdnl3_trans(struct PStack *st, int pr, void *arg) {
	st->l3.l3l2(st, pr, arg);
}
void
Isdnl3Free(void)
{
	FsmFree(&l3fsm);
}
static u_char
ReadISAC(struct IsdnCardState *cs, u_char offset)
{
	return (readb(cs->hw.isurf.isac + offset));
}
static u_char
ReadISAR(struct IsdnCardState *cs, int mode, u_char offset)
{	
	return(readb(cs->hw.isurf.isar + offset));
}
static u_char
ReadISAC(struct IsdnCardState *cs, u_char offset)
{
	return (readreg(cs->hw.ix1.isac_ale, cs->hw.ix1.isac, offset));
}
static void
WriteISAC(struct IsdnCardState *cs, u_char offset, u_char value)
{
	writereg(cs->hw.ix1.isac_ale, cs->hw.ix1.isac, offset, value);
}
static void
ReadISACfifo(struct IsdnCardState *cs, u_char * data, int size)
{
	readfifo(cs->hw.ix1.isac_ale, cs->hw.ix1.isac, 0, data, size);
}
static void
WriteISACfifo(struct IsdnCardState *cs, u_char * data, int size)
{
	writefifo(cs->hw.ix1.isac_ale, cs->hw.ix1.isac, 0, data, size);
}
static u_char
ReadHSCX(struct IsdnCardState *cs, int hscx, u_char offset)
{
	return (readreg(cs->hw.ix1.hscx_ale,
			cs->hw.ix1.hscx, offset + (hscx ? 0x40 : 0)));
}
static void
WriteHSCX(struct IsdnCardState *cs, int hscx, u_char offset, u_char value)
{
	writereg(cs->hw.ix1.hscx_ale,
		 cs->hw.ix1.hscx, offset + (hscx ? 0x40 : 0), value);
}
static void
l3_1tr6_reset(struct l3_process *pc, u_char pr, void *arg)
{
	release_l3_process(pc);
}
static void
l3dss1_reset(struct l3_process *pc, u_char pr, void *arg)
{
	dss1_release_l3_process(pc);
}
static void
l3ni1_reset(struct l3_process *pc, u_char pr, void *arg)
{
	ni1_release_l3_process(pc);
}
static void l3ni1_spid_send( struct l3_process *pc, u_char pr, void *arg )
{
	l3ni1_SendSpid( pc, pr, arg, 20 );
}
void
setstack_manager(struct PStack *st)
{
	st->ma.layer = hisax_manager;
}
static u_char
ReadISAC(struct IsdnCardState *cs, u_char offset)
{
	return (readreg(cs->hw.mic.adr, cs->hw.mic.isac, offset));
}
static void
WriteISAC(struct IsdnCardState *cs, u_char offset, u_char value)
{
	writereg(cs->hw.mic.adr, cs->hw.mic.isac, offset, value);
}
static void
ReadISACfifo(struct IsdnCardState *cs, u_char * data, int size)
{
	readfifo(cs->hw.mic.adr, cs->hw.mic.isac, 0, data, size);
}
static void
WriteISACfifo(struct IsdnCardState *cs, u_char * data, int size)
{
	writefifo(cs->hw.mic.adr, cs->hw.mic.isac, 0, data, size);
}
static u_char
ReadHSCX(struct IsdnCardState *cs, int hscx, u_char offset)
{
	return (readreg(cs->hw.mic.adr,
			cs->hw.mic.hscx, offset + (hscx ? 0x40 : 0)));
}
static void
WriteHSCX(struct IsdnCardState *cs, int hscx, u_char offset, u_char value)
{
	writereg(cs->hw.mic.adr,
		 cs->hw.mic.hscx, offset + (hscx ? 0x40 : 0), value);
}
static u_char ReadISAC(struct IsdnCardState *cs, u_char offset)
{
	return readreg(cs->hw.niccy.isac_ale, cs->hw.niccy.isac, offset);
}
static void WriteISAC(struct IsdnCardState *cs, u_char offset, u_char value)
{
	writereg(cs->hw.niccy.isac_ale, cs->hw.niccy.isac, offset, value);
}
static void ReadISACfifo(struct IsdnCardState *cs, u_char * data, int size)
{
	readfifo(cs->hw.niccy.isac_ale, cs->hw.niccy.isac, 0, data, size);
}
static void WriteISACfifo(struct IsdnCardState *cs, u_char * data, int size)
{
	writefifo(cs->hw.niccy.isac_ale, cs->hw.niccy.isac, 0, data, size);
}
static u_char ReadHSCX(struct IsdnCardState *cs, int hscx, u_char offset)
{
	return readreg(cs->hw.niccy.hscx_ale,
			cs->hw.niccy.hscx, offset + (hscx ? 0x40 : 0));
}
static void WriteHSCX(struct IsdnCardState *cs, int hscx, u_char offset,
		u_char value)
{
	writereg(cs->hw.niccy.hscx_ale,
		 cs->hw.niccy.hscx, offset + (hscx ? 0x40 : 0), value);
}
static u_char dummyrr(struct IsdnCardState *cs, int chan, u_char off)
{
	return(5);
}
static u_char dummyrr(struct IsdnCardState *cs, int chan, u_char off)
{
	return(5);
}
static u_char
ReadISAC(struct IsdnCardState *cs, u_char offset)
{
	return (readreg(cs->hw.teles3.cfg_reg, cs->hw.teles3.isac, offset));
}
static void
WriteISAC(struct IsdnCardState *cs, u_char offset, u_char value)
{
	writereg(cs->hw.teles3.cfg_reg, cs->hw.teles3.isac, offset, value);
}
static void
ReadISACfifo(struct IsdnCardState *cs, u_char * data, int size)
{
	read_fifo(cs->hw.teles3.cfg_reg, cs->hw.teles3.isacfifo, data, size);
}
static void
WriteISACfifo(struct IsdnCardState *cs, u_char * data, int size)
{
	write_fifo(cs->hw.teles3.cfg_reg, cs->hw.teles3.isacfifo, data, size);
}
static u_char
ReadHSCX(struct IsdnCardState *cs, int hscx, u_char offset)
{
	return (readreg(cs->hw.teles3.cfg_reg, cs->hw.teles3.hscx[hscx], offset));
}
static void
WriteHSCX(struct IsdnCardState *cs, int hscx, u_char offset, u_char value)
{
	writereg(cs->hw.teles3.cfg_reg, cs->hw.teles3.hscx[hscx], offset, value);
}
static void
release_io_s0box(struct IsdnCardState *cs)
{
	release_region(cs->hw.teles3.cfg_reg, 8);
}
static u_char
ReadISAC(struct IsdnCardState *cs, u_char offset)
{
	return (readreg(cs->hw.saphir.ale, cs->hw.saphir.isac, offset));
}
static void
WriteISAC(struct IsdnCardState *cs, u_char offset, u_char value)
{
	writereg(cs->hw.saphir.ale, cs->hw.saphir.isac, offset, value);
}
static void
ReadISACfifo(struct IsdnCardState *cs, u_char * data, int size)
{
	readfifo(cs->hw.saphir.ale, cs->hw.saphir.isac, 0, data, size);
}
static void
WriteISACfifo(struct IsdnCardState *cs, u_char * data, int size)
{
	writefifo(cs->hw.saphir.ale, cs->hw.saphir.isac, 0, data, size);
}
static u_char
ReadHSCX(struct IsdnCardState *cs, int hscx, u_char offset)
{
	return (readreg(cs->hw.saphir.ale, cs->hw.saphir.hscx,
		offset + (hscx ? 0x40 : 0)));
}
static void
WriteHSCX(struct IsdnCardState *cs, int hscx, u_char offset, u_char value)
{
	writereg(cs->hw.saphir.ale, cs->hw.saphir.hscx,
		offset + (hscx ? 0x40 : 0), value);
}
static u_char
ReadISAC(struct IsdnCardState *cs, u_char offset)
{
	return (readreg(cs->hw.sedl.adr, cs->hw.sedl.isac, offset));
}
static void
WriteISAC(struct IsdnCardState *cs, u_char offset, u_char value)
{
	writereg(cs->hw.sedl.adr, cs->hw.sedl.isac, offset, value);
}
static void
ReadISACfifo(struct IsdnCardState *cs, u_char * data, int size)
{
	readfifo(cs->hw.sedl.adr, cs->hw.sedl.isac, 0, data, size);
}
static void
WriteISACfifo(struct IsdnCardState *cs, u_char * data, int size)
{
	writefifo(cs->hw.sedl.adr, cs->hw.sedl.isac, 0, data, size);
}
static u_char
ReadISAC_IPAC(struct IsdnCardState *cs, u_char offset)
{
	return (readreg(cs->hw.sedl.adr, cs->hw.sedl.isac, offset|0x80));
}
static void
WriteISAC_IPAC(struct IsdnCardState *cs, u_char offset, u_char value)
{
	writereg(cs->hw.sedl.adr, cs->hw.sedl.isac, offset|0x80, value);
}
static void
ReadISACfifo_IPAC(struct IsdnCardState *cs, u_char * data, int size)
{
	readfifo(cs->hw.sedl.adr, cs->hw.sedl.isac, 0x80, data, size);
}
static void
WriteISACfifo_IPAC(struct IsdnCardState *cs, u_char * data, int size)
{
	writefifo(cs->hw.sedl.adr, cs->hw.sedl.isac, 0x80, data, size);
}
static u_char
ReadHSCX(struct IsdnCardState *cs, int hscx, u_char offset)
{
	return (readreg(cs->hw.sedl.adr,
			cs->hw.sedl.hscx, offset + (hscx ? 0x40 : 0)));
}
static void
WriteHSCX(struct IsdnCardState *cs, int hscx, u_char offset, u_char value)
{
	writereg(cs->hw.sedl.adr,
		 cs->hw.sedl.hscx, offset + (hscx ? 0x40 : 0), value);
}
static int __devinit
setup_sedlbauer_isapnp(struct IsdnCard *card, int *bytecnt)
{
	return -1;
}
static int __devinit
setup_sedlbauer_pci(struct IsdnCard *card)
{
	return (1);
}
static int __init init_sedlbauer_cs(void)
{
	return pcmcia_register_driver(&sedlbauer_driver);
}
static void __exit exit_sedlbauer_cs(void)
{
	pcmcia_unregister_driver(&sedlbauer_driver);
}
static inline int
calc_off(unsigned int base, unsigned int off)
{
	return(base + ((off & 0xfc)<<8) + ((off & 3)<<1));
}
static inline void
read_fifo(unsigned int adr, u_char * data, int size)
{
	insb(adr, data, size);
}
static void
write_fifo(unsigned int adr, u_char * data, int size)
{
	outsb(adr, data, size);
}
static u_char
ReadISAC(struct IsdnCardState *cs, u_char offset)
{
	return (bytein(calc_off(cs->hw.spt.isac, offset)));
}
static void
WriteISAC(struct IsdnCardState *cs, u_char offset, u_char value)
{
	byteout(calc_off(cs->hw.spt.isac, offset), value);
}
static void
ReadISACfifo(struct IsdnCardState *cs, u_char * data, int size)
{
	read_fifo(cs->hw.spt.isac, data, size);
}
static void
WriteISACfifo(struct IsdnCardState *cs, u_char * data, int size)
{
	write_fifo(cs->hw.spt.isac, data, size);
}
static u_char
ReadHSCX(struct IsdnCardState *cs, int hscx, u_char offset)
{
	return (bytein(calc_off(cs->hw.spt.hscx[hscx], offset)));
}
static void
WriteHSCX(struct IsdnCardState *cs, int hscx, u_char offset, u_char value)
{
	byteout(calc_off(cs->hw.spt.hscx[hscx], offset), value);
}
void st5481_usb_device_ctrl_msg(struct st5481_adapter *adapter,
			 u8 request, u16 value,
			 ctrl_complete_t complete, void *context)
{
	usb_ctrl_msg(adapter, request, 
		     USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE, 
		     value, 0, complete, context);
}
void
TeiFree(void)
{
	FsmFree(&teifsm);
}
static inline u_char
readisac(void __iomem *adr, u_char off)
{
	return readb(adr + ((off & 1) ? 0x2ff : 0x100) + off);
}
static inline u_char
readhscx(void __iomem *adr, int hscx, u_char off)
{
	return readb(adr + (hscx ? 0x1c0 : 0x180) +
		     ((off & 1) ? 0x1ff : 0) + off);
}
static u_char
ReadISAC(struct IsdnCardState *cs, u_char offset)
{
	return (readisac(cs->hw.teles0.membase, offset));
}
static void
WriteISAC(struct IsdnCardState *cs, u_char offset, u_char value)
{
	writeisac(cs->hw.teles0.membase, offset, value);
}
static void
ReadISACfifo(struct IsdnCardState *cs, u_char * data, int size)
{
	read_fifo_isac(cs->hw.teles0.membase, data, size);
}
static void
WriteISACfifo(struct IsdnCardState *cs, u_char * data, int size)
{
	write_fifo_isac(cs->hw.teles0.membase, data, size);
}
static u_char
ReadHSCX(struct IsdnCardState *cs, int hscx, u_char offset)
{
	return (readhscx(cs->hw.teles0.membase, hscx, offset));
}
static void
WriteHSCX(struct IsdnCardState *cs, int hscx, u_char offset, u_char value)
{
	writehscx(cs->hw.teles0.membase, hscx, offset, value);
}
static inline u_char
readreg(unsigned int adr, u_char off)
{
	return (bytein(adr + off));
}
static inline void
writereg(unsigned int adr, u_char off, u_char data)
{
	byteout(adr + off, data);
}
static inline void
read_fifo(unsigned int adr, u_char * data, int size)
{
	insb(adr, data, size);
}
static void
write_fifo(unsigned int adr, u_char * data, int size)
{
	outsb(adr, data, size);
}
static u_char
ReadISAC(struct IsdnCardState *cs, u_char offset)
{
	return (readreg(cs->hw.teles3.isac, offset));
}
static void
WriteISAC(struct IsdnCardState *cs, u_char offset, u_char value)
{
	writereg(cs->hw.teles3.isac, offset, value);
}
static void
ReadISACfifo(struct IsdnCardState *cs, u_char * data, int size)
{
	read_fifo(cs->hw.teles3.isacfifo, data, size);
}
static void
WriteISACfifo(struct IsdnCardState *cs, u_char * data, int size)
{
	write_fifo(cs->hw.teles3.isacfifo, data, size);
}
static u_char
ReadHSCX(struct IsdnCardState *cs, int hscx, u_char offset)
{
	return (readreg(cs->hw.teles3.hscx[hscx], offset));
}
static void
WriteHSCX(struct IsdnCardState *cs, int hscx, u_char offset, u_char value)
{
	writereg(cs->hw.teles3.hscx[hscx], offset, value);
}
static int __init init_teles_cs(void)
{
	return pcmcia_register_driver(&teles_cs_driver);
}
static void __exit exit_teles_cs(void)
{
	pcmcia_unregister_driver(&teles_cs_driver);
}
static u_char
ReadISAC(struct IsdnCardState *cs, u_char offset)
{
	return (readisac(cs->hw.teles0.membase, offset));
}
static void
WriteISAC(struct IsdnCardState *cs, u_char offset, u_char value)
{
	writeisac(cs->hw.teles0.membase, offset, value);
}
static void
ReadISACfifo(struct IsdnCardState *cs, u_char * data, int size)
{
	read_fifo_isac(cs->hw.teles0.membase, data, size);
}
static void
WriteISACfifo(struct IsdnCardState *cs, u_char * data, int size)
{
	write_fifo_isac(cs->hw.teles0.membase, data, size);
}
static u_char
ReadHSCX(struct IsdnCardState *cs, int hscx, u_char offset)
{
	return (readhscx(cs->hw.teles0.membase, hscx, offset));
}
static void
WriteHSCX(struct IsdnCardState *cs, int hscx, u_char offset, u_char value)
{
	writehscx(cs->hw.teles0.membase, hscx, offset, value);
}
static void
release_io_telespci(struct IsdnCardState *cs)
{
	iounmap(cs->hw.teles0.membase);
}
static void
setstack_W6692(struct PStack *st, struct IsdnCardState *cs)
{
	st->l1.l1hw = W6692_l1hw;
}
static u_char
ReadW6692(struct IsdnCardState *cs, u_char offset)
{
	return (inb(cs->hw.w6692.iobase + offset));
}
static void
WriteW6692(struct IsdnCardState *cs, u_char offset, u_char value)
{
	outb(value, cs->hw.w6692.iobase + offset);
}
static void
ReadISACfifo(struct IsdnCardState *cs, u_char * data, int size)
{
	insb(cs->hw.w6692.iobase + W_D_RFIFO, data, size);
}
static void
WriteISACfifo(struct IsdnCardState *cs, u_char * data, int size)
{
	outsb(cs->hw.w6692.iobase + W_D_XFIFO, data, size);
}
static u_char
ReadW6692B(struct IsdnCardState *cs, int bchan, u_char offset)
{
	return (inb(cs->hw.w6692.iobase + (bchan ? 0x40 : 0) + offset));
}
static void
WriteW6692B(struct IsdnCardState *cs, int bchan, u_char offset, u_char value)
{
	outb(value, cs->hw.w6692.iobase + (bchan ? 0x40 : 0) + offset);
}
/*****************************************************/
static void
StartDecryption(struct boot_data *boot)
{
	boot->Cryptor = CRYPT_STARTTERM;
}				/* StartDecryption */
void
isdn_audio_ulaw2alaw(unsigned char *buff, unsigned long len)
{
	isdn_audio_tlookup(isdn_audio_ulaw_to_alaw, buff, len);
}
void
isdn_audio_alaw2ulaw(unsigned char *buff, unsigned long len)
{
	isdn_audio_tlookup(isdn_audio_alaw_to_ulaw, buff, len);
}
static void bsd_incomp (void *state, struct sk_buff *skb_in,int proto)
{
	bsd_compress (state, skb_in, NULL, proto);
}
static void __exit isdn_bsdcomp_exit(void)
{
	isdn_ppp_unregister_compressor (&ippp_bsd_compress);
}
static inline int
isdn_minor2drv(int minor)
{
	return (dev->drvmap[minor]);
}
static inline int
isdn_minor2chan(int minor)
{
	return (dev->chanmap[minor]);
}
static __inline__ void isdn_net_zero_frame_cnt(isdn_net_local *lp)
{
	atomic_set(&lp->frame_cnt, 0);
}
static void isdn_net_lp_disconnected(isdn_net_local *lp)
{
	isdn_net_rm_from_bundle(lp);
}
static void 
isdn_net_ciscohdlck_disconnected(isdn_net_local *lp)
{
	del_timer(&lp->cisco_timer);
}
int
isdn_tty_capi_facility(capi_msg *cm) {
	return(-1); /* dummy */
}
static void
isdn_tty_off_hook(void)
{
	printk(KERN_DEBUG "isdn_tty_off_hook\n");
}
static void illegal_state_warn( unsigned state, unsigned char firstbyte) 
{
	printk( KERN_WARNING "isdn_x25iface: firstbyte %x illegal in"
		"current state %d\n",firstbyte, state );
}
static inline void
icn_disable_ram(icn_card * card)
{
	OUTB_P(0, ICN_MAPRAM);
}
static inline void
icn_enable_ram(icn_card * card)
{
	OUTB_P(0xff, ICN_MAPRAM);
}
struct mISDNdevice
*get_mdevice(u_int id)
{
	return dev_to_mISDN(class_find_device(&mISDN_class, NULL, &id,
		_get_mdevice));
}
void
dsp_bf_cleanup(struct dsp *dsp)
{
	dsp->bf_enable = 0;
}
void dsp_hwec_exit(void)
{
	mISDN_dsp_element_unregister(dsp_hwec);
}
void
mISDN_FsmFree(struct Fsm *fsm)
{
	kfree((void *) fsm->jumpmatrix);
}
static void
l1_reset(struct FsmInst *fi, int event, void *arg)
{
	mISDN_FsmChangeState(fi, ST_L1_F3);
}
static void
l1_go_F5(struct FsmInst *fi, int event, void *arg)
{
	mISDN_FsmChangeState(fi, ST_L1_F5);
}
static void
l1_go_F8(struct FsmInst *fi, int event, void *arg)
{
	mISDN_FsmChangeState(fi, ST_L1_F8);
}
void
l1_cleanup(void)
{
	mISDN_FsmFree(&l1fsm_s);
}
inline u_int
l2headersize(struct layer2 *l2, int ui)
{
	return ((test_bit(FLG_MOD128, &l2->flag) && (!ui)) ? 2 : 1) +
		(test_bit(FLG_LAPD, &l2->flag) ? 2 : 1);
}
inline u_int
l2addrsize(struct layer2 *l2)
{
	return test_bit(FLG_LAPD, &l2->flag) ? 2 : 1;
}
inline int
IsUI(u_char *data)
{
	return (data[0] & 0xef) == UI;
}
inline int
IsUA(u_char *data)
{
	return (data[0] & 0xef) == UA;
}
inline int
IsDM(u_char *data)
{
	return (data[0] & 0xef) == DM;
}
inline int
IsDISC(u_char *data)
{
	return (data[0] & 0xef) == DISC;
}
inline int
IsRR(u_char *data, struct layer2 *l2)
{
	if (test_bit(FLG_MOD128, &l2->flag))
		return data[0] == RR;
	else
		return (data[0] & 0xf) == 1;
}
inline int
IsREJ(u_char *data, struct layer2 *l2)
{
	return test_bit(FLG_MOD128, &l2->flag) ?
		data[0] == REJ : (data[0] & 0xf) == REJ;
}
inline int
IsFRMR(u_char *data)
{
	return (data[0] & 0xef) == FRMR;
}
inline int
IsRNR(u_char *data, struct layer2 *l2)
{
	return test_bit(FLG_MOD128, &l2->flag) ?
	    data[0] == RNR : (data[0] & 0xf) == RNR;
}
static unsigned int
legalnr(struct layer2 *l2, unsigned int nr)
{
	if (test_bit(FLG_MOD128, &l2->flag))
		return ((nr - l2->va) % 128) <= ((l2->vs - l2->va) % 128);
	else
		return ((nr - l2->va) % 8) <= ((l2->vs - l2->va) % 8);
}
inline u_char
get_PollFlag(struct layer2 *l2, struct sk_buff *skb)
{
	return skb->data[l2addrsize(l2)] & 0x10;
}
void
misdn_sock_cleanup(void)
{
	sock_unregister(PF_ISDN);
}
void
set_channel_address(struct mISDNchannel *ch, u_int sapi, u_int tei)
{
	ch->addr = sapi | (tei << 8);
}
void
__add_layer2(struct mISDNchannel *ch, struct mISDNstack *st)
{
	list_add_tail(&ch->list, &st->layer2);
}
void
mISDN_initstack(u_int *dp)
{
	debug = dp;
}
static void
da_deactivate_ind(struct FsmInst *fi, int event, void *arg)
{
	mISDN_FsmChangeState(fi, ST_L1_DEACT);
}
static int
mgr_bcast_ctrl(struct mISDNchannel *ch, u_int cmd, void *arg)
{
	return -EINVAL;
}
void mISDN_timer_cleanup(void)
{
	misc_deregister(&mISDNtimer);
}
static __inline__ void
pcbit_sched_delivery(struct pcbit_dev *dev)
{
	schedule_work(&dev->qdelivery);
}
static void __exit leds_exit(void)
{
	class_destroy(leds_class);
}
static int __init ams_delta_led_init(void)
{
	return platform_driver_register(&ams_delta_led_driver);
}
static void __exit ams_delta_led_exit(void)
{
	platform_driver_unregister(&ams_delta_led_driver);
}
static int __init modinit(void)
{
	return platform_driver_probe(&pwmled_driver, pwmled_probe);
}
static void __exit modexit(void)
{
	platform_driver_unregister(&pwmled_driver);
}
static int __init clevo_mail_led_probe(struct platform_device *pdev)
{
	return led_classdev_register(&pdev->dev, &clevo_mail_led);
}
static int __init cobalt_qube_led_init(void)
{
	return platform_driver_register(&cobalt_qube_led_driver);
}
static void __exit cobalt_qube_led_exit(void)
{
	platform_driver_unregister(&cobalt_qube_led_driver);
}
static int __init cobalt_raq_led_init(void)
{
	return platform_driver_register(&cobalt_raq_led_driver);
}
static int __init da903x_led_init(void)
{
	return platform_driver_register(&da903x_led_driver);
}
static void __exit da903x_led_exit(void)
{
	platform_driver_unregister(&da903x_led_driver);
}
static int __init dac124s085_leds_init(void)
{
	return spi_register_driver(&dac124s085_driver);
}
static void __exit dac124s085_leds_exit(void)
{
	spi_unregister_driver(&dac124s085_driver);
}
static int __init fsg_led_init(void)
{
	return platform_driver_register(&fsg_led_driver);
}

static void __exit fsg_led_exit(void)
{
	platform_driver_unregister(&fsg_led_driver);
}
static int __init h1940leds_init(void)
{
	return platform_driver_register(&h1940leds_driver);
}
static void __exit h1940leds_exit(void)
{
	platform_driver_unregister(&h1940leds_driver);
}
static int __init hp6xxled_init(void)
{
	return platform_driver_register(&hp6xxled_driver);
}
static void __exit hp6xxled_exit(void)
{
	platform_driver_unregister(&hp6xxled_driver);
}
static void locomoled_brightness_set0(struct led_classdev *led_cdev,
				enum led_brightness value)
{
	locomoled_brightness_set(led_cdev, value, LOCOMO_LPT0);
}
static void locomoled_brightness_set1(struct led_classdev *led_cdev,
				enum led_brightness value)
{
	locomoled_brightness_set(led_cdev, value, LOCOMO_LPT1);
}
static int __init locomoled_init(void)
{
	return locomo_driver_register(&locomoled_driver);
}
static void net48xx_error_led_set(struct led_classdev *led_cdev,
		enum led_brightness value)
{
	scx200_gpio_ops.gpio_set(NET48XX_ERROR_LED_GPIO, value ? 1 : 0);
}
static int net48xx_led_probe(struct platform_device *pdev)
{
	return led_classdev_register(&pdev->dev, &net48xx_error_led);
}
static int __init pca9532_init(void)
{
	return i2c_add_driver(&pca9532_driver);
}
static void __exit pca9532_exit(void)
{
	i2c_del_driver(&pca9532_driver);
}
static inline int pca95xx_num_input_regs(int bits)
{
	return (bits + 7) / 8;
}
static inline int pca95xx_num_led_regs(int bits)
{
	return (bits + 3)  / 4;
}
static inline u8 pca955x_ledsel(u8 oldval, int led_num, int state)
{
	return (oldval & (~(0x3 << (led_num << 1)))) |
		((state & 0x3) << (led_num << 1));
}
static int __init pca955x_leds_init(void)
{
	return i2c_add_driver(&pca955x_driver);
}
static void __exit pca955x_leds_exit(void)
{
	i2c_del_driver(&pca955x_driver);
}
static inline struct s3c24xx_gpio_led *pdev_to_gpio(struct platform_device *dev)
{
	return platform_get_drvdata(dev);
}
static inline struct s3c24xx_gpio_led *to_gpio(struct led_classdev *led_cdev)
{
	return container_of(led_cdev, struct s3c24xx_gpio_led, cdev);
}
static int __init s3c24xx_led_init(void)
{
	return platform_driver_register(&s3c24xx_led_driver);
}
static void __exit s3c24xx_led_exit(void)
{
	platform_driver_unregister(&s3c24xx_led_driver);
}
static void clockboard_left_set(struct led_classdev *led_cdev,
				enum led_brightness led_val)
{
	__clockboard_set(led_cdev, led_val, CLOCK_CTRL_LLED);
}
static void clockboard_middle_set(struct led_classdev *led_cdev,
				  enum led_brightness led_val)
{
	__clockboard_set(led_cdev, led_val, CLOCK_CTRL_MLED);
}
static void clockboard_right_set(struct led_classdev *led_cdev,
				 enum led_brightness led_val)
{
	__clockboard_set(led_cdev, led_val, CLOCK_CTRL_RLED);
}
static void fhc_left_set(struct led_classdev *led_cdev,
			 enum led_brightness led_val)
{
	__fhc_set(led_cdev, led_val, FHC_CONTROL_LLED);
}
static void fhc_middle_set(struct led_classdev *led_cdev,
			   enum led_brightness led_val)
{
	__fhc_set(led_cdev, led_val, FHC_CONTROL_MLED);
}
static void fhc_right_set(struct led_classdev *led_cdev,
			  enum led_brightness led_val)
{
	__fhc_set(led_cdev, led_val, FHC_CONTROL_RLED);
}
static int __devinit sunfire_clockboard_led_probe(struct platform_device *pdev)
{
	return sunfire_led_generic_probe(pdev, clockboard_led_types);
}
static int __devinit sunfire_fhc_led_probe(struct platform_device *pdev)
{
	return sunfire_led_generic_probe(pdev, fhc_led_types);
}
static int __devinit wm8350_led_init(void)
{
	return platform_driver_register(&wm8350_led_driver);
}
static void wm8350_led_exit(void)
{
	platform_driver_unregister(&wm8350_led_driver);
}
static int __init bl_trig_init(void)
{
	return led_trigger_register(&bl_led_trigger);
}
static void __exit bl_trig_exit(void)
{
	led_trigger_unregister(&bl_led_trigger);
}
static void defon_trig_activate(struct led_classdev *led_cdev)
{
	led_set_brightness(led_cdev, led_cdev->max_brightness);
}
static int __init defon_trig_init(void)
{
	return led_trigger_register(&defon_led_trigger);
}

static void __exit defon_trig_exit(void)
{
	led_trigger_unregister(&defon_led_trigger);
}
static int __init heartbeat_trig_init(void)
{
	return led_trigger_register(&heartbeat_led_trigger);
}
static void __exit heartbeat_trig_exit(void)
{
	led_trigger_unregister(&heartbeat_led_trigger);
}
static void __exit ledtrig_ide_exit(void)
{
	led_trigger_unregister_simple(ledtrig_ide);
}
static int __init timer_trig_init(void)
{
	return led_trigger_register(&timer_led_trigger);
}
static void __exit timer_trig_exit(void)
{
	led_trigger_unregister(&timer_led_trigger);
}
int lguest_address_ok(const struct lguest *lg,
		      unsigned long addr, unsigned long len)
{
	return (addr+len) / PAGE_SIZE < lg->pfn_limit && (addr+len >= addr);
}
static unsigned long idt_address(u32 lo, u32 hi)
{
	return (lo & 0x0000FFFF) | (hi & 0xFFFF0000);
}
static int idt_type(u32 lo, u32 hi)
{
	return (hi >> 8) & 0xF;
}
static int idt_present(u32 lo, u32 hi)
{
	return (hi & 0x8000);
}
static bool could_be_syscall(unsigned int num)
{
	return num == SYSCALL_VECTOR || num == syscall_vector;
}
static int has_err(unsigned int trap)
{
	return (trap == 8 || (trap >= 10 && trap <= 14) || trap == 17);
}
static inline void *lguest_map(unsigned long phys_addr, unsigned long pages)
{
	return (__force void *)ioremap_cache(phys_addr, PAGE_SIZE*pages);
}
static inline void lguest_unmap(void *addr)
{
	iounmap((__force void __iomem *)addr);
}
static struct lguest_vqconfig *lg_vq(const struct lguest_device_desc *desc)
{
	return (void *)(desc + 1);
}
static u8 *lg_features(const struct lguest_device_desc *desc)
{
	return (void *)(lg_vq(desc) + desc->num_vq);
}
static u8 *lg_config(const struct lguest_device_desc *desc)
{
	return lg_features(desc) + desc->feature_len * 2;
}
static unsigned desc_size(const struct lguest_device_desc *desc)
{
	return sizeof(*desc)
		+ desc->num_vq * sizeof(struct lguest_vqconfig)
		+ desc->feature_len * 2
		+ desc->config_len;
}
static u8 lg_get_status(struct virtio_device *vdev)
{
	return to_lgdev(vdev)->desc->status;
}
static void lg_reset(struct virtio_device *vdev)
{
	set_status(vdev, 0);
}
int __init lguest_device_init(void)
{
	return misc_register(&lguest_dev);
}
void __exit lguest_device_remove(void)
{
	misc_deregister(&lguest_dev);
}
void guest_pagetable_flush_user(struct lg_cpu *cpu)
{
	flush_user_mappings(cpu->lg, cpu->cpu_pgd);
}
void free_pagetables(void)
{
	free_switcher_pte_pages();
}
static int ignored_gdt(unsigned int num)
{
	return (num == GDT_ENTRY_TSS
		|| num == GDT_ENTRY_LGUEST_CS
		|| num == GDT_ENTRY_LGUEST_DS
		|| num == GDT_ENTRY_DOUBLEFAULT_TSS);
}
static unsigned long switcher_offset(void)
{
	return SWITCHER_ADDR - (unsigned long)start_switcher_text;
}
static struct lguest_pages *lguest_pages(unsigned int cpu)
{
	return &(((struct lguest_pages *)
		  (SWITCHER_ADDR + SHARED_SWITCHER_PAGES*PAGE_SIZE))[cpu]);
}
int adb_iop_autopoll(int devs)
{
	return 0;
}
static void
__adb_probe_task(struct work_struct *bullshit)
{
	kthread_run(adb_probe_task, NULL, "kadbprobe");
}
static int __init macio_bus_driver_init(void)
{
	return bus_register(&macio_bus_type);
}
void macio_unregister_driver(struct macio_driver *drv)
{
	driver_unregister(&drv->driver);
}
static void __devexit macio_pci_remove(struct pci_dev* pdev)
{
	panic("removing of macio-asic not supported !\n");
}
static u8
ohare_mb_content(struct media_bay_info *bay)
{
	return (MB_IN32(bay, OHARE_MBCR) >> 12) & 7;
}
static u8
heathrow_mb_content(struct media_bay_info *bay)
{
	return (MB_IN32(bay, HEATHROW_MBCR) >> 12) & 7;
}
static void
ohare_mb_un_reset(struct media_bay_info* bay)
{
	MB_BIS(bay, OHARE_FCR, OH_BAY_RESET_N);
}
static void keylargo_mb_init(struct media_bay_info *bay)
{
	MB_BIS(bay, KEYLARGO_MBCR, KL_MBCR_MB0_ENABLE);
}
static void heathrow_mb_un_reset(struct media_bay_info* bay)
{
	MB_BIS(bay, HEATHROW_FCR, HRW_BAY_RESET_N);
}
static void keylargo_mb_un_reset(struct media_bay_info* bay)
{
	MB_BIS(bay, KEYLARGO_MBCR, KL_MBCR_MB0_DEV_RESET);
}
static void ohare_mb_un_reset_ide(struct media_bay_info* bay)
{
	MB_BIS(bay, OHARE_FCR, OH_IDE1_RESET_N);
}
static void heathrow_mb_un_reset_ide(struct media_bay_info* bay)
{
	MB_BIS(bay, HEATHROW_FCR, HRW_IDE1_RESET_N);
}
static void keylargo_mb_un_reset_ide(struct media_bay_info* bay)
{
	MB_BIS(bay, KEYLARGO_FCR1, KL1_EIDE0_RESET_N);
}
void __exit nvram_cleanup(void)
{
        misc_deregister( &nvram_dev );
}
static inline int bcd2hex (int n)
{
	return (((n & 0xf0) >> 4) * 10) + (n & 0xf);
}
static inline int hex2bcd (int n)
{
	return ((n / 10) << 4) + (n % 10);
}
int smu_present(void)
{
	return smu != NULL;
}
const struct smu_sdbp_header *smu_get_sdb_partition(int id, unsigned int *size)
{
	return __smu_get_sdb_partition(id, size, 0);
}
static ssize_t show_##name(struct device *dev, struct device_attribute *attr, char *buf)	\
{								\
	return sprintf(buf, "%d\n", data);			\
}
static ssize_t show_##name(struct device *dev, struct device_attribute *attr, char *buf)       \
{								\
	return sprintf(buf, "%s\n", data);			\
}
static ssize_t show_##name(struct device *dev, struct device_attribute *attr, char *buf)       \
{								\
	return sprintf(buf, "%d (%d rpm)\n", 			\
		thermostat->last_speed[data],			\
		read_fan_speed(thermostat, FAN_SPEED[data])	\
		);						\
}
static ssize_t show_##name(struct device *dev, struct device_attribute *attr, char *buf)	\
{								\
	return sprintf(buf, "%d", data);			\
}
static void
print_temp( const char *s, int temp )
{
	printk("%s%d.%d C", s ? s : "", temp>>8, (temp & 255)*10/256 );
}
static ssize_t
show_cpu_temperature( struct device *dev, struct device_attribute *attr, char *buf )
{
	return sprintf(buf, "%d.%d\n", x.temp>>8, (x.temp & 255)*10/256 );
}
static ssize_t
show_case_temperature( struct device *dev, struct device_attribute *attr, char *buf )
{
	return sprintf(buf, "%d.%d\n", x.casetemp>>8, (x.casetemp & 255)*10/256 );
}
static int
therm_of_probe( struct of_device *dev, const struct of_device_id *match )
{
	return i2c_add_driver( &g4fan_driver );
}
static int pmu_backlight_get_brightness(struct backlight_device *bd)
{
	return bd->props.brightness;
}
static int pmu_probe(void)
{
	return vias == NULL? -ENODEV: 0;
}
int
pmu_get_model(void)
{
	return pmu_kind;
}
int
pmu_present(void)
{
	return via != 0;
}
static ssize_t
pmu_write(struct file *file, const char __user *buf,
			 size_t count, loff_t *ppos)
{
	return 0;
}
static int pmu_sleep_valid(suspend_state_t state)
{
	return state == PM_SUSPEND_MEM
		&& (pmac_call_feature(PMAC_FTR_SLEEP_STATE, NULL, 0, -1) >= 0);
}
int
pmu_get_model(void)
{
	return pmu_kind;
}
int
pmu_present(void)
{
	return (pmu_kind != PMU_UNKNOWN);
}
static inline void wf_notify(int event, void *param)
{
	blocking_notifier_call_chain(&wf_client_list, event, param);
}
int wf_is_overtemp(void)
{
	return (wf_overtemp != 0);
}
static s32 clamp_min(struct wf_control *ct)
{
	return 0;
}
static s32 clamp_max(struct wf_control *ct)
{
	return 1;
}
static void __exit wf_lm75_sensor_exit(void)
{
	i2c_del_driver(&wf_lm75_driver);
}
static void __exit wf_max6690_sensor_exit(void)
{
	i2c_del_driver(&wf_max6690_driver);
}
static void __exit wf_pm112_exit(void)
{
	platform_driver_unregister(&wf_pm112_driver);
}
static void __exit pm121_exit(void)
{
	platform_driver_unregister(&pm121_driver);
}
static void __exit wf_smu_exit(void)
{
	platform_driver_unregister(&wf_smu_driver);
}
static void __exit wf_smu_exit(void)
{
	platform_driver_unregister(&wf_smu_driver);
}
static int __init sat_sensors_init(void)
{
	return i2c_add_driver(&wf_sat_driver);
}
int __init mca_system_init (void)
{
	return bus_register(&mca_bus_type);
}
int mca_device_claimed(struct mca_device *mca_dev)
{
	return mca_dev->driver_loaded;
}
void mca_device_set_claim(struct mca_device *mca_dev, int val)
{
	mca_dev->driver_loaded = val;
}
enum MCA_AdapterStatus mca_device_status(struct mca_device *mca_dev)
{
	return mca_dev->status;
}
static inline char * bmname(struct bitmap *bitmap)
{
	return bitmap->mddev ? mdname(bitmap->mddev) : "mdX";
}
static inline unsigned long file_page_index(unsigned long chunk)
{
	return CHUNK_BIT_OFFSET(chunk) >> PAGE_BIT_SHIFT;
}
static inline unsigned long file_page_offset(unsigned long chunk)
{
	return CHUNK_BIT_OFFSET(chunk) & (PAGE_BITS - 1);
}
static inline void set_page_attr(struct bitmap *bitmap, struct page *page,
				enum bitmap_page_attr attr)
{
	__set_bit((page->index<<2) + attr, bitmap->filemap_attr);
}
static inline void clear_page_attr(struct bitmap *bitmap, struct page *page,
				enum bitmap_page_attr attr)
{
	__clear_bit((page->index<<2) + attr, bitmap->filemap_attr);
}
static inline unsigned long test_page_attr(struct bitmap *bitmap, struct page *page,
					   enum bitmap_page_attr attr)
{
	return test_bit((page->index<<2) + attr, bitmap->filemap_attr);
}
static void crypt_inc_pending(struct dm_crypt_io *io)
{
	atomic_inc(&io->pending);
}
static unsigned int pages_to_ios(unsigned int pages)
{
	return 4 * pages;	/* too many ? */
}
int dm_io_client_resize(unsigned num_pages, struct dm_io_client *client)
{
	return mempool_resize(client->pool, pages_to_ios(num_pages),
			      GFP_KERNEL);
}
static inline void bio_set_region(struct bio *bio, unsigned region)
{
	bio->bi_io_vec[bio->bi_max_vecs].bv_len = region;
}
static inline unsigned bio_get_region(struct bio *bio)
{
	return bio->bi_io_vec[bio->bi_max_vecs].bv_len;
}
static void dm_hash_exit(void)
{
	dm_hash_remove_all(0);
}
static inline void *align_ptr(void *ptr)
{
	return (void *) (((size_t) (ptr + ALIGN_MASK)) & ~ALIGN_MASK);
}
static void free_params(struct dm_ioctl *param)
{
	vfree(param);
}
static long dm_ctl_ioctl(struct file *file, uint command, ulong u)
{
	return (long)ctl_ioctl(command, (struct dm_ioctl __user *)u);
}
static long dm_compat_ctl_ioctl(struct file *file, uint command, ulong u)
{
	return (long)dm_ctl_ioctl(file, command, (ulong) compat_ptr(u));
}
static void wake(struct dm_kcopyd_client *kc)
{
	queue_work(kc->kcopyd_wq, &kc->kcopyd_work);
}
void dm_linear_exit(void)
{
	dm_unregister_target(&linear_target);
}
static inline int log_test_bit(uint32_t *bs, unsigned bit)
{
	return ext2_test_bit(bit, (unsigned long *) bs) ? 1 : 0;
}
static int core_ctr(struct dm_dirty_log *log, struct dm_target *ti,
		    unsigned int argc, char **argv)
{
	return create_log_context(log, ti, argc, argv, NULL);
}
static int core_flush(struct dm_dirty_log *log)
{
	return 0;
}
static void free_pgpath(struct pgpath *pgpath)
{
	kfree(pgpath);
}
static int __must_push_back(struct multipath *m)
{
	return (m->queue_if_no_path != m->saved_queue_if_no_path &&
		dm_noflush_suspending(m->ti));
}
static void wakeup_all_recovery_waiters(void *context)
{
	wake_up_all(&_kmirrord_recovery_stopped);
}
static struct mirror *bio_get_m(struct bio *bio)
{
	return (struct mirror *) bio->bi_next;
}
static void bio_set_m(struct bio *bio, struct mirror *m)
{
	bio->bi_next = (struct bio *) m;
}
static struct mirror *get_default_mirror(struct mirror_set *ms)
{
	return &ms->mirror[atomic_read(&ms->default_mirror)];
}
static sector_t map_sector(struct mirror *m, struct bio *bio)
{
	return m->offset + (bio->bi_sector - m->ms->ti->begin);
}
static void __exit dm_mirror_exit(void)
{
	dm_unregister_target(&mirror_target);
}
static region_t dm_rh_sector_to_region(struct dm_region_hash *rh, sector_t sector)
{
	return sector >> rh->region_shift;
}
sector_t dm_rh_region_to_sector(struct dm_region_hash *rh, region_t region)
{
	return region << rh->region_shift;
}
region_t dm_rh_bio_to_region(struct dm_region_hash *rh, struct bio *bio)
{
	return dm_rh_sector_to_region(rh, bio->bi_sector - rh->target_begin);
}
void *dm_rh_region_context(struct dm_region *reg)
{
	return reg->rh->context;
}
region_t dm_rh_get_region_key(struct dm_region *reg)
{
	return reg->key;
}
sector_t dm_rh_get_region_size(struct dm_region_hash *rh)
{
	return rh->region_size;
}
struct dm_dirty_log *dm_rh_dirty_log(struct dm_region_hash *rh)
{
	return rh->log;
}
static unsigned rh_hash(struct dm_region_hash *rh, region_t region)
{
	return (unsigned) ((region * rh->prime) >> rh->shift) & rh->mask;
}
static void __rh_insert(struct dm_region_hash *rh, struct dm_region *reg)
{
	list_add(&reg->hash_list, rh->buckets + rh_hash(rh, reg->key));
}
int dm_rh_recovery_in_flight(struct dm_region_hash *rh)
{
	return atomic_read(&rh->recovery_in_flight);
}
int dm_rh_flush(struct dm_region_hash *rh)
{
	return rh->log->type->flush(rh->log);
}
static unsigned sectors_to_pages(unsigned sectors)
{
	return DIV_ROUND_UP(sectors, PAGE_SIZE >> 9);
}
static chunk_t area_location(struct pstore *ps, chunk_t area)
{
	return 1 + ((ps->exceptions_per_area + 1) * area);
}
static void zero_memory_area(struct pstore *ps)
{
	memset(ps->area, 0, ps->snap->chunk_size << SECTOR_SHIFT);
}
static struct pstore *get_info(struct dm_exception_store *store)
{
	return (struct pstore *) store->context;
}
int dm_persistent_snapshot_init(void)
{
	return 0;
}
static void transient_destroy(struct dm_exception_store *store)
{
	kfree(store->context);
}
static int transient_read_metadata(struct dm_exception_store *store,
				   int (*callback)(void *callback_context,
						   chunk_t old, chunk_t new),
				   void *callback_context)
{
	return 0;
}
static void transient_commit_exception(struct dm_exception_store *store,
				       struct dm_snap_exception *e,
				       void (*callback) (void *, int success),
				       void *callback_context)
{
	callback(callback_context, 1);
}
int dm_transient_snapshot_init(void)
{
	return 0;
}
static void exit_origin_hash(void)
{
	kfree(_origins);
}
static unsigned origin_hash(struct block_device *bdev)
{
	return bdev->bd_dev & ORIGIN_MASK;
}
static uint32_t exception_hash(struct exception_table *et, chunk_t chunk)
{
	return (chunk >> et->hash_shift) & et->hash_mask;
}
static void remove_exception(struct dm_snap_exception *e)
{
	list_del(&e->hash_list);
}
static void free_exception(struct dm_snap_exception *e)
{
	kmem_cache_free(exception_cache, e);
}
static void get_pending_exception(struct dm_snap_pending_exception *pe)
{
	atomic_inc(&pe->ref_count);
}
int dm_sysfs_init(struct mapped_device *md)
{
	return kobject_init_and_add(dm_kobject(md), &dm_ktype,
				    &disk_to_dev(dm_disk(md))->kobj,
				    "%s", "dm");
}
void dm_sysfs_exit(struct mapped_device *md)
{
	kobject_put(dm_kobject(md));
}
static inline unsigned int get_child(unsigned int n, unsigned int k)
{
	return (n * CHILDREN_PER_NODE) + k;
}
static inline sector_t *get_node(struct dm_table *t,
				 unsigned int l, unsigned int n)
{
	return t->index[l] + (n * KEYS_PER_NODE);
}
void dm_table_get(struct dm_table *t)
{
	atomic_inc(&t->holders);
}
sector_t dm_table_get_size(struct dm_table *t)
{
	return t->num_targets ? (t->highs[t->num_targets - 1] + 1) : 0;
}
unsigned int dm_table_get_num_targets(struct dm_table *t)
{
	return t->num_targets;
}
struct list_head *dm_table_get_devices(struct dm_table *t)
{
	return &t->devices;
}
fmode_t dm_table_get_mode(struct dm_table *t)
{
	return t->mode;
}
int dm_table_barrier_ok(struct dm_table *t)
{
	return t->barriers_supported;
}
static void load_module(const char *name)
{
	request_module("dm-%s", name);
}
static int io_err_ctr(struct dm_target *tt, unsigned int argc, char **args)
{
	return 0;
}
static int io_err_map(struct dm_target *tt, struct bio *bio,
		      union map_info *map_context)
{
	return -EIO;
}
int __init dm_target_init(void)
{
	return dm_register_target(&error_target);
}
void dm_target_exit(void)
{
	dm_unregister_target(&error_target);
}
static void dm_uevent_free(struct dm_uevent *event)
{
	kmem_cache_free(_dm_event_cache, event);
}
void dm_uevent_exit(void)
{
	kmem_cache_destroy(_dm_event_cache);
}
static void __exit dm_zero_exit(void)
{
	dm_unregister_target(&zero_target);
}
int dm_open_count(struct mapped_device *md)
{
	return atomic_read(&md->open_count);
}
static struct dm_io *alloc_io(struct mapped_device *md)
{
	return mempool_alloc(md->io_pool, GFP_NOIO);
}
static void free_io(struct mapped_device *md, struct dm_io *io)
{
	mempool_free(io, md->io_pool);
}
static struct dm_target_io *alloc_tio(struct mapped_device *md)
{
	return mempool_alloc(md->tio_pool, GFP_NOIO);
}
static void free_tio(struct mapped_device *md, struct dm_target_io *tio)
{
	mempool_free(tio, md->tio_pool);
}
static int __noflush_suspending(struct mapped_device *md)
{
	return test_bit(DMF_NOFLUSH_SUSPENDING, &md->flags);
}
void *dm_get_mdptr(struct mapped_device *md)
{
	return md->interface_ptr;
}
void dm_set_mdptr(struct mapped_device *md, void *ptr)
{
	md->interface_ptr = ptr;
}
void dm_get(struct mapped_device *md)
{
	atomic_inc(&md->holders);
}
const char *dm_device_name(struct mapped_device *md)
{
	return md->name;
}
void dm_kobject_uevent(struct mapped_device *md)
{
	kobject_uevent(&disk_to_dev(md->disk)->kobj, KOBJ_CHANGE);
}
uint32_t dm_next_uevent_seq(struct mapped_device *md)
{
	return atomic_add_return(1, &md->uevent_seq);
}
uint32_t dm_get_event_nr(struct mapped_device *md)
{
	return atomic_read(&md->event_nr);
}
int dm_wait_event(struct mapped_device *md, int event_nr)
{
	return wait_event_interruptible(md->eventq,
			(event_nr != atomic_read(&md->event_nr)));
}
struct gendisk *dm_disk(struct mapped_device *md)
{
	return md->disk;
}
struct kobject *dm_kobject(struct mapped_device *md)
{
	return &md->kobj;
}
int dm_suspended(struct mapped_device *md)
{
	return test_bit(DMF_SUSPENDED, &md->flags);
}
static int __init raid_init(void)
{
	return register_md_personality(&faulty_personality);
}
static void raid_exit(void)
{
	unregister_md_personality(&faulty_personality);
}
static void linear_status (struct seq_file *seq, mddev_t *mddev)
{
	seq_printf(seq, " %dk rounding", mddev->chunk_size/1024);
}
static int __init linear_init (void)
{
	return register_md_personality (&linear_personality);
}
static void linear_exit (void)
{
	unregister_md_personality (&linear_personality);
}
static inline int speed_min(mddev_t *mddev)
{
	return mddev->sync_speed_min ?
		mddev->sync_speed_min : sysctl_speed_limit_min;
}
static inline int speed_max(mddev_t *mddev)
{
	return mddev->sync_speed_max ?
		mddev->sync_speed_max : sysctl_speed_limit_max;
}
static inline int mddev_lock(mddev_t * mddev)
{
	return mutex_lock_interruptible(&mddev->reconfig_mutex);
}
static inline int mddev_trylock(mddev_t * mddev)
{
	return mutex_trylock(&mddev->reconfig_mutex);
}
static void bi_complete(struct bio *bio, int error)
{
	complete((struct completion*)bio->bi_private);
}
static int uuid_equal(mdp_super_t *sb1, mdp_super_t *sb2)
{
	return 	sb1->set_uuid0 == sb2->set_uuid0 &&
		sb1->set_uuid1 == sb2->set_uuid1 &&
		sb1->set_uuid2 == sb2->set_uuid2 &&
		sb1->set_uuid3 == sb2->set_uuid3;
}
static void print_desc(mdp_disk_t *desc)
{
	printk(" DISK<N:%d,(%d,%d),R:%d,S:%d>\n", desc->number,
		desc->major,desc->minor,desc->raid_disk,desc->state);
}
static ssize_t
errors_show(mdk_rdev_t *rdev, char *page)
{
	return sprintf(page, "%d\n", atomic_read(&rdev->corrected_errors));
}
static ssize_t
slot_show(mdk_rdev_t *rdev, char *page)
{
	if (rdev->raid_disk < 0)
		return sprintf(page, "none\n");
	else
		return sprintf(page, "%d\n", rdev->raid_disk);
}
static ssize_t
offset_show(mdk_rdev_t *rdev, char *page)
{
	return sprintf(page, "%llu\n", (unsigned long long)rdev->data_offset);
}
static ssize_t
rdev_size_show(mdk_rdev_t *rdev, char *page)
{
	return sprintf(page, "%llu\n", (unsigned long long)rdev->size);
}
static ssize_t
resync_start_show(mddev_t *mddev, char *page)
{
	return sprintf(page, "%llu\n", (unsigned long long)mddev->recovery_cp);
}
static ssize_t
null_show(mddev_t *mddev, char *page)
{
	return -EINVAL;
}
static ssize_t
size_show(mddev_t *mddev, char *page)
{
	return sprintf(page, "%llu\n", (unsigned long long)mddev->size);
}
static ssize_t
metadata_show(mddev_t *mddev, char *page)
{
	if (mddev->persistent)
		return sprintf(page, "%d.%d\n",
			       mddev->major_version, mddev->minor_version);
	else if (mddev->external)
		return sprintf(page, "external:%s\n", mddev->metadata_type);
	else
		return sprintf(page, "none\n");
}
static ssize_t
mismatch_cnt_show(mddev_t *mddev, char *page)
{
	return sprintf(page, "%llu\n",
		       (unsigned long long) mddev->resync_mismatches);
}
static ssize_t
sync_min_show(mddev_t *mddev, char *page)
{
	return sprintf(page, "%d (%s)\n", speed_min(mddev),
		       mddev->sync_speed_min ? "local": "system");
}
static ssize_t
sync_max_show(mddev_t *mddev, char *page)
{
	return sprintf(page, "%d (%s)\n", speed_max(mddev),
		       mddev->sync_speed_max ? "local": "system");
}
static ssize_t
degraded_show(mddev_t *mddev, char *page)
{
	return sprintf(page, "%d\n", mddev->degraded);
}
static ssize_t
sync_force_parallel_show(mddev_t *mddev, char *page)
{
	return sprintf(page, "%d\n", mddev->parallel_resync);
}
int min_sync_show(mddev_t *mddev, char *page)
{
	return sprintf(page, "%llu\n",
		       (unsigned long long)mddev->resync_min);
}
static ssize_t
max_sync_show(mddev_t *mddev, char *page)
{
	if (mddev->resync_max == MaxSector)
		return sprintf(page, "max\n");
	else
		return sprintf(page, "%llu\n",
			       (unsigned long long)mddev->resync_max);
}

static ssize_t
suspend_lo_show(mddev_t *mddev, char *page)
{
	return sprintf(page, "%llu\n", (unsigned long long)mddev->suspend_lo);
}
static ssize_t
suspend_hi_show(mddev_t *mddev, char *page)
{
	return sprintf(page, "%llu\n", (unsigned long long)mddev->suspend_hi);
}
static int get_ro(char *buffer, struct kernel_param *kp)
{
	return sprintf(buffer, "%d", start_readonly);
}
static void multipath_unplug(struct request_queue *q)
{
	unplug_slaves(q->queuedata);
}
static int __init multipath_init (void)
{
	return register_md_personality (&multipath_personality);
}
static void __exit multipath_exit (void)
{
	unregister_md_personality (&multipath_personality);
}
static int __init raid0_init (void)
{
	return register_md_personality (&raid0_personality);
}
static void raid0_exit (void)
{
	unregister_md_personality (&raid0_personality);
}
static void r1bio_pool_free(void *r1_bio, void *data)
{
	kfree(r1_bio);
}
static int __init raid_init(void)
{
	return register_md_personality(&raid1_personality);
}
static void raid_exit(void)
{
	unregister_md_personality(&raid1_personality);
}
static void r10bio_pool_free(void *r10_bio, void *data)
{
	kfree(r10_bio);
}
static int __init raid_init(void)
{
	return register_md_personality(&raid10_personality);
}
static void raid_exit(void)
{
	unregister_md_personality(&raid10_personality);
}
static inline int raid5_bi_phys_segments(struct bio *bio)
{
	return bio->bi_phys_segments & 0xffff;
}
static inline int raid5_bi_hw_segments(struct bio *bio)
{
	return (bio->bi_phys_segments >> 16) & 0xffff;
}
static inline void raid5_set_bi_hw_segments(struct bio *bio, unsigned int cnt)
{
	bio->bi_phys_segments = raid5_bi_phys_segments(bio) || (cnt << 16);
}
static int stripe_operations_active(struct stripe_head *sh)
{
	return sh->check_state || sh->reconstruct_state ||
	       test_bit(STRIPE_BIOFILL_RUN, &sh->state) ||
	       test_bit(STRIPE_COMPUTE_RUN, &sh->state);
}
static bool handle_stripe(struct stripe_head *sh, struct page *tmp_page)
{
	if (sh->raid_conf->level == 6)
		return handle_stripe6(sh, tmp_page);
	else
		return handle_stripe5(sh);
}
static int raid6_have_mmx(void)
{
	return boot_cpu_has(X86_FEATURE_MMX);
}
static int raid6_have_sse1_or_mmxext(void)
{
	return boot_cpu_has(X86_FEATURE_MMX) &&
		(boot_cpu_has(X86_FEATURE_XMM) ||
		 boot_cpu_has(X86_FEATURE_MMXEXT));
}
static int raid6_have_sse2(void)
{
	return boot_cpu_has(X86_FEATURE_MMX) &&
		boot_cpu_has(X86_FEATURE_FXSR) &&
		boot_cpu_has(X86_FEATURE_XMM) &&
		boot_cpu_has(X86_FEATURE_XMM2);
}
static int inline getbit(u32 *samples, int bit)
{
	return (samples[bit/32] & (1 << (31-(bit%32)))) ? 1 : 0;
}
int saa7146_wait_for_debi_done(struct saa7146_dev *dev, int nobusyloop)
{
	if (nobusyloop)
		return saa7146_wait_for_debi_done_sleep(dev, 50000, 250000);
	else
		return saa7146_wait_for_debi_done_busyloop(dev, 50000, 250000);
}
static int __init saa7146_vv_init_module(void)
{
	return 0;
}
static u32 saa7146_i2c_func(struct i2c_adapter *adapter)
{
	return	  I2C_FUNC_I2C
		| I2C_FUNC_SMBUS_QUICK
		| I2C_FUNC_SMBUS_READ_BYTE	| I2C_FUNC_SMBUS_WRITE_BYTE
		| I2C_FUNC_SMBUS_READ_BYTE_DATA | I2C_FUNC_SMBUS_WRITE_BYTE_DATA;
}
static int vidioc_enum_fmt_vid_overlay(struct file *file, void *fh, struct v4l2_fmtdesc *f)
{
	return vidioc_enum_fmt_vid_cap(file, fh, f);
}
static u32 MXL_GetXtalInt(u32 Xtal_Freq)
{
	if ((Xtal_Freq % 1000000) == 0)
		return (Xtal_Freq / 10000);
	else
		return (((Xtal_Freq / 1000000) + 1)*100);
}
static u32 MXL_Ceiling(u32 value, u32 resolution)
{
	return value / resolution + (value % resolution > 0 ? 1 : 0);
}
static inline int tuner_signal(const int status)
{
	return (status & TUNER_SIGNAL) << 13;
}
static inline int tuner_islocked(const int status)
{
	return (status & TUNER_FL);
}
static inline int tuner_afcstatus(const int status)
{
	return (status & TUNER_AFC) - 2;
}
static int xc_send_i2c_data(struct xc5000_priv *priv, u8 *buf, int len)
{
	return xc5000_writeregs(priv, buf, len)
		? XC_RESULT_I2C_WRITE_FAILURE : XC_RESULT_SUCCESS;
}
static int xc_read_i2c_data(struct xc5000_priv *priv, u8 *buf, int len)
{
	return xc5000_readregs(priv, buf, len)
		? XC_RESULT_I2C_READ_FAILURE : XC_RESULT_SUCCESS;
}
static void xc_wait(int wait_ms)
{
	msleep(wait_ms);
}
static int xc_shutdown(struct xc5000_priv *priv)
{
	return XC_RESULT_SUCCESS;
}
static int xc_get_ADC_Envelope(struct xc5000_priv *priv, u16 *adc_envelope)
{
	return xc_read_reg(priv, XREG_ADC_ENV, adc_envelope);
}
static int xc_get_lock_status(struct xc5000_priv *priv, u16 *lock_status)
{
	return xc_read_reg(priv, XREG_LOCK, lock_status);
}
static int xc_get_frame_lines(struct xc5000_priv *priv, u16 *frame_lines)
{
	return xc_read_reg(priv, XREG_FRAME_LINES, frame_lines);
}
static int xc_get_quality(struct xc5000_priv *priv, u16 *quality)
{
	return xc_read_reg(priv, XREG_QUALITY, quality);
}
static int flexcop_diseqc_send_master_cmd(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd* cmd)
{
	return flexcop_send_diseqc_msg(fe, cmd->msg_len, cmd->msg, 0);
}
static int flexcop_diseqc_send_burst(struct dvb_frontend* fe, fe_sec_mini_cmd_t minicmd)
{
	return flexcop_send_diseqc_msg(fe, 0, NULL, minicmd);
}
void flexcop_smc_ctrl(struct flexcop_device *fc, int onoff)
{
	flexcop_set_ibi_value(ctrl_208,SMC_Enable_sig,onoff);
}
static void flexcop_null_filter_ctrl(struct flexcop_device *fc, int onoff)
{
	flexcop_set_ibi_value(ctrl_208,Null_filter_sig,onoff);
}
void flexcop_mac_filter_ctrl(struct flexcop_device *fc, int onoff)
{
	flexcop_set_ibi_value(ctrl_208,MAC_filter_Mode_sig,onoff);
}
static void flexcop_pid_group_filter_ctrl(struct flexcop_device *fc, int onoff)
{
	flexcop_set_ibi_value(ctrl_208,Mask_filter_sig,onoff);
}
static void flexcop_pid_Stream1_PID_ctrl(struct flexcop_device *fc, u16 pid, int onoff)
{
	pid_ctrl(pid_filter_300,Stream1_PID,Stream1_filter_sig,Stream1_trans,0);
}
static void flexcop_pid_Stream2_PID_ctrl(struct flexcop_device *fc, u16 pid, int onoff)
{
	pid_ctrl(pid_filter_300,Stream2_PID,Stream2_filter_sig,Stream2_trans,0);
}
static void flexcop_pid_PCR_PID_ctrl(struct flexcop_device *fc, u16 pid, int onoff)
{
	pid_ctrl(pid_filter_304,PCR_PID,PCR_filter_sig,PCR_trans,0);
}
static void flexcop_pid_PMT_PID_ctrl(struct flexcop_device *fc, u16 pid, int onoff)
{
	pid_ctrl(pid_filter_304,PMT_PID,PMT_filter_sig,PMT_trans,0);
}
static void flexcop_pid_EMM_PID_ctrl(struct flexcop_device *fc, u16 pid, int onoff)
{
	pid_ctrl(pid_filter_308,EMM_PID,EMM_filter_sig,EMM_trans,0);
}
static void flexcop_pid_ECM_PID_ctrl(struct flexcop_device *fc, u16 pid, int onoff)
{
	pid_ctrl(pid_filter_308,ECM_PID,ECM_filter_sig,ECM_trans,0);
}
static u32 flexcop_i2c_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_I2C;
}
void flexcop_device_name(struct flexcop_device *fc,const char *prefix,const
		char *suffix)
{
	info("%s '%s' at the '%s' bus controlled by a '%s' %s",prefix,
			flexcop_device_names[fc->dev_type],flexcop_bus_names[fc->bus_type],
			flexcop_revision_names[fc->rev],suffix);
}
static int __init flexcop_pci_module_init(void)
{
	return pci_register_driver(&flexcop_pci_driver);
}
static void __exit flexcop_pci_module_exit(void)
{
	pci_unregister_driver(&flexcop_pci_driver);
}
static void flexcop_sram_set_chip (struct flexcop_device *fc, flexcop_sram_type_t type)
{
	flexcop_set_ibi_value(wan_ctrl_reg_71c,sram_chip,type);
}
void flexcop_wan_set_speed(struct flexcop_device *fc, flexcop_wan_speed_t s)
{
	flexcop_set_ibi_value(wan_ctrl_reg_71c,wan_speed_sig,s);
}
static int flexcop_usb_get_mac_addr(struct flexcop_device *fc, int extended)
{
	return flexcop_usb_memory_req(fc->bus_specific,B2C2_USB_READ_V8_MEM,
			V8_MEMORY_PAGE_FLASH,0x1f010,1,fc->dvb_adapter.proposed_mac,6);
}
static int flexcop_usb_write_ibi_reg(struct flexcop_device *fc, flexcop_ibi_register reg, flexcop_ibi_value val)
{
	return flexcop_usb_readwrite_dw(fc,reg, &val.raw, 0);
}
static int flexcop_usb_i2c_request(struct flexcop_i2c_adapter *i2c,
	flexcop_access_op_t op, u8 chipaddr, u8 addr, u8 *buf, u16 len)
{
	if (op == FC_READ)
		return flexcop_usb_i2c_req(i2c, B2C2_USB_I2C_REQUEST,
			USB_FUNC_I2C_READ, chipaddr, addr, buf, len);
	else
		return flexcop_usb_i2c_req(i2c, B2C2_USB_I2C_REQUEST,
			USB_FUNC_I2C_WRITE, chipaddr, addr, buf, len);
}
static int flexcop_usb_stream_control(struct flexcop_device *fc, int onoff)
{
	return 0;
}
static void flexcop_usb_exit(struct flexcop_usb *fc_usb)
{
	usb_set_intfdata(fc_usb->uintf, NULL);
}
static void __exit flexcop_usb_module_exit(void)
{
	usb_deregister(&flexcop_usb_driver);
}
void flexcop_pass_dmx_data(struct flexcop_device *fc, u8 *buf, u32 len)
{
	dvb_dmx_swfilter(&fc->demux, buf, len);
}
void flexcop_pass_dmx_packets(struct flexcop_device *fc, u8 *buf, u32 no)
{
	dvb_dmx_swfilter_packets(&fc->demux, buf, no);
}
static void flexcop_module_cleanup(void)
{
	info(DRIVER_NAME " unloaded successfully");
}
static const char * __devinit card_name(const struct pci_device_id *id)
{
	return id->driver_data ? (const char *)id->driver_data : "Unknown";
}
static fe_code_rate_t dst_get_fec(struct dst_state *state)
{
	return state->fec;
}
static fe_modulation_t dst_get_modulation(struct dst_state *state)
{
	return state->modulation;
}
static int dst_get_tuning_algo(struct dvb_frontend *fe)
{
	return dst_algo;
}
static int ca_set_slot_descr(void)
{
	return -EOPNOTSUPP;
}
static int ca_set_pid(void)
{
	return -EOPNOTSUPP;
}
static int ca_get_slot_descr(struct dst_state *state, struct ca_msg *p_ca_message, void __user *arg)
{
	return -EOPNOTSUPP;
}
static int __init dvb_bt8xx_init(void)
{
	return bttv_sub_register(&driver, "dvb");
}
static void __exit dvb_bt8xx_exit(void)
{
	bttv_sub_unregister(&driver);
}
static u32 functionality(struct i2c_adapter *adap)
{
	return I2C_FUNC_I2C;
}
static inline struct dm1105dvb *feed_to_dm1105dvb(struct dvb_demux_feed *feed)
{
	return container_of(feed->demux, struct dm1105dvb, demux);
}
static inline struct dm1105dvb *frontend_to_dm1105dvb(struct dvb_frontend *fe)
{
	return container_of(fe->dvb, struct dm1105dvb, dvb_adapter);
}
static void dm1105dvb_set_dma_addr(struct dm1105dvb *dm1105dvb)
{
	outl(cpu_to_le32(dm1105dvb->dma_addr), dm_io_mem(DM1105_STADR));
}
static void dm1105dvb_dma_unmap(struct dm1105dvb *dm1105dvb)
{
	pci_free_consistent(dm1105dvb->pdev, 6*DM1105_DMA_BYTES, dm1105dvb->ts_buf, dm1105dvb->dma_addr);
}
static int __init dm1105_init(void)
{
	return pci_register_driver(&dm1105_driver);
}
static void __exit dm1105_exit(void)
{
	pci_unregister_driver(&dm1105_driver);
}
static int dvb_demux_ioctl(struct inode *inode, struct file *file,
			   unsigned int cmd, unsigned long arg)
{
	return dvb_usercopy(inode, file, cmd, arg, dvb_demux_do_ioctl);
}
static int dvb_dvr_ioctl(struct inode *inode, struct file *file,
			 unsigned int cmd, unsigned long arg)
{
	return dvb_usercopy(inode, file, cmd, arg, dvb_dvr_do_ioctl);
}
static int dvb_ca_en50221_io_ioctl(struct inode *inode, struct file *file,
				   unsigned int cmd, unsigned long arg)
{
	return dvb_usercopy(inode, file, cmd, arg, dvb_ca_en50221_io_do_ioctl);
}
static inline u16 section_length(const u8 *buf)
{
	return 3 + ((buf[1] & 0x0f) << 8) + buf[2];
}
static inline u16 ts_pid(const u8 *buf)
{
	return ((buf[1] & 0x1f) << 8) + buf[2];
}
static u32 dvb_dmx_crc32(struct dvb_demux_feed *f, const u8 *src, size_t len)
{
	return (f->feed.sec.crc_val = crc32_be(f->feed.sec.crc_val, src, len));
}
static void dvb_dmx_memcopy(struct dvb_demux_feed *f, u8 *d, const u8 *s,
			    size_t len)
{
	memcpy(d, s, len);
}
s32 timeval_usec_diff(struct timeval lasttime, struct timeval curtime)
{
	return ((curtime.tv_usec < lasttime.tv_usec) ?
		1000000 - lasttime.tv_usec + curtime.tv_usec :
		curtime.tv_usec - lasttime.tv_usec);
}
static int ule_test_sndu( struct dvb_net_priv *p )
{
	return -1;
}
static int ule_exthdr_padding(struct dvb_net_priv *p)
{
	return 0;
}
static int dvb_net_ioctl(struct inode *inode, struct file *file,
	      unsigned int cmd, unsigned long arg)
{
	return dvb_usercopy(inode, file, cmd, arg, dvb_net_do_ioctl);
}
int dvb_ringbuffer_empty(struct dvb_ringbuffer *rbuf)
{
	return (rbuf->pread==rbuf->pwrite);
}
static int a800_power_ctrl(struct dvb_usb_device *d, int onoff)
{
	return 0;
}
static int a800_probe(struct usb_interface *intf,
		const struct usb_device_id *id)
{
	return dvb_usb_device_init(intf, &a800_properties,
				   THIS_MODULE, NULL, adapter_nr);
}
static void __exit a800_module_exit(void)
{
	usb_deregister(&a800_driver);
}
static int af9005_fe_read_snr(struct dvb_frontend *fe, u16 * snr)
{
	return -ENOSYS;
}
static int af9005_fe_sleep(struct dvb_frontend *fe)
{
	return af9005_fe_power(fe, 0);
}
static int af9005_usb_read_tuner_registers(struct dvb_usb_device *d,
					   u16 reg, u8 * values, int len)
{
	return af9005_generic_read_write(d, reg,
					 AF9005_CMD_READ, AF9005_TUNER_REG,
					 values, len);
}
static int af9005_usb_write_tuner_registers(struct dvb_usb_device *d,
					    u16 reg, u8 * values, int len)
{
	return af9005_generic_read_write(d, reg,
					 AF9005_CMD_WRITE,
					 AF9005_TUNER_REG, values, len);
}
static u32 af9005_i2c_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_I2C;
}
static int af9005_power_ctrl(struct dvb_usb_device *d, int onoff)
{
	return 0;
}
static int af9005_usb_probe(struct usb_interface *intf,
			    const struct usb_device_id *id)
{
	return dvb_usb_device_init(intf, &af9005_properties,
				   THIS_MODULE, NULL, adapter_nr);
}
static int af9015_ctrl_msg(struct dvb_usb_device *d, struct req_t *req)
{
	return af9015_rw_udev(d->udev, req);
}
static int af9015_write_reg(struct dvb_usb_device *d, u16 addr, u8 val)
{
	return af9015_write_regs(d, addr, &val, 1);
}
static u32 af9015_i2c_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_I2C;
}
static int af9015_set_reg_bit(struct dvb_usb_device *d, u16 addr, u8 bit)
{
	return af9015_do_reg_bit(d, addr, bit, 1);
}
static int af9015_clear_reg_bit(struct dvb_usb_device *d, u16 addr, u8 bit)
{
	return af9015_do_reg_bit(d, addr, bit, 0);
}
static void __exit af9015_usb_module_exit(void)
{
	usb_deregister(&af9015_usb_driver);
}
static u32 anysee_i2c_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_I2C;
}
static void __exit anysee_module_exit(void)
{
	usb_deregister(&anysee_driver);
}
static u32 au6610_i2c_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_I2C;
}
static int au6610_qt1010_tuner_attach(struct dvb_usb_adapter *adap)
{
	return dvb_attach(qt1010_attach,
			  adap->fe, &adap->dev->i2c_adap,
			  &au6610_qt1010_config) == NULL ? -ENODEV : 0;
}
static void __exit au6610_module_exit(void)
{
	usb_deregister(&au6610_driver);
}
static int cinergyt2_usb_probe(struct usb_interface *intf,
				const struct usb_device_id *id)
{
	return dvb_usb_device_init(intf, &cinergyt2_properties,
					THIS_MODULE, NULL, adapter_nr);
}
static void __exit cinergyt2_usb_exit(void)
{
	usb_deregister(&cinergyt2_driver);
}
static int cinergyt2_fe_init(struct dvb_frontend *fe)
{
	return 0;
}
static int cinergyt2_fe_get_frontend(struct dvb_frontend *fe,
				  struct dvb_frontend_parameters *fep)
{
	return 0;
}
static void cxusb_nano2_led(struct dvb_usb_device *d, int onoff)
{
	cxusb_bluebird_gpio_rw(d, 0x40, onoff ? 0 : 0x40);
}
static u32 cxusb_i2c_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_I2C;
}
static int dib7070_tuner_reset(struct dvb_frontend *fe, int onoff)
{
	return dib7000p_set_gpio(fe, 8, 0, !onoff);
}
static int dib7070_tuner_sleep(struct dvb_frontend *fe, int onoff)
{
	return 0;
}
static void __exit cxusb_module_exit(void)
{
	usb_deregister(&cxusb_driver);
}
static u32 dib0700_i2c_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_I2C;
}
static void __exit dib0700_module_exit(void)
{
	usb_deregister(&dib0700_driver);
}
static int dib7070_tuner_reset(struct dvb_frontend *fe, int onoff)
{
	return dib7000p_set_gpio(fe, 8, 0, !onoff);
}
static int dib7070_tuner_sleep(struct dvb_frontend *fe, int onoff)
{
	return dib7000p_set_gpio(fe, 9, 0, onoff);
}
int dibusb2_0_power_ctrl(struct dvb_usb_device *d, int onoff)
{
	if (onoff) {
	} else
		return 0;
}
static u32 dibusb_i2c_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_I2C;
}
static void __exit dibusb_module_exit(void)
{
	usb_deregister(&dibusb_driver);
}
static int dibusb_mc_probe(struct usb_interface *intf,
		const struct usb_device_id *id)
{
	return dvb_usb_device_init(intf, &dibusb_mc_properties, THIS_MODULE,
				   NULL, adapter_nr);
}
static void __exit dibusb_mc_module_exit(void)
{
	usb_deregister(&dibusb_mc_driver);
}
static u32 digitv_i2c_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_I2C;
}
static void __exit digitv_module_exit(void)
{
	usb_deregister(&digitv_driver);
}
static int dtt200u_fe_sleep(struct dvb_frontend* fe)
{
	return dtt200u_fe_init(fe);
}
static void __exit dtt200u_usb_module_exit(void)
{
	usb_deregister(&dtt200u_usb_driver);
}
static u32 dtv5100_i2c_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_I2C;
}
static int dtv5100_tuner_attach(struct dvb_usb_adapter *adap)
{
	return dvb_attach(qt1010_attach,
			  adap->fe, &adap->dev->i2c_adap,
			  &dtv5100_qt1010_config) == NULL ? -ENODEV : 0;
}
static void __exit dtv5100_module_exit(void)
{
	usb_deregister(&dtv5100_driver);
}
static int usb_cypress_writemem(struct usb_device *udev,u16 addr,u8 *data, u8 len)
{
	return usb_control_msg(udev, usb_sndctrlpipe(udev,0),
			0xa0, USB_TYPE_VENDOR, addr, 0x00, data, len, 5000);
}
int dvb_usb_generic_write(struct dvb_usb_device *d, u8 *buf, u16 len)
{
	return dvb_usb_generic_rw(d,buf,len,NULL,0,0);
}
int dvb_usb_adapter_stream_exit(struct dvb_usb_adapter *adap)
{
	return usb_urb_exit(&adap->stream);
}
static u32 dw210x_i2c_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_I2C;
}
static void __exit dw2102_module_exit(void)
{
	usb_deregister(&dw2102_driver);
}
static u32 gl861_i2c_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_I2C;
}
static int gl861_tuner_attach(struct dvb_usb_adapter *adap)
{
	return dvb_attach(qt1010_attach,
			  adap->fe, &adap->dev->i2c_adap,
			  &gl861_qt1010_config) == NULL ? -ENODEV : 0;
}
static void __exit gl861_module_exit(void)
{
	usb_deregister(&gl861_driver);
}
static int gp8psk_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)
{
	return gp8psk_usb_out_op(adap->dev, ARM_TRANSFER, onoff, 0 , NULL, 0);
}
static void __exit gp8psk_usb_module_exit(void)
{
	usb_deregister(&gp8psk_usb_driver);
}
static u32 m920x_i2c_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_I2C;
}
static void __exit m920x_module_exit(void)
{
	usb_deregister(&m920x_driver);
}
static int nova_t_probe(struct usb_interface *intf,
		const struct usb_device_id *id)
{
	return dvb_usb_device_init(intf, &nova_t_properties,
				   THIS_MODULE, NULL, adapter_nr);
}
static void __exit nova_t_module_exit(void)
{
	usb_deregister(&nova_t_driver);
}
static u32 opera1_i2c_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_I2C;
}
static void __exit opera1_module_exit(void)
{
	usb_deregister(&opera1_driver);
}
static u32 ttusb2_i2c_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_I2C;
}
static void __exit ttusb2_module_exit(void)
{
	usb_deregister(&ttusb2_driver);
}
static void __exit umt_module_exit(void)
{
	usb_deregister(&umt_driver);
}
static int vp702x_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)
{
	return 0;
}
static int vp702x_usb_probe(struct usb_interface *intf,
		const struct usb_device_id *id)
{
	return dvb_usb_device_init(intf, &vp702x_properties,
				   THIS_MODULE, NULL, adapter_nr);
}
static void __exit vp702x_usb_module_exit(void)
{
	usb_deregister(&vp702x_usb_driver);
}
static int vp7045_fe_init(struct dvb_frontend* fe)
{
	return 0;
}
static int vp7045_fe_sleep(struct dvb_frontend* fe)
{
	return 0;
}
static int vp7045_fe_get_frontend(struct dvb_frontend* fe,
				  struct dvb_frontend_parameters *fep)
{
	return 0;
}
static int vp7045_read_mac_addr(struct dvb_usb_device *d,u8 mac[6])
{
	return vp7045_read_eeprom(d,mac, 6, MAC_0_ADDR);
}
static int vp7045_usb_probe(struct usb_interface *intf,
		const struct usb_device_id *id)
{
	return dvb_usb_device_init(intf, &vp7045_properties,
				   THIS_MODULE, NULL, adapter_nr);
}
static void __exit vp7045_usb_module_exit(void)
{
	usb_deregister(&vp7045_usb_driver);
}
static inline struct node_entry *node_of(struct firedtv *fdtv)
{
	return container_of(fdtv->device, struct unit_directory, device)->ne;
}
static int node_lock(struct firedtv *fdtv, u64 addr, void *data, __be32 arg)
{
	return hpsb_node_lock(node_of(fdtv), addr, EXTCODE_COMPARE_SWAP, data,
			      (__force quadlet_t)arg);
}
static int node_read(struct firedtv *fdtv, u64 addr, void *data, size_t len)
{
	return hpsb_node_read(node_of(fdtv), addr, data, len);
}
static int node_write(struct firedtv *fdtv, u64 addr, void *data, size_t len)
{
	return hpsb_node_write(node_of(fdtv), addr, data, len);
}
static int get_ca_object_length(struct avc_response_frame *r)
{
	return r->operand[7];
}
static inline u32 get_opcr(__be32 opcr, u32 mask, u32 shift)
{
	return (be32_to_cpu(opcr) >> shift) & mask;
}
static int fdtv_ca_ready(struct firedtv_tuner_status *stat)
{
	return stat->ca_initialization_status	== 1 &&
	       stat->ca_error_flag		== 0 &&
	       stat->ca_dvb_flag		== 1 &&
	       stat->ca_module_present_status	== 1;
}
static int fdtv_ca_reset(struct firedtv *fdtv)
{
	return avc_ca_reset(fdtv) ? -EFAULT : 0;
}
static unsigned int fdtv_ca_io_poll(struct file *file, poll_table *wait)
{
	return POLLIN;
}
static inline void dealloc_channel(struct firedtv *fdtv, int i)
{
	__clear_bit(i, &fdtv->channel_active);
}
static int __init fdtv_init(void)
{
	return fdtv_1394_init(fdtv_id_table);
}
static void __exit fdtv_exit(void)
{
	fdtv_1394_exit();
}
static int fdtv_diseqc_send_burst(struct dvb_frontend *fe,
				  fe_sec_mini_cmd_t minicmd)
{
	return 0;
}
static int fdtv_read_uncorrected_blocks(struct dvb_frontend *fe, u32 *ucblocks)
{
	return -EOPNOTSUPP;
}
static int fdtv_get_frontend(struct dvb_frontend *fe,
			     struct dvb_frontend_parameters *params)
{
	return -EOPNOTSUPP;
}
static int af9013_write_reg(struct af9013_state *state, u16 reg, u8 val)
{
	return af9013_write_ofdm_regs(state, reg, &val, 1);
}
static int au8522_read_signal_strength(struct dvb_frontend *fe,
				       u16 *signal_strength)
{
	return au8522_read_snr(fe, signal_strength);
}
static int au8522_read_ber(struct dvb_frontend *fe, u32 *ber)
{
	return au8522_read_ucblocks(fe, ber);
}
static int bcm3510_writeB(struct bcm3510_state *state, u8 reg, bcm3510_register_value v)
{
	return bcm3510_writebytes(state,reg,&v.raw,1);
}
static int bcm3510_readB(struct bcm3510_state *state, u8 reg, bcm3510_register_value *v)
{
	return bcm3510_readbytes(state,reg,&v->raw,1);
}
static int bcm3510_sleep(struct dvb_frontend* fe)
{
	return 0;
}
static int cx24116_read_snr(struct dvb_frontend *fe, u16 *snr)
{
	if (esno_snr == 1)
		return cx24116_read_snr_esno(fe, snr);
	else
		return cx24116_read_snr_pct(fe, snr);
}
static int cx24116_get_algo(struct dvb_frontend *fe)
{
	return DVBFE_ALGO_HW;
}
static int cx24123_get_algo(struct dvb_frontend *fe)
{
	return 1; /* FE_ALGO_HW */
}
static u32 cx24123_tuner_i2c_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_I2C;
}
static int dib3000mb_fe_init_nonmobile(struct dvb_frontend* fe)
{
	return dib3000mb_fe_init(fe, 0);
}
static int dib3000mb_set_frontend_and_tuner(struct dvb_frontend* fe, struct dvb_frontend_parameters *fep)
{
	return dib3000mb_set_frontend(fe, fep, 1);
}
static u32 dibx000_i2c_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_I2C;
}
void dibx000_exit_i2c_master(struct dibx000_i2c_master *mst)
{
	i2c_del_adapter(&mst->gated_tuner_i2c_adap);
}
static int drx397x_get_frontend(struct dvb_frontend *fe,
				struct dvb_frontend_parameters *params)
{
	return 0;
}
static int drx397x_sleep(struct dvb_frontend *fe)
{
	return 0;
}
static int dvb_dummy_fe_get_frontend(struct dvb_frontend* fe, struct dvb_frontend_parameters *p)
{
	return 0;
}
static int dvb_dummy_fe_sleep(struct dvb_frontend* fe)
{
	return 0;
}
static int dvb_dummy_fe_init(struct dvb_frontend* fe)
{
	return 0;
}
static int dvb_dummy_fe_set_tone(struct dvb_frontend* fe, fe_sec_tone_mode_t tone)
{
	return 0;
}
static int dvb_dummy_fe_set_voltage(struct dvb_frontend* fe, fe_sec_voltage_t voltage)
{
	return 0;
}
static int itd1000_get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)
{
	return 0;
}
static int itd1000_sleep(struct dvb_frontend *fe)
{
	return 0;
}
static int lgdt3304_init(struct dvb_frontend *fe) {
	return 0;
}
static int lgdt3304_sleep(struct dvb_frontend *fe) {
	return 0;
}
static inline int mt312_readreg(struct mt312_state *state,
				const enum mt312_reg_addr reg, u8 *val)
{
	return mt312_read(state, reg, val, 1);
}
static inline int mt312_writereg(struct mt312_state *state,
				 const enum mt312_reg_addr reg, const u8 val)
{
	return mt312_write(state, reg, &val, 1);
}
static inline u32 mt312_div(u32 a, u32 b)
{
	return (a + (b / 2)) / b;
}
static int mt312_reset(struct mt312_state *state, const u8 full)
{
	return mt312_writereg(state, RESET, full ? 0x80 : 0x40);
}
static int nxt200x_sleep(struct dvb_frontend* fe)
{
	return 0;
}
static int or51132_init(struct dvb_frontend* fe)
{
	return 0;
}
static int or51132_sleep(struct dvb_frontend* fe)
{
	return 0;
}
static int or51211_sleep(struct dvb_frontend* fe)
{
	return 0;
}
static int s5h1409_read_signal_strength(struct dvb_frontend *fe,
					u16 *signal_strength)
{
	return s5h1409_read_snr(fe, signal_strength);
}
static int s5h1409_read_ber(struct dvb_frontend *fe, u32 *ber)
{
	return s5h1409_read_ucblocks(fe, ber);
}
static int s5h1411_sleep(struct dvb_frontend *fe)
{
	return s5h1411_set_powerstate(fe, 1);
}
static int s5h1411_read_signal_strength(struct dvb_frontend *fe,
	u16 *signal_strength)
{
	return s5h1411_read_snr(fe, signal_strength);
}
static int s5h1411_read_ber(struct dvb_frontend *fe, u32 *ber)
{
	return s5h1411_read_ucblocks(fe, ber);
}
static u32 s5h1420_getsymbolrate(struct s5h1420_state* state)
{
	return state->symbol_rate;
}
static u32 s5h1420_tuner_i2c_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_I2C;
}
static int sp8870_read_data_valid_signal(struct sp8870_state* state)
{
	return (sp8870_readreg(state, 0x0D02) > 0);
}
static int sp8870_wake_up(struct sp8870_state* state)
{
	return sp8870_writereg(state, 0xC18, 0x00D);
}
static long stb0899_calc_derot_time(long srate)
{
	if (srate > 0)
		return (100000 / (srate / 1000));
	else
		return 0;
}
int stb0899_write_reg(struct stb0899_state *state, unsigned int reg, u8 data)
{
	return stb0899_write_regs(state, reg, &data, 1);
}
static int stb0899_track(struct dvb_frontend *fe, struct dvb_frontend_parameters *p)
{
	return 0;
}
static enum dvbfe_algo stb0899_frontend_algo(struct dvb_frontend *fe)
{
	return DVBFE_ALGO_CUSTOM;
}
static int stb6100_sleep(struct dvb_frontend *fe)
{
	return 0;
}
static int ves1x93_set_fec (struct ves1x93_state* state, fe_code_rate_t fec)
{
	if (fec == FEC_AUTO)
		return ves1x93_writereg (state, 0x0d, 0x08);
	else if (fec < FEC_1_2 || fec > FEC_8_9)
		return -EINVAL;
	else
		return ves1x93_writereg (state, 0x0d, fec - FEC_1_2);
}
static fe_code_rate_t ves1x93_get_fec (struct ves1x93_state* state)
{
	return FEC_1_2 + ((ves1x93_readreg (state, 0x0d) >> 4) & 0x7);
}
static inline struct pluto *feed_to_pluto(struct dvb_demux_feed *feed)
{
	return container_of(feed->demux, struct pluto, demux);
}
static inline struct pluto *frontend_to_pluto(struct dvb_frontend *fe)
{
	return container_of(fe->dvb, struct pluto, dvb_adapter);
}
static inline u32 pluto_readreg(struct pluto *pluto, u32 reg)
{
	return readl(&pluto->io_mem[reg]);
}
static inline void pluto_writereg(struct pluto *pluto, u32 reg, u32 val)
{
	writel(val, &pluto->io_mem[reg]);
}
static void pluto_set_dma_addr(struct pluto *pluto)
{
	pluto_writereg(pluto, REG_PCAR, pluto->dma_addr);
}
static void pluto_dma_unmap(struct pluto *pluto)
{
	pci_unmap_single(pluto->pdev, pluto->dma_addr,
			TS_DMA_BYTES, PCI_DMA_FROMDEVICE);
}
static int __init pluto2_init(void)
{
	return pci_register_driver(&pluto2_driver);
}
static void __exit pluto2_exit(void)
{
	pci_unregister_driver(&pluto2_driver);
}
void smscore_set_board_id(struct smscore_device_t *core, int id)
{
	core->board_id = id;
}
int smscore_get_board_id(struct smscore_device_t *core)
{
	return core->board_id;
}
int smscore_get_device_mode(struct smscore_device_t *coredev)
{
	return coredev->mode;
}
void smscore_putbuffer(struct smscore_device_t *coredev,
		       struct smscore_buffer_t *cb)
{
	list_add_locked(&cb->entry, &coredev->buffers, &coredev->bufferslock);
}
static void smsusb_disconnect(struct usb_interface *intf)
{
	smsusb_term_device(intf);
}
static void put_firmware(struct av7110* av7110)
{
	vfree(av7110->bin_fw);
}
static void __exit av7110_exit(void)
{
	saa7146_unregister_extension(&av7110_extension_driver);
}
int av7110_ca_register(struct av7110 *av7110)
{
	return dvb_register_device(&av7110->dvb_adapter, &av7110->ca_dev,
				   &dvbdev_ca, av7110, DVB_DEVICE_CA);
}
void av7110_ca_unregister(struct av7110 *av7110)
{
	dvb_unregister_device(av7110->ca_dev);
}
int av7110_ca_init(struct av7110* av7110)
{
	return ci_ll_init(&av7110->ci_rbuffer, &av7110->ci_wbuffer, 8192);
}
void av7110_ca_exit(struct av7110* av7110)
{
	ci_ll_release(&av7110->ci_rbuffer, &av7110->ci_wbuffer);
}
static inline int SetColorBlend(struct av7110 *av7110, u8 windownr)
{
	return av7110_fw_cmd(av7110, COMTYPE_OSD, SetCBlend, 1, windownr);
}
static inline int SetBlend_(struct av7110 *av7110, u8 windownr,
		     enum av7110_osd_palette_type colordepth, u16 index, u8 blending)
{
	return av7110_fw_cmd(av7110, COMTYPE_OSD, SetBlend, 4,
			     windownr, colordepth, index, blending);
}
static inline int SetColor_(struct av7110 *av7110, u8 windownr,
		     enum av7110_osd_palette_type colordepth, u16 index, u16 colorhi, u16 colorlo)
{
	return av7110_fw_cmd(av7110, COMTYPE_OSD, SetColor, 5,
			     windownr, colordepth, index, colorhi, colorlo);
}
static inline int SetFont(struct av7110 *av7110, u8 windownr, u8 fontsize,
			  u16 colorfg, u16 colorbg)
{
	return av7110_fw_cmd(av7110, COMTYPE_OSD, Set_Font, 4,
			     windownr, fontsize, colorfg, colorbg);
}
static inline int DrawLine(struct av7110 *av7110, u8 windownr,
			   u16 x, u16 y, u16 dx, u16 dy, u16 color)
{
	return av7110_fw_cmd(av7110, COMTYPE_OSD, DLine, 6,
			     windownr, x, y, dx, dy, color);
}
static inline int DrawBlock(struct av7110 *av7110, u8 windownr,
			    u16 x, u16 y, u16 dx, u16 dy, u16 color)
{
	return av7110_fw_cmd(av7110, COMTYPE_OSD, DBox, 6,
			     windownr, x, y, dx, dy, color);
}
static inline int HideWindow(struct av7110 *av7110, u8 windownr)
{
	return av7110_fw_cmd(av7110, COMTYPE_OSD, WHide, 1, windownr);
}
static inline int MoveWindowRel(struct av7110 *av7110, u8 windownr, u16 x, u16 y)
{
	return av7110_fw_cmd(av7110, COMTYPE_OSD, WMoveD, 3, windownr, x, y);
}
static inline int MoveWindowAbs(struct av7110 *av7110, u8 windownr, u16 x, u16 y)
{
	return av7110_fw_cmd(av7110, COMTYPE_OSD, WMoveA, 3, windownr, x, y);
}
static inline int DestroyOSDWindow(struct av7110 *av7110, u8 windownr)
{
	return av7110_fw_cmd(av7110, COMTYPE_OSD, WDestroy, 1, windownr);
}
static inline int CreateOSDWindow(struct av7110 *av7110, u8 windownr,
				  osd_raw_window_t disptype,
				  u16 width, u16 height)
{
	return av7110_fw_cmd(av7110, COMTYPE_OSD, WCreate, 4,
			     windownr, disptype, width, height);
}
void av7110_ipack_free(struct ipack *p)
{
	vfree(p->buf);
}
static int __init budget_av_init(void)
{
	return saa7146_register_extension(&budget_extension);
}
static void __exit budget_av_exit(void)
{
	saa7146_unregister_extension(&budget_extension);
}
static int __init budget_ci_init(void)
{
	return saa7146_register_extension(&budget_extension);
}
static void __exit budget_ci_exit(void)
{
	saa7146_unregister_extension(&budget_extension);
}
static int __init budget_patch_init(void)
{
	return saa7146_register_extension(&budget_extension);
}
static void __exit budget_patch_exit(void)
{
	saa7146_unregister_extension(&budget_extension);
}
static int __init budget_init(void)
{
	return saa7146_register_extension(&budget_extension);
}
static void __exit budget_exit(void)
{
	saa7146_unregister_extension(&budget_extension);
}
static void ttusb_handle_ts_data(struct dvb_demux_feed *dvbdmxfeed, const u8 * data,
			  int len)
{
	dvbdmxfeed->cb.ts(data, len, 0, 0, &dvbdmxfeed->feed.ts, 0);
}
static u32 functionality(struct i2c_adapter *adapter)
{
	return I2C_FUNC_I2C;
}
static void __exit ttusb_exit(void)
{
	usb_deregister(&ttusb_driver);
}
static void __exit ttusb_dec_exit(void)
{
	usb_deregister(&ttusb_dec_driver);
}
static void __exit dsbr100_exit(void)
{
	usb_deregister(&usb_dsbr100_driver);
}
static int rtrack_exclusive_open(struct file *file)
{
	return test_and_set_bit(0, &rtrack_unit.in_use) ? -EBUSY : 0;
}
static int aztech_exclusive_open(struct file *file)
{
	return test_and_set_bit(0, &aztech_unit.in_use) ? -EBUSY : 0;
}
static inline void gemtek_pci_nil( u32 port, u8 *last_byte )
{
	__gemtek_pci_cmd( 0x00, port, last_byte, false );
}
static inline void gemtek_pci_cmd( u16 cmd, u32 port, u8 *last_byte )
{
	__gemtek_pci_cmd( cmd, port, last_byte, true );
}
static inline unsigned int gemtek_pci_getsignal( struct gemtek_pci_card *card )
{
	return ( inb( card->iobase ) & 0x08 ) ? 0 : 1;
}
static int gemtek_pci_exclusive_open(struct file *file)
{
	return test_and_set_bit(0, &in_use) ? -EBUSY : 0;
}
static int __init gemtek_pci_init_module( void )
{
	return pci_register_driver( &gemtek_pci_driver );
}
static void __exit gemtek_pci_cleanup_module( void )
{
	pci_unregister_driver(&gemtek_pci_driver);
}
static unsigned long gemtek_convfreq(unsigned long freq)
{
	return ((freq<<FSCALE) + IF_OFFSET + REF_FREQ/2) / REF_FREQ;
}
static inline int gemtek_getsigstr(void)
{
	return inb_p(io) & GEMTEK_NS ? 0 : 1;
}
static int gemtek_exclusive_open(struct file *file)
{
	return test_and_set_bit(0, &in_use) ? -EBUSY : 0;
}
static int maestro_exclusive_open(struct file *file)
{
	return test_and_set_bit(0, &in_use) ? -EBUSY : 0;
}
static void __exit maestro_radio_exit(void)
{
	pci_unregister_driver(&maestro_r_driver);
}
static int maxiradio_exclusive_open(struct file *file)
{
	return test_and_set_bit(0, &in_use) ? -EBUSY : 0;
}
static int __init maxiradio_radio_init(void)
{
	return pci_register_driver(&maxiradio_driver);
}
static void __exit maxiradio_radio_exit(void)
{
	pci_unregister_driver(&maxiradio_driver);
}
static void __exit amradio_exit(void)
{
	usb_deregister(&usb_amradio_driver);
}
static int rtrack2_exclusive_open(struct file *file)
{
	return test_and_set_bit(0, &rtrack2_unit.in_use) ? -EBUSY : 0;
}
static int fmi_exclusive_open(struct file *file)
{
	return test_and_set_bit(0, &fmi_unit.in_use) ? -EBUSY : 0;
}
static int fmr2_exclusive_open(struct file *file)
{
	return test_and_set_bit(0, &fmr2_unit.in_use) ? -EBUSY : 0;
}
static void __exit si470x_module_exit(void)
{
	usb_deregister(&si470x_usb_driver);
}
static int tea5764_is_muted(struct tea5764_device *radio)
{
	return radio->regs.tnctrl & TEA5764_TNCTRL_MU;
}
static void __exit tea5764_exit(void)
{
	i2c_del_driver(&tea5764_i2c_driver);
}
static int terratec_exclusive_open(struct file *file)
{
	return test_and_set_bit(0, &terratec_unit.in_use) ? -EBUSY : 0;
}
static int tr_getstereo(void)
{
	return curstereo;
}
static int trust_exclusive_open(struct file *file)
{
	return test_and_set_bit(0, &in_use) ? -EBUSY : 0;
}
static int typhoon_exclusive_open(struct file *file)
{
	return test_and_set_bit(0, &typhoon_unit.in_use) ? -EBUSY : 0;
}
static int typhoon_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, typhoon_proc_show, NULL);
}
static int zoltrix_exclusive_open(struct file *file)
{
	return test_and_set_bit(0, &zoltrix_unit.in_use) ? -EBUSY : 0;
}
static inline int adv7170_read(struct i2c_client *client, u8 reg)
{
	return i2c_smbus_read_byte_data(client, reg);
}
static inline int adv7175_write(struct i2c_client *client, u8 reg, u8 value)
{
	return i2c_smbus_write_byte_data(client, reg, value);
}
static inline int adv7175_read(struct i2c_client *client, u8 reg)
{
	return i2c_smbus_read_byte_data(client, reg);
}
static inline void disable_dma(void)
{
	ar_outl(0x8000, M32R_DMAEN_PORTL);	/* disable DMA0 */
}
static inline void enable_dma(void)
{
	ar_outl(0x8080, M32R_DMAEN_PORTL);	/* enable DMA0 */
}
static inline void clear_dma_status(void)
{
	ar_outl(0x8000, M32R_DMAEDET_PORTL);	/* clear status */
}
static long ar_ioctl(struct file *file, unsigned int cmd,
		    unsigned long arg)
{
	return video_usercopy(file, cmd, arg, ar_do_ioctl);
}
static int ar_exclusive_open(struct file *file)
{
	return test_and_set_bit(0, &ardev.in_use) ? -EBUSY : 0;
}
static void __exit au0828_exit(void)
{
	usb_deregister(&au0828_usb_driver);
}
static u32 au0828_functionality(struct i2c_adapter *adap)
{
	return I2C_FUNC_SMBUS_EMUL | I2C_FUNC_I2C;
}
static inline int bt819_read(struct i2c_client *client, u8 reg)
{
	return i2c_smbus_read_byte_data(client, reg);
}
static int bt866_legacy_probe(struct i2c_adapter *adapter)
{
	return adapter->id == I2C_HW_B_ZR36067;
}
static void tibetCS16_muxsel(struct bttv *btv, unsigned int input)
{
	gpio_bits(0x0f0000, input << 16);
}
static void request_module_async(struct work_struct *work)
{
	request_module("dvb-bt8xx");
}
static
int check_btres(struct bttv_fh *fh, int bit)
{
	return (fh->resources & bit);
}
static
int locked_btres(struct bttv *btv, int bit)
{
	return (btv->resources & bit);
}
static void
disclaim_vbi_lines(struct bttv *btv)
{
	btv->vbi_end = 0;
}
static inline int
audio_mute(struct bttv *btv, int mute)
{
	return audio_mux(btv, btv->audio, mute);
}
static inline int
audio_input(struct bttv *btv, int input)
{
	return audio_mux(btv, input, btv->mute);
}
static int radio_s_std(struct file *file, void *fh, v4l2_std_id *norm)
{
	return 0;
}
static u32 functionality(struct i2c_adapter *adap)
{
	return I2C_FUNC_SMBUS_EMUL;
}
static inline int read_lpstatus(struct qcam_device *q)
{
	return parport_read_status(q->pport);
}
static inline int read_lpdata(struct qcam_device *q)
{
	return parport_read_data(q->pport);
}
static inline void write_lpdata(struct qcam_device *q, int d)
{
	parport_write_data(q->pport, d);
}
static long qcam_ioctl(struct file *file,
		     unsigned int cmd, unsigned long arg)
{
	return video_usercopy(file, cmd, arg, qcam_do_ioctl);
}
static void __exit exit_bw_qcams(void)
{
	parport_unregister_driver(&bwqcam_driver);
}
static inline void qcam_set_ack(struct qcam_device *qcam, unsigned int i)
{
	parport_frob_control(qcam->pport, 8, i?8:0);
}
static inline unsigned int qcam_ready1(struct qcam_device *qcam)
{
	return (parport_read_status(qcam->pport) & 0x8)?1:0;
}
static inline unsigned int qcam_ready2(struct qcam_device *qcam)
{
	return (parport_read_data(qcam->pport) & 0x1)?1:0;
}
static long qcam_ioctl(struct file *file,
		      unsigned int cmd, unsigned long arg)
{
	return video_usercopy(file, cmd, arg, qcam_do_ioctl);
}
static void cq_attach(struct parport *port)
{
	init_cqcam(port);
}
static inline int cafe_needs_config(struct cafe_camera *cam)
{
	return test_bit(CF_CONFIG_NEEDED, &cam->flags);
}
static inline void cafe_reg_write(struct cafe_camera *cam, unsigned int reg,
		unsigned int val)
{
	iowrite32(val, cam->regs + reg);
}
static inline unsigned int cafe_reg_read(struct cafe_camera *cam,
		unsigned int reg)
{
	return ioread32(cam->regs + reg);
}
static inline void cafe_reg_clear_bit(struct cafe_camera *cam,
		unsigned int reg, unsigned int val)
{
	cafe_reg_write_mask(cam, reg, 0, val);
}
static inline void cafe_reg_set_bit(struct cafe_camera *cam,
		unsigned int reg, unsigned int val)
{
	cafe_reg_write_mask(cam, reg, val, val);
}
static u32 cafe_smbus_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_SMBUS_READ_BYTE_DATA  |
	       I2C_FUNC_SMBUS_WRITE_BYTE_DATA;
}
static void cafe_smbus_shutdown(struct cafe_camera *cam)
{
	i2c_del_adapter(&cam->i2c_adapter);
}
static void cafe_ctlr_irq_disable(struct cafe_camera *cam)
{
	cafe_reg_clear_bit(cam, REG_IRQMASK, FRAMEIRQS);
}
static void cafe_ctlr_start(struct cafe_camera *cam)
{
	cafe_reg_set_bit(cam, REG_CTRL0, C0_ENABLE);
}
static void cafe_ctlr_stop(struct cafe_camera *cam)
{
	cafe_reg_clear_bit(cam, REG_CTRL0, C0_ENABLE);
}
static int cafe_vidioc_s_std(struct file *filp, void *priv, v4l2_std_id *a)
{
	return 0;
}
static void __exit proc_cpia_destroy(void)
{
	remove_proc_entry("cpia", NULL);
}
static inline int init_stream_cap(struct cam_data *cam)
{
	return do_command(cam, CPIA_COMMAND_InitStreamCap,
			  0, cam->params.streamStartLine, 0, 0);
}
static void put_cam(struct cpia_camera_ops* ops)
{
	module_put(ops->owner);
}
static long cpia_ioctl(struct file *file,
		     unsigned int cmd, unsigned long arg)
{
	return video_usercopy(file, cmd, arg, cpia_do_ioctl);
}
static void __exit cpia_exit(void)
{
	proc_cpia_destroy();
}
static void wake_system(struct camera_data *cam)
{
	cpia2_do_command(cam, CPIA2_CMD_SET_WAKEUP, TRANSFER_WRITE, 0);
}
int cpia2_usb_init(void)
{
	return usb_register(&cpia2_driver);
}
static long cpia2_ioctl(struct file *file,
		       unsigned int cmd, unsigned long arg)
{
	return video_usercopy(file, cmd, arg, cpia2_do_ioctl);
}
static void EndTransferMode(struct pp_cam_entry *cam)
{
	parport_negotiate(cam->port, IEEE1284_MODE_COMPAT);
}
static int cpia_usb_registerCallback(void *privdata, void (*cb) (void *cbdata),
	void *cbdata)
{
	return -ENODEV;
}
static int cpia_usb_streamStart(void *privdata)
{
	return -ENODEV;
}
static int cpia_usb_streamStop(void *privdata)
{
	return -ENODEV;
}
static void __exit usb_cpia_cleanup(void)
{
	usb_deregister(&cpia_driver);
}
static int cs5345_command(struct i2c_client *client, unsigned cmd, void *arg)
{
	return v4l2_subdev_command(i2c_get_clientdata(client), cmd, arg);
}
static int cs53l32a_command(struct i2c_client *client, unsigned cmd, void *arg)
{
	return v4l2_subdev_command(i2c_get_clientdata(client), cmd, arg);
}
void cx18_audio_set_route(struct cx18 *cx, struct v4l2_routing *route)
{
	cx18_i2c_hw(cx, cx->card->hw_audio_ctrl,
			VIDIOC_INT_S_AUDIO_ROUTING, route);
}
static void set_bass(struct cx18 *cx, int bass)
{
	cx18_av_and_or(cx, 0x8d9, ~0x3f, 48 - (bass * 48 / 0xffff));
}
static void set_treble(struct cx18 *cx, int treble)
{
	cx18_av_and_or(cx, 0x8db, ~0x3f, 48 - (treble * 48 / 0xffff));
}
static int get_mute(struct cx18 *cx)
{
	return cx18_av_read(cx, 0x8d3) & 0x2 ? 1 : 0;
}
u32 cx18_av_read4(struct cx18 *cx, u16 addr)
{
	return cx18_read_reg(cx, 0xc40000 + addr);
}
int cx18_av_and_or(struct cx18 *cx, u16 addr, unsigned and_mask,
		   u8 or_value)
{
	return cx18_av_write(cx, addr,
			     (cx18_av_read(cx, addr) & and_mask) |
			     or_value);
}
int cx18_av_and_or4(struct cx18 *cx, u16 addr, u32 and_mask,
		   u32 or_value)
{
	return cx18_av_write4(cx, addr,
			     (cx18_av_read4(cx, addr) & and_mask) |
			     or_value);
}
static int attach_inform(struct i2c_client *client)
{
	return 0;
}
static int valid_service_line(int field, int line, int is_pal)
{
	return (is_pal && line >= 6 &&
		((field == 0 && line <= 23) || (field == 1 && line <= 22))) ||
	       (!is_pal && line >= 10 && line < 22);
}
static int cx18_try_fmt_vbi_cap(struct file *file, void *fh,
				struct v4l2_format *fmt)
{
	return cx18_g_fmt_vbi_cap(file, fh, fmt);
}
static int cx18_g_enc_index(struct file *file, void *fh,
				struct v4l2_enc_idx *idx)
{
	return -EINVAL;
}
void cx18_set_funcs(struct video_device *vdev)
{
	vdev->ioctl_ops = &cx18_ioctl_ops;
}
static
void free_epu_work_order(struct cx18 *cx, struct cx18_epu_work_order *order)
{
	atomic_set(&order->pending, 0);
}
int cx18_api(struct cx18 *cx, u32 cmd, int args, u32 data[])
{
	return cx18_api_call(cx, cmd, args, data);
}
static void bb_buf_release(struct videobuf_queue *q,
	struct videobuf_buffer *vb)
{
	cx23885_free_buffer(q, (struct cx23885_buffer *)vb);
}
static void cx23885_fini(void)
{
	pci_unregister_driver(&cx23885_pci_driver);
}
static void dvb_buf_release(struct videobuf_queue *q,
			    struct videobuf_buffer *vb)
{
	cx23885_free_buffer(q, (struct cx23885_buffer *)vb);
}
static u32 cx23885_functionality(struct i2c_adapter *adap)
{
	return I2C_FUNC_SMBUS_EMUL | I2C_FUNC_I2C;
}
static int res_check(struct cx23885_fh *fh, unsigned int bit)
{
	return fh->resources & bit;
}
static int res_locked(struct cx23885_dev *dev, unsigned int bit)
{
	return dev->resources & bit;
}
static void set_bass(struct i2c_client *client, int bass)
{
	cx25840_and_or(client, 0x8d9, ~0x3f, 48 - (bass * 48 / 0xffff));
}
static void set_treble(struct i2c_client *client, int treble)
{
	cx25840_and_or(client, 0x8db, ~0x3f, 48 - (treble * 48 / 0xffff));
}
int cx25840_and_or(struct i2c_client *client, u16 addr, unsigned and_mask,
		   u8 or_value)
{
	return cx25840_write(client, addr,
			     (cx25840_read(client, addr) & and_mask) |
			     or_value);
}
static int snd_cx88_close(struct snd_pcm_substream *substream)
{
	return 0;
}
static int snd_cx88_prepare(struct snd_pcm_substream *substream)
{
	return 0;
}
static void cx88_audio_fini(void)
{
	pci_unregister_driver(&cx88_audio_pci_driver);
}
static void
bb_buf_release(struct videobuf_queue *q, struct videobuf_buffer *vb)
{
	cx88_free_buffer(q, (struct cx88_buffer*)vb);
}
static void blackbird_fini(void)
{
	cx8802_unregister_driver(&cx8802_blackbird_driver);
}
static unsigned int inline norm_swidth(v4l2_std_id norm)
{
	return (norm & (V4L2_STD_MN & ~V4L2_STD_PAL_Nc)) ? 754 : 922;
}
static unsigned int inline norm_hdelay(v4l2_std_id norm)
{
	return (norm & (V4L2_STD_MN & ~V4L2_STD_PAL_Nc)) ? 135 : 186;
}
static unsigned int inline norm_vdelay(v4l2_std_id norm)
{
	return (norm & V4L2_STD_625_50) ? 0x24 : 0x18;
}
static unsigned int inline norm_vbipack(v4l2_std_id norm)
{
	return (norm & V4L2_STD_625_50) ? 511 : 400;
}
static void dvb_buf_release(struct videobuf_queue *q,
			    struct videobuf_buffer *vb)
{
	cx88_free_buffer(q, (struct cx88_buffer*)vb);
}
static void dvb_fini(void)
{
	cx8802_unregister_driver(&cx8802_dvb_driver);
}
static void cx8802_fini(void)
{
	pci_unregister_driver(&cx8802_pci_driver);
}
void cx88_newstation(struct cx88_core *core)
{
	core->audiomode_manual = UNSET;
}
static
int res_check(struct cx8800_fh *fh, unsigned int bit)
{
	return (fh->resources & bit);
}
static
int res_locked(struct cx8800_dev *dev, unsigned int bit)
{
	return (dev->resources & bit);
}
static int radio_s_audio (struct file *file, void *fh,
			  struct v4l2_audio *a)
{
	return 0;
}
static int radio_s_input (struct file *file, void *fh, unsigned int i)
{
	return 0;
}
static void cx8800_fini(void)
{
	pci_unregister_driver(&cx8800_pci_driver);
}
static int snd_em28xx_prepare(struct snd_pcm_substream *substream)
{
	return 0;
}
static int __init em28xx_alsa_register(void)
{
	return em28xx_register_extension(&audio_ops);
}
static void __exit em28xx_alsa_unregister(void)
{
	em28xx_unregister_extension(&audio_ops);
}
static void __exit em28xx_module_exit(void)
{
	usb_deregister(&em28xx_usb_driver);
}
int em28xx_read_reg(struct em28xx *dev, u16 reg)
{
	return em28xx_read_reg_req(dev, USB_REQ_GET_STATUS, reg);
}
int em28xx_write_reg(struct em28xx *dev, u16 reg, u8 val)
{
	return em28xx_write_regs(dev, reg, &val, 1);
}
static int __init em28xx_dvb_register(void)
{
	return em28xx_register_extension(&dvb_ops);
}
static void __exit em28xx_dvb_unregister(void)
{
	em28xx_unregister_extension(&dvb_ops);
}
static u32 functionality(struct i2c_adapter *adap)
{
	return I2C_FUNC_SMBUS_EMUL;
}
static int res_check(struct em28xx_fh *fh)
{
	return (fh->stream_on);
}
static int radio_s_audio(struct file *file, void *fh,
			 struct v4l2_audio *a)
{
	return 0;
}
static int radio_s_input(struct file *file, void *fh, unsigned int i)
{
	return 0;
}
static int et61x251_i2c_read(struct et61x251_device* cam, u8 address)
{
	return et61x251_i2c_try_read(cam, &cam->sensor, address);
}
static int et61x251_i2c_write(struct et61x251_device* cam,
			      u8 address, u8 value)
{
	return et61x251_i2c_try_write(cam, &cam->sensor, address, value);
}
static void __exit et61x251_module_exit(void)
{
	usb_deregister(&et61x251_usb_driver);
}
static int sd_probe(struct usb_interface *intf,
			const struct usb_device_id *id)
{
	return gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),
				THIS_MODULE);
}
static void sd_stopN(struct gspca_dev *gspca_dev)
{
	et_video(gspca_dev, 0);		/* video off */
}
static int sd_probe(struct usb_interface *intf,
		    const struct usb_device_id *id)
{
	return gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),
			       THIS_MODULE);
}
static int sd_probe(struct usb_interface *intf,
		const struct usb_device_id *id)
{
	return gspca_dev_probe(intf, id,
			&sd_desc,
			sizeof(struct usb_fpix),
			THIS_MODULE);
}
static int vidioc_s_std(struct file *filp, void *priv,
			v4l2_std_id *parm)
{
	return 0;
}
static void __exit gspca_exit(void)
{
	info("main deregistered");
}
static int m5602_probe(struct usb_interface *intf,
		       const struct usb_device_id *id)
{
	return gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),
			       THIS_MODULE);
}
int mt9m111_power_down(struct sd *sd)
{
	return 0;
}
int po1030_power_down(struct sd *sd)
{
	return 0;
}
int s5k4aa_power_down(struct sd *sd)
{
	return 0;
}
int s5k83a_power_down(struct sd *sd)
{
	return 0;
}
static int sd_init(struct gspca_dev *gspca_dev)
{
	return 0;
}
static int sd_probe(struct usb_interface *intf,
			const struct usb_device_id *id)
{
	return gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),
				THIS_MODULE);
}
static int sd_init(struct gspca_dev *gspca_dev)
{
	return 0;
}
static int sd_probe(struct usb_interface *intf,
		    const struct usb_device_id *id)
{
	return gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),
			       THIS_MODULE);
}
static void ov51x_led_control(struct sd *sd, int on)
{
	reg_w_mask(sd, OV519_GPIO_DATA_OUT0, !on, 1);	/* 0 / 1 */
}
static int sd_probe(struct usb_interface *intf,
			const struct usb_device_id *id)
{
	return gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),
				THIS_MODULE);
}
static int sd_probe(struct usb_interface *intf, const struct usb_device_id *id)
{
	return gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),
			       THIS_MODULE);
}
static int sd_probe(struct usb_interface *intf,
			const struct usb_device_id *id)
{
	return gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),
				THIS_MODULE);
}
static int sd_probe(struct usb_interface *intf,
			const struct usb_device_id *id)
{
	return gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),
				THIS_MODULE);
}
static void reg_r(struct gspca_dev *gspca_dev,
		  __u16 value)
{
	usb_control_msg(gspca_dev->dev,
			usb_rcvctrlpipe(gspca_dev->dev, 0),
			0,			/* request */
			USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,
			value,
			0,			/* index */
			gspca_dev->usb_buf, 1,
			500);
}
static void sd_stopN(struct gspca_dev *gspca_dev)
{
	sd_init(gspca_dev);
}
static int sd_probe(struct usb_interface *intf,
			const struct usb_device_id *id)
{
	return gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),
				THIS_MODULE);
}
static void setvflip(struct sd *sd)
{
	i2c_w1(&sd->gspca_dev, 0x75,			/* COMN */
		sd->vflip ? 0x82 : 0x02);
}
static void setinfrared(struct sd *sd)
{
	i2c_w1(&sd->gspca_dev, 0x02,			/* gpio */
		sd->infrared ? 0x66 : 0x64);
}
static int sd_probe(struct usb_interface *intf,
		    const struct usb_device_id *id)
{
	return gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),
				THIS_MODULE);
}
static void reg_r(struct gspca_dev *gspca_dev,
		  __u16 index,
		  __u16 length)
{
	usb_control_msg(gspca_dev->dev,
			usb_rcvctrlpipe(gspca_dev->dev, 0),
			0,
			USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
			0,		/* value */
			index, gspca_dev->usb_buf, length, 500);
}
static int sd_probe(struct usb_interface *intf,
			const struct usb_device_id *id)
{
	return gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),
				THIS_MODULE);
}
static void sd_stopN(struct gspca_dev *gspca_dev)
{
	reg_write(gspca_dev->dev, SPCA501_REG_CTLRL, 0x01, 0x00);
}
static int sd_probe(struct usb_interface *intf,
			const struct usb_device_id *id)
{
	return gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),
				THIS_MODULE);
}
static int sd_init(struct gspca_dev *gspca_dev)
{
	return 0;
}
static void sd_stopN(struct gspca_dev *gspca_dev)
{
	reg_write(gspca_dev->dev, 0x02, 0x00, 0x00);
}
static int sd_probe(struct usb_interface *intf,
			const struct usb_device_id *id)
{
	return gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),
				THIS_MODULE);
}
static void reg_r(struct gspca_dev *gspca_dev,
		  __u16 req,
		  __u16 index,
		  __u16 length)
{
	usb_control_msg(gspca_dev->dev,
			usb_rcvctrlpipe(gspca_dev->dev, 0),
			req,
			USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
			0,		/* value */
			index, gspca_dev->usb_buf, length,
			500);
}

static void reg_w(struct usb_device *dev,
		  __u16 req,
		  __u16 value,
		  __u16 index)
{
	usb_control_msg(dev,
			usb_sndctrlpipe(dev, 0),
			req,
			USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
			value, index,
			NULL, 0, 500);
}
static void spca506_Initi2c(struct gspca_dev *gspca_dev)
{
	reg_w(gspca_dev->dev, 0x07, SAA7113_I2C_BASE_WRITE, 0x0004);
}
static int sd_probe(struct usb_interface *intf,
			const struct usb_device_id *id)
{
	return gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),
				THIS_MODULE);
}
static int sd_init(struct gspca_dev *gspca_dev)
{
	return 0;
}
static void sd_stopN(struct gspca_dev *gspca_dev)
{
	reg_write(gspca_dev->dev, 0x8112, 0x20);
}
static int sd_probe(struct usb_interface *intf,
			const struct usb_device_id *id)
{
	return gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),
				THIS_MODULE);
}
static void reg_r(struct gspca_dev *gspca_dev,
		  __u16 index, __u16 length)
{
	usb_control_msg(gspca_dev->dev,
			usb_rcvctrlpipe(gspca_dev->dev, 0),
			0,			/* request */
			USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
			0,			/* value */
			index, gspca_dev->usb_buf, length, 500);
}
static void reg_w_buf(struct gspca_dev *gspca_dev,
		      __u16 index, __u16 len)
{
	usb_control_msg(gspca_dev->dev,
			usb_sndctrlpipe(gspca_dev->dev, 0),
			0,			/* request */
			USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
			0,			/* value */
			index, gspca_dev->usb_buf, len, 500);
}
static int sd_probe(struct usb_interface *intf,
		    const struct usb_device_id *id)
{
	return gspca_dev_probe(intf, id,
				sd_desc[id->driver_info],
				sizeof(struct sd),
			       THIS_MODULE);
}
static int set_par(struct gspca_dev *gspca_dev,
		   int parval)
{
	return snd_val(gspca_dev, 0x003f08, parval);
}
static int sd_probe(struct usb_interface *intf,
			const struct usb_device_id *id)
{
	return gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),
				THIS_MODULE);
}
static int pb0100_dump(struct sd *sd)
{
	return 0;
}
static int sd_probe(struct usb_interface *intf,
			const struct usb_device_id *id)
{
	return gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),
				THIS_MODULE);
}
static void reg_w(struct gspca_dev *gspca_dev,
		  u16 index)
{
	usb_control_msg(gspca_dev->dev,
			usb_sndctrlpipe(gspca_dev->dev, 0),
			0,
			USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
			0, index,
			NULL, 0, 500);
}
static int sd_probe(struct usb_interface *intf,
		    const struct usb_device_id *id)
{
	return gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),
			       THIS_MODULE);
}
static void sd_stopN(struct gspca_dev *gspca_dev)
{
	reg_w1(gspca_dev, R3B_Test3, 0x0b);	/* Test0Sel = 11 = GPIO */
}
static int sd_probe(struct usb_interface *intf,
		    const struct usb_device_id *id)
{
	return gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),
			       THIS_MODULE);
}
static void reg_r(struct gspca_dev *gspca_dev,
		  __u16 req,
		  __u16 index,
		  __u16 len)
{
	usb_control_msg(gspca_dev->dev,
			usb_rcvctrlpipe(gspca_dev->dev, 0),
			req,
			USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
			1,			/* value */
			index, gspca_dev->usb_buf, len,
			500);
}

static void reg_w(struct usb_device *dev,
			    __u16 req,
			    __u16 value,
			    __u16 index)
{
	usb_control_msg(dev,
			usb_sndctrlpipe(dev, 0),
			req,
			USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
			value, index, NULL, 0,
			500);
}
static int sd_init(struct gspca_dev *gspca_dev)
{
	return 0;
}
static int sd_probe(struct usb_interface *intf,
			const struct usb_device_id *id)
{
	return gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),
				THIS_MODULE);
}
static void reg_w_i(struct usb_device *dev,
			__u8 value,
			__u16 index)
{
	usb_control_msg(dev,
			usb_sndctrlpipe(dev, 0),
			0xa0,
			USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
			value, index, NULL, 0,
			500);
}
static int sd_probe(struct usb_interface *intf,
			const struct usb_device_id *id)
{
	return gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),
				THIS_MODULE);
}
static void __exit hexium_cleanup_module(void)
{
	saa7146_unregister_extension(&hexium_extension);
}
static int std_callback(struct saa7146_dev *dev, struct saa7146_standard *std)
{
	return 0;
}
static void __exit hexium_cleanup_module(void)
{
	saa7146_unregister_extension(&extension);
}
static int __init indycam_init(void)
{
	return i2c_add_driver(&i2c_driver_indycam);
}
static void __exit indycam_exit(void)
{
	i2c_del_driver(&i2c_driver_indycam);
}
static inline int get_key_haup(struct IR_i2c *ir, u32 *ir_key, u32 *ir_raw)
{
	return get_key_haup_common (ir, ir_key, ir_raw, 3, 0);
}
static inline int get_key_haup_xvr(struct IR_i2c *ir, u32 *ir_key, u32 *ir_raw)
{
	return get_key_haup_common (ir, ir_key, ir_raw, 6, 3);
}
static int __init ir_init(void)
{
	return i2c_add_driver(&driver);
}
static void __exit ir_fini(void)
{
	i2c_del_driver(&driver);
}
static void module_cleanup(void)
{
	pci_unregister_driver(&ivtv_pci_driver);
}
static inline struct ivtv *sd_to_ivtv(struct v4l2_subdev *sd)
{
	return container_of(sd, struct ivtv, sd_gpio);
}
static void ivtv_setscl(struct ivtv *itv, int state)
{
	write_reg(~state, IVTV_REG_I2C_SETSCL_OFFSET);
}
static void ivtv_setsda(struct ivtv *itv, int state)
{
	write_reg(~state & 1, IVTV_REG_I2C_SETSDA_OFFSET);
}
static int ivtv_getscl(struct ivtv *itv)
{
	return read_reg(IVTV_REG_I2C_GETSCL_OFFSET) & 1;
}
static int ivtv_getsda(struct ivtv *itv)
{
	return read_reg(IVTV_REG_I2C_GETSDA_OFFSET) & 1;
}
static u32 ivtv_functionality(struct i2c_adapter *adap)
{
	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
}
static int valid_service_line(int field, int line, int is_pal)
{
	return (is_pal && line >= 6 && (line != 23 || field == 0)) ||
	       (!is_pal && line >= 10 && line < 22);
}
static int ivtv_try_fmt_sliced_vbi_out(struct file *file, void *fh, struct v4l2_format *fmt)
{
	return ivtv_g_fmt_sliced_vbi_out(file, fh, fmt);
}
static int ivtv_try_fmt_vbi_cap(struct file *file, void *fh, struct v4l2_format *fmt)
{
	return ivtv_g_fmt_vbi_cap(file, fh, fmt);
}
static int ivtv_s_fmt_sliced_vbi_out(struct file *file, void *fh, struct v4l2_format *fmt)
{
	return ivtv_g_fmt_sliced_vbi_out(file, fh, fmt);
}
void ivtv_set_funcs(struct video_device *vdev)
{
	vdev->ioctl_ops = &ivtv_ioctl_ops;
}
int ivtv_api_func(void *priv, u32 cmd, int in, int out, u32 data[CX2341X_MBOX_MAX_DATA])
{
	return ivtv_api(priv, cmd, in, data);
}
void ivtv_yuv_frame_complete(struct ivtv *itv)
{
	atomic_set(&itv->yuv_info.next_fill_frame,
			(itv->yuv_info.draw_frame + 1) % IVTV_YUV_BUFFERS);
}
static int ks0127_legacy_probe(struct i2c_adapter *adapter)
{
	return adapter->id == I2C_HW_B_ZR36067;
}
static inline struct m52790_state *to_state(struct v4l2_subdev *sd)
{
	return container_of(sd, struct m52790_state, sd);
}
static int m52790_command(struct i2c_client *client, unsigned cmd, void *arg)
{
	return v4l2_subdev_command(i2c_get_clientdata(client), cmd, arg);
}
static inline int mchip_hsize(void)
{
	return meye.params.subsample ? 320 : 640;
}
static inline int mchip_vsize(void)
{
	return meye.params.subsample ? 240 : 480;
}
static void mchip_set_framerate(void)
{
	mchip_set(MCHIP_HIC_S_RATE, meye.params.framerate);
}
static void __exit meye_exit(void)
{
	pci_unregister_driver(&meye_driver);
}
int msp_read_dem(struct i2c_client *client, int addr)
{
	return msp_read(client, I2C_MSP_DEM, addr);
}
int msp_read_dsp(struct i2c_client *client, int addr)
{
	return msp_read(client, I2C_MSP_DSP, addr);
}
int msp_write_dem(struct i2c_client *client, int addr, int val)
{
	return msp_write(client, I2C_MSP_DEM, addr, val);
}
int msp_write_dsp(struct i2c_client *client, int addr, int val)
{
	return msp_write(client, I2C_MSP_DSP, addr, val);
}
static int msp_command(struct i2c_client *client, unsigned cmd, void *arg)
{
	return v4l2_subdev_command(i2c_get_clientdata(client), cmd, arg);
}
static int bus_switch_possible(struct mt9m001 *mt9m001)
{
	return gpio_is_valid(mt9m001->switch_gpio);
}
static int __init mt9m001_mod_init(void)
{
	return i2c_add_driver(&mt9m001_i2c_driver);
}
static void __exit mt9m001_mod_exit(void)
{
	i2c_del_driver(&mt9m001_i2c_driver);
}
static int mt9m111_setfmt_bayer8(struct soc_camera_device *icd)
{
	return mt9m111_setup_pixfmt(icd, MT9M111_OUTFMT_PROCESSED_BAYER);
}
static int mt9m111_setfmt_bayer10(struct soc_camera_device *icd)
{
	return mt9m111_setup_pixfmt(icd, MT9M111_OUTFMT_BYPASS_IFP);
}
static int mt9m111_start_capture(struct soc_camera_device *icd)
{
	return 0;
}
static int mt9m111_stop_capture(struct soc_camera_device *icd)
{
	return 0;
}
static int mt9m111_set_bus_param(struct soc_camera_device *icd, unsigned long f)
{
	return 0;
}
static int __init mt9m111_mod_init(void)
{
	return i2c_add_driver(&mt9m111_i2c_driver);
}
static void __exit mt9m111_mod_exit(void)
{
	i2c_del_driver(&mt9m111_i2c_driver);
}
static int __init mt9t031_mod_init(void)
{
	return i2c_add_driver(&mt9t031_i2c_driver);
}
static void __exit mt9t031_mod_exit(void)
{
	i2c_del_driver(&mt9t031_i2c_driver);
}
static int bus_switch_possible(struct mt9v022 *mt9v022)
{
	return gpio_is_valid(mt9v022->switch_gpio);
}
static int __init mt9v022_mod_init(void)
{
	return i2c_add_driver(&mt9v022_i2c_driver);
}
static void __exit mt9v022_mod_exit(void)
{
	i2c_del_driver(&mt9v022_i2c_driver);
}
static void __exit mxb_cleanup_module(void)
{
	saa7146_unregister_extension(&extension);
}
static int omap24xxcam_dmahw_running(unsigned long base, int dmach)
{
	return omap24xxcam_reg_in(base, CAMDMA_CCR(dmach)) & CAMDMA_CCR_ENABLE;
}
static void omap24xxcam_dmahw_transfer_start(unsigned long base, int dmach)
{
	omap24xxcam_reg_out(base, CAMDMA_CCR(dmach),
			    CAMDMA_CCR_SEL_SRC_DST_SYNC
			    | CAMDMA_CCR_BS
			    | CAMDMA_CCR_DST_AMODE_POST_INC
			    | CAMDMA_CCR_SRC_AMODE_POST_INC
			    | CAMDMA_CCR_ENABLE
			    | CAMDMA_CCR_FS
			    | CAMDMA_CCR_SYNCHRO_CAMERA);
}
static void omap24xxcam_core_enable(const struct omap24xxcam_device *cam)
{
	omap24xxcam_reg_out(cam->mmio_base + CC_REG_OFFSET, CC_CTRL,
			    cam->cc_ctrl);
}
static void omap24xxcam_core_disable(const struct omap24xxcam_device *cam)
{
	omap24xxcam_reg_out(cam->mmio_base + CC_REG_OFFSET, CC_CTRL,
			    CC_CTRL_CC_RST);
}
static int __init omap24xxcam_init(void)
{
	return platform_driver_register(&omap24xxcam_driver);
}
static void __exit omap24xxcam_cleanup(void)
{
	platform_driver_unregister(&omap24xxcam_driver);
}
static int
ov51x_wait_frames_inactive(struct usb_ov511 *ov)
{
	return wait_event_interruptible(ov->wq, ov->curframe < 0);
}
static inline long int
get_frame_length(struct ov511_frame *frame)
{
	if (!frame)
		return 0;
	else
		return ((frame->width * frame->height
			 * get_depth(frame->format)) >> 3);
}
static int ov7670_init(struct i2c_client *client)
{
	return ov7670_write_array(client, ov7670_default_regs);
}
static unsigned char ov7670_sm_to_abs(unsigned char v)
{
	if ((v & 0x80) == 0)
		return v + 128;
	else
		return 128 - (v & 0x7f);
}
static unsigned char ov7670_abs_to_sm(unsigned char v)
{
	if (v > 127)
		return v & 0x7f;
	else
		return (128 - v) | 0x80;
}
static int ov7670_t_contrast(struct i2c_client *client, int value)
{
	return ov7670_write(client, REG_CONTRAS, (unsigned char) value);
}
static void __exit ov7670_mod_exit(void)
{
	i2c_del_driver(&ov7670_driver);
}
static int ov772x_set_bus_param(struct soc_camera_device *icd,
				unsigned long		  flags)
{
	return 0;
}
static void ov772x_video_remove(struct soc_camera_device *icd)
{
	soc_camera_video_stop(icd);
}
static int __init ov772x_module_init(void)
{
	return i2c_add_driver(&ov772x_i2c_driver);
}
static void __exit ov772x_module_exit(void)
{
	i2c_del_driver(&ov772x_i2c_driver);
}
static void __exit ovcamchip_exit(void)
{
	i2c_del_driver(&driver);
}
static inline void mvv_write(u8 index, u8 value)
{
	outw(index|(value<<8), io_port);
}
static void pms_videosource(short source)
{
	mvv_write(0x2E, source?0x31:0x30);
}
static void pms_spacialcompl(short data)
{
	mvv_write(0x3B, data);
}
static void pms_spacialcomph(short data)
{
	mvv_write(0x3A, data);
}
static long pms_ioctl(struct file *file,
		     unsigned int cmd, unsigned long arg)
{
	return video_usercopy(file, cmd, arg, pms_do_ioctl);
}
static unsigned int pvr2_msp3400_describe(struct pvr2_msp3400_handler *ctxt,
					  char *buf,unsigned int cnt)
{
	return scnprintf(buf,cnt,"handler: pvrusb2-audio v4l2");
}
static void pvr2_context_notify(struct pvr2_context *mp)
{
	pvr2_context_set_notify(mp,!0);
}
static int pvr2_context_shutok(void)
{
	return pvr2_context_cleanup_flag && (pvr2_context_exist_first == NULL);
}
static void pvr2_context_enter(struct pvr2_context *mp)
{
	mutex_lock(&mp->mutex);
}
unsigned int pvr2_channel_get_limited_inputs(struct pvr2_channel *cp)
{
	return cp->input_mask;
}
int pvr2_ctrl_set_value(struct pvr2_ctrl *cptr,int val)
{
	return pvr2_ctrl_set_mask_value(cptr,~0,val);
}
static unsigned int decoder_describe(struct pvr2_v4l_cx2584x *ctxt,
				     char *buf,unsigned int cnt)
{
	return scnprintf(buf,cnt,"handler: pvrusb2-cx2584x-v4l");
}
static void pvr2_dvb_notify(struct pvr2_dvb_adapter *adap)
{
	wake_up(&adap->buffer_wait_data);
}
static void trace_stbit(const char *name,int val)
{
	pvr2_trace(PVR2_TRACE_STBITS,
		   "State bit %s <-- %s",
		   name,(val ? "true" : "false"));
}
static int ctrl_freq_is_dirty(struct pvr2_ctrl *cptr)
{
	return cptr->hdw->freqDirty != 0;
}
static void ctrl_freq_clear_dirty(struct pvr2_ctrl *cptr)
{
	cptr->hdw->freqDirty = 0;
}
static int ctrl_check_input(struct pvr2_ctrl *cptr,int v)
{
	return ((1 << v) & cptr->hdw->input_allowed_mask) != 0;
}
static int ctrl_set_input(struct pvr2_ctrl *cptr,int m,int v)
{
	return pvr2_hdw_set_input(cptr->hdw,v);
}
static int ctrl_isdirty_input(struct pvr2_ctrl *cptr)
{
	return cptr->hdw->input_dirty != 0;
}
static void ctrl_cleardirty_input(struct pvr2_ctrl *cptr)
{
	cptr->hdw->input_dirty = 0;
}
static int ctrl_cx2341x_is_dirty(struct pvr2_ctrl *cptr)
{
	return cptr->hdw->enc_stale != 0;
}
static int ctrl_stdcur_is_dirty(struct pvr2_ctrl *cptr)
{
	return cptr->hdw->std_dirty != 0;
}
static void ctrl_stdcur_clear_dirty(struct pvr2_ctrl *cptr)
{
	cptr->hdw->std_dirty = 0;
}
static int ctrl_stdenumcur_is_dirty(struct pvr2_ctrl *cptr)
{
	return cptr->hdw->std_dirty != 0;
}
static void ctrl_stdenumcur_clear_dirty(struct pvr2_ctrl *cptr)
{
	cptr->hdw->std_dirty = 0;
}
struct usb_device *pvr2_hdw_get_dev(struct pvr2_hdw *hdw)
{
	return hdw->usb_dev;
}
unsigned long pvr2_hdw_get_sn(struct pvr2_hdw *hdw)
{
	return hdw->serial_number;
}
const char *pvr2_hdw_get_bus_info(struct pvr2_hdw *hdw)
{
	return hdw->bus_info;
}
const char *pvr2_hdw_get_device_identifier(struct pvr2_hdw *hdw)
{
	return hdw->identifier;
}
unsigned long pvr2_hdw_get_cur_freq(struct pvr2_hdw *hdw)
{
	return hdw->freqSelector ? hdw->freqValTelevision : hdw->freqValRadio;
}
int pvr2_hdw_get_unit_number(struct pvr2_hdw *hdw)
{
	return hdw->unit_number;
}
int pvr2_hdw_get_state(struct pvr2_hdw *hdw)
{
	return hdw->master_state;
}
int pvr2_hdw_get_streaming(struct pvr2_hdw *hdw)
{
	return hdw->state_pipeline_req != 0;
}
int pvr2_hdw_dev_ok(struct pvr2_hdw *hdw)
{
	return (hdw && hdw->flag_ok);
}
unsigned int pvr2_hdw_get_ctrl_count(struct pvr2_hdw *hdw)
{
	return hdw->control_cnt;
}
static int pvr2_hdw_wait(struct pvr2_hdw *hdw,int state)
{
	return wait_event_interruptible(
		hdw->state_wait_data,
		(hdw->state_stale == 0) &&
		(!state || (hdw->master_state != state)));
}
const char *pvr2_hdw_get_driver_name(struct pvr2_hdw *hdw)
{
	return hdw->name;
}
const char *pvr2_hdw_get_desc(struct pvr2_hdw *hdw)
{
	return hdw->hdw_desc->description;
}
const char *pvr2_hdw_get_type(struct pvr2_hdw *hdw)
{
	return hdw->hdw_desc->shortname;
}
struct pvr2_stream *pvr2_hdw_get_video_stream(struct pvr2_hdw *hp)
{
	return hp->vid_stream;
}
int pvr2_hdw_cpufw_get_enabled(struct pvr2_hdw *hdw)
{
	return hdw->fw_buffer != NULL;
}
int pvr2_send_request(struct pvr2_hdw *hdw,
		      void *write_data,unsigned int write_len,
		      void *read_data,unsigned int read_len)
{
	return pvr2_send_request_ex(hdw,HZ*4,0,
				    write_data,write_len,
				    read_data,read_len);
}
int pvr2_hdw_cmd_deep_reset(struct pvr2_hdw *hdw)
{
	return pvr2_issue_simple_cmd(hdw,FX2CMD_DEEP_RESET);
}
int pvr2_hdw_cmd_powerup(struct pvr2_hdw *hdw)
{
	return pvr2_issue_simple_cmd(hdw,FX2CMD_POWER_ON);
}
int pvr2_hdw_cmd_powerdown(struct pvr2_hdw *hdw)
{
	return pvr2_issue_simple_cmd(hdw,FX2CMD_POWER_OFF);
}
static int pvr2_hdw_cmd_onair_digital_path_ctrl(struct pvr2_hdw *hdw,
						int onoff)
{
	return pvr2_issue_simple_cmd(hdw,(onoff ?
					  FX2CMD_ONAIR_DTV_STREAMING_ON :
					  FX2CMD_ONAIR_DTV_STREAMING_OFF));
}
int pvr2_hdw_gpio_get_dir(struct pvr2_hdw *hdw,u32 *dp)
{
	return pvr2_read_register(hdw,PVR2_GPIO_DIR,dp);
}
int pvr2_hdw_gpio_get_out(struct pvr2_hdw *hdw,u32 *dp)
{
	return pvr2_read_register(hdw,PVR2_GPIO_OUT,dp);
}
int pvr2_hdw_gpio_get_in(struct pvr2_hdw *hdw,u32 *dp)
{
	return pvr2_read_register(hdw,PVR2_GPIO_IN,dp);
}
unsigned int pvr2_hdw_get_input_available(struct pvr2_hdw *hdw)
{
	return hdw->input_avail_mask;
}
unsigned int pvr2_hdw_get_input_allowed(struct pvr2_hdw *hdw)
{
	return hdw->input_allowed_mask;
}
static int check_standard(struct pvr2_hdw *hdw)
{
	return (hdw->input_dirty != 0) || (hdw->std_dirty != 0);
}
static int check_bcsh(struct pvr2_hdw *hdw)
{
	return (hdw->brightness_dirty ||
		hdw->contrast_dirty ||
		hdw->saturation_dirty ||
		hdw->hue_dirty);
}
static int check_volume(struct pvr2_hdw *hdw)
{
	return (hdw->volume_dirty ||
		hdw->balance_dirty ||
		hdw->bass_dirty ||
		hdw->treble_dirty ||
		hdw->mute_dirty);
}
static int check_audiomode(struct pvr2_hdw *hdw)
{
	return (hdw->input_dirty ||
		hdw->audiomode_dirty);
}
static int check_frequency(struct pvr2_hdw *hdw)
{
	return hdw->freqDirty != 0;
}
static int check_size(struct pvr2_hdw *hdw)
{
	return (hdw->res_hor_dirty || hdw->res_ver_dirty);
}
static int check_crop(struct pvr2_hdw *hdw)
{
	return (hdw->cropl_dirty || hdw->cropt_dirty ||
		hdw->cropw_dirty || hdw->croph_dirty);
}
static int check_log(struct pvr2_hdw *hdw)
{
	return hdw->log_requested != 0;
}
void pvr2_v4l2_cmd_stream(struct pvr2_i2c_client *cp,int fl)
{
	pvr2_i2c_client_cmd(cp,
			    (fl ? VIDIOC_STREAMON : VIDIOC_STREAMOFF),NULL);
}
static int i2c_black_hole(struct pvr2_hdw *hdw,
			   u8 i2c_addr,u8 *wdata,u16 wlen,u8 *rdata,u16 rlen)
{
	return -EIO;
}
static u32 pvr2_i2c_functionality(struct i2c_adapter *adap)
{
	return I2C_FUNC_SMBUS_EMUL | I2C_FUNC_I2C;
}
static void pvr2_buffer_describe(struct pvr2_buffer *bp,const char *msg)
{
	pvr2_trace(PVR2_TRACE_INFO,
		   "buffer%s%s %p state=%s id=%d status=%d"
		   " stream=%p purb=%p sig=0x%x",
		   (msg ? " " : ""),
		   (msg ? msg : ""),
		   bp,
		   (bp ? pvr2_buffer_state_decode(bp->state) : "(invalid)"),
		   (bp ? bp->id : 0),
		   (bp ? bp->status : 0),
		   (bp ? bp->stream : NULL),
		   (bp ? bp->purb : NULL),
		   (bp ? bp->signature : 0));
}
int pvr2_stream_get_buffer_count(struct pvr2_stream *sp)
{
	return sp->buffer_target_count;
}
int pvr2_stream_get_ready_count(struct pvr2_stream *sp)
{
	return sp->r_count;
}
unsigned int pvr2_buffer_get_count(struct pvr2_buffer *bp)
{
	return bp->used_count;
}
int pvr2_buffer_get_status(struct pvr2_buffer *bp)
{
	return bp->status;
}
int pvr2_buffer_get_id(struct pvr2_buffer *bp)
{
	return bp->id;
}
struct pvr2_stream *pvr2_ioread_get_stream(struct pvr2_ioread *cp)
{
	return cp->stream;
}
v4l2_std_id pvr2_std_get_usable(void)
{
	return CSTD_ALL;
}
void pvr2_sysfs_class_destroy(struct pvr2_sysfs_class *clp)
{
	class_unregister(&clp->class);
}
static unsigned int pvr2_tuner_describe(struct pvr2_tuner_handler *ctxt,char *buf,unsigned int cnt)
{
	return scnprintf(buf,cnt,"handler: pvrusb2-tuner");
}
static void pvr2_v4l2_notify(struct pvr2_v4l2_fh *fhp)
{
	wake_up(&fhp->wait_data);
}
static unsigned int decoder_describe(struct pvr2_v4l_decoder *ctxt,char *buf,unsigned int cnt)
{
	return scnprintf(buf,cnt,"handler: pvrusb2-video-v4l");
}
static unsigned int wm8775_describe(struct pvr2_v4l_wm8775 *ctxt,
				     char *buf,unsigned int cnt)
{
	return scnprintf(buf,cnt,"handler: pvrusb2-wm8775");
}
static int send_video_command(struct usb_device *udev, int index, void *buf, int buflen)
{
	return usb_control_msg(udev,
		usb_sndctrlpipe(udev, 0),
		SET_EP_STREAM_CTL,
		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
		VIDEO_OUTPUT_CONTROL_FORMATTER,
		index,
		buf, buflen, 1000);
}
static void pxa_camera_deactivate(struct pxa_camera_dev *pcdev)
{
	clk_disable(pcdev->clk);
}
static int __devinit pxa_camera_init(void)
{
	return platform_driver_register(&pxa_camera_driver);
}
static void __exit pxa_camera_exit(void)
{
	platform_driver_unregister(&pxa_camera_driver);
}
static int norm_maxw(struct video_device *vdev)
{
	return (vdev->current_norm & V4L2_STD_NTSC) ?
	    LINE_SZ_4CIFS_NTSC : LINE_SZ_4CIFS_PAL;
}
static int norm_maxh(struct video_device *vdev)
{
	return (vdev->current_norm & V4L2_STD_NTSC) ?
	    (NUM_LINES_1CIFS_NTSC * 2) : (NUM_LINES_1CIFS_PAL * 2);
}
static int norm_minw(struct video_device *vdev)
{
	return (vdev->current_norm & V4L2_STD_NTSC) ?
	    LINE_SZ_1CIFS_NTSC : LINE_SZ_1CIFS_PAL;
}
static int norm_minh(struct video_device *vdev)
{
	return (vdev->current_norm & V4L2_STD_NTSC) ?
	    (NUM_LINES_1CIFS_NTSC) : (NUM_LINES_1CIFS_PAL);
}
static int res_locked(struct s2255_dev *dev, struct s2255_fh *fh)
{
	return dev->resources[fh->channel];
}
static int res_check(struct s2255_fh *fh)
{
	return fh->resources[fh->channel];
}
static void __exit usb_s2255_exit(void)
{
	usb_deregister(&s2255_driver);
}
static inline struct saa5246a_device *to_dev(struct v4l2_subdev *sd)
{
	return container_of(sd, struct saa5246a_device, sd);
}
static inline struct saa5249_device *to_dev(struct v4l2_subdev *sd)
{
	return container_of(sd, struct saa5249_device, sd);
}
static int __init saa6588_init_module(void)
{
	return i2c_add_driver(&driver);
}
static void __exit saa6588_cleanup_module(void)
{
	i2c_del_driver(&driver);
}
static inline int saa7110_read(struct i2c_client *client)
{
	return i2c_smbus_read_byte(client);
}
static int saa7111_init_decoder(struct i2c_client *client,
		struct video_decoder_init *init)
{
	return saa7111_write_block(client, init->data, init->len);
}
static inline int saa7111_read(struct i2c_client *client, u8 reg)
{
	return i2c_smbus_read_byte_data(client, reg);
}
static inline int saa7114_write(struct i2c_client *client, u8 reg, u8 value)
{
	return i2c_smbus_write_byte_data(client, reg, value);
}
static inline int saa7114_read(struct i2c_client *client, u8 reg)
{
	return i2c_smbus_read_byte_data(client, reg);
}
static inline struct saa711x_state *to_state(struct v4l2_subdev *sd)
{
	return container_of(sd, struct saa711x_state, sd);
}
static int saa711x_command(struct i2c_client *client, unsigned cmd, void *arg)
{
	return v4l2_subdev_command(i2c_get_clientdata(client), cmd, arg);
}
static inline struct saa7127_state *to_state(struct v4l2_subdev *sd)
{
	return container_of(sd, struct saa7127_state, sd);
}
static inline struct saa6752hs_state *to_state(struct v4l2_subdev *sd)
{
	return container_of(sd, struct saa6752hs_state, sd);
}
static int saa6752hs_s_ext_ctrls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ctrls)
{
	return saa6752hs_do_ext_ctrls(sd, ctrls, 1);
}
static int saa6752hs_try_ext_ctrls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ctrls)
{
	return saa6752hs_do_ext_ctrls(sd, ctrls, 0);
}
static void board_flyvideo(struct saa7134_dev *dev)
{
	printk("%s: there are different flyvideo cards with different tuners\n"
	       "%s: out there, you might have to use the tuner=<nr> insmod\n"
	       "%s: option to override the default value.\n",
	       dev->name, dev->name, dev->name);
}
int saa7134_buffer_startpage(struct saa7134_buf *buf)
{
	return saa7134_buffer_pages(buf->vb.bsize) * buf->vb.i;
}
static void saa7134_fini(void)
{
	pci_unregister_driver(&saa7134_pci_driver);
}
static int philips_td1316_tuner_set_params(struct dvb_frontend *fe, struct dvb_frontend_parameters *params)
{
	return philips_tda6651_pll_set(fe, params);
}
static int __init dvb_register(void)
{
	return saa7134_ts_register(&dvb_ops);
}
static void __exit dvb_unregister(void)
{
	saa7134_ts_unregister(&dvb_ops);
}
static void empress_signal_change(struct saa7134_dev *dev)
{
	schedule_work(&dev->empress_workqueue);
}
static int __init empress_register(void)
{
	return saa7134_ts_register(&empress_ops);
}
static void __exit empress_unregister(void)
{
	saa7134_ts_unregister(&empress_ops);
}
static u32 functionality(struct i2c_adapter *adap)
{
	return I2C_FUNC_SMBUS_EMUL;
}
static int get_key_pinnacle_grey(struct IR_i2c *ir, u32 *ir_key, u32 *ir_raw)
{
	return get_key_pinnacle(ir, ir_key, ir_raw, 1, 0xfe, 0xff);
}
static int get_key_pinnacle_color(struct IR_i2c *ir, u32 *ir_key, u32 *ir_raw)
{
	return get_key_pinnacle(ir, ir_key, ir_raw, 2, 0x80, 0x88);
}
int saa7134_vbi_fini(struct saa7134_dev *dev)
{
	return 0;
}
static int res_check(struct saa7134_fh *fh, unsigned int bit)
{
	return (fh->resources & bit);
}
static int res_locked(struct saa7134_dev *dev, unsigned int bit)
{
	return (dev->resources & bit);
}
static int saa7134_s_audio(struct file *file, void *priv, struct v4l2_audio *a)
{
	return 0;
}
static int saa7134_g_parm(struct file *file, void *fh,
				struct v4l2_streamparm *parm)
{
	return 0;
}
static int radio_s_audio(struct file *file, void *priv,
					struct v4l2_audio *a)
{
	return 0;
}
static int radio_s_input(struct file *filp, void *priv, unsigned int i)
{
	return 0;
}
static int radio_s_std(struct file *file, void *fh, v4l2_std_id *norm)
{
	return 0;
}
static inline struct saa717x_state *to_state(struct v4l2_subdev *sd)
{
	return container_of(sd, struct saa717x_state, sd);
}
static int saa717x_command(struct i2c_client *client, unsigned cmd, void *arg)
{
	return v4l2_subdev_command(i2c_get_clientdata(client), cmd, arg);
}
static inline int saa7185_read(struct i2c_client *client)
{
	return i2c_smbus_read_byte(client);
}
static u8 saa7191_read_reg(struct i2c_client *client,
			   u8 reg)
{
	return ((struct saa7191 *)i2c_get_clientdata(client))->reg[reg];
}
static int saa7191_init(void)
{
	return i2c_add_driver(&i2c_driver_saa7191);
}
static void saa7191_exit(void)
{
	i2c_del_driver(&i2c_driver_saa7191);
}
static int se401_sndctrl(int set, struct usb_se401 *se401, unsigned short req,
			 unsigned short value, unsigned char *cp, int size)
{
	return usb_control_msg (
		se401->dev,
		set ? usb_sndctrlpipe(se401->dev, 0) : usb_rcvctrlpipe(se401->dev, 0),
		req,
		(set ? USB_DIR_OUT : USB_DIR_IN) | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
		value,
		0,
		cp,
		size,
		1000
	);
}
static int se401_set_feature(struct usb_se401 *se401, unsigned short selector,
			     unsigned short param)
{
	return usb_control_msg (
		se401->dev,
		usb_sndctrlpipe(se401->dev, 0),
		SE401_REQ_SET_EXT_FEATURE,
		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
		param,
		selector,
		NULL,
		0,
		1000
	);
}
static long se401_ioctl(struct file *file,
		       unsigned int cmd, unsigned long arg)
{
	return video_usercopy(file, cmd, arg, se401_do_ioctl);
}
static void ceu_write(struct sh_mobile_ceu_dev *priv,
		      unsigned long reg_offs, u32 data)
{
	iowrite32(data, priv->base + reg_offs);
}
static u32 ceu_read(struct sh_mobile_ceu_dev *priv, unsigned long reg_offs)
{
	return ioread32(priv->base + reg_offs);
}
static void sh_mobile_ceu_videobuf_release(struct videobuf_queue *vq,
					   struct videobuf_buffer *vb)
{
	free_buffer(vq, container_of(vb, struct sh_mobile_ceu_buffer, vb));
}
static int __init sh_mobile_ceu_init(void)
{
	return platform_driver_register(&sh_mobile_ceu_driver);
}
static void __exit sh_mobile_ceu_exit(void)
{
	platform_driver_unregister(&sh_mobile_ceu_driver);
}
int
sn9c102_i2c_try_read(struct sn9c102_device* cam,
		     const struct sn9c102_sensor* sensor, u8 address)
{
	return sn9c102_i2c_try_raw_read(cam, sensor, sensor->i2c_slave_id,
					address, 1, NULL);
}
static int sn9c102_i2c_try_write(struct sn9c102_device* cam,
				 const struct sn9c102_sensor* sensor,
				 u8 address, u8 value)
{
	return sn9c102_i2c_try_raw_write(cam, sensor, 3,
					 sensor->i2c_slave_id, address,
					 value, 0, 0, 0);
}
int sn9c102_i2c_read(struct sn9c102_device* cam, u8 address)
{
	return sn9c102_i2c_try_read(cam, &cam->sensor, address);
}
int sn9c102_i2c_write(struct sn9c102_device* cam, u8 address, u8 value)
{
	return sn9c102_i2c_try_write(cam, &cam->sensor, address, value);
}
static void __exit sn9c102_module_exit(void)
{
	usb_deregister(&sn9c102_usb_driver);
}
static void soc_camera_free_user_formats(struct soc_camera_device *icd)
{
	vfree(icd->user_formats);
}
static int soc_camera_platform_set_bus_param(struct soc_camera_device *icd,
					     unsigned long flags)
{
	return 0;
}
static int soc_camera_platform_set_fmt(struct soc_camera_device *icd,
				       __u32 pixfmt, struct v4l2_rect *rect)
{
	return 0;
}
static void soc_camera_platform_video_remove(struct soc_camera_device *icd)
{
	soc_camera_video_stop(icd);
}
static int __init soc_camera_platform_module_init(void)
{
	return platform_driver_register(&soc_camera_platform_driver);
}
static void __exit soc_camera_platform_module_exit(void)
{
	platform_driver_unregister(&soc_camera_platform_driver);
}
static int stk_vidioc_s_input(struct file *filp, void *priv, unsigned int i)
{
	if (i != 0)
		return -EINVAL;
	else
		return 0;
}
static int stk_vidioc_s_std(struct file *filp, void *priv, v4l2_std_id *a)
{
	return 0;
}
static void __exit stk_camera_exit(void)
{
	usb_deregister(&stk_camera_driver);
}
static ssize_t saa_read(struct file *file, char __user * buf,
	size_t count, loff_t * ppos)
{
	return -EINVAL;
}
static void __devexit stradis_remove(struct pci_dev *pdev)
{
	stradis_release_saa(pdev);
}
static long stv680_ioctl(struct file *file,
			unsigned int cmd, unsigned long arg)
{
	return video_usercopy(file, cmd, arg, stv680_do_ioctl);
}
static int ioctl_reset(struct v4l2_int_device *s)
{
	return -EBUSY;
}
static int ioctl_init(struct v4l2_int_device *s)
{
	return tcm825x_configure(s);
}
static int ioctl_dev_exit(struct v4l2_int_device *s)
{
	return 0;
}
static void __exit tcm825x_exit(void)
{
	i2c_del_driver(&tcm825x_i2c_driver);
}
static inline struct tda7432 *to_state(struct v4l2_subdev *sd)
{
	return container_of(sd, struct tda7432, sd);
}
static int tda7432_command(struct i2c_client *client, unsigned cmd, void *arg)
{
	return v4l2_subdev_command(i2c_get_clientdata(client), cmd, arg);
}
static inline struct tda9875 *to_state(struct v4l2_subdev *sd)
{
	return container_of(sd, struct tda9875, sd);
}
static int tda9875_command(struct i2c_client *client, unsigned cmd, void *arg)
{
	return v4l2_subdev_command(i2c_get_clientdata(client), cmd, arg);
}
static inline struct tlv320aic23b_state *to_state(struct v4l2_subdev *sd)
{
	return container_of(sd, struct tlv320aic23b_state, sd);
}
static int tlv320aic23b_command(struct i2c_client *client, unsigned cmd, void *arg)
{
	return v4l2_subdev_command(i2c_get_clientdata(client), cmd, arg);
}
static inline struct tuner *to_tuner(struct v4l2_subdev *sd)
{
	return container_of(sd, struct tuner, sd);
}
static inline int check_v4l2(struct tuner *t)
{
	return 0;
}
static int tuner_command(struct i2c_client *client, unsigned cmd, void *arg)
{
	return v4l2_subdev_command(i2c_get_clientdata(client), cmd, arg);
}
static inline struct CHIPSTATE *to_state(struct v4l2_subdev *sd)
{
	return container_of(sd, struct CHIPSTATE, sd);
}
static int tda9855_volume(int val) { return val/0x2e8+0x27; }
static int tda9855_bass(int val)   { return val/0xccc+0x06; }
static int tda9855_treble(int val) { return (val/0x1c71+0x3)<<1; }
static int tea6300_shift10(int val) { return val >> 10; }
static int tea6300_shift12(int val) { return val >> 12; }
static int tea6320_volume(int val) { return (val / (65535/(63-12)) + 12) & 0x3f; }
static int tea6320_shift11(int val) { return val >> 11; }
static int tda8425_shift10(int val) { return (val >> 10) | 0xc0; }
static int tda8425_shift12(int val) { return (val >> 12) | 0xf0; }
static int tvaudio_command(struct i2c_client *client, unsigned cmd, void *arg)
{
	return v4l2_subdev_command(i2c_get_clientdata(client), cmd, arg);
}
static int ioctl_dev_exit(struct v4l2_int_device *s)
{
	return 0;
}
static int __init tvp514x_init(void)
{
	return i2c_add_driver(&tvp514x_i2c_driver);
}
static void __exit tvp514x_cleanup(void)
{
	i2c_del_driver(&tvp514x_i2c_driver);
}
static inline struct tvp5150 *to_tvp5150(struct v4l2_subdev *sd)
{
	return container_of(sd, struct tvp5150, sd);
}
static int tvp5150_command(struct i2c_client *client, unsigned cmd, void *arg)
{
	return v4l2_subdev_command(i2c_get_clientdata(client), cmd, arg);
}
static int tw9910_stop_capture(struct soc_camera_device *icd)
{
	return 0;
}
static int tw9910_set_bus_param(struct soc_camera_device *icd,
				unsigned long flags)
{
	return 0;
}
static void tw9910_video_remove(struct soc_camera_device *icd)
{
	soc_camera_video_stop(icd);
}
static int __init tw9910_module_init(void)
{
	return i2c_add_driver(&tw9910_i2c_driver);
}
static void __exit tw9910_module_exit(void)
{
	i2c_del_driver(&tw9910_i2c_driver);
}
static inline struct upd64031a_state *to_state(struct v4l2_subdev *sd)
{
	return container_of(sd, struct upd64031a_state, sd);
}
static int upd64031a_command(struct i2c_client *client, unsigned cmd, void *arg)
{
	return v4l2_subdev_command(i2c_get_clientdata(client), cmd, arg);
}
static inline struct upd64083_state *to_state(struct v4l2_subdev *sd)
{
	return container_of(sd, struct upd64083_state, sd);
}
static int upd64083_command(struct i2c_client *client, unsigned cmd, void *arg)
{
	return v4l2_subdev_command(i2c_get_clientdata(client), cmd, arg);
}
static int ibmcam_calculate_fps(struct uvd *uvd)
{
	return 3 + framerate*4 + framerate/2;
}
static void __exit ibmcam_cleanup(void)
{
	usbvideo_Deregister(&cams);
}
static void __exit konicawc_cleanup(void)
{
	usbvideo_Deregister(&cams);
}
static void qcm_stop_int_data(struct qcm *cam)
{
	usb_kill_urb(cam->button_urb);
}
static void qcm_free_int(struct qcm *cam)
{
	usb_free_urb(cam->button_urb);
}
static void __exit qcm_exit(void)
{
	usbvideo_Deregister(&cams);
}
static int ultracam_calculate_fps(struct uvd *uvd)
{
	return 3 + framerate*4 + framerate/2;
}
static void ultracam_video_start(struct uvd *uvd)
{
	ultracam_reinit_iso(uvd, 0);
}
static void __exit ultracam_cleanup(void)
{
	usbvideo_Deregister(&cams);
}
static long usbvideo_v4l_ioctl(struct file *file,
		       unsigned int cmd, unsigned long arg)
{
	return video_usercopy(file, cmd, arg, usbvideo_v4l_do_ioctl);
}
void usbvision_set_powerOffTimer(struct usb_usbvision *usbvision)
{
	mod_timer(&usbvision->powerOffTimer, jiffies + USBVISION_POWEROFF_TIME);
}
static u32 functionality(struct i2c_adapter *adap)
{
	return I2C_FUNC_SMBUS_EMUL | I2C_FUNC_10BIT_ADDR;
}
void call_i2c_clients(struct usb_usbvision *usbvision, unsigned int cmd,
		      void *arg)
{
	i2c_clients_command(&usbvision->i2c_adap, cmd, arg);
}
static ssize_t show_version(struct device *cd,
			    struct device_attribute *attr, char *buf)
{
	return sprintf(buf, "%s\n", USBVISION_VERSION_STRING);
}
static int usbvision_vbi_open(struct file *file)
{
	return -ENODEV;
}
static int usbvision_vbi_close(struct file *file)
{
	return -ENODEV;
}
static long usbvision_do_vbi_ioctl(struct file *file,
				 unsigned int cmd, void *arg)
{
	return -ENOIOCTLCMD;
}
static long usbvision_vbi_ioctl(struct file *file,
		       unsigned int cmd, unsigned long arg)
{
	return video_usercopy(file, cmd, arg, usbvision_do_vbi_ioctl);
}
static inline __u8 *uvc_ctrl_data(struct uvc_control *ctrl, int id)
{
	return ctrl->data + id * ctrl->info->size;
}
static inline int uvc_test_bit(const __u8 *data, int bit)
{
	return (data[bit >> 3] >> (bit & 7)) & 1;
}
static inline void uvc_clear_bit(__u8 *data, int bit)
{
	data[bit >> 3] &= ~(1 << (bit & 7));
}
int uvc_ctrl_begin(struct uvc_video_device *video)
{
	return mutex_lock_interruptible(&video->ctrl_mutex) ? -ERESTARTSYS : 0;
}
static int uvc_resume(struct usb_interface *intf)
{
	return __uvc_resume(intf, 0);
}
static int uvc_reset_resume(struct usb_interface *intf)
{
	return __uvc_resume(intf, 1);
}
static void __exit uvc_cleanup(void)
{
	usb_deregister(&uvc_driver.driver);
}
static int uvc_has_privileges(struct uvc_fh *handle)
{
	return handle->state == UVC_HANDLE_ACTIVE;
}
int uvc_commit_video(struct uvc_video_device *video,
	struct uvc_streaming_control *probe)
{
	return uvc_set_video_ctrl(video, probe, 0);
}
static unsigned int __pure
palette_to_pixelformat(unsigned int palette)
{
	if (palette < ARRAY_SIZE(palette2pixelformat))
		return palette2pixelformat[palette];
	else
		return 0;
}
int v4l2_prio_open(struct v4l2_prio_state *global, enum v4l2_priority *local)
{
	return v4l2_prio_change(global,local,V4L2_PRIORITY_DEFAULT);
}
struct video_device *video_device_alloc(void)
{
	return kzalloc(sizeof(struct video_device), GFP_KERNEL);
}
void video_device_release(struct video_device *vdev)
{
	kfree(vdev);
}
static inline void video_get(struct video_device *vdev)
{
	get_device(&vdev->dev);
}
static inline void video_put(struct video_device *vdev)
{
	put_device(&vdev->dev);
}
struct video_device *video_devdata(struct file *file)
{
	return video_device[iminor(file->f_path.dentry->d_inode)];
}
int video_register_device(struct video_device *vdev, int type, int nr)
{
	return video_register_device_index(vdev, type, nr, -1);
}
static int no_such_ioctl_0(struct v4l2_int_device *d)
{
	return -ENOIOCTLCMD;
}
int v4l2_int_ioctl_0(struct v4l2_int_device *d, int cmd)
{
	return ((v4l2_int_ioctl_func_0 *)
		find_ioctl(d->u.slave, cmd,
			   (v4l2_int_ioctl_func *)no_such_ioctl_0))(d);
}
static int no_such_ioctl_1(struct v4l2_int_device *d, void *arg)
{
	return -ENOIOCTLCMD;
}
int v4l2_int_ioctl_1(struct v4l2_int_device *d, int cmd, void *arg)
{
	return ((v4l2_int_ioctl_func_1 *)
		find_ioctl(d->u.slave, cmd,
			   (v4l2_int_ioctl_func *)no_such_ioctl_1))(d, arg);
}

static inline void dbgrect(struct video_device *vfd, char *s,
							struct v4l2_rect *r)
{
	dbgarg2("%sRect start at %dx%d, size=%dx%d\n", s, r->left, r->top,
						r->width, r->height);
}

static inline void v4l_print_pix_fmt(struct video_device *vfd,
						struct v4l2_pix_format *fmt)
{
	dbgarg2("width=%d, height=%d, format=%c%c%c%c, field=%s, "
		"bytesperline=%d sizeimage=%d, colorspace=%d\n",
		fmt->width, fmt->height,
		(fmt->pixelformat & 0xff),
		(fmt->pixelformat >>  8) & 0xff,
		(fmt->pixelformat >> 16) & 0xff,
		(fmt->pixelformat >> 24) & 0xff,
		prt_names(fmt->field, v4l2_field_names),
		fmt->bytesperline, fmt->sizeimage, fmt->colorspace);
}
void *videobuf_queue_to_vmalloc (struct videobuf_queue *q,
			   struct videobuf_buffer *buf)
{
	if (q->int_ops->vmalloc)
		return q->int_ops->vmalloc(buf);
	else
		return NULL;
}
void videobuf_queue_dma_contig_init(struct videobuf_queue *q,
				    struct videobuf_queue_ops *ops,
				    struct device *dev,
				    spinlock_t *irqlock,
				    enum v4l2_buf_type type,
				    enum v4l2_field field,
				    unsigned int msize,
				    void *priv)
{
	videobuf_queue_core_init(q, ops, dev, irqlock, type, field, msize,
				 priv, &qops);
}
void videobuf_queue_sg_init(struct videobuf_queue* q,
			 struct videobuf_queue_ops *ops,
			 struct device *dev,
			 spinlock_t *irqlock,
			 enum v4l2_buf_type type,
			 enum v4l2_field field,
			 unsigned int msize,
			 void *priv)
{
	videobuf_queue_core_init(q, ops, dev, irqlock, type, field, msize,
				 priv, &sg_ops);
}
static int __videobuf_sync(struct videobuf_queue *q,
			   struct videobuf_buffer *buf)
{
	return 0;
}
void videobuf_queue_vmalloc_init(struct videobuf_queue* q,
			 struct videobuf_queue_ops *ops,
			 void *dev,
			 spinlock_t *irqlock,
			 enum v4l2_buf_type type,
			 enum v4l2_field field,
			 unsigned int msize,
			 void *priv)
{
	videobuf_queue_core_init(q, ops, dev, irqlock, type, field, msize,
				 priv, &qops);
}
unsigned i2c_vino_getctrl(void *data)
{
	return vino->i2c_control;
}
void i2c_vino_setctrl(void *data, unsigned val)
{
	vino->i2c_control = val;
}
unsigned i2c_vino_rdata(void *data)
{
	return vino->i2c_data;
}
void i2c_vino_wdata(void *data, unsigned val)
{
	vino->i2c_data = val;
}
static int vino_i2c_add_bus(void)
{
	return i2c_sgi_add_bus(&vino_i2c_adapter);
}
static int vino_i2c_del_bus(void)
{
	return i2c_del_adapter(&vino_i2c_adapter);
}
static int i2c_camera_command(unsigned int cmd, void *arg)
{
	return vino_drvdata->camera.driver->
		driver->command(vino_drvdata->camera.driver,
				cmd, arg);
}
static int i2c_decoder_command(unsigned int cmd, void *arg)
{
	return vino_drvdata->decoder.driver->
		driver->command(vino_drvdata->decoder.driver,
				cmd, arg);
}
static void vino_free_buffer(struct vino_framebuffer *fb)
{
	vino_free_buffer_with_count(fb, fb->desc_table.page_count);
}
static inline unsigned int vino_fifo_get_used(struct vino_framebuffer_fifo *f)
{
	return f->used;
}
static inline void vino_set_default_clipping(struct vino_channel_settings *vcs)
{
	vino_set_clipping(vcs, 0, 0, vino_data_norms[vcs->data_norm].width,
			  vino_data_norms[vcs->data_norm].height);
}
static inline void vino_set_default_scaling(struct vino_channel_settings *vcs)
{
	vino_set_scaling(vcs, vcs->clipping.right - vcs->clipping.left,
			 vcs->clipping.bottom - vcs->clipping.top);
}
static inline void vino_set_default_framerate(struct
					      vino_channel_settings *vcs)
{
	vino_set_framerate(vcs, vino_data_norms[vcs->data_norm].fps_max);
}
static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id *i)
{
	return 0;
}
static void __exit vivi_exit(void)
{
	vivi_release();
}
static inline struct vp27smpx_state *to_state(struct v4l2_subdev *sd)
{
	return container_of(sd, struct vp27smpx_state, sd);
}
static int vp27smpx_command(struct i2c_client *client, unsigned cmd, void *arg)
{
	return v4l2_subdev_command(i2c_get_clientdata(client), cmd, arg);
}
static inline int vpx3220_read(struct i2c_client *client, u8 reg)
{
	return i2c_smbus_read_byte_data(client, reg);
}
static inline void w9966_setState(struct w9966_dev* cam, int mask, int val)
{
	cam->dev_state = (cam->dev_state & ~mask) ^ val;
}
static inline int w9966_getState(struct w9966_dev* cam, int mask, int val)
{
	return ((cam->dev_state & mask) == val);
}
static long w9966_v4l_ioctl(struct file *file,
			   unsigned int cmd, unsigned long arg)
{
	return video_usercopy(file, cmd, arg, w9966_v4l_do_ioctl);
}
static void __exit w9966_mod_term(void)
{
	parport_unregister_driver(&w9966_ppd);
}
static u32 w9968cf_i2c_func(struct i2c_adapter* adap)
{
	return I2C_FUNC_SMBUS_READ_BYTE |
	       I2C_FUNC_SMBUS_READ_BYTE_DATA  |
	       I2C_FUNC_SMBUS_WRITE_BYTE_DATA;
}
static inline struct wm8739_state *to_state(struct v4l2_subdev *sd)
{
	return container_of(sd, struct wm8739_state, sd);
}
static int wm8739_command(struct i2c_client *client, unsigned cmd, void *arg)
{
	return v4l2_subdev_command(i2c_get_clientdata(client), cmd, arg);
}
static inline struct wm8775_state *to_state(struct v4l2_subdev *sd)
{
	return container_of(sd, struct wm8775_state, sd);
}
static int wm8775_command(struct i2c_client *client, unsigned cmd, void *arg)
{
	return v4l2_subdev_command(i2c_get_clientdata(client), cmd, arg);
}
static void __exit zc0301_module_exit(void)
{
	usb_deregister(&zc0301_usb_driver);
}
static int proc_videocodecs_open(struct inode *inode, struct file *file)
{
	return single_open(file, proc_videocodecs_show, NULL);
}
static void __exit
videocodec_exit (void)
{
	remove_proc_entry("videocodecs", NULL);
}
static void
dc10plus_init (struct zoran *zr)
{
	dprintk(3, KERN_DEBUG "%s: dc10plus_init()\n", ZR_DEVNAME(zr));
}
static void
zoran_unregister_i2c (struct zoran *zr)
{
	i2c_del_adapter(&zr->i2c_adapter);
}
void
zoran_vdev_release (struct video_device *vdev)
{
	kfree(vdev);
}
static void __exit zoran_exit(void)
{
	pci_unregister_driver(&zoran_driver);
}
static inline void
set_frame (struct zoran *zr,
	   int           val)
{
	GPIO(zr, zr->card.gpio[ZR_GPIO_JPEG_FRAME], val);
}
static ssize_t
zoran_read (struct file *file,
	    char        __user *data,
	    size_t       count,
	    loff_t      *ppos)
{
	return -EINVAL;
}
static ssize_t
zoran_write (struct file *file,
	     const char  __user *data,
	     size_t       count,
	     loff_t      *ppos)
{
	return -EINVAL;
}
static long
zoran_ioctl(struct file  *file,
	    unsigned int  cmd,
	    unsigned long arg)
{
	return video_usercopy(file, cmd, arg, zoran_do_ioctl);
}
static int zr364xx_vidioc_streamon(struct file *file, void *priv,
				   enum v4l2_buf_type type)
{
	return 0;
}
static int zr364xx_vidioc_streamoff(struct file *file, void *priv,
				    enum v4l2_buf_type type)
{
	return 0;
}
static int memstick_dummy_check(struct memstick_dev *card)
{
	return 0;
}
void memstick_detect_change(struct memstick_host *host)
{
	queue_work(workqueue, &host->media_checker);
}
void memstick_unregister_driver(struct memstick_driver *drv)
{
	driver_unregister(&drv->driver);
}
static int mspro_block_bd_release(struct gendisk *disk, fmode_t mode)
{
	return mspro_block_disk_release(disk);
}
static int h_mspro_block_default(struct memstick_dev *card,
				 struct memstick_request **mrq)
{
	return mspro_block_complete_req(card, (*mrq)->error);
}
static int h_mspro_block_default_bad(struct memstick_dev *card,
				     struct memstick_request **mrq)
{
	return -ENXIO;
}
static void jmb38x_ms_dummy_submit(struct memstick_host *msh)
{
	return;
}
static int __init jmb38x_ms_init(void)
{
	return pci_register_driver(&jmb38x_ms_driver);
}
static void __exit jmb38x_ms_exit(void)
{
	pci_unregister_driver(&jmb38x_ms_driver);
}
static void tifm_ms_dummy_submit(struct memstick_host *msh)
{
	return;
}
static int __init tifm_ms_init(void)
{
	return tifm_register_driver(&tifm_ms_driver);
}
static void __exit tifm_ms_exit(void)
{
	tifm_unregister_driver(&tifm_ms_driver);
}
static int
mptfc_abort(struct scsi_cmnd *SCpnt)
{
	return
	    mptfc_block_error_handler(SCpnt, mptscsih_abort, __func__);
}
static int
mptfc_dev_reset(struct scsi_cmnd *SCpnt)
{
	return
	    mptfc_block_error_handler(SCpnt, mptscsih_dev_reset, __func__);
}
static int
mptfc_bus_reset(struct scsi_cmnd *SCpnt)
{
	return
	    mptfc_block_error_handler(SCpnt, mptscsih_bus_reset, __func__);
}
static int
mptfc_host_reset(struct scsi_cmnd *SCpnt)
{
	return
	    mptfc_block_error_handler(SCpnt, mptscsih_host_reset, __func__);
}
static void
mpt_lan_post_receive_buckets_work(struct work_struct *work)
{
	mpt_lan_post_receive_buckets(container_of(work, struct mpt_lan_priv,
						  post_buckets_task.work));
}
static inline int
mptsas_is_end_device(struct mptsas_devinfo * attached)
{
	if ((attached->sas_address) &&
	    (attached->device_info &
	    MPI_SAS_DEVICE_INFO_END_DEVICE) &&
	    ((attached->device_info &
	    MPI_SAS_DEVICE_INFO_SSP_TARGET) |
	    (attached->device_info &
	    MPI_SAS_DEVICE_INFO_STP_TARGET) |
	    (attached->device_info &
	    MPI_SAS_DEVICE_INFO_SATA_DEVICE)))
		return 1;
	else
		return 0;
}
static inline struct sas_rphy *
mptsas_get_rphy(struct mptsas_phyinfo *phy_info)
{
	if (phy_info->port_details)
		return phy_info->port_details->rphy;
	else
		return NULL;
}
static inline struct sas_port *
mptsas_get_port(struct mptsas_phyinfo *phy_info)
{
	if (phy_info->port_details)
		return phy_info->port_details->port;
	else
		return NULL;
}
static inline struct scsi_target *
mptsas_get_starget(struct mptsas_phyinfo *phy_info)
{
	if (phy_info->port_details)
		return phy_info->port_details->starget;
	else
		return NULL;
}
static void
mptsas_reprobe_target(struct scsi_target *starget, int uld_attach)
{
	starget_for_each_device(starget, uld_attach ? (void *)1 : NULL,
			mptsas_reprobe_lun);
}
static void
mptspi_print_write_nego(struct _MPT_SCSI_HOST *hd, struct scsi_target *starget, u32 ii)
{
	ddvprintk(hd->ioc, printk(MYIOC_s_DEBUG_FMT "id=%d Requested = 0x%08x"
	    " ( %s factor = 0x%02x @ offset = 0x%02x %s%s%s%s%s%s%s%s)\n",
	    hd->ioc->name, starget->id, ii,
	    ii & MPI_SCSIDEVPAGE0_NP_WIDE ? "Wide ": "",
	    ((ii >> 8) & 0xFF), ((ii >> 16) & 0xFF),
	    ii & MPI_SCSIDEVPAGE0_NP_IU ? "IU ": "",
	    ii & MPI_SCSIDEVPAGE0_NP_DT ? "DT ": "",
	    ii & MPI_SCSIDEVPAGE0_NP_QAS ? "QAS ": "",
	    ii & MPI_SCSIDEVPAGE0_NP_HOLD_MCS ? "HOLDMCS ": "",
	    ii & MPI_SCSIDEVPAGE0_NP_WR_FLOW ? "WRFLOW ": "",
	    ii & MPI_SCSIDEVPAGE0_NP_RD_STRM ? "RDSTRM ": "",
	    ii & MPI_SCSIDEVPAGE0_NP_RTI ? "RTI ": "",
	    ii & MPI_SCSIDEVPAGE0_NP_PCOMP_EN ? "PCOMP ": ""));
}
static void
mptspi_print_read_nego(struct _MPT_SCSI_HOST *hd, struct scsi_target *starget, u32 ii)
{
	ddvprintk(hd->ioc, printk(MYIOC_s_DEBUG_FMT "id=%d Read = 0x%08x"
	    " ( %s factor = 0x%02x @ offset = 0x%02x %s%s%s%s%s%s%s%s)\n",
	    hd->ioc->name, starget->id, ii,
	    ii & MPI_SCSIDEVPAGE0_NP_WIDE ? "Wide ": "",
	    ((ii >> 8) & 0xFF), ((ii >> 16) & 0xFF),
	    ii & MPI_SCSIDEVPAGE0_NP_IU ? "IU ": "",
	    ii & MPI_SCSIDEVPAGE0_NP_DT ? "DT ": "",
	    ii & MPI_SCSIDEVPAGE0_NP_QAS ? "QAS ": "",
	    ii & MPI_SCSIDEVPAGE0_NP_HOLD_MCS ? "HOLDMCS ": "",
	    ii & MPI_SCSIDEVPAGE0_NP_WR_FLOW ? "WRFLOW ": "",
	    ii & MPI_SCSIDEVPAGE0_NP_RD_STRM ? "RDSTRM ": "",
	    ii & MPI_SCSIDEVPAGE0_NP_RTI ? "RTI ": "",
	    ii & MPI_SCSIDEVPAGE0_NP_PCOMP_EN ? "PCOMP ": ""));
}
 static void __exit i2o_bus_exit(void)
{
	i2o_driver_unregister(&i2o_bus_driver);
}
 static void i2o_exec_wait_free(struct i2o_exec_wait *wait)
{
	kfree(wait);
}
 int __init i2o_exec_init(void)
{
	return i2o_driver_register(&i2o_exec_driver);
}
 void i2o_exec_exit(void)
{
	i2o_driver_unregister(&i2o_exec_driver);
}
 static inline void i2o_block_request_free(struct i2o_block_request *ireq)
{
	mempool_free(ireq, i2o_blk_req_pool.pool);
}
static void i2o_config_old_exit(void)
{
	misc_deregister(&i2o_miscdev);
}

static int i2o_seq_open_hrt(struct inode *inode, struct file *file)
{
	return single_open(file, i2o_seq_show_hrt, PDE(inode)->data);
}

static int i2o_seq_open_lct(struct inode *inode, struct file *file)
{
	return single_open(file, i2o_seq_show_lct, PDE(inode)->data);
}

static int i2o_seq_open_status(struct inode *inode, struct file *file)
{
	return single_open(file, i2o_seq_show_status, PDE(inode)->data);
}

static int i2o_seq_open_hw(struct inode *inode, struct file *file)
{
	return single_open(file, i2o_seq_show_hw, PDE(inode)->data);
}

static int i2o_seq_open_ddm_table(struct inode *inode, struct file *file)
{
	return single_open(file, i2o_seq_show_ddm_table, PDE(inode)->data);
}

static int i2o_seq_open_driver_store(struct inode *inode, struct file *file)
{
	return single_open(file, i2o_seq_show_driver_store, PDE(inode)->data);
}

static int i2o_seq_open_drivers_stored(struct inode *inode, struct file *file)
{
	return single_open(file, i2o_seq_show_drivers_stored, PDE(inode)->data);
}

static int i2o_seq_open_groups(struct inode *inode, struct file *file)
{
	return single_open(file, i2o_seq_show_groups, PDE(inode)->data);
}

static int i2o_seq_open_phys_device(struct inode *inode, struct file *file)
{
	return single_open(file, i2o_seq_show_phys_device, PDE(inode)->data);
}

static int i2o_seq_open_claimed(struct inode *inode, struct file *file)
{
	return single_open(file, i2o_seq_show_claimed, PDE(inode)->data);
}

static int i2o_seq_open_users(struct inode *inode, struct file *file)
{
	return single_open(file, i2o_seq_show_users, PDE(inode)->data);
}

static int i2o_seq_open_priv_msgs(struct inode *inode, struct file *file)
{
	return single_open(file, i2o_seq_show_priv_msgs, PDE(inode)->data);
}

static int i2o_seq_open_authorized_users(struct inode *inode, struct file *file)
{
	return single_open(file, i2o_seq_show_authorized_users,
			   PDE(inode)->data);
}

static int i2o_seq_open_dev_identity(struct inode *inode, struct file *file)
{
	return single_open(file, i2o_seq_show_dev_identity, PDE(inode)->data);
}

static int i2o_seq_open_ddm_identity(struct inode *inode, struct file *file)
{
	return single_open(file, i2o_seq_show_ddm_identity, PDE(inode)->data);
}

static int i2o_seq_open_uinfo(struct inode *inode, struct file *file)
{
	return single_open(file, i2o_seq_show_uinfo, PDE(inode)->data);
}

static int i2o_seq_open_sgl_limits(struct inode *inode, struct file *file)
{
	return single_open(file, i2o_seq_show_sgl_limits, PDE(inode)->data);
}

static int i2o_seq_open_sensors(struct inode *inode, struct file *file)
{
	return single_open(file, i2o_seq_show_sensors, PDE(inode)->data);
}

static int i2o_seq_open_dev_name(struct inode *inode, struct file *file)
{
	return single_open(file, i2o_seq_show_dev_name, PDE(inode)->data);
}
 static struct i2o_scsi_host *i2o_scsi_get_host(struct i2o_controller *c)
{
	return c->driver_data[i2o_scsi_driver.context];
}
static void __exit i2o_scsi_exit(void)
{
	/* Unregister I2O SCSI OSM from I2O core */
	i2o_driver_unregister(&i2o_scsi_driver);
}
 int __init i2o_pci_init(void)
{
	return pci_register_driver(&i2o_pci_driver);
}
 void __exit i2o_pci_exit(void)
{
	pci_unregister_driver(&i2o_pci_driver);
}
static inline void asic3_write_register(struct asic3 *asic,
				 unsigned int reg, u32 value)
{
	iowrite16(value, asic->mapping +
		  (reg >> asic->bus_shift));
}
static inline u32 asic3_read_register(struct asic3 *asic,
			       unsigned int reg)
{
	return ioread16(asic->mapping +
			(reg >> asic->bus_shift));
}
static inline int asic3_irq_to_index(struct asic3 *asic, int irq)
{
	return (irq - asic->irq_base) & 0xf;
}
static int asic3_gpio_direction_input(struct gpio_chip *chip,
				      unsigned offset)
{
	return asic3_gpio_direction(chip, offset, 0);
}
static int asic3_gpio_direction_output(struct gpio_chip *chip,
				       unsigned offset, int value)
{
	return asic3_gpio_direction(chip, offset, 1);
}
int da903x_write(struct device *dev, int reg, uint8_t val)
{
	return __da903x_write(to_i2c_client(dev), reg, val);
}
int da903x_writes(struct device *dev, int reg, int len, uint8_t *val)
{
	return __da903x_writes(to_i2c_client(dev), reg, len, val);
}
int da903x_read(struct device *dev, int reg, uint8_t *val)
{
	return __da903x_read(to_i2c_client(dev), reg, val);
}
int da903x_reads(struct device *dev, int reg, int len, uint8_t *val)
{
	return __da903x_reads(to_i2c_client(dev), reg, len, val);
}
static int da9030_read_status(struct da903x_chip *chip, unsigned int *status)
{
	return __da903x_read(chip->client, DA9030_STATUS, (uint8_t *)status);
}
static int da903x_remove_subdevs(struct da903x_chip *chip)
{
	return device_for_each_child(chip->dev, NULL, __remove_subdev);
}
static int __init da903x_init(void)
{
	return i2c_add_driver(&da903x_driver);
}
static void __exit da903x_exit(void)
{
	i2c_del_driver(&da903x_driver);
}
int dm355evm_msp_write(u8 value, u8 reg)
{
	return i2c_smbus_write_byte_data(msp430, reg, value);
}
int dm355evm_msp_read(u8 reg)
{
	return i2c_smbus_read_byte_data(msp430, reg);
}
static void msp_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
{
	msp_gpio_out(chip, offset, value);
}
static void dm355evm_power_off(void)
{
	dm355evm_command(MSP_COMMAND_POWEROFF);
}
static int __init dm355evm_msp_init(void)
{
	return i2c_add_driver(&dm355evm_msp_driver);
}
static void __exit dm355evm_msp_exit(void)
{
	i2c_del_driver(&dm355evm_msp_driver);
}
static inline void egpio_writew(u16 value, struct egpio_info *ei, int reg)
{
	writew(value, ei->base_addr + (reg << ei->bus_shift));
}
static inline u16 egpio_readw(struct egpio_info *ei, int reg)
{
	return readw(ei->base_addr + (reg << ei->bus_shift));
}
static inline int egpio_pos(struct egpio_info *ei, int bit)
{
	return bit >> ei->reg_shift;
}
static inline int egpio_bit(struct egpio_info *ei, int bit)
{
	return 1 << (bit & ((1 << ei->reg_shift)-1));
}
static int __init egpio_init(void)
{
	return platform_driver_probe(&egpio_driver, egpio_probe);
}
static void __exit egpio_exit(void)
{
	platform_driver_unregister(&egpio_driver);
}
static int __init pasic3_base_init(void)
{
	return platform_driver_probe(&pasic3_driver, pasic3_probe);
}
static void __exit pasic3_base_exit(void)
{
	platform_driver_unregister(&pasic3_driver);
}
static int mcp_bus_match(struct device *dev, struct device_driver *drv)
{
	return 1;
}
void mcp_host_unregister(struct mcp *mcp)
{
	device_unregister(&mcp->attached_device);
}
void mcp_driver_unregister(struct mcp_driver *mcpdrv)
{
	driver_unregister(&mcpdrv->drv);
}
static int __init mcp_init(void)
{
	return bus_register(&mcp_bus_type);
}
static void __exit mcp_exit(void)
{
	bus_unregister(&mcp_bus_type);
}
static void mcp_sa11x0_disable(struct mcp *mcp)
{
	Ser4MCCR0 &= ~MCCR0_MCE;
}
static int __init mcp_sa11x0_init(void)
{
	return platform_driver_register(&mcp_sa11x0_driver);
}
static void __exit mcp_sa11x0_exit(void)
{
	platform_driver_unregister(&mcp_sa11x0_driver);
}
static int menelaus_ack_irq(int irq)
{
	if (irq > 7)
		return menelaus_write_reg(MENELAUS_INT_ACK2, 1 << (irq - 8));
	else
		return menelaus_write_reg(MENELAUS_INT_ACK1, 1 << irq);
}
int menelaus_get_slot_pin_states(void)
{
	return menelaus_read_reg(MENELAUS_MCT_PIN_ST);
}
static void __exit menelaus_exit(void)
{
	i2c_del_driver(&menelaus_i2c_driver);
}
void mfd_remove_devices(struct device *parent)
{
	device_for_each_child(parent, NULL, mfd_remove_devices_fn);
}
static inline struct pcf50633_adc *__to_adc(struct pcf50633 *pcf)
{
	return platform_get_drvdata(pcf->adc_pdev);
}
static int __init pcf50633_adc_init(void)
{
	return platform_driver_register(&pcf50633_adc_driver);
}
static void __exit pcf50633_adc_exit(void)
{
	platform_driver_unregister(&pcf50633_adc_driver);
}
static int __init pcf50633_init(void)
{
	return i2c_add_driver(&pcf50633_driver);
}
static void __exit pcf50633_exit(void)
{
	i2c_del_driver(&pcf50633_driver);
}
static void sm501_sync_regs(struct sm501_devdata *sm)
{
	readl(sm->regs);
}
static long sm501fb_round_div(long num, long denom)
{
        return (2 * num + denom) / (2 * denom);
}
static struct sm501_device *to_sm_device(struct platform_device *pdev)
{
	return container_of(pdev, struct sm501_device, pdev);
}
static void sm501_device_release(struct device *dev)
{
	kfree(to_sm_device(to_platform_device(dev)));
}
static inline struct sm501_gpio_chip *to_sm501_gpio(struct gpio_chip *gc)
{
	return container_of(gc, struct sm501_gpio_chip, gpio);
}
static inline struct sm501_devdata *sm501_gpio_to_dev(struct sm501_gpio *gpio)
{
	return container_of(gpio, struct sm501_devdata, gpio);
}
static inline int sm501_gpio_isregistered(struct sm501_devdata *sm)
{
	return sm->gpio.registered;
}
static inline int sm501_register_gpio(struct sm501_devdata *sm)
{
	return 0;
}
static inline int sm501_gpio_pin2nr(struct sm501_devdata *sm, unsigned int pin)
{
	return -1;
}
static inline int sm501_gpio_isregistered(struct sm501_devdata *sm)
{
	return 0;
}
static void __exit t7l66xb_exit(void)
{
	platform_driver_unregister(&t7l66xb_platform_driver);
}
static int __init tc6387xb_init(void)
{
	return platform_driver_register(&tc6387xb_platform_driver);
}
static void __exit tc6387xb_exit(void)
{
	platform_driver_unregister(&tc6387xb_platform_driver);
}
static int __init tc6393xb_init(void)
{
	return platform_driver_register(&tc6393xb_driver);
}
static void __exit tc6393xb_exit(void)
{
	platform_driver_unregister(&tc6393xb_driver);
}
static void dbg_chgstat(char *buf, size_t len, u8 chgstatus)
{
	snprintf(buf, len, "%02x%s%s%s%s%s%s%s%s\n",
		chgstatus,
		(chgstatus & TPS_CHG_USB) ? " USB" : "",
		(chgstatus & TPS_CHG_AC) ? " AC" : "",
		(chgstatus & TPS_CHG_THERM) ? " therm" : "",
		(chgstatus & TPS_CHG_TERM) ? " done" :
			((chgstatus & (TPS_CHG_USB|TPS_CHG_AC))
				? " (charging)" : ""),
		(chgstatus & TPS_CHG_TAPER_TMO) ? " taper_tmo" : "",
		(chgstatus & TPS_CHG_CHG_TMO) ? " charge_tmo" : "",
		(chgstatus & TPS_CHG_PRECHG_TMO) ? " prechg_tmo" : "",
		(chgstatus & TPS_CHG_TEMP_ERR) ? " temp_err" : "");
}

static void dbg_regstat(char *buf, size_t len, u8 regstatus)
{
	snprintf(buf, len, "%02x %s%s%s%s%s%s%s%s\n",
		regstatus,
		(regstatus & TPS_REG_ONOFF) ? "off" : "(on)",
		(regstatus & TPS_REG_COVER) ? " uncover" : "",
		(regstatus & TPS_REG_UVLO) ? " UVLO" : "",
		(regstatus & TPS_REG_NO_CHG) ? " NO_CHG" : "",
		(regstatus & TPS_REG_PG_LD02) ? " ld02_bad" : "",
		(regstatus & TPS_REG_PG_LD01) ? " ld01_bad" : "",
		(regstatus & TPS_REG_PG_MAIN) ? " main_bad" : "",
		(regstatus & TPS_REG_PG_CORE) ? " core_bad" : "");
}
static int dbg_tps_open(struct inode *inode, struct file *file)
{
	return single_open(file, dbg_show, inode->i_private);
}
static void __exit tps_exit(void)
{
	i2c_del_driver(&tps65010_driver);
}
int twl4030_i2c_read_u8(u8 mod_no, u8 *value, u8 reg)
{
	return twl4030_i2c_read(mod_no, value, reg, 1);
}
static inline struct device *add_child(unsigned chip, const char *name,
		void *pdata, unsigned pdata_len,
		bool can_wakeup, int irq0, int irq1)
{
	return add_numbered_child(chip, name, -1, pdata, pdata_len,
		can_wakeup, irq0, irq1);
}
static struct device *
add_regulator(int num, struct regulator_init_data *pdata)
{
	return add_regulator_linked(num, pdata, NULL, 0);
}
static int __init twl4030_init(void)
{
	return i2c_add_driver(&twl4030_driver);
}
static void __exit twl4030_exit(void)
{
	i2c_del_driver(&twl4030_driver);
}
static int __init ucb1400_core_init(void)
{
	return driver_register(&ucb1400_core_driver);
}
static void __exit ucb1400_core_exit(void)
{
	driver_unregister(&ucb1400_core_driver);
}
static int __init ucb1x00_assabet_init(void)
{
	return ucb1x00_register_driver(&ucb1x00_assabet_driver);
}
static void __exit ucb1x00_assabet_exit(void)
{
	ucb1x00_unregister_driver(&ucb1x00_assabet_driver);
}
unsigned int ucb1x00_io_read(struct ucb1x00 *ucb)
{
	return ucb1x00_reg_read(ucb, UCB_IO_DATA);
}
static inline void ucb1x00_ts_mode_int(struct ucb1x00_ts *ts)
{
	ucb1x00_reg_write(ts->ucb, UCB_TS_CR,
			UCB_TS_CR_TSMX_POW | UCB_TS_CR_TSPX_POW |
			UCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_GND |
			UCB_TS_CR_MODE_INT);
}
static int __init ucb1x00_ts_init(void)
{
	return ucb1x00_register_driver(&ucb1x00_ts_driver);
}
static void __exit ucb1x00_ts_exit(void)
{
	ucb1x00_unregister_driver(&ucb1x00_ts_driver);
}
static int gpio_set_debounce(struct wm8350 *wm8350, int gpio, int db)
{
	if (db == WM8350_GPIO_DEBOUNCE_ON)
		return wm8350_set_bits(wm8350, WM8350_GPIO_DEBOUNCE,
				       1 << gpio);
	else
		return wm8350_clear_bits(wm8350,
					 WM8350_GPIO_DEBOUNCE, 1 << gpio);
}
static int gpio_set_pull_up(struct wm8350 *wm8350, int gpio, int up)
{
	if (up)
		return wm8350_set_bits(wm8350,
				       WM8350_GPIO_PIN_PULL_UP_CONTROL,
				       1 << gpio);
	else
		return wm8350_clear_bits(wm8350,
					 WM8350_GPIO_PIN_PULL_UP_CONTROL,
					 1 << gpio);
}
static int gpio_set_pull_down(struct wm8350 *wm8350, int gpio, int down)
{
	if (down)
		return wm8350_set_bits(wm8350,
				       WM8350_GPIO_PULL_DOWN_CONTROL,
				       1 << gpio);
	else
		return wm8350_clear_bits(wm8350,
					 WM8350_GPIO_PULL_DOWN_CONTROL,
					 1 << gpio);
}
static int gpio_set_polarity(struct wm8350 *wm8350, int gpio, int pol)
{
	if (pol == WM8350_GPIO_ACTIVE_HIGH)
		return wm8350_set_bits(wm8350,
				       WM8350_GPIO_PIN_POLARITY_TYPE,
				       1 << gpio);
	else
		return wm8350_clear_bits(wm8350,
					 WM8350_GPIO_PIN_POLARITY_TYPE,
					 1 << gpio);
}
static int gpio_set_invert(struct wm8350 *wm8350, int gpio, int invert)
{
	if (invert == WM8350_GPIO_INVERT_ON)
		return wm8350_set_bits(wm8350, WM8350_GPIO_INT_MODE, 1 << gpio);
	else
		return wm8350_clear_bits(wm8350,
					 WM8350_GPIO_INT_MODE, 1 << gpio);
}
static int __init wm8350_i2c_init(void)
{
	return i2c_add_driver(&wm8350_i2c_driver);
}
static void __exit wm8350_i2c_exit(void)
{
	i2c_del_driver(&wm8350_i2c_driver);
}
static void wm8400_release(struct wm8400 *wm8400)
{
	mfd_remove_devices(wm8400->dev);
}
static void __exit wm8400_module_exit(void)
{
	i2c_del_driver(&wm8400_i2c_driver);
}
static int __init ssc_init(void)
{
	return platform_driver_probe(&ssc_driver, ssc_probe);
}
static void __exit ssc_exit(void)
{
	platform_driver_unregister(&ssc_driver);
}
static inline void pwm_writel(const struct pwm *p, unsigned offset, u32 val)
{
	__raw_writel(val, p->base + offset);
}
static inline u32 pwm_readl(const struct pwm *p, unsigned offset)
{
	return __raw_readl(p->base + offset);
}
static inline void __iomem *pwmc_regs(const struct pwm *p, int index)
{
	return p->base + 0x200 + index * 0x20;
}
static int __init pwm_init(void)
{
	return platform_driver_probe(&atmel_pwm_driver, pwm_probe);
}
static void __exit pwm_exit(void)
{
	platform_driver_unregister(&atmel_pwm_driver);
}
static int __init tc_init(void)
{
	return platform_driver_probe(&tc_driver, tc_probe);
}
static int duramar2150_c2port_c2d_get(struct c2port_device *dev)
{
	return inb(DATA_PORT) & C2D;
}
static void __exit c2port_exit(void)
{
	class_destroy(c2port_class);
}
static void __exit at24_exit(void)
{
	i2c_del_driver(&at24_driver);
}
static int __init at25_init(void)
{
	return spi_register_driver(&at25_driver);
}
static void __exit at25_exit(void)
{
	spi_unregister_driver(&at25_driver);
}
static int __init eeprom_init(void)
{
	return i2c_add_driver(&eeprom_driver);
}
static void __exit eeprom_exit(void)
{
	i2c_del_driver(&eeprom_driver);
}
static void __exit enclosure_exit(void)
{
	class_unregister(&enclosure_class);
}
static int cpustate_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, cpustate_proc_read, NULL);
}
static unsigned char cpustate_get_state(void)
{
	return cpustate.cached_val;
}
static int cpustate_release(struct inode *inode, struct file *file)
{
	return cpustate_free_ref();
}
static int __init cpustate_init(void)
{
	return platform_driver_register(&hdpu_cpustate_driver);
}
static void __exit cpustate_exit(void)
{
	platform_driver_unregister(&hdpu_cpustate_driver);
}
static int hdpu_slot_id_open(struct inode *inode, struct file *file)
{
	return single_open(file, hdpu_slot_id_read, NULL);
}
static int hdpu_chassis_id_open(struct inode *inode, struct file *file)
{
	return single_open(file, hdpu_chassis_id_read, NULL);
}
static int __init nexus_init(void)
{
	return platform_driver_register(&hdpu_nexus_driver);
}
static void __exit nexus_exit(void)
{
	platform_driver_unregister(&hdpu_nexus_driver);
}
static inline int get_entry_id(int entry)
{
	return (entry & ENTRY_MASK_DESCRIPTOR) >> ENTRY_BITPOS_DESCRIPTOR;
}
static inline int get_entry_len(int entry)
{
	return ((entry & ENTRY_MASK_QWORDS) >> ENTRY_BITPOS_QWORDS) << 3;
}
static inline int desc_mem_sz(int nr_entry)
{
	return nr_entry << L2_QENTRY_SZ;
}
static inline void doorbell_set(struct ccb *ccb)
{
	iowrite8(1, ccb->ccb_u5.db_base);
}
static inline void doorbell_clr(struct ccb *ccb)
{
	iowrite8(2, ccb->ccb_u5.db_base);
}
static inline int fifo_sz(int nr_entry)
{
	return (nr_entry * sizeof(u64)) + FIFOHANDLESIZE;
}
static inline int is_channel_reset(struct ccb *ccb)
{
	return FIFOBARTOHANDLE(ccb->ccb_u1.send_fifobar)->reset;
}
static inline void set_channel_reset(struct ccb *ccb)
{
	FIFOBARTOHANDLE(ccb->ccb_u1.send_fifobar)->reset = 1;
}
static inline int is_device_reset(struct ilo_hwinfo *hw)
{
	return ioread32(&hw->mmio_vaddr[DB_OUT]) & (1 << DB_RESET);
}
static inline void clear_device(struct ilo_hwinfo *hw)
{
	iowrite32(-1, &hw->mmio_vaddr[DB_OUT]);
}
static void enqueue_command(struct service_processor *sp, struct command *cmd)
{
	list_add_tail(&cmd->queue_node, &sp->command_queue);
}
void ibmasm_wait_for_response(struct command *cmd, int timeout)
{
	wait_event_interruptible_timeout(cmd->wait,
				cmd->status == IBMASM_CMD_COMPLETE ||
				cmd->status == IBMASM_CMD_FAILED,
				timeout * HZ);
}
static inline int event_available(struct event_buffer *b, struct event_reader *r)
{
	return (r->next_serial_number < b->next_serial_number);
}
void ibmasm_event_buffer_exit(struct service_processor *sp)
{
	kfree(sp->event_buffer);
}
void ibmasm_register_panic_notifier(void)
{
	atomic_notifier_chain_register(&panic_notifier_list, &panic_notifier);
}
void ibmasm_unregister_panic_notifier(void)
{
	atomic_notifier_chain_unregister(&panic_notifier_list,
			&panic_notifier);
}
static int ibmasmfs_get_super(struct file_system_type *fst,
			int flags, const char *name, void *data,
			struct vfsmount *mnt)
{
	return get_sb_single(fst, flags, data, ibmasmfs_fill_super, mnt);
}
int ibmasmfs_register(void)
{
	return register_filesystem(&ibmasmfs_type);
}
void ibmasmfs_unregister(void)
{
	unregister_filesystem(&ibmasmfs_type);
}
void ibmasmfs_add_sp(struct service_processor *sp)
{
	list_add(&sp->node, &service_processors);
}
static int remote_settings_file_close(struct inode *inode, struct file *file)
{
	return 0;
}
static int __init ics932s401_init(void)
{
	return i2c_add_driver(&ics932s401_driver);
}
static void __exit ics932s401_exit(void)
{
	i2c_del_driver(&ics932s401_driver);
}
static int __devinit
ioc4_init(void)
{
	return pci_register_driver(&ioc4_driver);
}
static noinline void kgdbts_break_test(void)
{
	v2printk("kgdbts: breakpoint complete\n");
}
static void sw_break(char *arg)
{
	break_helper(force_hwbrks ? "Z1" : "Z0", arg, 0);
}
static void sw_rem_break(char *arg)
{
	break_helper(force_hwbrks ? "z1" : "z0", arg, 0);
}
static void hw_break(char *arg)
{
	break_helper("Z1", arg, 0);
}
static void hw_rem_break(char *arg)
{
	break_helper("z1", arg, 0);
}
static void hw_write_break(char *arg)
{
	break_helper("Z2", arg, 0);
}
static void hw_rem_write_break(char *arg)
{
	break_helper("z2", arg, 0);
}
static void hw_access_break(char *arg)
{
	break_helper("Z4", arg, 0);
}
static void hw_rem_access_break(char *arg)
{
	break_helper("z4", arg, 0);
}
static void hw_break_val_access(void)
{
	hw_break_val2 = hw_break_val;
}
static void hw_break_val_write(void)
{
	hw_break_val++;
}
static ssize_t phantom_show_version(struct class *cls, char *buf)
{
	return sprintf(buf, PHANTOM_VERSION "\n");
}
static inline int is_gru_paddr(unsigned long paddr)
{
	return paddr >= gru_start_paddr && paddr < gru_end_paddr;
}
static inline struct gru_state *irq_to_gru(int irq)
{
	return &gru_base[uv_numa_blade_id()]->bs_grus[irq - IRQ_GRU];
}
static int get_base_irq(void)
{
	return IRQ_GRU;
}
static void gru_free_cpu_resources(void *cb, void *dsr)
{
	preempt_enable();
}
int gru_cpu_fault_map_id(void)
{
	return uv_blade_processor_id() % GRU_NUM_TFM;
}
unsigned long gru_reserve_cb_resources(struct gru_state *gru, int cbr_au_count,
				       char *cbmap)
{
	return reserve_resources(&gru->gs_cbr_map, cbr_au_count, GRU_CBR_AU,
				 cbmap);
}
unsigned long gru_reserve_ds_resources(struct gru_state *gru, int dsr_au_count,
				       char *dsmap)
{
	return reserve_resources(&gru->gs_dsr_map, dsr_au_count, GRU_DSR_AU,
				 dsmap);
}
static int check_gru_resources(struct gru_state *gru, int cbr_au_count,
			       int dsr_au_count, int max_active_contexts)
{
	return hweight64(gru->gs_cbr_map) >= cbr_au_count
		&& hweight64(gru->gs_dsr_map) >= dsr_au_count
		&& gru->gs_active_contexts < max_active_contexts;
}
static int statistics_open(struct inode *inode, struct file *file)
{
	return single_open(file, statistics_show, NULL);
}
static int options_open(struct inode *inode, struct file *file)
{
	return single_open(file, options_show, NULL);
}
static int cch_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &cch_seq_ops);
}
static int gru_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &gru_seq_ops);
}
void gru_proc_exit(void)
{
	delete_proc_files();
}
static inline int get_on_blade_tgh(struct gru_state *gru)
{
	return uv_blade_processor_id() >> gru->gs_tgh_local_shift;
}
static enum xp_retval
xpc_notloaded(void)
{
	return xpNotLoaded;
}
static unsigned long
xp_pa_sn2(void *addr)
{
	return __pa(addr);
}
static int
xp_cpu_to_nasid_sn2(int cpuid)
{
	return cpuid_to_nasid(cpuid);
}
static unsigned long
xp_pa_uv(void *addr)
{
	return uv_gpa(addr);
}
static int
xp_cpu_to_nasid_uv(int cpuid)
{
	return UV_PNODE_TO_NASID(uv_cpu_to_pnode(cpuid));
}
void
xp_exit_uv(void)
{
	BUG_ON(!is_uv());
}
static void
xpc_teardown_partitions(void)
{
	kfree(xpc_partitions);
}
void __exit
xpc_exit(void)
{
	xpc_do_exit(xpUnloading);
}
void
xpc_teardown_rsvd_page(void)
{
	xpc_rsvd_page->ts_jiffies = 0;
}
static int
xpc_setup_partitions_sn_sn2(void)
{
	return 0;
}
static u64
xpc_receive_IRQ_amo_sn2(struct amo *amo)
{
	return FETCHOP_LOAD_OP(TO_AMO((u64)&amo->variable), FETCHOP_CLEAR);
}
static void
xpc_send_chctl_closereply_sn2(struct xpc_channel *ch, unsigned long *irq_flags)
{
	XPC_SEND_NOTIFY_IRQ_SN2(ch, XPC_CHCTL_CLOSEREPLY, irq_flags);
}
static void
xpc_send_chctl_msgrequest_sn2(struct xpc_channel *ch)
{
	XPC_SEND_NOTIFY_IRQ_SN2(ch, XPC_CHCTL_MSGREQUEST, NULL);
}
static void
xpc_send_chctl_local_msgrequest_sn2(struct xpc_channel *ch)
{
	XPC_SEND_LOCAL_NOTIFY_IRQ_SN2(ch, XPC_CHCTL_MSGREQUEST);
}
static void
xpc_save_remote_msgqueue_pa_sn2(struct xpc_channel *ch,
				unsigned long msgqueue_pa)
{
	ch->sn.sn2.remote_msgqueue_pa = msgqueue_pa;
}
static void
xpc_increment_heartbeat_sn2(void)
{
	xpc_vars_sn2->heartbeat++;
}
static void
xpc_heartbeat_exit_sn2(void)
{
	xpc_offline_heartbeat_sn2();
}
static void
xpc_request_partition_activation_sn2(struct xpc_rsvd_page *remote_rp,
				     unsigned long remote_rp_pa, int nasid)
{
	xpc_send_local_activate_IRQ_sn2(nasid);
}
static void
xpc_request_partition_reactivation_sn2(struct xpc_partition *part)
{
	xpc_send_local_activate_IRQ_sn2(part->sn.sn2.activate_IRQ_nasid);
}
static void
xpc_notify_senders_of_disconnect_sn2(struct xpc_channel *ch)
{
	xpc_notify_senders_sn2(ch, ch->reason, ch->sn.sn2.w_local_GP.put);
}
static int
xpc_n_of_deliverable_payloads_sn2(struct xpc_channel *ch)
{
	return ch->sn.sn2.w_remote_GP.put - ch->sn.sn2.w_local_GP.get;
}
static void
xpc_increment_heartbeat_uv(void)
{
	xpc_send_heartbeat_uv(XPC_ACTIVATE_MQ_MSG_INC_HEARTBEAT_UV);
}
static void
xpc_offline_heartbeat_uv(void)
{
	xpc_send_heartbeat_uv(XPC_ACTIVATE_MQ_MSG_OFFLINE_HEARTBEAT_UV);
}
static void
xpc_online_heartbeat_uv(void)
{
	xpc_send_heartbeat_uv(XPC_ACTIVATE_MQ_MSG_ONLINE_HEARTBEAT_UV);
}
static void
xpc_heartbeat_exit_uv(void)
{
	xpc_send_heartbeat_uv(XPC_ACTIVATE_MQ_MSG_OFFLINE_HEARTBEAT_UV);
}
static void
xpc_request_partition_reactivation_uv(struct xpc_partition *part)
{
	xpc_send_local_activate_IRQ_uv(part, XPC_P_ASR_ACTIVATE_UV);
}
static void
xpc_cancel_partition_deactivation_request_uv(struct xpc_partition *part)
{
	return;
}
static int
xpc_n_of_fifo_entries_uv(struct xpc_fifo_head_uv *head)
{
	return head->n_entries;
}
static void
xpc_teardown_ch_structures_sn_uv(struct xpc_partition *part)
{
	return;
}
static void
xpc_save_remote_msgqueue_pa_uv(struct xpc_channel *ch,
			       unsigned long msgqueue_pa)
{
	ch->sn.uv.remote_notify_mq_gpa = msgqueue_pa;
}
static int
xpc_partition_engaged_uv(short partid)
{
	return (xpc_partitions[partid].sn.uv.flags & XPC_P_ENGAGED_UV) != 0;
}
static int
xpc_n_of_deliverable_payloads_uv(struct xpc_channel *ch)
{
	return xpc_n_of_fifo_entries_uv(&ch->sn.uv.recv_msg_list);
}
static void
xpnet_dev_tx_timeout(struct net_device *dev)
{
	dev->stats.tx_errors++;
}
inline static void tifm_7xx1_sock_power_off(char __iomem *sock_addr)
{
	writel((~TIFM_CTRL_POWER_MASK) & readl(sock_addr + SOCK_CONTROL),
	       sock_addr + SOCK_CONTROL);
}
inline static char __iomem *
tifm_7xx1_sock_addr(char __iomem *base_addr, unsigned int sock_num)
{
	return base_addr + ((sock_num + 1) << 10);
}
static int tifm_7xx1_dummy_has_ms_pif(struct tifm_adapter *fm,
				      struct tifm_dev *sock)
{
	return 0;
}
static int __init tifm_7xx1_init(void)
{
	return pci_register_driver(&tifm_7xx1_driver);
}
static void __exit tifm_7xx1_exit(void)
{
	pci_unregister_driver(&tifm_7xx1_driver);
}
static void tifm_dummy_event(struct tifm_dev *sock)
{
	return;
}
void tifm_free_adapter(struct tifm_adapter *fm)
{
	put_device(&fm->dev);
}
int tifm_map_sg(struct tifm_dev *sock, struct scatterlist *sg, int nents,
		int direction)
{
	return pci_map_sg(to_pci_dev(sock->dev.parent), sg, nents, direction);
}
void tifm_unmap_sg(struct tifm_dev *sock, struct scatterlist *sg, int nents,
		   int direction)
{
	pci_unmap_sg(to_pci_dev(sock->dev.parent), sg, nents, direction);
}
void tifm_queue_work(struct work_struct *work)
{
	queue_work(workqueue, work);
}
void tifm_unregister_driver(struct tifm_driver *drv)
{
	driver_unregister(&drv->driver);
}
static inline int mmc_blk_readonly(struct mmc_card *card)
{
	return mmc_card_readonly(card) ||
	       !(card->csd.cmdclass & CCC_BLOCK_WRITE);
}
static int mmc_test_prepare_write(struct mmc_test_card *test)
{
	return __mmc_test_prepare(test, 1);
}
static int mmc_test_prepare_read(struct mmc_test_card *test)
{
	return __mmc_test_prepare(test, 0);
}
static void mmc_test_remove(struct mmc_card *card)
{
	device_remove_file(&card->dev, &dev_attr_test);
}
static int __init mmc_test_init(void)
{
	return mmc_register_driver(&mmc_driver);
}
static void __exit mmc_test_exit(void)
{
	mmc_unregister_driver(&mmc_driver);
}
static void sdio_uart_port_put(struct sdio_uart_port *port)
{
	kref_put(&port->kref, sdio_uart_port_destroy);
}
static inline void sdio_out(struct sdio_uart_port *port, int offset, int value)
{
	sdio_writeb(port->func, value, port->regs_offset + offset, NULL);
}
static int mmc_bus_match(struct device *dev, struct device_driver *drv)
{
	return 1;
}
int mmc_register_bus(void)
{
	return bus_register(&mmc_bus_type);
}
void mmc_unregister_bus(void)
{
	bus_unregister(&mmc_bus_type);
}
static int mmc_schedule_delayed_work(struct delayed_work *work,
				     unsigned long delay)
{
	return queue_delayed_work(workqueue, work, delay);
}
static void mmc_flush_scheduled_work(void)
{
	flush_workqueue(workqueue);
}
static void mmc_wait_done(struct mmc_request *mrq)
{
	complete(mrq->done_data);
}
static int mmc_ios_open(struct inode *inode, struct file *file)
{
	return single_open(file, mmc_ios_show, inode->i_private);
}
void mmc_remove_host_debugfs(struct mmc_host *host)
{
	debugfs_remove_recursive(host->debugfs_root);
}
void mmc_remove_card_debugfs(struct mmc_card *card)
{
	debugfs_remove_recursive(card->debugfs_root);
}
int mmc_register_host_class(void)
{
	return class_register(&mmc_host_class);
}
void mmc_unregister_host_class(void)
{
	class_unregister(&mmc_host_class);
}
int mmc_deselect_cards(struct mmc_host *host)
{
	return _mmc_select_card(host, NULL);
}
int mmc_send_ext_csd(struct mmc_card *card, u8 *ext_csd)
{
	return mmc_send_cxd_data(card, card->host, MMC_SEND_EXT_CSD,
			ext_csd, 512);
}
int sdio_register_bus(void)
{
	return bus_register(&sdio_bus_type);
}
void sdio_unregister_bus(void)
{
	bus_unregister(&sdio_bus_type);
}
int sdio_read_common_cis(struct mmc_card *card)
{
	return sdio_read_cis(card, NULL);
}
int sdio_memcpy_fromio(struct sdio_func *func, void *dst,
	unsigned int addr, int count)
{
	return sdio_io_rw_ext_helper(func, 0, addr, 1, dst, count);
}
int sdio_memcpy_toio(struct sdio_func *func, unsigned int addr,
	void *src, int count)
{
	return sdio_io_rw_ext_helper(func, 1, addr, 1, src, count);
}
int sdio_readsb(struct sdio_func *func, void *dst, unsigned int addr,
	int count)
{
	return sdio_io_rw_ext_helper(func, 0, addr, 0, dst, count);
}
int sdio_writesb(struct sdio_func *func, unsigned int addr, void *src,
	int count)
{
	return sdio_io_rw_ext_helper(func, 1, addr, 0, src, count);
}
static void at91_mci_disable(struct at91mci_host *host)
{
	at91_mci_write(host, AT91_MCI_CR, AT91_MCI_MCIDIS | AT91_MCI_SWRST);
}
static int __init at91_mci_init(void)
{
	return platform_driver_probe(&at91_mci_driver, at91_mci_probe);
}
static void __exit at91_mci_exit(void)
{
	platform_driver_unregister(&at91_mci_driver);
}
static int atmci_req_open(struct inode *inode, struct file *file)
{
	return single_open(file, atmci_req_show, inode->i_private);
}
static int atmci_regs_open(struct inode *inode, struct file *file)
{
	return single_open(file, atmci_regs_show, inode->i_private);
}
static inline unsigned int ns_to_clocks(struct atmel_mci *host,
					unsigned int ns)
{
	return (ns * (host->bus_hz / 1000000) + 999) / 1000;
}
static int atmci_submit_data_dma(struct atmel_mci *host, struct mmc_data *data)
{
	return -ENOSYS;
}
static int __init atmci_init(void)
{
	return platform_driver_probe(&atmci_driver, atmci_probe);
}
static void __exit atmci_exit(void)
{
	platform_driver_unregister(&atmci_driver);
}
static int __init imxmci_init(void)
{
	return platform_driver_register(&imxmci_driver);
}
static void __exit imxmci_exit(void)
{
	platform_driver_unregister(&imxmci_driver);
}
static inline int mmc_cs_off(struct mmc_spi_host *host)
{
	return spi_setup(host->spi);
}
static inline int
mmc_spi_wait_unbusy(struct mmc_spi_host *host, ktime_t timeout)
{
	return mmc_spi_skip(host, timeout, sizeof(host->data->status), 0);
}
static int mmc_spi_readtoken(struct mmc_spi_host *host, ktime_t timeout)
{
	return mmc_spi_skip(host, timeout, 1, 0xff);
}
static int __init mmc_spi_init(void)
{
	return spi_register_driver(&mmc_spi_driver);
}
static void __exit mmc_spi_exit(void)
{
	spi_unregister_driver(&mmc_spi_driver);
}
static int __init mmci_init(void)
{
	return amba_driver_register(&mmci_driver);
}
static void __exit mmci_exit(void)
{
	amba_driver_unregister(&mmci_driver);
}
static inline int mxcmci_use_dma(struct mxcmci_host *host)
{
	return host->do_dma;
}
static int __init mxcmci_init(void)
{
	return platform_driver_register(&mxcmci_driver);
}
static void __exit mxcmci_exit(void)
{
	platform_driver_unregister(&mxcmci_driver);
}
static struct of_mmc_spi *to_of_mmc_spi(struct device *dev)
{
	return container_of(dev->platform_data, struct of_mmc_spi, pdata);
}
static int of_mmc_spi_get_cd(struct device *dev)
{
	return of_mmc_spi_read_gpio(dev, CD_GPIO);
}
static int of_mmc_spi_get_ro(struct device *dev)
{
	return of_mmc_spi_read_gpio(dev, WP_GPIO);
}
static int __init mmc_omap_init(void)
{
	return platform_driver_register(&mmc_omap_driver);
}
static void __exit mmc_omap_exit(void)
{
	platform_driver_unregister(&mmc_omap_driver);
}
static int __init omap_mmc_init(void)
{
	return platform_driver_register(&omap_mmc_driver);
}
static void __exit omap_mmc_cleanup(void)
{
	platform_driver_unregister(&omap_mmc_driver);
}
static int __init pxamci_init(void)
{
	return platform_driver_register(&pxamci_driver);
}
static void __exit pxamci_exit(void)
{
	platform_driver_unregister(&pxamci_driver);
}
static void __exit ricoh_mmc_drv_exit(void)
{
	pci_unregister_driver(&ricoh_mmc_driver);
}
static inline void clear_imask(struct s3cmci_host *host)
{
	writel(0, host->base + host->sdiimsk);
}
static inline void s3cmci_cpufreq_deregister(struct s3cmci_host *host)
{
	cpufreq_unregister_notifier(&host->freq_transition,
				    CPUFREQ_TRANSITION_NOTIFIER);
}
static inline int s3cmci_cpufreq_register(struct s3cmci_host *host)
{
	return 0;
}
static int __devinit s3cmci_2410_probe(struct platform_device *dev)
{
	return s3cmci_probe(dev, 0);
}
static int __devinit s3cmci_2412_probe(struct platform_device *dev)
{
	return s3cmci_probe(dev, 1);
}
static int __devinit s3cmci_2440_probe(struct platform_device *dev)
{
	return s3cmci_probe(dev, 1);
}
static int __init sdhci_drv_init(void)
{
	return pci_register_driver(&sdhci_driver);
}
static void __exit sdhci_drv_exit(void)
{
	pci_unregister_driver(&sdhci_driver);
}
void sdhci_free_host(struct sdhci_host *host)
{
	mmc_free_host(host->mmc);
}
static int __init sdricoh_drv_init(void)
{
	return pcmcia_register_driver(&sdricoh_driver);
}

static void __exit sdricoh_drv_exit(void)
{
	pcmcia_unregister_driver(&sdricoh_driver);
}
static int tifm_sd_suspend(struct tifm_dev *sock, pm_message_t state)
{
	return mmc_suspend_host(tifm_get_drvdata(sock), state);
}
static int __init tifm_sd_init(void)
{
	return tifm_register_driver(&tifm_sd_driver);
}
static void __exit tifm_sd_exit(void)
{
	tifm_unregister_driver(&tifm_sd_driver);
}
static int __init tmio_mmc_init(void)
{
	return platform_driver_register(&tmio_mmc_driver);
}
static void __exit tmio_mmc_exit(void)
{
	platform_driver_unregister(&tmio_mmc_driver);
}
static inline char *wbsd_sg_to_buffer(struct wbsd_host *host)
{
	return sg_virt(host->cur_sg);
}
static int __devinit wbsd_probe(struct platform_device *dev)
{
	return wbsd_init(&dev->dev, param_io, param_irq, param_dma, 0);
}
static void __devexit wbsd_pnp_remove(struct pnp_dev *dev)
{
	wbsd_shutdown(&dev->dev, 1);
}
static int __init afs_parser_init(void)
{
	return register_mtd_parser(&afs_parser);
}
static void __exit afs_parser_exit(void)
{
	deregister_mtd_parser(&afs_parser);
}
static int __init ar7_parser_init(void)
{
	return register_mtd_parser(&ar7_parser);
}
static int cfi_intelext_read_fact_prot_reg(struct mtd_info *mtd, loff_t from,
					   size_t len, size_t *retlen,
					    u_char *buf)
{
	return cfi_intelext_otp_walk(mtd, from, len, retlen,
				     buf, do_otp_read, 0);
}
static int cfi_intelext_read_user_prot_reg(struct mtd_info *mtd, loff_t from,
					   size_t len, size_t *retlen,
					    u_char *buf)
{
	return cfi_intelext_otp_walk(mtd, from, len, retlen,
				     buf, do_otp_read, 1);
}
static int cfi_intelext_write_user_prot_reg(struct mtd_info *mtd, loff_t from,
					    size_t len, size_t *retlen,
					     u_char *buf)
{
	return cfi_intelext_otp_walk(mtd, from, len, retlen,
				     buf, do_otp_write, 1);
}
static int cfi_atmel_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
{
	return cfi_varsize_frob(mtd, do_atmel_lock, ofs, len, NULL);
}
static int cfi_atmel_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
{
	return cfi_varsize_frob(mtd, do_atmel_unlock, ofs, len, NULL);
}
struct mtd_info *cfi_probe(struct map_info *map)
{
	return mtd_do_chip_probe(map, &cfi_chip_probe);
}
static void __exit cfi_probe_exit(void)
{
	unregister_mtd_chip_driver(&cfi_chipdrv);
}
static struct mtd_info *jedec_probe(struct map_info *map)
{
	return mtd_do_chip_probe(map, &jedec_chip_probe);
}
static void __exit jedec_probe_exit(void)
{
	unregister_mtd_chip_driver(&jedec_chipdrv);
}
static int map_absent_erase(struct mtd_info *mtd, struct erase_info *instr)
{
	return -ENODEV;
}
static void __exit map_absent_exit(void)
{
	unregister_mtd_chip_driver(&map_absent_chipdrv);
}
static void __exit map_ram_exit(void)
{
	unregister_mtd_chip_driver(&mapram_chipdrv);
}
static int maprom_erase (struct mtd_info *mtd, struct erase_info *info)
{
	return -EROFS;
}
static void __exit map_rom_exit(void)
{
	unregister_mtd_chip_driver(&maprom_chipdrv);
}
static int __init cmdline_parser_init(void)
{
	return register_mtd_parser(&cmdline_parser);
}
static struct page *page_read(struct address_space *mapping, int index)
{
	return read_mapping_page(mapping, index, NULL);
}
static int block2mtd_setup(const char *val, struct kernel_param *kp)
{
	return block2mtd_setup2(val);
}
static int DoC_SelectChip(void __iomem * docptr, int chip)
{
	return 0;
}
static inline struct m25p *mtd_to_m25p(struct mtd_info *mtd)
{
	return container_of(mtd, struct m25p, mtd);
}
static int m25p80_init(void)
{
	return spi_register_driver(&m25p80_driver);
}
static void m25p80_exit(void)
{
	spi_unregister_driver(&m25p80_driver);
}
static inline int dataflash_status(struct spi_device *spi)
{
	return spi_w8r8(spi, OP_READ_STATUS);
}
static char *otp_setup(struct mtd_info *device, char revision)
{
	return " (OTP)";
}
static inline int __devinit
add_dataflash(struct spi_device *spi, char *name,
		int nr_pages, int pagesize, int pageoffset)
{
	return add_dataflash_otp(spi, name, nr_pages, pagesize,
			pageoffset, 0);
}
static int __init dataflash_init(void)
{
	return spi_register_driver(&dataflash_driver);
}
static void __exit dataflash_exit(void)
{
	spi_unregister_driver(&dataflash_driver);
}
static int __init init_phram(void)
{
	return 0;
}
static void __exit cleanup_phram(void)
{
	unregister_devices();
}
static void pmc551_unpoint(struct mtd_info *mtd, loff_t from, size_t len)
{
	printk(KERN_DEBUG "pmc551_unpoint()\n");
}
static u32 *ps3vram_get_notifier(u32 *reports, int notifier)
{
	return (void *) reports +
		DMA_NOTIFIER_OFFSET_BASE +
		DMA_NOTIFIER_SIZE * notifier;
}
static void ps3vram_out_ring(struct ps3vram_priv *priv, u32 data)
{
	*(priv->fifo_ptr)++ = data;
}
static void ps3vram_begin_ring(struct ps3vram_priv *priv, u32 chan,
				      u32 tag, u32 size)
{
	ps3vram_out_ring(priv, (size << 18) | (chan << 13) | tag);
}
static int __init ps3vram_init(void)
{
	return ps3_system_bus_driver_register(&ps3vram_driver);
}
static void __exit ps3vram_exit(void)
{
	ps3_system_bus_driver_unregister(&ps3vram_driver);
}
static void __exit cleanup_slram(void)
{
	unregister_devices();
}
static int ftl_readsect(struct mtd_blktrans_dev *dev,
			      unsigned long block, char *buf)
{
	return ftl_read((void *)dev, buf, block, 1);
}
static int ftl_writesect(struct mtd_blktrans_dev *dev,
			      unsigned long block, char *buf)
{
	return ftl_write((void *)dev, buf, block, 1);
}
static int init_ftl(void)
{
	return register_mtd_blktrans(&ftl_tr);
}
static void __exit cleanup_ftl(void)
{
	deregister_mtd_blktrans(&ftl_tr);
}
static int __init init_inftl(void)
{
	return register_mtd_blktrans(&inftl_tr);
}
static void __exit cleanup_inftl(void)
{
	deregister_mtd_blktrans(&inftl_tr);
}
static int lpddr_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
{
	return do_xxlock(mtd, ofs, len, DO_XXLOCK_LOCK);
}
static int lpddr_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
{
	return do_xxlock(mtd, ofs, len, DO_XXLOCK_UNLOCK);
}
static void __exit lpddr_probe_exit(void)
{
	unregister_mtd_chip_driver(&lpddr_chipdrv);
}
static void __exit cleanup_amd76xrom(void)
{
	amd76xrom_remove_one(amd76xrom_window.pdev);
}
static int __init bfin_flash_init(void)
{
	return platform_driver_register(&bfin_flash_driver);
}
static void __exit bfin_flash_exit(void)
{
	platform_driver_unregister(&bfin_flash_driver);
}
static void __exit clps_destroy_partitions(void)
{
	kfree(parsed_parts);
}
static void __exit cleanup_ck804xrom(void)
{
	ck804xrom_remove_one(ck804xrom_window.pdev);
}
static void dc21285_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
{
	memcpy(to, (void*)(map->virt + from), len);
}
static void __exit cleanup_esb2rom(void)
{
	esb2rom_remove_one(esb2rom_window.pdev);
}
static void __exit cleanup_ichxrom(void)
{
	ichxrom_remove_one(ichxrom_window.pdev);
}
static int __init armflash_init(void)
{
	return platform_driver_register(&armflash_driver);
}
static void __exit armflash_exit(void)
{
	platform_driver_unregister(&armflash_driver);
}
static void __devexit vr_nor_destroy_mtd_setup(struct vr_nor_mtd *p)
{
	map_destroy(p->info);
}
static int __init vr_nor_mtd_init(void)
{
	return pci_register_driver(&vr_nor_pci_driver);
}
static void __exit vr_nor_mtd_exit(void)
{
	pci_unregister_driver(&vr_nor_pci_driver);
}
static void ixp2000_flash_write8(struct map_info *map, map_word d, unsigned long ofs)
{
	*(__u8 *) (address_fix8_write(map->map_priv_1 +
				      flash_bank_setup(map, ofs))) = d.x[0];
}
static int __init ixp2000_flash_init(void)
{
	return platform_driver_register(&ixp2000_flash_driver);
}
static void __exit ixp2000_flash_exit(void)
{
	platform_driver_unregister(&ixp2000_flash_driver);
}
static inline u16 flash_read16(void __iomem *addr)
{
	return be16_to_cpu(__raw_readw((void __iomem *)((unsigned long)addr ^ 0x2)));
}
static inline void flash_write16(u16 d, void __iomem *addr)
{
	__raw_writew(cpu_to_be16(d), (void __iomem *)((unsigned long)addr ^ 0x2));
}
static inline u16 flash_read16(const void __iomem *addr)
{
	return __raw_readw(addr);
}
static inline void flash_write16(u16 d, void __iomem *addr)
{
	__raw_writew(d, addr);
}
static void ixp4xx_write16(struct map_info *map, map_word d, unsigned long adr)
{
	flash_write16(d.x[0], map->virt + adr);
}
static int __init ixp4xx_flash_init(void)
{
	return platform_driver_register(&ixp4xx_flash_driver);
}
static void __exit ixp4xx_flash_exit(void)
{
	platform_driver_unregister(&ixp4xx_flash_driver);
}
static map_word __xipram simple_map_read(struct map_info *map, unsigned long ofs)
{
	return inline_map_read(map, ofs);
}
static void __xipram simple_map_write(struct map_info *map, const map_word datum, unsigned long ofs)
{
	inline_map_write(map, datum, ofs);
}
static void __xipram simple_map_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
{
	inline_map_copy_from(map, to, from, len);
}
static void __xipram simple_map_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
{
	inline_map_copy_to(map, to, from, len);
}
static int __init omapflash_init(void)
{
	return platform_driver_probe(&omapflash_driver, omapflash_probe);
}
static void __exit omapflash_exit(void)
{
	platform_driver_unregister(&omapflash_driver);
}
static unsigned long
intel_dc21285_translate(struct map_pci_info *map, unsigned long ofs)
{
	return ofs & 0x00ffffc0 ? ofs : (ofs ^ (1 << 5));
}
static int __init mtd_pci_maps_init(void)
{
	return pci_register_driver(&mtd_pci_driver);
}
static void __exit mtd_pci_maps_exit(void)
{
	pci_unregister_driver(&mtd_pci_driver);
}
static int __init of_flash_init(void)
{
	return of_register_platform_driver(&of_flash_driver);
}
static void __exit of_flash_exit(void)
{
	of_unregister_platform_driver(&of_flash_driver);
}
static inline struct platram_info *to_platram_info(struct platform_device *dev)
{
	return (struct platram_info *)platform_get_drvdata(dev);
}
static void __exit platram_exit(void)
{
	platform_driver_unregister(&platram_driver);
}
static void pxa2xx_map_inval_cache(struct map_info *map, unsigned long from,
				      ssize_t len)
{
	flush_ioremap_region(map->phys, map->cached, from, len);
}
static int __init init_pxa2xx_flash(void)
{
	return platform_driver_register(&pxa2xx_flash_driver);
}
static void __exit cleanup_pxa2xx_flash(void)
{
	platform_driver_unregister(&pxa2xx_flash_driver);
}
static int __init sa1100_mtd_init(void)
{
	return platform_driver_register(&sa1100_mtd_driver);
}
static void __exit sa1100_mtd_exit(void)
{
	platform_driver_unregister(&sa1100_mtd_driver);
}
static int __init
scb2_flash_init(void)
{
	return pci_register_driver(&scb2_flash_driver);
}
static void __exit
scb2_flash_exit(void)
{
	pci_unregister_driver(&scb2_flash_driver);
}
static int __init uflash_init(void)
{
	return of_register_driver(&uflash_driver, &of_bus_type);
}
static void __exit uflash_exit(void)
{
	of_unregister_driver(&uflash_driver);
}
static void tsunami_flash_write8(struct map_info *map, map_word value, unsigned long offset)
{
	tsunami_tig_writeb(value.x[0], offset);
}
static int __init init_mtdblock(void)
{
	return register_mtd_blktrans(&mtdblock_tr);
}
static void __exit cleanup_mtdblock(void)
{
	deregister_mtd_blktrans(&mtdblock_tr);
}
static int __init mtdblock_init(void)
{
	return register_mtd_blktrans(&mtdblock_tr);
}
static void __exit mtdblock_exit(void)
{
	deregister_mtd_blktrans(&mtdblock_tr);
}
static void mtdchar_erase_callback (struct erase_info *instr)
{
	wake_up((wait_queue_head_t *)instr->priv);
}
static void concat_erase_callback(struct erase_info *instr)
{
	wake_up((wait_queue_head_t *) instr->priv);
}
static int __init alauda_init(void)
{
	return usb_register(&alauda_driver);
}
static void __exit alauda_exit(void)
{
	usb_deregister(&alauda_driver);
}
static int ams_delta_nand_ready(struct mtd_info *mtd)
{
	return gpio_get_value(AMS_DELTA_GPIO_PIN_NAND_RB);
}
static int __init atmel_nand_init(void)
{
	return platform_driver_probe(&atmel_nand_driver, atmel_nand_probe);
}
static void __exit atmel_nand_exit(void)
{
	platform_driver_unregister(&atmel_nand_driver);
}
static struct bf5xx_nand_info *mtd_to_nand_info(struct mtd_info *mtd)
{
	return container_of(mtd, struct bf5xx_nand_info, mtd);
}
static struct bf5xx_nand_info *to_nand_info(struct platform_device *pdev)
{
	return platform_get_drvdata(pdev);
}
static struct bf5xx_nand_platform *to_nand_plat(struct platform_device *pdev)
{
	return pdev->dev.platform_data;
}
static void bf5xx_nand_enable_hwecc(struct mtd_info *mtd, int mode)
{
	return;
}
static void __exit bf5xx_nand_exit(void)
{
	platform_driver_unregister(&bf5xx_nand_driver);
}
static void cafe_nand_bug(struct mtd_info *mtd)
{
	BUG();
}
static int cafe_nand_block_bad(struct mtd_info *mtd, loff_t ofs, int getchip)
{
	return 0;
}
static int cafe_nand_init(void)
{
	return pci_register_driver(&cafe_nand_pci_driver);
}
static void cafe_nand_exit(void)
{
	pci_unregister_driver(&cafe_nand_pci_driver);
}
static inline void nand_cs_on(void)
{
	gpio_set_value(GPIO_NAND_CS, 0);
}
static int doc200x_block_bad(struct mtd_info *mtd, loff_t ofs, int getchip)
{
	return 0;
}
static int ep7312_device_ready(struct mtd_info *mtd)
{
	return 1;
}
static void __exit excite_nand_exit(void)
{
	platform_driver_unregister(&excite_nand_driver);
}
static int __init fsl_elbc_init(void)
{
	return of_register_platform_driver(&fsl_elbc_ctrl_driver);
}
static void __exit fsl_elbc_exit(void)
{
	of_unregister_platform_driver(&fsl_elbc_ctrl_driver);
}
static int __init fun_module_init(void)
{
	return of_register_platform_driver(&of_fun_driver);
}
static void __exit fun_module_exit(void)
{
	of_unregister_platform_driver(&of_fun_driver);
}
static void __exit gpio_nand_exit(void)
{
	platform_driver_unregister(&gpio_nand_driver);
}
static int mxc_nand_dev_ready(struct mtd_info *mtd)
{
	return 1;
}
static int mxc_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat,
				  u_char *ecc_code)
{
	return 0;
}
static int mxc_nand_verify_buf(struct mtd_info *mtd,
				const u_char *buf, int len)
{
	return -EFAULT;
}
static void __exit mxc_nd_cleanup(void)
{
	platform_driver_unregister(&mxcnd_driver);
}
static int nand_erase(struct mtd_info *mtd, struct erase_info *instr)
{
	return nand_erase_nand(mtd, instr, 0);
}
static void __exit nand_base_exit(void)
{
	led_trigger_unregister_simple(nand_led_trigger);
}
static inline union ns_mem *NS_GET_PAGE(struct nandsim *ns)
{
	return &(ns->pages[ns->regs.row]);
}
static inline u_char *NS_PAGE_BYTE_OFF(struct nandsim *ns)
{
	return NS_GET_PAGE(ns)->byte + ns->regs.column + ns->regs.off;
}
static int __init ndfc_nand_init(void)
{
	return of_register_platform_driver(&ndfc_driver);
}
static void __exit ndfc_nand_exit(void)
{
	of_unregister_platform_driver(&ndfc_driver);
}
static int __init orion_nand_init(void)
{
	return platform_driver_register(&orion_nand_driver);
}
static void __exit orion_nand_exit(void)
{
	platform_driver_unregister(&orion_nand_driver);
}
int pasemi_device_ready(struct mtd_info *mtd)
{
	return !!(inl(lpcctl) & LBICTRL_LPCCTL_NR);
}
static int __init pasemi_nand_init(void)
{
	return of_register_platform_driver(&pasemi_nand_driver);
}
static void __exit pasemi_nand_exit(void)
{
	of_unregister_platform_driver(&pasemi_nand_driver);
}
static int __init plat_nand_init(void)
{
	return platform_driver_register(&plat_nand_driver);
}
static void __exit plat_nand_exit(void)
{
	platform_driver_unregister(&plat_nand_driver);
}
static int pxa3xx_nand_verify_buf(struct mtd_info *mtd,
		const uint8_t *buf, int len)
{
	return 0;
}
static void pxa3xx_nand_select_chip(struct mtd_info *mtd, int chip)
{
	return;
}
static void pxa3xx_nand_ecc_hwctl(struct mtd_info *mtd, int mode)
{
	return;
}
static int pxa3xx_nand_ecc_calculate(struct mtd_info *mtd,
		const uint8_t *dat, uint8_t *ecc_code)
{
	return 0;
}
static int __init pxa3xx_nand_init(void)
{
	return platform_driver_register(&pxa3xx_nand_driver);
}
static void __exit pxa3xx_nand_exit(void)
{
	platform_driver_unregister(&pxa3xx_nand_driver);
}
static struct s3c2410_nand_mtd *s3c2410_nand_mtd_toours(struct mtd_info *mtd)
{
	return container_of(mtd, struct s3c2410_nand_mtd, mtd);
}
static struct s3c2410_nand_info *s3c2410_nand_mtd_toinfo(struct mtd_info *mtd)
{
	return s3c2410_nand_mtd_toours(mtd)->info;
}
static struct s3c2410_nand_info *to_nand_info(struct platform_device *dev)
{
	return platform_get_drvdata(dev);
}
static struct s3c2410_platform_nand *to_nand_plat(struct platform_device *dev)
{
	return dev->dev.platform_data;
}
static inline int allow_clk_stop(struct s3c2410_nand_info *info)
{
	return clock_stop;
}
static inline void s3c2410_nand_cpufreq_deregister(struct s3c2410_nand_info *info)
{
	cpufreq_unregister_notifier(&info->freq_transition,
				    CPUFREQ_TRANSITION_NOTIFIER);
}
static inline int s3c2410_nand_cpufreq_register(struct s3c2410_nand_info *info)
{
	return 0;
}
static int s3c2410_nand_add_partition(struct s3c2410_nand_info *info,
				      struct s3c2410_nand_mtd *mtd,
				      struct s3c2410_nand_set *set)
{
	return add_mtd_device(&mtd->mtd);
}
static int s3c2410_nand_probe(struct platform_device *dev)
{
	return s3c24xx_nand_probe(dev, TYPE_S3C2410);
}
static int s3c2440_nand_probe(struct platform_device *dev)
{
	return s3c24xx_nand_probe(dev, TYPE_S3C2440);
}
static int s3c2412_nand_probe(struct platform_device *dev)
{
	return s3c24xx_nand_probe(dev, TYPE_S3C2412);
}
static void start_translation(struct sh_flctl *flctl)
{
	writeb(TRSTRT, FLTRCR(flctl));
}
static void flctl_register_init(struct sh_flctl *flctl, unsigned long val)
{
	writel(val, FLCMNCR(flctl));
}
static int __init flctl_nand_init(void)
{
	return platform_driver_register(&flctl_driver);
}
static void __exit flctl_nand_cleanup(void)
{
	platform_driver_unregister(&flctl_driver);
}
static int __init sharpsl_nand_init(void)
{
	return platform_driver_register(&sharpsl_nand_driver);
}
static void __exit sharpsl_nand_exit(void)
{
	platform_driver_unregister(&sharpsl_nand_driver);
}
static int __init tmio_init(void)
{
	return platform_driver_register(&tmio_driver);
}
static void __exit tmio_exit(void)
{
	platform_driver_unregister(&tmio_driver);
}
static int ts7250_device_ready(struct mtd_info *mtd)
{
	return __raw_readb(TS72XX_NAND_BUSY_VIRT_BASE) & 0x20;
}
static int __init init_nftl(void)
{
	return register_mtd_blktrans(&nftl_tr);
}
static void __exit cleanup_nftl(void)
{
	deregister_mtd_blktrans(&nftl_tr);
}
static int __init generic_onenand_init(void)
{
	return platform_driver_register(&generic_onenand_driver);
}
static void __exit generic_onenand_exit(void)
{
	platform_driver_unregister(&generic_onenand_driver);
}
static inline unsigned short read_reg(struct omap2_onenand *c, int reg)
{
	return readw(c->onenand.base + reg);
}
static inline void write_reg(struct omap2_onenand *c, unsigned short value,
			     int reg)
{
	writew(value, c->onenand.base + reg);
}
static void wait_err(char *msg, int state, unsigned int ctrl, unsigned int intr)
{
	printk(KERN_ERR "onenand_wait: %s! state %d ctrl 0x%04x intr 0x%04x\n",
	       msg, state, ctrl, intr);
}
static void wait_warn(char *msg, int state, unsigned int ctrl,
		      unsigned int intr)
{
	printk(KERN_WARNING "onenand_wait: %s! state %d ctrl 0x%04x "
	       "intr 0x%04x\n", msg, state, ctrl, intr);
}
int omap2_onenand_rephase(void)
{
	return driver_for_each_device(&omap2_onenand_driver.driver, NULL,
				      NULL, __adjust_timing);
}
static void __exit omap2_onenand_exit(void)
{
	platform_driver_unregister(&omap2_onenand_driver);
}
static unsigned short onenand_readw(void __iomem *addr)
{
	return readw(addr);
}
static void onenand_writew(unsigned short value, void __iomem *addr)
{
	writew(value, addr);
}
static int onenand_read_fact_prot_reg(struct mtd_info *mtd, loff_t from,
			size_t len, size_t *retlen, u_char *buf)
{
	return onenand_otp_walk(mtd, from, len, retlen, buf, do_otp_read, MTD_OTP_FACTORY);
}
static int onenand_read_user_prot_reg(struct mtd_info *mtd, loff_t from,
			size_t len, size_t *retlen, u_char *buf)
{
	return onenand_otp_walk(mtd, from, len, retlen, buf, do_otp_read, MTD_OTP_USER);
}
static int onenand_write_user_prot_reg(struct mtd_info *mtd, loff_t from,
			size_t len, size_t *retlen, u_char *buf)
{
	return onenand_otp_walk(mtd, from, len, retlen, buf, do_otp_write, MTD_OTP_USER);
}
static int onenand_suspend(struct mtd_info *mtd)
{
	return onenand_get_device(mtd, FL_PM_SUSPENDED);
}
static inline int redboot_checksum(struct fis_image_desc *img)
{
	return 1;
}
static int __init redboot_parser_init(void)
{
	return register_mtd_parser(&redboot_parser);
}
static void __exit redboot_parser_exit(void)
{
	deregister_mtd_parser(&redboot_parser);
}
static int __init init_rfd_ftl(void)
{
	return register_mtd_blktrans(&rfd_ftl_tr);
}
static void __exit cleanup_rfd_ftl(void)
{
	deregister_mtd_blktrans(&rfd_ftl_tr);
}
static void __exit cleanup_ssfdcr(void)
{
	deregister_mtd_blktrans(&ssfdcr_tr);
}
static inline void simple_srand(unsigned long seed)
{
	next = seed;
}
static void __exit mtd_oobtest_exit(void)
{
	return;
}
static inline void simple_srand(unsigned long seed)
{
	next = seed;
}
static void __exit mtd_pagetest_exit(void)
{
	return;
}
static void __exit mtd_readtest_exit(void)
{
	return;
}
static inline void simple_srand(unsigned long seed)
{
	next = seed;
}
static inline void start_timing(void)
{
	do_gettimeofday(&start);
}
static inline void stop_timing(void)
{
	do_gettimeofday(&finish);
}
static void __exit mtd_speedtest_exit(void)
{
	return;
}
static inline void simple_srand(unsigned long seed)
{
	next = seed;
}
static int do_operation(void)
{
	if (simple_rand() & 1)
		return do_read();
	else
		return do_write();
}
static void __exit mtd_stresstest_exit(void)
{
	return;
}
static inline void simple_srand(unsigned long seed)
{
	next = seed;
}
static inline void clear_data(unsigned char *buf, size_t len)
{
	memset(buf, 0, len);
}
static void __exit mtd_subpagetest_exit(void)
{
	return;
}
static inline void start_timing(void)
{
	do_gettimeofday(&start);
}
static inline void stop_timing(void)
{
	do_gettimeofday(&finish);
}
static void __exit tort_exit(void)
{
	return;
}
static ssize_t ubi_version_show(struct class *class, char *buf)
{
	return sprintf(buf, "%d\n", UBI_VERSION);
}
static void erase_callback(struct erase_info *ei)
{
	wake_up_interruptible((wait_queue_head_t *)ei->priv);
}
static u32 netdev_get_msglevel(struct net_device *dev)
{
	return debug;
}
static void netdev_set_msglevel(struct net_device *dev, u32 level)
{
	debug = level;
}
static inline unsigned char inb_status(unsigned int base_addr)
{
	return inb(base_addr + PORT_STATUS);
}
static inline int inb_command(unsigned int base_addr)
{
	return inb(base_addr + PORT_COMMAND);
}
static inline void outb_command(unsigned char val, unsigned int base_addr)
{
	outb(val, base_addr + PORT_COMMAND);
}
static inline unsigned int backlog_next(unsigned int n)
{
	return (n + 1) % BACKLOG_SIZE;
}
static u32 netdev_get_msglevel(struct net_device *dev)
{
	return debug;
}
static void netdev_set_msglevel(struct net_device *dev, u32 level)
{
	debug = level;
}
static u32 netdev_get_msglevel(struct net_device *dev)
{
	return debug;
}
static void netdev_set_msglevel(struct net_device *dev, u32 level)
{
	debug = level;
}
static int el3_pnp_suspend(struct pnp_dev *pdev, pm_message_t state)
{
	return el3_suspend(&pdev->dev, state);
}
static int el3_pnp_resume(struct pnp_dev *pdev)
{
	return el3_resume(&pdev->dev);
}
static u32 el3_get_msglevel(struct net_device *dev)
{
	return el3_debug;
}
static void el3_set_msglevel(struct net_device *dev, u32 v)
{
	el3_debug = v;
}
static u32 netdev_get_msglevel(struct net_device *dev)
{
	return corkscrew_debug;
}
static void netdev_set_msglevel(struct net_device *dev, u32 level)
{
	corkscrew_debug = level;
}
/* Macros for ring index manipulations */
static inline u16 next_rx(u16 rx) { return (rx+1)&(RX_RING_LEN-1); }
static inline u16 prev_rx(u16 rx) { return (rx-1)&(RX_RING_LEN-1); }

static inline u16 next_tx(u16 tx) { return (tx+1)&(TX_RING_LEN-1); }
static void mc32_set_multicast_list(struct net_device *dev)
{
	do_mc32_set_multicast_list(dev,0);
}
static void mc32_reset_multicast_list(struct net_device *dev)
{
	do_mc32_set_multicast_list(dev,1);
}
static u32 netdev_get_msglevel(struct net_device *dev)
{
	return mc32_debug;
}
static void netdev_set_msglevel(struct net_device *dev, u32 level)
{
	mc32_debug = level;
}
static u32 vortex_get_msglevel(struct net_device *dev)
{
	return vortex_debug;
}
static void vortex_set_msglevel(struct net_device *dev, u32 dbg)
{
	vortex_debug = dbg;
}
static int cp_get_regs_len(struct net_device *dev)
{
	return CP_REGS_SIZE;
}
static void __exit cp_exit (void)
{
	pci_unregister_driver (&cp_driver);
}
static void rtl8139_get_strings(struct net_device *dev, u32 stringset, u8 *data)
{
	memcpy(data, ethtool_stats_keys, sizeof(ethtool_stats_keys));
}
static void __exit rtl8139_cleanup_module (void)
{
	pci_unregister_driver (&rtl8139_pci_driver);
}
static void print_eth(unsigned char *add, char *str)
{
	printk(KERN_DEBUG "i596 0x%p, %pM --> %pM %02X%02X, %s\n",
	       add, add + 6, add, add[12], add[13], str);
}
int ei_open(struct net_device *dev)
{
	return __ei_open(dev);
}
int ei_close(struct net_device *dev)
{
	return __ei_close(dev);
}
int ei_start_xmit(struct sk_buff *skb, struct net_device *dev)
{
	return __ei_start_xmit(skb, dev);
}
struct net_device_stats *ei_get_stats(struct net_device *dev)
{
	return __ei_get_stats(dev);
}
void ei_set_multicast_list(struct net_device *dev)
{
	__ei_set_multicast_list(dev);
}
void ei_tx_timeout(struct net_device *dev)
{
	__ei_tx_timeout(dev);
}
irqreturn_t ei_interrupt(int irq, void *dev_id)
{
	return __ei_interrupt(irq, dev_id);
}
void ei_poll(struct net_device *dev)
{
	__ei_poll(dev);
}
void NS8390_init(struct net_device *dev, int startp)
{
	__NS8390_init(dev, startp);
}
static int __init ns8390_module_init(void)
{
	return 0;
}
int eip_open(struct net_device *dev)
{
	return __ei_open(dev);
}
int eip_close(struct net_device *dev)
{
	return __ei_close(dev);
}
int eip_start_xmit(struct sk_buff *skb, struct net_device *dev)
{
	return __ei_start_xmit(skb, dev);
}
struct net_device_stats *eip_get_stats(struct net_device *dev)
{
	return __ei_get_stats(dev);
}
void eip_set_multicast_list(struct net_device *dev)
{
	__ei_set_multicast_list(dev);
}
void eip_tx_timeout(struct net_device *dev)
{
	__ei_tx_timeout(dev);
}
irqreturn_t eip_interrupt(int irq, void *dev_id)
{
	return __ei_interrupt(irq, dev_id);
}
void eip_poll(struct net_device *dev)
{
	__ei_poll(dev);
}
void NS8390p_init(struct net_device *dev, int startp)
{
	__NS8390_init(dev, startp);
}
int init_module(void)
{
	return 0;
}
static int __init a2065_init_module(void)
{
	return zorro_register_driver(&a2065_driver);
}
static void __exit a2065_cleanup_module(void)
{
	zorro_unregister_driver(&a2065_driver);
}
static int __init acenic_init(void)
{
	return pci_register_driver(&acenic_pci_driver);
}
static void __exit acenic_exit(void)
{
	pci_unregister_driver(&acenic_pci_driver);
}
static int amd8111e_vlan_rx(struct amd8111e_priv *lp, struct sk_buff *skb, u16 vlan_tag)
{
	return vlan_hwaccel_receive_skb(skb, lp->vlgrp,vlan_tag);
}
static int amd8111e_get_regs_len(struct net_device *dev)
{
	return AMD8111E_REG_DUMP_LEN;
}
static int __init amd8111e_init(void)
{
	return pci_register_driver(&amd8111e_driver);
}
static void __exit amd8111e_cleanup(void)
{
	pci_unregister_driver(&amd8111e_driver);
}
static void __exit arcnet_raw_exit(void)
{
	arcnet_unregister_proto(&rawmode_proto);
}
static void null_rx(struct net_device *dev, int bufnum,
		    struct archdr *pkthdr, int length)
{
	BUGMSG(D_PROTO,
	"rx: don't know how to deal with proto %02Xh from host %02Xh.\n",
	       pkthdr->soft.rfc1201.proto, pkthdr->hard.source);
}
static void __exit capmode_module_exit(void)
{
	arcnet_unregister_proto(&capmode_proto);
}
static void __exit com20020pci_cleanup(void)
{
	pci_unregister_driver(&com20020pci_driver);
}
static void com90io_copy_to_card(struct net_device *dev, int bufnum, int offset,
				 void *buf, int count)
{
	TIME("put_whole_buffer", count, put_whole_buffer(dev, bufnum * 512 + offset, count, buf));
}
static void com90io_copy_from_card(struct net_device *dev, int bufnum, int offset,
				   void *buf, int count)
{
	TIME("get_whole_buffer", count, get_whole_buffer(dev, bufnum * 512 + offset, count, buf));
}
static void __exit arcnet_rfc1051_exit(void)
{
	arcnet_unregister_proto(&rfc1051_proto);
}
static void __exit arcnet_rfc1201_exit(void)
{
	arcnet_unregister_proto(&rfc1201_proto);
}
static int __init ariadne_init_module(void)
{
    return zorro_register_driver(&ariadne_driver);
}
static void __exit ariadne_cleanup_module(void)
{
    zorro_unregister_driver(&ariadne_driver);
}
static void mdio_write(struct net_device *dev, int phy_id, int location, int value)
{
	write_phy(phy_id, location, value);
}
static int __init at91ether_init(void)
{
	return platform_driver_register(&at91ether_driver);
}
static void __exit at91ether_exit(void)
{
	platform_driver_unregister(&at91ether_driver);
}
static void __exit ep93xx_eth_cleanup_module(void)
{
	platform_driver_unregister(&ep93xx_eth_driver);
}
static struct net_device_stats *
ether1_getstats (struct net_device *dev)
{
	return &priv(dev)->stats;
}
static int __init ether1_init(void)
{
	return ecard_register_driver(&ether1_driver);
}
static void __exit ether1_exit(void)
{
	ecard_remove_driver(&ether1_driver);
}
static struct net_device_stats *ether3_getstats(struct net_device *dev)
{
	return &priv(dev)->stats;
}
static int __init ether3_init(void)
{
	return ecard_register_driver(&ether3_driver);
}
static void __exit ether3_exit(void)
{
	ecard_remove_driver(&ether3_driver);
}
static inline unsigned int etherh_get_stat(struct etherh_priv *eh)
{
	return readb(eh->ctrl_port);
}
static void __exit etherh_exit(void)
{
	ecard_remove_driver(&etherh_driver);
}
static inline void debug_desc(u32 phys, struct desc *desc)
{
	printk(KERN_DEBUG "%X: %X %3X %3X %08X %2X < %2X %4X %X"
	       " %X %X %02X%02X%02X%02X%02X%02X < %02X%02X%02X%02X%02X%02X\n",
	       phys, desc->next, desc->buf_len, desc->pkt_len,
	       desc->data, desc->dest_id, desc->src_id, desc->flags,
	       desc->qos, desc->padlen, desc->vlan_tci,
	       desc->dst_mac_0, desc->dst_mac_1, desc->dst_mac_2,
	       desc->dst_mac_3, desc->dst_mac_4, desc->dst_mac_5,
	       desc->src_mac_0, desc->src_mac_1, desc->src_mac_2,
	       desc->src_mac_3, desc->src_mac_4, desc->src_mac_5);
}
static inline u32
ks8695_readreg(struct ks8695_priv *ksp, int reg)
{
	return readl(ksp->io_regs + reg);
}
static inline void
ks8695_writereg(struct ks8695_priv *ksp, int reg, u32 value)
{
	writel(value, ksp->io_regs + reg);
}
static int
ks8695_set_pause(struct net_device *ndev, struct ethtool_pauseparam *param)
{
	return -EOPNOTSUPP;
}
static void __exit
ks8695_cleanup(void)
{
	platform_driver_unregister(&ks8695_driver);
}
static u32 atl1e_get_tx_csum(struct net_device *netdev)
{
	return (netdev->features & NETIF_F_HW_CSUM) != 0;
}
static u32 atl1e_get_msglevel(struct net_device *netdev)
{
	return 1;
}
static int atl1e_get_regs_len(struct net_device *netdev)
{
	return AT_REGS_LEN * sizeof(u32);
}
void atl1e_set_ethtool_ops(struct net_device *netdev)
{
	SET_ETHTOOL_OPS(netdev, &atl1e_ethtool_ops);
}
bool atl1e_write_eeprom(struct atl1e_hw *hw, u32 offset, u32 value)
{
	return true;
}
void atl1e_force_ps(struct atl1e_hw *hw)
{
	AT_WRITE_REGW(hw, REG_GPHY_CTRL,
			GPHY_CTRL_PW_WOL_DIS | GPHY_CTRL_EXT_RESET);
}
static void atl1e_del_timer(struct atl1e_adapter *adapter)
{
	del_timer_sync(&adapter->phy_config_timer);
}
static int __devinit atl1e_alloc_queues(struct atl1e_adapter *adapter)
{
	return 0;
}
static void atl1e_cal_ring_size(struct atl1e_adapter *adapter, u32 *ring_size)
{
	*ring_size = ((u32)(adapter->tx_ring.count *
		     sizeof(struct atl1e_tpd_desc) + 7
		     + adapter->rx_ring.real_page_size * AT_PAGE_NUM_PER_QUEUE *
			adapter->num_rx_queues + 31
		     + (1 + AT_PAGE_NUM_PER_QUEUE * adapter->num_rx_queues) *
			sizeof(u32) + 3));
}
static void atl1e_shutdown(struct pci_dev *pdev)
{
	atl1e_suspend(pdev, PMSG_SUSPEND);
}
static int __init atl1e_init_module(void)
{
	return pci_register_driver(&atl1e_driver);
}
static void __exit atl1e_exit_module(void)
{
	pci_unregister_driver(&atl1e_driver);
}
static void atl1_shutdown(struct pci_dev *pdev)
{
	atl1_suspend(pdev, PMSG_SUSPEND);
}
static void __exit atl1_exit_module(void)
{
	pci_unregister_driver(&atl1_driver);
}
static int __init atl1_init_module(void)
{
	return pci_register_driver(&atl1_driver);
}
static int atl1_get_regs_len(struct net_device *netdev)
{
	return ATL1_REG_COUNT * sizeof(u32);
}
static u32 atl1_get_rx_csum(struct net_device *netdev)
{
	return 1;
}
static void atl2_restore_vlan(struct atl2_adapter *adapter)
{
	atl2_vlan_rx_register(adapter->netdev, adapter->vlgrp);
}
static void atl2_shutdown(struct pci_dev *pdev)
{
	atl2_suspend(pdev, PMSG_SUSPEND);
}
static void __exit atl2_exit_module(void)
{
	pci_unregister_driver(&atl2_driver);
}
static u32 atl2_get_tx_csum(struct net_device *netdev)
{
	return (netdev->features & NETIF_F_HW_CSUM) != 0;
}
static u32 atl2_get_msglevel(struct net_device *netdev)
{
	return 0;
}
static int atl2_get_regs_len(struct net_device *netdev)
{
	return sizeof(u32) * ATL2_REGS_LEN;
}
static void atl2_set_ethtool_ops(struct net_device *netdev)
{
	SET_ETHTOOL_OPS(netdev, &atl2_ethtool_ops);
}
static bool atl2_write_eeprom(struct atl2_hw *hw, u32 offset, u32 value)
{
	return true;
}
static void atlx_restore_vlan(struct atlx_adapter *adapter)
{
	atlx_vlan_rx_register(adapter->netdev, adapter->vlgrp);
}
static int __init axdrv_init(void)
{
	return platform_driver_register(&axdrv);
}
static void __exit axdrv_exit(void)
{
	platform_driver_unregister(&axdrv);
}
static inline void b44_sync_dma_desc_for_device(struct ssb_device *sdev,
						dma_addr_t dma_base,
						unsigned long offset,
						enum dma_data_direction dir)
{
	ssb_dma_sync_single_range_for_device(sdev, dma_base,
					     offset & dma_desc_align_mask,
					     dma_desc_sync_size, dir);
}
static inline void b44_sync_dma_desc_for_cpu(struct ssb_device *sdev,
					     dma_addr_t dma_base,
					     unsigned long offset,
					     enum dma_data_direction dir)
{
	ssb_dma_sync_single_range_for_cpu(sdev, dma_base,
					  offset & dma_desc_align_mask,
					  dma_desc_sync_size, dir);
}
static inline unsigned long br32(const struct b44 *bp, unsigned long reg)
{
	return ssb_read32(bp->sdev, reg);
}
static inline void bw32(const struct b44 *bp,
			unsigned long reg, unsigned long val)
{
	ssb_write32(bp->sdev, reg, val);
}
static inline void __b44_disable_ints(struct b44 *bp)
{
	bw32(bp, B44_IMASK, 0);
}
static void b44_enable_ints(struct b44 *bp)
{
	bw32(bp, B44_IMASK, bp->imask);
}
static inline void b44_pci_exit(void)
{
	ssb_pcihost_unregister(&b44_pci_driver);
}
static int bfin_mdiobus_reset(struct mii_bus *bus)
{
	return 0;
}
static int __init bfin_mac_init(void)
{
	return platform_driver_register(&bfin_mac_driver);
}
static void __exit bfin_mac_cleanup(void)
{
	platform_driver_unregister(&bfin_mac_driver);
}
static inline
void bmwrite(struct net_device *dev, unsigned long reg_offset, unsigned data )
{
	out_le16((void __iomem *)dev->base_addr + reg_offset, data);
}
static inline
unsigned short bmread(struct net_device *dev, unsigned long reg_offset )
{
	return in_le16((void __iomem *)dev->base_addr + reg_offset);
}
static void
bnx2_shmem_wr(struct bnx2 *bp, u32 offset, u32 val)
{
	bnx2_reg_wr_ind(bp, bp->shmem_base + offset, val);
}
static u32
bnx2_shmem_rd(struct bnx2 *bp, u32 offset)
{
	return (bnx2_reg_rd_ind(bp, bp->shmem_base + offset));
}
static char *
bnx2_xceiver_str(struct bnx2 *bp)
{
	return ((bp->phy_port == PORT_FIBRE) ? "SerDes" :
		((bp->phy_flags & BNX2_PHY_FLAG_SERDES) ? "Remote Copper" :
		 "Copper"));
}
static int
bnx2_get_regs_len(struct net_device *dev)
{
	return BNX2_REGDUMP_LEN;
}
static int __init bnx2_init(void)
{
	return pci_register_driver(&bnx2_pci_driver);
}
static void __exit bnx2_cleanup(void)
{
	pci_unregister_driver(&bnx2_pci_driver);
}
static int bnx2x_self_test_count(struct net_device *dev)
{
	return BNX2X_NUM_TESTS;
}
static inline int __agg_has_partner(struct aggregator *agg)
{
	return !is_zero_ether_addr(agg->partner_system.mac_addr_value);
}
static inline void __disable_port(struct port *port)
{
	bond_set_slave_inactive_flags(port->slave);
}
static inline int __port_is_enabled(struct port *port)
{
	return(port->slave->state == BOND_STATE_ACTIVE);
}
static inline void __get_rx_machine_lock(struct port *port)
{
	spin_lock_bh(&(SLAVE_AD_INFO(port->slave).rx_machine_lock));
}
static inline void __release_rx_machine_lock(struct port *port)
{
	spin_unlock_bh(&(SLAVE_AD_INFO(port->slave).rx_machine_lock));
}
static inline void __initialize_port_locks(struct port *port)
{
	spin_lock_init(&(SLAVE_AD_INFO(port->slave).rx_machine_lock));
}
 static void __attach_bond_to_agg(struct port *port)
{
	port=NULL; // just to satisfy the compiler
}
 static void __detach_bond_from_agg(struct port *port)
{
	port=NULL; // just to satisfy the compiler
}
static inline struct arp_pkt *arp_pkt(const struct sk_buff *skb)
{
	return (struct arp_pkt *)skb_network_header(skb);
}
static inline void _lock_tx_hashtbl(struct bonding *bond)
{
	spin_lock_bh(&(BOND_ALB_INFO(bond).tx_hashtbl_lock));
}
static inline void _unlock_tx_hashtbl(struct bonding *bond)
{
	spin_unlock_bh(&(BOND_ALB_INFO(bond).tx_hashtbl_lock));
}
static inline void _lock_rx_hashtbl(struct bonding *bond)
{
	spin_lock_bh(&(BOND_ALB_INFO(bond).rx_hashtbl_lock));
}
static inline void _unlock_rx_hashtbl(struct bonding *bond)
{
	spin_unlock_bh(&(BOND_ALB_INFO(bond).rx_hashtbl_lock));
}
void bond_register_ipv6_notifier(void)
{
	register_inet6addr_notifier(&bond_inet6addr_notifier);
}
void bond_unregister_ipv6_notifier(void)
{
	unregister_inet6addr_notifier(&bond_inet6addr_notifier);
}
static inline int bond_is_dmi_same(struct dev_mc_list *dmi1, struct dev_mc_list *dmi2)
{
	return memcmp(dmi1->dmi_addr, dmi2->dmi_addr, dmi1->dmi_addrlen) == 0 &&
			dmi1->dmi_addrlen == dmi2->dmi_addrlen;
}
static void bond_unregister_lacpdu(struct bonding *bond)
{
	dev_remove_pack(&(BOND_AD_INFO(bond).ad_pkt_type));
}
static void bond_set_lockdep_class_one(struct net_device *dev,
				       struct netdev_queue *txq,
				       void *_unused)
{
	lockdep_set_class(&txq->_xmit_lock,
			  &bonding_netdev_xmit_lock_key);
}
void bond_destroy_sysfs(void)
{
	netdev_class_remove_file(&class_attr_bonding_masters);
}
static void *bsd_comp_alloc (unsigned char *options, int opt_len)
  {
    return bsd_alloc (options, opt_len, 0);
  }
static void *bsd_decomp_alloc (unsigned char *options, int opt_len)
  {
    return bsd_alloc (options, opt_len, 1);
  }
static int bsd_comp_init (void *state, unsigned char *options,
			  int opt_len, int unit, int opthdr, int debug)
  {
    return bsd_init (state, options, opt_len, unit, debug, 0);
  }
static int bsd_decomp_init (void *state, unsigned char *options,
			    int opt_len, int unit, int opthdr, int mru,
			    int debug)
  {
    return bsd_init (state, options, opt_len, unit, debug, 1);
  }
static void bsd_incomp (void *state, unsigned char *ibuf, int icnt)
  {
    (void) bsd_compress (state, ibuf, (char *) 0, icnt, 0);
  }
static void __exit bsdcomp_cleanup(void)
{
	ppp_unregister_compressor(&ppp_bsd_compress);
}
static __exit void vcan_cleanup_module(void)
{
	rtnl_link_unregister(&vcan_link_ops);
}
static inline void *tx_tiny_buf(struct cas *cp, const int ring,
				const int entry)
{
	return cp->tx_tiny_bufs[ring] + TX_TINY_BUF_LEN*entry;
}
static void cas_get_strings(struct net_device *dev, u32 stringset, u8 *data)
{
	 memcpy(data, &ethtool_cassini_statnames,
					 CAS_NUM_STAT_KEYS * ETH_GSTRING_LEN);
}
static void __exit cas_cleanup(void)
{
	pci_unregister_driver(&cas_driver);
}
static inline void schedule_mac_stats_update(struct adapter *ap, int secs)
{
	schedule_delayed_work(&ap->stats_update_task, secs * HZ);
}
static inline void cancel_mac_stats_update(struct adapter *ap)
{
	cancel_delayed_work(&ap->stats_update_task);
}
static int get_regs_len(struct net_device *dev)
{
	return T2_REGMAP_SIZE;
}
static int __init t1_init_module(void)
{
	return pci_register_driver(&driver);
}
static void __exit t1_cleanup_module(void)
{
	pci_unregister_driver(&driver);
}
const struct espi_intr_counts *t1_espi_get_intr_counts(struct peespi *espi)
{
	return &espi->intr_cnt;
}
void t1_espi_destroy(struct peespi *espi)
{
	kfree(espi);
}
static void mv88e1xxx_destroy(struct cphy *cphy)
{
	kfree(cphy);
}
static int mv88e1xxx_phy_reset(adapter_t* adapter)
{
	return 0;
}
static int mv88x201x_reset(struct cphy *cphy, int wait)
{
	return 0;
}
static int mv88x201x_set_loopback(struct cphy *cphy, int on)
{
	return 0;
}
static void mv88x201x_destroy(struct cphy *cphy)
{
	kfree(cphy);
}
static int my3126_reset(struct cphy *cphy, int wait)
{
	return 0;
}
static int my3126_interrupt_clear(struct cphy *cphy)
{
	return 0;
}
static int my3126_set_loopback(struct cphy *cphy, int on)
{
	return 0;
}
static void my3126_destroy(struct cphy *cphy)
{
	kfree(cphy);
}
static int pm3393_reset(struct cmac *cmac)
{
	return 0;
}
static int pm3393_loopback_enable(struct cmac *cmac)
{
	return 0;
}
static int pm3393_loopback_disable(struct cmac *cmac)
{
	return 0;
}
static void pm3393_destroy(struct cmac *cmac)
{
	kfree(cmac);
}
static inline unsigned int jumbo_payload_capacity(const struct sge *sge)
{
	return sge->freelQ[sge->jumbo_fl].rx_buffer_size -
		sge->freelQ[sge->jumbo_fl].dma_offset -
		sizeof(struct cpl_rx_data);
}
const struct sge_intr_counts *t1_sge_get_intr_counts(const struct sge *sge)
{
	return &sge->stats;
}
static void t1_tpi_par(adapter_t *adapter, u32 value)
{
	writel(V_TPIPAR(value), adapter->regs + A_TPI_PAR);
}
const struct board_info *t1_get_board_info(unsigned int board_id)
{
	return board_id < ARRAY_SIZE(t1_board) ? &t1_board[board_id] : NULL;
}
void t1_tp_destroy(struct petp *tp)
{
	kfree(tp);
}
void t1_tp_set_ip_checksum_offload(struct petp *tp, int enable)
{
	set_csum_offload(tp, F_IP_CSUM, enable);
}
void t1_tp_set_udp_checksum_offload(struct petp *tp, int enable)
{
	set_csum_offload(tp, F_UDP_CSUM, enable);
}
void t1_tp_set_tcp_checksum_offload(struct petp *tp, int enable)
{
	set_csum_offload(tp, F_TCP_CSUM, enable);
}
static int mac_intr_handler(struct cmac *mac)
{
	return 0;
}
static int mac_intr_enable(struct cmac *mac)
{
	return 0;
}
static int mac_intr_disable(struct cmac *mac)
{
	return 0;
}
static int mac_intr_clear(struct cmac *mac)
{
	return 0;
}
static void mac_destroy(struct cmac *mac)
{
	kfree(mac);
}
static void
dummy_check_speed(struct net_device* dev)
{
	current_speed = 100;
}
static void
dummy_check_duplex(struct net_device* dev)
{
	full_duplex = 1;
}
static void
e100_netpoll(struct net_device* netdev)
{
	e100rxtx_interrupt(NETWORK_DMA_TX_IRQ_NBR, netdev, NULL);
}
static int
etrax_init_module(void)
{
	return etrax_ethernet_init();
}
static u16
readword(unsigned long base_addr, int portno)
{
	return __raw_readw(base_addr + (portno << 1));
}
static void
writeword(unsigned long base_addr, int portno, u16 value)
{
	__raw_writew(value, base_addr + (portno << 1));
}
static u16
readword(unsigned long base_addr, int portno)
{
	return __raw_readl(base_addr + (portno << 1));
}
static void
writeword(unsigned long base_addr, int portno, u16 value)
{
	__raw_writel(value, base_addr + (portno << 1));
}
static u16
readword(unsigned long base_addr, int portno)
{
	return inw(base_addr + (portno << 1));
}
static void
writeword(unsigned long base_addr, int portno, u16 value)
{
	outw(value, base_addr + (portno << 1));
}
static u16
readword(unsigned long base_addr, int portno)
{
	return inw(base_addr + portno);
}
static void
writeword(unsigned long base_addr, int portno, u16 value)
{
	outw(value, base_addr + portno);
}
static int ael1002_intr_noop(struct cphy *phy)
{
	return 0;
}
static int ael1006_reset(struct cphy *phy, int wait)
{
	return t3_phy_reset(phy, MDIO_DEV_PMA_PMD, wait);
}
static int ael1006_power_down(struct cphy *phy, int enable)
{
	return t3_mdio_change_bits(phy, MDIO_DEV_PMA_PMD, MII_BMCR,
				   BMCR_PDOWN, enable ? BMCR_PDOWN : 0);
}
static int xaui_direct_reset(struct cphy *phy, int wait)
{
	return 0;
}
static int xaui_direct_power_down(struct cphy *phy, int enable)
{
	return 0;
}
static ssize_t store_nfilters(struct device *d, struct device_attribute *attr,
			      const char *buf, size_t len)
{
	return attr_store(d, buf, len, set_nfilters, 0, ~0);
}
static ssize_t store_nservers(struct device *d, struct device_attribute *attr,
			      const char *buf, size_t len)
{
	return attr_store(d, buf, len, set_nservers, 0, ~0);
}
static int get_regs_len(struct net_device *dev)
{
	return T3_REGMAP_SIZE;
}
static int get_eeprom_len(struct net_device *dev)
{
	return EEPROMSIZE;
}
static int in_range(int val, int lo, int hi)
{
	return val < 0 || (val <= hi && val >= lo);
}
static inline u32 get_hwtid(struct sk_buff *skb)
{
	return ntohl((__force __be32)skb->priority) >> 8 & 0xfffff;
}
static inline u32 get_opcode(struct sk_buff *skb)
{
	return G_OPCODE(ntohl((__force __be32)skb->csum));
}
static void free_tid_maps(struct tid_info *t)
{
	cxgb_free_mem(t->tid_tab);
}
static inline unsigned int vlan_prio(const struct l2t_entry *e)
{
	return e->vlan >> 13;
}
static inline unsigned int arp_hash(u32 key, int ifindex,
				    const struct l2t_data *d)
{
	return jhash_2words(key, ifindex, 0) & (d->nentries - 1);
}
static inline void arpq_enqueue(struct l2t_entry *e, struct sk_buff *skb)
{
	__skb_queue_tail(&e->arpq, skb);
}
void t3_free_l2t(struct l2t_data *d)
{
	cxgb_free_mem(d);
}
static inline void mc5_dbgi_mode_enable(const struct mc5 *mc5)
{
	t3_write_reg(mc5->adapter, A_MC5_DB_CONFIG,
		     V_TMMODE(mc5->mode == MC5_MODE_72_BIT) | F_DBGIEN);
}
static void mc5_dbgi_mode_disable(const struct mc5 *mc5)
{
	t3_write_reg(mc5->adapter, A_MC5_DB_CONFIG,
		     V_TMMODE(mc5->mode == MC5_MODE_72_BIT) |
		     V_COMPEN(mc5->mode == MC5_MODE_72_BIT) |
		     V_PRTYEN(mc5->parity_enabled) | F_MBUSEN);
}
static inline struct sge_qset *fl_to_qset(const struct sge_fl *q, int qidx)
{
	return container_of(q, struct sge_qset, fl[qidx]);
}
static inline struct sge_qset *rspq_to_qset(const struct sge_rspq *q)
{
	return container_of(q, struct sge_qset, rspq);
}
static inline struct sge_qset *txq_to_qset(const struct sge_txq *q, int qidx)
{
	return container_of(q, struct sge_qset, txq[qidx]);
}
static inline void __refill_fl(struct adapter *adap, struct sge_fl *fl)
{
	refill_fl(adap, fl, min(16U, fl->size - fl->credits),
		  GFP_ATOMIC | __GFP_COMP);
}
static inline unsigned int sgl_len(unsigned int n)
{
	return (3 * n) / 2 + (n & 1);
}
static inline void wr_gen2(struct tx_desc *d, unsigned int gen)
{
	d->flit[TX_DESC_FLITS - 1] = cpu_to_be64(gen);
}
static inline int immediate(const struct sk_buff *skb)
{
	return skb->len <= WR_LEN;
}
static inline int queue_set(const struct sk_buff *skb)
{
	return skb->priority >> 1;
}
static inline int is_ctrl_pkt(const struct sk_buff *skb)
{
	return skb->priority & 1;
}
static inline int is_arp(struct sk_buff *skb)
{
	return skb->protocol == htons(ETH_P_ARP);
}
static inline int is_eth_tcp(u32 rss)
{
	return G_HASHTYPE(ntohl(rss)) == RSS_HASH_4_TUPLE;
}
static inline int is_new_response(const struct rsp_desc *r,
				  const struct sge_rspq *q)
{
	return (r->intr_gen & F_RSPD_GEN2) == q->gen;
}
static inline int napi_is_scheduled(struct napi_struct *napi)
{
	return test_bit(NAPI_STATE_SCHED, &napi->state);
}
void t3_sge_start(struct adapter *adap)
{
	t3_set_reg_field(adap, A_SG_CONTROL, F_GLOBALENABLE, F_GLOBALENABLE);
}
int t3_phy_lasi_intr_enable(struct cphy *phy)
{
	return mdio_write(phy, MDIO_DEV_PMA_PMD, LASI_CTRL, 1);
}
int t3_phy_lasi_intr_disable(struct cphy *phy)
{
	return mdio_write(phy, MDIO_DEV_PMA_PMD, LASI_CTRL, 0);
}
const struct adapter_info *t3_get_adapter_info(unsigned int id)
{
	return id < ARRAY_SIZE(t3_adap_info) ? &t3_adap_info[id] : NULL;
}
int t3_seeprom_wp(struct adapter *adapter, int enable)
{
	return t3_seeprom_write(adapter, EEPROM_STAT_ADDR, enable ? 0xc : 0);
}
static unsigned int hex2int(unsigned char c)
{
	return isdigit(c) ? c - '0' : toupper(c) - 'A' + 10;
}
int t3_get_fw_version(struct adapter *adapter, u32 *vers)
{
	return t3_read_flash(adapter, FW_VERS_ADDR, 1, vers, 0);
}
void t3_set_vlan_accel(struct adapter *adapter, unsigned int ports, int on)
{
	t3_set_reg_field(adapter, A_TP_OUT_CONFIG,
			 ports << S_VLANEXTRACTIONENABLE,
			 on ? (ports << S_VLANEXTRACTIONENABLE) : 0);
}
void t3_tp_set_max_rxsize(struct adapter *adap, unsigned int size)
{
	t3_write_reg(adap, A_TP_PARA_REG7,
		     V_PMMAXXFERLEN0(size) | V_PMMAXXFERLEN1(size));
}
void t3_tp_get_mib_stats(struct adapter *adap, struct tp_mib_stats *tps)
{
	t3_read_indirect(adap, A_TP_MIB_INDEX, A_TP_MIB_RDATA, (u32 *) tps,
			 sizeof(*tps) / sizeof(u32), 0);
}
void t3_led_ready(struct adapter *adapter)
{
	t3_set_reg_field(adapter, A_T3DBG_GPIO_EN, F_GPIO0_OUT_VAL,
			 F_GPIO0_OUT_VAL);
}
static int vsc8211_reset(struct cphy *cphy, int wait)
{
	return t3_phy_reset(cphy, 0, 0);
}
static int vsc8211_intr_enable(struct cphy *cphy)
{
	return mdio_write(cphy, 0, VSC8211_INTR_ENABLE, INTR_MASK);
}
static int vsc8211_intr_disable(struct cphy *cphy)
{
	return mdio_write(cphy, 0, VSC8211_INTR_ENABLE, 0);
}
static int vsc8211_autoneg_enable(struct cphy *cphy)
{
	return t3_mdio_change_bits(cphy, 0, MII_BMCR, BMCR_PDOWN | BMCR_ISOLATE,
				   BMCR_ANENABLE | BMCR_ANRESTART);
}
static int vsc8211_autoneg_restart(struct cphy *cphy)
{
	return t3_mdio_change_bits(cphy, 0, MII_BMCR, BMCR_PDOWN | BMCR_ISOLATE,
				   BMCR_ANRESTART);
}
static int vsc8211_power_down(struct cphy *cphy, int enable)
{
	return t3_mdio_change_bits(cphy, 0, MII_BMCR, BMCR_PDOWN,
				   enable ? BMCR_PDOWN : 0);
}
static inline int macidx(const struct cmac *mac)
{
	return mac->offset / (XGMAC0_1_BASE_ADDR - XGMAC0_0_BASE_ADDR);
}
static inline void dfx_outl(DFX_board_t *bp, int offset, u32 data)
{
	outl(data, bp->base.port + offset);
}
static inline void dfx_inl(DFX_board_t *bp, int offset, u32 *data)
{
	*data = inl(bp->base.port + offset);
}
static __devinit int dfx_pci_register(struct pci_dev *pdev,
				      const struct pci_device_id *ent)
{
	return dfx_register(&pdev->dev);
}
static void __devexit dfx_pci_unregister(struct pci_dev *pdev)
{
	dfx_unregister(&pdev->dev);
}
static int __devexit depca_isa_remove(struct platform_device *pdev)
{
	return depca_device_remove(&pdev->dev);
}
static inline dma_addr_t desc_to_dma(struct netdev_desc *desc)
{
	return le64_to_cpu(desc->fraginfo) & DMA_48BIT_MASK;
}
static int __init
rio_init (void)
{
	return pci_register_driver(&rio_driver);
}
static void __exit
rio_exit (void)
{
	pci_unregister_driver (&rio_driver);
}
static inline board_info_t *to_dm9000_board(struct net_device *dev)
{
	return netdev_priv(dev);
}
static void dm9000_outblk_8bit(void __iomem *reg, void *data, int count)
{
	writesb(reg, data, count);
}
static void dm9000_outblk_16bit(void __iomem *reg, void *data, int count)
{
	writesw(reg, data, (count+1) >> 1);
}
static void dm9000_outblk_32bit(void __iomem *reg, void *data, int count)
{
	writesl(reg, data, (count+3) >> 2);
}
static void dm9000_inblk_8bit(void __iomem *reg, void *data, int count)
{
	readsb(reg, data, count);
}
static void dm9000_inblk_16bit(void __iomem *reg, void *data, int count)
{
	readsw(reg, data, (count+1) >> 1);
}
static void dm9000_inblk_32bit(void __iomem *reg, void *data, int count)
{
	readsl(reg, data, (count+3) >> 2);
}
static int dm9000_get_eeprom_len(struct net_device *dev)
{
	return 128;
}
static void __exit
dm9000_cleanup(void)
{
	platform_driver_unregister(&dm9000_driver);
}
static void __exit dummy_cleanup_module(void)
{
	rtnl_link_unregister(&dummy_link_ops);
}
static inline void e100_write_flush(struct nic *nic)
{
	(void)ioread8(&nic->csr->scb.status);
}
static int mdio_read(struct net_device *netdev, int addr, int reg)
{
	return mdio_ctrl(netdev_priv(netdev), addr, mdi_read, reg, 0);
}
static void mdio_write(struct net_device *netdev, int addr, int reg, int data)
{
	mdio_ctrl(netdev_priv(netdev), addr, mdi_write, reg, data);
}
static int e100_asf(struct nic *nic)
{
	return((nic->pdev->device >= 0x1050) && (nic->pdev->device <= 0x1057) &&
	   (nic->eeprom[eeprom_config_asf] & eeprom_asf) &&
	   !(nic->eeprom[eeprom_config_asf] & eeprom_gcl) &&
	   ((nic->eeprom[eeprom_smbus_addr] & 0xFF) != 0xFE));
}
static void e100_shutdown(struct pci_dev *pdev)
{
	e100_suspend(pdev, PMSG_SUSPEND);
}
static void __exit e100_cleanup_module(void)
{
	pci_unregister_driver(&e100_driver);
}
static u32 e1000_get_tx_csum(struct net_device *netdev)
{
	return (netdev->features & NETIF_F_HW_CSUM) != 0;
}
static int e1000_get_regs_len(struct net_device *netdev)
{
	return E1000_REGS_LEN * sizeof(u32);
}
void e1000_set_ethtool_ops(struct net_device *netdev)
{
	SET_ETHTOOL_OPS(netdev, &e1000_ethtool_ops);
}
static void __exit e1000_exit_module(void)
{
	pci_unregister_driver(&e1000_driver);
}
void e1000_io_write(struct e1000_hw *hw, unsigned long port, u32 value)
{
	outl(value, port);
}
static void e1000_shutdown(struct pci_dev *pdev)
{
	e1000_suspend(pdev, PMSG_SUSPEND);
}
static s32 e1000_write_nvm_80003es2lan(struct e1000_hw *hw, u16 offset,
				       u16 words, u16 *data)
{
	return e1000e_write_nvm_spi(hw, offset, words, data);
}
static u32 e1000_get_tx_csum(struct net_device *netdev)
{
	return ((netdev->features & NETIF_F_HW_CSUM) != 0);
}
static int e1000_get_regs_len(struct net_device *netdev)
{
	return E1000_REGS_LEN * sizeof(u32);
}
void e1000e_set_ethtool_ops(struct net_device *netdev)
{
	SET_ETHTOOL_OPS(netdev, &e1000_ethtool_ops);
}
static inline u16 __er16flash(struct e1000_hw *hw, unsigned long reg)
{
	return readw(hw->flash_address + reg);
}
static inline u32 __er32flash(struct e1000_hw *hw, unsigned long reg)
{
	return readl(hw->flash_address + reg);
}
static inline void __ew16flash(struct e1000_hw *hw, unsigned long reg, u16 val)
{
	writew(val, hw->flash_address + reg);
}
static inline void __ew32flash(struct e1000_hw *hw, unsigned long reg, u32 val)
{
	writel(val, hw->flash_address + reg);
}
char *e1000e_get_hw_dev_name(struct e1000_hw *hw)
{
	return hw->adapter->netdev->name;
}
static void e1000_update_mc_addr_list(struct e1000_hw *hw, u8 *mc_addr_list,
				      u32 mc_addr_count, u32 rar_used_count,
				      u32 rar_count)
{
	hw->mac.ops.update_mc_addr_list(hw, mc_addr_list, mc_addr_count,
				        rar_used_count, rar_count);
}
static void e1000_shutdown(struct pci_dev *pdev)
{
	e1000_suspend(pdev, PMSG_SUSPEND);
}
static inline unsigned short scb_status(struct net_device *dev)
{
	return inw(dev->base_addr + 0xc008);
}
static inline unsigned short scb_rdcmd(struct net_device *dev)
{
	return inw(dev->base_addr + 0xc00a);
}
static inline void scb_command(struct net_device *dev, unsigned short cmd)
{
	outw(cmd, dev->base_addr + 0xc00a);
}
static inline void scb_wrcbl(struct net_device *dev, unsigned short val)
{
	outw(val, dev->base_addr + 0xc00c);
}
static inline void scb_wrrfa(struct net_device *dev, unsigned short val)
{
	outw(val, dev->base_addr + 0xc00e);
}
static inline void set_loopback(struct net_device *dev)
{
	outb(inb(dev->base_addr + Config) | 2, dev->base_addr + Config);
}
static inline void clear_loopback(struct net_device *dev)
{
	outb(inb(dev->base_addr + Config) & ~2, dev->base_addr + Config);
}
static u32 ehea_get_rx_csum(struct net_device *dev)
{
	return 1;
}
void ehea_set_ethtool_ops(struct net_device *netdev)
{
	SET_ETHTOOL_OPS(netdev, &ehea_ethtool_ops);
}
static int ehea_refill_rq2(struct ehea_port_res *pr, int nr_of_wqes)
{
	return ehea_refill_rq_def(pr, &pr->rq2_skba, 2,
				  nr_of_wqes, EHEA_RWQE2_TYPE,
				  EHEA_RQ2_PKT_SIZE + NET_IP_ALIGN);
}
static int ehea_refill_rq3(struct ehea_port_res *pr, int nr_of_wqes)
{
	return ehea_refill_rq_def(pr, &pr->rq3_skba, 3,
				  nr_of_wqes, EHEA_RWQE3_TYPE,
				  EHEA_MAX_PACKET_SIZE + NET_IP_ALIGN);
}
int ehea_rem_smrs(struct ehea_port_res *pr)
{
	if ((ehea_rem_mr(&pr->send_mr))
	    || (ehea_rem_mr(&pr->recv_mr)))
		return -EIO;
	else
		return 0;
}
static ssize_t ehea_show_capabilities(struct device_driver *drv,
				      char *buf)
{
	return sprintf(buf, "%d", EHEA_CAPABILITIES);
}
u64 ehea_h_query_ehea_qp(const u64 adapter_handle, const u8 qp_category,
			 const u64 qp_handle, const u64 sel_mask, void *cb_addr)
{
	return ehea_plpar_hcall_norets(H_QUERY_HEA_QP,
				       adapter_handle,		/* R4 */
				       qp_category,		/* R5 */
				       qp_handle,		/* R6 */
				       sel_mask,		/* R7 */
				       virt_to_abs(cb_addr),	/* R8 */
				       0, 0);
}
u64 ehea_h_free_resource(const u64 adapter_handle, const u64 res_handle,
			 u64 force_bit)
{
	return ehea_plpar_hcall_norets(H_FREE_RESOURCE,
				       adapter_handle,	   /* R4 */
				       res_handle,	   /* R5 */
				       force_bit,
				       0, 0, 0, 0);	   /* R7-R10 */
}
u64 ehea_h_reset_events(const u64 adapter_handle, const u64 neq_handle,
			const u64 event_mask)
{
	return ehea_plpar_hcall_norets(H_RESET_EVENTS,
				       adapter_handle,		/* R4 */
				       neq_handle,		/* R5 */
				       event_mask,		/* R6 */
				       0, 0, 0, 0);		/* R7-R12 */
}
u64 ehea_h_error_data(const u64 adapter_handle, const u64 ressource_handle,
		      void *rblock)
{
	return ehea_plpar_hcall_norets(H_ERROR_DATA,
				       adapter_handle,		/* R4 */
				       ressource_handle,	/* R5 */
				       virt_to_abs(rblock),	/* R6 */
				       0, 0, 0, 0);		/* R7-R12 */
}
static inline u32 map_wqe_size(u8 wqe_enc_size)
{
	return 128 << wqe_enc_size;
}
static inline int ehea_calc_index(unsigned long i, unsigned long s)
{
	return (i >> s) & EHEA_INDEX_MASK;
}
static int wait_phy_ready(struct enc28j60_net *priv)
{
	return poll_ready(priv, MISTAT, MISTAT_BUSY, 0) ? 0 : 1;
}
static u16 rx_packet_start(u16 ptr)
{
	if (ptr + RSV_SIZE > RXEND_INIT)
		return (ptr + RSV_SIZE) - (RXEND_INIT - RXSTART_INIT + 1);
	else
		return ptr + RSV_SIZE;
}
static int
enc28j60_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
{
	return enc28j60_setlink(dev, cmd->autoneg, cmd->speed, cmd->duplex);
}
static void __exit enc28j60_exit(void)
{
	spi_unregister_driver(&enc28j60_driver);
}
static void enic_wq_free_buf(struct vnic_wq *wq,
	struct cq_desc *cq_desc, struct vnic_wq_buf *buf, void *opaque)
{
	enic_free_wq_buf(wq, buf);
}
static void enic_reset_mcaddrs(struct enic *enic)
{
	enic->mc_count = 0;
}
static void __exit enic_cleanup_module(void)
{
	pci_unregister_driver(&enic_driver);
}
void enic_add_station_addr(struct enic *enic)
{
	vnic_dev_add_addr(enic->vdev, enic->mac_addr);
}
void enic_add_multicast_addr(struct enic *enic, u8 *addr)
{
	vnic_dev_add_addr(enic->vdev, addr);
}
void enic_del_multicast_addr(struct enic *enic, u8 *addr)
{
	vnic_dev_del_addr(enic->vdev, addr);
}
void *vnic_dev_priv(struct vnic_dev *vdev)
{
	return vdev->priv;
}
unsigned int vnic_dev_get_res_count(struct vnic_dev *vdev,
	enum vnic_res_type type)
{
	return vdev->res[type].count;
}
void vnic_dev_clear_desc_ring(struct vnic_dev_ring *ring)
{
	memset(ring->descs, 0, ring->size);
}
void vnic_dev_set_intr_mode(struct vnic_dev *vdev,
	enum vnic_dev_intr_mode intr_mode)
{
	vdev->intr_mode = intr_mode;
}
enum vnic_dev_intr_mode vnic_dev_get_intr_mode(
	struct vnic_dev *vdev)
{
	return vdev->intr_mode;
}
void vnic_intr_free(struct vnic_intr *intr)
{
	intr->ctrl = NULL;
}
void vnic_intr_clean(struct vnic_intr *intr)
{
	iowrite32(0, &intr->ctrl->int_credits);
}
unsigned int vnic_rq_error_status(struct vnic_rq *rq)
{
	return ioread32(&rq->ctrl->error_status);
}
void vnic_rq_enable(struct vnic_rq *rq)
{
	iowrite32(1, &rq->ctrl->enable);
}
unsigned int vnic_wq_error_status(struct vnic_wq *wq)
{
	return ioread32(&wq->ctrl->error_status);
}
void vnic_wq_enable(struct vnic_wq *wq)
{
	iowrite32(1, &wq->ctrl->enable);
}
static inline void __epic_pci_commit(long ioaddr)
{
	inl(ioaddr + INTMASK);
}
static u32 netdev_get_msglevel(struct net_device *dev)
{
	return debug;
}
static void netdev_set_msglevel(struct net_device *dev, u32 value)
{
	debug = value;
}
static void __exit epic_cleanup (void)
{
	pci_unregister_driver (&epic_driver);
}
static u32 netdev_get_msglevel(struct net_device *dev)
{
	return debug;
}
static void netdev_set_msglevel(struct net_device *dev, u32 value)
{
	debug = value;
}
static void __exit fealnx_exit(void)
{
	pci_unregister_driver(&fealnx_driver);
}
static void __exit
fec_enet_cleanup(void)
{
	platform_driver_unregister(&fec_driver);
}
static void mpc52xx_fec_get_drvinfo(struct net_device *dev,
		struct ethtool_drvinfo *info)
{
	strcpy(info->driver, DRIVER_NAME);
}
static int mpc52xx_fec_mdio_read(struct mii_bus *bus, int phy_id, int reg)
{
	return mpc52xx_fec_mdio_transfer(bus, phy_id, reg, FEC_MII_READ_FRAME);
}
static int mpc52xx_fec_mdio_write(struct mii_bus *bus, int phy_id, int reg,
		u16 data)
{
	return mpc52xx_fec_mdio_transfer(bus, phy_id, reg,
		data | FEC_MII_WRITE_FRAME);
}
static inline struct fe_priv *get_nvpriv(struct net_device *dev)
{
	return netdev_priv(dev);
}
static inline u8 __iomem *get_hwbase(struct net_device *dev)
{
	return ((struct fe_priv *)netdev_priv(dev))->base;
}
static inline void pci_push(u8 __iomem *base)
{
	readl(base);
}
static inline u32 nv_descr_getlength(struct ring_desc *prd, u32 v)
{
	return le32_to_cpu(prd->flaglen)
		& ((v == DESC_VER_1) ? LEN_MASK_V1 : LEN_MASK_V2);
}
static inline u32 nv_descr_getlength_ex(struct ring_desc_ex *prd, u32 v)
{
	return le32_to_cpu(prd->flaglen) & LEN_MASK_V2;
}
static inline u32 dma_low(dma_addr_t addr)
{
	return addr;
}
static inline u32 dma_high(dma_addr_t addr)
{
	return addr>>31>>1;	/* 0 if 32bit, shift down by 32 if 64bit */
}
static inline u32 nv_get_empty_tx_slots(struct fe_priv *np)
{
	return (u32)(np->tx_ring_size - ((np->tx_ring_size + (np->put_tx_ctx - np->get_tx_ctx)) % np->tx_ring_size));
}
static void nv_poll_controller(struct net_device *dev)
{
	nv_do_nic_poll((unsigned long) dev);
}
static int __init init_nic(void)
{
	return pci_register_driver(&driver);
}
static void __exit exit_nic(void)
{
	pci_unregister_driver(&driver);
}
static int fs_nway_reset(struct net_device *dev)
{
	return 0;
}
static void cleanup_immap(void)
{
	iounmap(fs_enet_immap);
}
static void ev_error(struct net_device *dev, u32 int_events)
{
	printk(KERN_WARNING DRV_MODULE_NAME
	       ": %s FS_ENET ERROR(s) 0x%x\n", dev->name, int_events);
}
static int get_regs_len(struct net_device *dev)
{
	return sizeof(fcc_t) + sizeof(fcc_enet_t) + 1;
}
static void ev_error(struct net_device *dev, u32 int_events)
{
	printk(KERN_WARNING DRV_MODULE_NAME
	       ": %s FEC ERROR(s) 0x%x\n", dev->name, int_events);
}
static int get_regs_len(struct net_device *dev)
{
	return sizeof(fec_t);
}
static void ev_error(struct net_device *dev, u32 int_events)
{
	printk(KERN_WARNING DRV_MODULE_NAME
	       ": %s SCC ERROR(s) 0x%x\n", dev->name, int_events);
}
static int get_regs_len(struct net_device *dev)
{
	return sizeof(scc_t) + sizeof(scc_enet_t __iomem *);
}
static inline void bb_set(u32 __iomem *p, u32 m)
{
	out_be32(p, in_be32(p) | m);
}
static inline void bb_clr(u32 __iomem *p, u32 m)
{
	out_be32(p, in_be32(p) & ~m);
}
static inline int bb_read(u32 __iomem *p, u32 m)
{
	return (in_be32(p) & m) != 0;
}
static int fs_enet_mdio_bb_init(void)
{
	return of_register_platform_driver(&fs_enet_bb_mdio_driver);
}
static void fs_enet_mdio_bb_exit(void)
{
	of_unregister_platform_driver(&fs_enet_bb_mdio_driver);
}
static int fs_enet_fec_mii_reset(struct mii_bus *bus)
{
	return 0;
}
static int fs_enet_mdio_fec_init(void)
{
	return of_register_platform_driver(&fs_enet_fec_mdio_driver);
}
static void fs_enet_mdio_fec_exit(void)
{
	of_unregister_platform_driver(&fs_enet_fec_mdio_driver);
}
int __init fsl_pq_mdio_init(void)
{
	return of_register_platform_driver(&fsl_pq_mdio_driver);
}
void fsl_pq_mdio_exit(void)
{
	of_unregister_platform_driver(&fsl_pq_mdio_driver);
}
static inline int gfar_uses_fcb(struct gfar_private *priv)
{
	return priv->vlgrp || priv->rx_csum_enable;
}
static inline struct txbd8 *next_txbd(struct txbd8 *bdp, struct txbd8 *base,
		int ring_size)
{
	return skip_txbd(bdp, 1, base, ring_size);
}
static int __init gfar_init(void)
{
	return of_register_platform_driver(&gfar_driver);
}
static void __exit gfar_exit(void)
{
	of_unregister_platform_driver(&gfar_driver);
}
static int gfar_reglen(struct net_device *dev)
{
	return sizeof (struct gfar);
}
int __init gfar_mdio_init(void)
{
	return of_register_platform_driver(&gianfar_mdio_driver);
}
void gfar_mdio_exit(void)
{
	of_unregister_platform_driver(&gianfar_mdio_driver);
}
static void __exit hamachi_exit (void)
{
	pci_unregister_driver(&hamachi_driver);
}
static int sp_rebuild_header(struct sk_buff *skb)
{
	return ax25_rebuild_header(skb);
}
static inline int check_crc_ccitt(const unsigned char *buf, int cnt)
{
	return (crc_ccitt(0xffff, buf, cnt) & 0xffff) == 0xf0b8;
}
static inline int calc_crc_ccitt(const unsigned char *buf, int cnt)
{
	return (crc_ccitt(0xffff, buf, cnt) ^ 0xffff) & 0xffff;
}
static void bpq_set_lockdep_class_one(struct net_device *dev,
				      struct netdev_queue *txq,
				      void *_unused)
{
	lockdep_set_class(&txq->_xmit_lock, &bpq_netdev_xmit_lock_key);
}
static inline int dev_is_ethdev(struct net_device *dev)
{
	return (
			dev->type == ARPHRD_ETHER
			&& strncmp(dev->name, "dummy", 5)
	);
}
static void bpq_seq_stop(struct seq_file *seq, void *v)
{
	rcu_read_unlock();
}
static int bpq_info_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &bpq_seqops);
}
static inline int check_crc_ccitt(const unsigned char *buf, int cnt)
{
	return (crc_ccitt(0xffff, buf, cnt) & 0xffff) == 0xf0b8;
}
static void __exit hdlcdrv_cleanup_driver(void)
{
	printk(KERN_INFO "hdlcdrv: cleanup\n");
}
static int ax_rebuild_header(struct sk_buff *skb)
{
	return ax25_rebuild_header(skb);
}
static inline void wr(struct scc_channel *scc, unsigned char reg,
	unsigned char val)
{
	OutReg(scc->ctrl, reg, (scc->wreg[reg] = val));
}
static inline void or(struct scc_channel *scc, unsigned char reg, unsigned char val)
{
	OutReg(scc->ctrl, reg, (scc->wreg[reg] |= val));
}
static inline void cl(struct scc_channel *scc, unsigned char reg, unsigned char val)
{
	OutReg(scc->ctrl, reg, (scc->wreg[reg] &= ~val));
}
static void *scc_net_seq_start(struct seq_file *seq, loff_t *pos)
{
	return *pos ? scc_net_seq_idx(*pos - 1) : SEQ_START_TOKEN;
}
static int scc_net_seq_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &scc_net_seq_ops);
}
static void ptt_on(struct net_device *dev)
{
	outb(PTT_ON, MCR(dev->base_addr));
}
static void ptt_off(struct net_device *dev)
{
	outb(PTT_OFF, MCR(dev->base_addr));
}
static void *yam_seq_start(struct seq_file *seq, loff_t *pos)
{
	return (*pos < NR_PORTS) ? yam_devs[*pos] : NULL;
}
static int yam_info_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &yam_seqops);
}
static inline u_int pdl_map_data(struct hp100_private *lp, void *data)
{
	return pci_map_single(lp->pci_dev, data,
			      MAX_ETHER_SIZE, PCI_DMA_FROMDEVICE);
}
static void wait(void)
{
	mdelay(1);
}
static int __init hplance_init_module(void)
{
	return dio_register_driver(&hplance_driver);
}
static void __exit hplance_cleanup_module(void)
{
        dio_unregister_driver(&hplance_driver);
}
static void hydra_reset_8390(struct net_device *dev)
{
    printk(KERN_INFO "Hydra hw reset not there\n");
}
static int __init hydra_init_module(void)
{
    return zorro_register_driver(&hydra_driver);
}
static void __exit hydra_cleanup_module(void)
{
    zorro_unregister_driver(&hydra_driver);
}
static inline int emac_phy_supports_gige(int phy_mode)
{
	return  phy_mode == PHY_MODE_GMII ||
		phy_mode == PHY_MODE_RGMII ||
		phy_mode == PHY_MODE_SGMII ||
		phy_mode == PHY_MODE_TBI ||
		phy_mode == PHY_MODE_RTBI;
}
static inline int emac_phy_gpcs(int phy_mode)
{
	return  phy_mode == PHY_MODE_SGMII ||
		phy_mode == PHY_MODE_TBI ||
		phy_mode == PHY_MODE_RTBI;
}
static u32 emac_calc_base_mr1(struct emac_instance *dev, int tx_size, int rx_size)
{
	return emac_has_feature(dev, EMAC_FTR_EMAC4) ?
		__emac4_calc_base_mr1(dev, tx_size, rx_size) :
		__emac_calc_base_mr1(dev, tx_size, rx_size);
}
static inline u32 emac_calc_trtr(struct emac_instance *dev, unsigned int size)
{
	if (emac_has_feature(dev, EMAC_FTR_EMAC4))
		return ((size >> 6) - 1) << EMAC_TRTR_SHIFT_EMAC4;
	else
		return ((size >> 6) - 1) << EMAC_TRTR_SHIFT;
}
static inline u32 emac_calc_rwmr(struct emac_instance *dev,
				 unsigned int low, unsigned int high)
{
	if (emac_has_feature(dev, EMAC_FTR_EMAC4))
		return (low << 22) | ( (high & 0x3ff) << 6);
	else
		return (low << 23) | ( (high & 0x1ff) << 7);
}
static int emac_get_regs_len(struct emac_instance *dev)
{
	if (emac_has_feature(dev, EMAC_FTR_EMAC4))
		return sizeof(struct emac_ethtool_regs_subhdr) +
			EMAC4_ETHTOOL_REGS_SIZE(dev);
	else
		return sizeof(struct emac_ethtool_regs_subhdr) +
			EMAC_ETHTOOL_REGS_SIZE(dev);
}
static int emac_ethtool_get_stats_count(struct net_device *ndev)
{
	return EMAC_ETHTOOL_STATS_COUNT;
}
static void emac_sysrq_handler(int key, struct tty_struct *tty)
{
	emac_dbg_dump_all();
}
int __init emac_init_debug(void)
{
	return register_sysrq_key('c', &emac_sysrq_op);
}
void __exit emac_fini_debug(void)
{
	unregister_sysrq_key('c', &emac_sysrq_op);
}
int __init emac_init_debug(void)
{
	return 0;
}
int mal_get_regs_len(struct mal_instance *mal)
{
	return sizeof(struct emac_ethtool_regs_subhdr) +
	    sizeof(struct mal_regs);
}
int __init mal_init(void)
{
	return of_register_platform_driver(&mal_of_driver);
}
void mal_exit(void)
{
	of_unregister_platform_driver(&mal_of_driver);
}
static inline int phy_read(struct mii_phy *phy, int reg)
{
	return phy->mdio_read(phy->dev, phy->address, reg);
}
static inline void phy_write(struct mii_phy *phy, int reg, int val)
{
	phy->mdio_write(phy->dev, phy->address, reg, val);
}
static inline int gpcs_phy_read(struct mii_phy *phy, int reg)
{
	return phy->mdio_read(phy->dev, phy->gpcs_address, reg);
}
static inline void gpcs_phy_write(struct mii_phy *phy, int reg, int val)
{
	phy->mdio_write(phy->dev, phy->gpcs_address, reg, val);
}
static inline int rgmii_valid_mode(int phy_mode)
{
	return  phy_mode == PHY_MODE_GMII ||
		phy_mode == PHY_MODE_MII ||
		phy_mode == PHY_MODE_RGMII ||
		phy_mode == PHY_MODE_TBI ||
		phy_mode == PHY_MODE_RTBI;
}
int rgmii_get_regs_len(struct of_device *ofdev)
{
	return sizeof(struct emac_ethtool_regs_subhdr) +
		sizeof(struct rgmii_regs);
}
int __init rgmii_init(void)
{
	return of_register_platform_driver(&rgmii_driver);
}
void rgmii_exit(void)
{
	of_unregister_platform_driver(&rgmii_driver);
}
int tah_get_regs_len(struct of_device *ofdev)
{
	return sizeof(struct emac_ethtool_regs_subhdr) +
		sizeof(struct tah_regs);
}
int __init tah_init(void)
{
	return of_register_platform_driver(&tah_driver);
}
void tah_exit(void)
{
	of_unregister_platform_driver(&tah_driver);
}
static inline int zmii_valid_mode(int mode)
{
	return  mode == PHY_MODE_MII ||
		mode == PHY_MODE_RMII ||
		mode == PHY_MODE_SMII ||
		mode == PHY_MODE_NA;
}
int zmii_get_regs_len(struct of_device *ofdev)
{
	return sizeof(struct emac_ethtool_regs_subhdr) +
		sizeof(struct zmii_regs);
}
int __init zmii_init(void)
{
	return of_register_platform_driver(&zmii_driver);
}
void zmii_exit(void)
{
	of_unregister_platform_driver(&zmii_driver);
}
static int __init ibmlana_init_module(void)
{
	return mca_register_driver(&ibmlana_driver);
}
static void __exit ibmlana_cleanup_module(void)
{
	mca_unregister_driver(&ibmlana_driver);
}
static inline u32 ibmveth_rxq_flags(struct ibmveth_adapter *adapter)
{
	return adapter->rx_queue.queue_addr[adapter->rx_queue.index].flags_off;
}
static inline int ibmveth_rxq_toggle(struct ibmveth_adapter *adapter)
{
	return (ibmveth_rxq_flags(adapter) & IBMVETH_RXQ_TOGGLE) >> IBMVETH_RXQ_TOGGLE_SHIFT;
}
static inline int ibmveth_rxq_pending_buffer(struct ibmveth_adapter *adapter)
{
	return (ibmveth_rxq_toggle(adapter) == adapter->rx_queue.toggle);
}
static inline int ibmveth_rxq_buffer_valid(struct ibmveth_adapter *adapter)
{
	return (ibmveth_rxq_flags(adapter) & IBMVETH_RXQ_VALID);
}
static inline int ibmveth_rxq_frame_offset(struct ibmveth_adapter *adapter)
{
	return (ibmveth_rxq_flags(adapter) & IBMVETH_RXQ_OFF_MASK);
}
static inline int ibmveth_rxq_frame_length(struct ibmveth_adapter *adapter)
{
	return (adapter->rx_queue.queue_addr[adapter->rx_queue.index].length);
}
static inline int ibmveth_rxq_csum_good(struct ibmveth_adapter *adapter)
{
	return (ibmveth_rxq_flags(adapter) & IBMVETH_RXQ_CSUM_GOOD);
}
static u32 netdev_get_link(struct net_device *dev) {
	return 1;
}
static int ibmveth_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
{
	return -EOPNOTSUPP;
}
static void ibmveth_proc_unregister_driver(void)
{
	remove_proc_entry(IBMVETH_PROC_DIR, init_net.proc_net);
}
static int ibmveth_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, ibmveth_show, PDE(inode)->data);
}
static void __exit ifb_cleanup_module(void)
{
	rtnl_link_unregister(&ifb_link_ops);
}
static u32 igb_get_tx_csum(struct net_device *netdev)
{
	return (netdev->features & NETIF_F_IP_CSUM) != 0;
}
static int igb_get_regs_len(struct net_device *netdev)
{
	return IGB_REGS_LEN * sizeof(u32);
}
static int igb_set_phy_loopback(struct igb_adapter *adapter)
{
	return igb_integrated_phy_loopback(adapter);
}
void igb_set_ethtool_ops(struct net_device *netdev)
{
	SET_ETHTOOL_OPS(netdev, &igb_ethtool_ops);
}
static void igb_shutdown(struct pci_dev *pdev)
{
	igb_suspend(pdev, PMSG_SUSPEND);
}
static inline struct net_device *priv_netdev(struct ioc3_private *dev)
{
	return (void *)dev - ((sizeof(struct net_device) + 31) & ~31);
}
static inline unsigned long aligned_rx_skb_addr(unsigned long addr)
{
	return (~addr + 1) & (IOC3_CACHELINE - 1UL);
}
static inline u32 mcr_pack(u32 pulse, u32 sample)
{
	return (pulse << 10) | (sample << 2);
}
static int ioc3_is_menet(struct pci_dev *pdev)
{
	return pdev->bus->parent == NULL &&
	       ioc3_adjacent_is_ioc3(pdev, 0) &&
	       ioc3_adjacent_is_ioc3(pdev, 1) &&
	       ioc3_adjacent_is_ioc3(pdev, 2);
}
static int __init ioc3_init_module(void)
{
	return pci_register_driver(&ioc3_driver);
}
static void __exit ioc3_cleanup_module(void)
{
	pci_unregister_driver(&ioc3_driver);
}
static void send_end(void __iomem *ioaddr, u8 phyctrlpolarity)
{
	ipg_w8((IPG_PC_MGMTCLK_LO | (IPG_PC_MGMTDATA & 0) | IPG_PC_MGMTDIR |
		phyctrlpolarity) & IPG_PC_RSVD_MASK, PHY_CTRL);
}
static int __init ipg_init_module(void)
{
	return pci_register_driver(&ipg_pci_driver);
}
static void __exit ipg_exit_module(void)
{
	pci_unregister_driver(&ipg_pci_driver);
}
static int __init act200l_sir_init(void)
{
	return irda_register_dongle(&act200l);
}
static void __exit act200l_sir_cleanup(void)
{
	irda_unregister_dongle(&act200l);
}
static int ali_ircc_init_43(ali_chip_t *chip, chipio_t *info) 
{
	return 0;
}
static int ali_ircc_init_53(ali_chip_t *chip, chipio_t *info) 
{
	return 0;
}
static int __init
donauboe_init (void)
{
  return pci_register_driver(&donauboe_pci_driver);
}
static void __exit
donauboe_cleanup (void)
{
  pci_unregister_driver(&donauboe_pci_driver);
}
static int __init ep7211_sir_init(void)
{
	return irda_register_dongle(&ep7211);
}
static void __exit ep7211_sir_cleanup(void)
{
	irda_unregister_dongle(&ep7211);
}
static int ep7211_change_speed(struct sir_dev *dev, unsigned speed)
{
	return 0;
}
static int ep7211_reset(struct sir_dev *dev)
{
	return 0;
}
static int __init esi_sir_init(void)
{
	return irda_register_dongle(&esi);
}
static void __exit esi_sir_cleanup(void)
{
	irda_unregister_dongle(&esi);
}
static int __init girbil_sir_init(void)
{
	return irda_register_dongle(&girbil);
}
static void __exit girbil_sir_cleanup(void)
{
	irda_unregister_dongle(&girbil);
}
static int irda_usb_is_receiving(struct irda_usb_cb *self)
{
	return 0; /* For now */
}
static void __exit usb_irda_cleanup(void)
{
	usb_deregister(&irda_driver);
}
static int __init kingsun_init(void)
{
	return usb_register(&irda_driver);
}
static void __exit kingsun_cleanup(void)
{
	usb_deregister(&irda_driver);
}
static int __init ks959_init(void)
{
	return usb_register(&irda_driver);
}
static void __exit ks959_cleanup(void)
{
	usb_deregister(&irda_driver);
}
static int __init ksdazzle_init(void)
{
	return usb_register(&irda_driver);
}
static void __exit ksdazzle_cleanup(void)
{
	usb_deregister(&irda_driver);
}
static int __init litelink_sir_init(void)
{
	return irda_register_dongle(&litelink);
}
static void __exit litelink_sir_cleanup(void)
{
	irda_unregister_dongle(&litelink);
}
static int __init mcp2120_sir_init(void)
{
	return irda_register_dongle(&mcp2120);
}
static void __exit mcp2120_sir_cleanup(void)
{
	irda_unregister_dongle(&mcp2120);
}
static void __exit mcs_exit(void)
{
	usb_deregister(&mcs_driver);
}
static int nsc_ircc_init_338(nsc_chip_t *chip, chipio_t *info) 
{
	return 0;
}
static int __init old_belkin_sir_init(void)
{
	return irda_register_dongle(&old_belkin);
}
static void __exit old_belkin_sir_cleanup(void)
{
	irda_unregister_dongle(&old_belkin);
}
static int __init pxa_irda_init(void)
{
	return platform_driver_register(&pxa_ir_driver);
}
static void __exit pxa_irda_exit(void)
{
	platform_driver_unregister(&pxa_ir_driver);
}
static void __exit sa1100_irda_exit(void)
{
	platform_driver_unregister(&sa1100ir_driver);
}
static void __exit sir_wq_exit(void)
{
	destroy_workqueue(irda_sir_wq);
}
static inline void register_bank(int iobase, int bank)
{
        outb(((inb(iobase + IRCC_MASTER) & 0xf0) | (bank & 0x07)),
               iobase + IRCC_MASTER);
}
static int smsc_ircc_is_receiving(struct smsc_ircc_cb *self)
{
	return (self->rx_buff.state != OUTSIDE_FRAME);
}
static int smsc_ircc_probe_transceiver_smsc_ircc_atc(int fir_base)
{
	return 0;
}
static int smsc_ircc_probe_transceiver_smsc_ircc_fast_pin_select(int fir_base)
{
	return 0;
}
static int smsc_ircc_probe_transceiver_toshiba_sat1800(int fir_base)
{
	return 0;
}
static inline int isfir(u32 speed)
{
	return (speed == 4000000);
}
static int __init stir_init(void)
{
	return usb_register(&irda_driver);
}
static void __exit stir_cleanup(void)
{
	usb_deregister(&irda_driver);
}
static void __exit tekram_sir_cleanup(void)
{
	irda_unregister_dongle(&tekram);
}
static void __exit toim3232_sir_cleanup(void)
{
	irda_unregister_dongle(&toim3232);
}
static int vlsi_seq_open(struct inode *inode, struct file *file)
{
	return single_open(file, vlsi_seq_show, PDE(inode)->data);
}
static inline int veth_stack_is_empty(struct veth_lpar_connection *cnx)
{
	return cnx->msg_stack_head == NULL;
}
static inline HvLpEvent_Rc
veth_signalevent(struct veth_lpar_connection *cnx, u16 subtype,
		 HvLpEvent_AckInd ackind, HvLpEvent_AckType acktype,
		 u64 token,
		 u64 data1, u64 data2, u64 data3, u64 data4, u64 data5)
{
	return HvCallEvent_signalLpEventFast(cnx->remote_lp,
					     HvLpEvent_Type_VirtualLan,
					     subtype, ackind, acktype,
					     cnx->src_inst,
					     cnx->dst_inst,
					     token, data1, data2, data3,
					     data4, data5);
}
static inline void veth_kick_statemachine(struct veth_lpar_connection *cnx)
{
	schedule_delayed_work(&cnx->statemachine_wq, 0);
}
static u32 veth_get_link(struct net_device *dev)
{
	return 1;
}
static u32
ixgb_get_tx_csum(struct net_device *netdev)
{
	return (netdev->features & NETIF_F_HW_CSUM) != 0;
}
static int
ixgb_get_regs_len(struct net_device *netdev)
{
	return IXGB_REG_DUMP_LEN;
}
static int
ixgb_get_eeprom_len(struct net_device *netdev)
{
	return (IXGB_EEPROM_SIZE << 1);
}
void ixgb_set_ethtool_ops(struct net_device *netdev)
{
	SET_ETHTOOL_OPS(netdev, &ixgb_ethtool_ops);
}
static void __exit
ixgb_exit_module(void)
{
	pci_unregister_driver(&ixgb_driver);
}
static u16 ixgbe_dcb_select_queue(struct net_device *dev, struct sk_buff *skb)
{
	return 0;
}
static u8 ixgbe_dcbnl_setnumtcs(struct net_device *netdev, int tcid, u8 num)
{
	return -EINVAL;
}
static void ixgbe_dcbnl_setpfcstate(struct net_device *netdev, u8 state)
{
	return;
}
static u32 ixgbe_get_tx_csum(struct net_device *netdev)
{
	return (netdev->features & NETIF_F_IP_CSUM) != 0;
}
static int ixgbe_get_regs_len(struct net_device *netdev)
{
	return IXGBE_REGS_LEN * sizeof(u32);
}
void ixgbe_set_ethtool_ops(struct net_device *netdev)
{
	SET_ETHTOOL_OPS(netdev, &ixgbe_ethtool_ops);
}
static inline u16 ixgbe_get_hdr_info(union ixgbe_adv_rx_desc *rx_desc)
{
	return rx_desc->wb.lower.lo_dword.hs_rss.hdr_info;
}
static inline u16 ixgbe_get_pkt_info(union ixgbe_adv_rx_desc *rx_desc)
{
	return rx_desc->wb.lower.lo_dword.hs_rss.pkt_info;
}
static void ixgbe_shutdown(struct pci_dev *pdev)
{
	ixgbe_suspend(pdev, PMSG_SUSPEND);
}
s32 ixgbe_reset_phy_generic(struct ixgbe_hw *hw)
{
	return hw->phy.ops.write_reg(hw, IXGBE_MDIO_PHY_XS_CONTROL,
	                             IXGBE_MDIO_PHY_XS_DEV_TYPE,
	                             IXGBE_MDIO_PHY_XS_RESET);
}
int pm3386_secondary_present(void)
{
	return pm3386_reg_read(1, 0) == 0x3386;
}
static u16 swaph(u16 x)
{
	return ((x << 8) | (x >> 8)) & 0xffff;
}
int pm3386_port_count(void)
{
	return 2 + pm3386_secondary_present();
}
void pm3386_set_carrier(int port, int state)
{
	pm3386_port_reg_write(port, 0x703, 0x10, state ? 0x1001 : 0x0000);
}
static int __init jazz_sonic_init_module(void)
{
	return platform_driver_register(&jazz_sonic_driver);
}
static void __exit jazz_sonic_cleanup_module(void)
{
	platform_driver_unregister(&jazz_sonic_driver);
}
static inline void
jme_stop_irq(struct jme_adapter *jme)
{
	jwrite32f(jme, JME_IENC, INTR_ENABLE);
}
static inline void
jme_enable_shadow(struct jme_adapter *jme)
{
	jwrite32(jme,
		 JME_SHBA_LO,
		 ((u32)jme->shadow_dma & ~((u32)0x1F)) | SHBA_POSTEN);
}
static inline void
jme_disable_shadow(struct jme_adapter *jme)
{
	jwrite32(jme, JME_SHBA_LO, 0x0);
}
static inline void
jme_set_phyfifoa(struct jme_adapter *jme)
{
	jme_mdio_write(jme->dev, jme->mii_if.phy_id, 27, 0x0004);
}
static inline void
jme_set_phyfifob(struct jme_adapter *jme)
{
	jme_mdio_write(jme->dev, jme->mii_if.phy_id, 27, 0x0000);
}
static inline void
jme_restart_tx_engine(struct jme_adapter *jme)
{
	jwrite32(jme, JME_TXCS, jme->reg_txcs |
				TXCS_SELECT_QUEUE0 |
				TXCS_ENABLE);
}
static inline void
jme_restart_rx_engine(struct jme_adapter *jme)
{
	jwrite32(jme, JME_RXCS, jme->reg_rxcs |
				RXCS_QUEUESEL_Q0 |
				RXCS_ENABLE |
				RXCS_QST);
}
static inline void
jme_stop_pcc_timer(struct jme_adapter *jme)
{
	jwrite32(jme, JME_TMCSR, 0);
}
static inline void
jme_polling_mode(struct jme_adapter *jme)
{
	jme_set_rx_pcc(jme, PCC_OFF);
}
static inline void
jme_interrupt_mode(struct jme_adapter *jme)
{
	jme_set_rx_pcc(jme, PCC_P1);
}
static void
jme_reset_link(struct jme_adapter *jme)
{
	jwrite32(jme, JME_TMCSR, TMCSR_SWIT);
}
static inline void
jme_phy_off(struct jme_adapter *jme)
{
	jme_mdio_write(jme->dev, jme->mii_if.phy_id, MII_BMCR, BMCR_PDOWN);
}
static int
jme_get_regs_len(struct net_device *netdev)
{
	return JME_REG_LEN;
}
static void __exit
jme_cleanup_module(void)
{
	pci_unregister_driver(&jme_driver);
}
static inline void korina_chain_dma(struct dma_reg *ch, u32 dma_addr)
{
	writel(dma_addr, &ch->dmandptr);
}
static void korina_start_rx(struct korina_private *lp,
					struct dma_desc *rd)
{
	korina_start_dma(lp->rx_dma_regs, CPHYSADDR(rd));
}
static void korina_chain_rx(struct korina_private *lp,
					struct dma_desc *rd)
{
	korina_chain_dma(lp->rx_dma_regs, CPHYSADDR(rd));
}
static int __init korina_init_module(void)
{
	return platform_driver_register(&korina_driver);
}
static void korina_cleanup_module(void)
{
	return platform_driver_unregister(&korina_driver);
}
static inline void ca(struct net_device *dev)
{
	gsc_writel(0, dev->base_addr + PA_CHANNEL_ATTENTION);
}
static void __exit lasi_82596_exit(void)
{
	unregister_parisc_driver(&lan_driver);
}
static void print_eth(unsigned char *add, char *str)
{
	printk(KERN_DEBUG "i596 0x%p, %pM --> %pM %02X%02X, %s\n",
	       add, add + 6, add, add[12], add[13], str);
}
static struct net_device *____alloc_ei_netdev(int size)
{
	return alloc_netdev(sizeof(struct ei_device) + size, "eth%d",
				ethdev_setup);
}
static u32 always_on(struct net_device *dev)
{
	return 1;
}
static inline phys_addr
va_to_pa(void *x) {
	return x ? virt_to_bus(x) : I596_NULL;
}
static inline void *
pa_to_va(phys_addr x) {
	return (x == I596_NULL) ? NULL : bus_to_virt(x);
}
static inline void
CLEAR_INT(void) {
	outb(0, IOADDR+8);
}
static inline int
readreg(struct net_device *dev, int portno)
{
	return swab16(nubus_readw(dev->mem_start + portno));
}
static inline void
writereg(struct net_device *dev, int portno, int value)
{
	nubus_writew(swab16(value), dev->mem_start + portno);
}
static int macb_mdio_reset(struct mii_bus *bus)
{
	return 0;
}
static int __init macb_init(void)
{
	return platform_driver_probe(&macb_driver, macb_probe);
}
static void __exit macb_exit(void)
{
	platform_driver_unregister(&macb_driver);
}
static irqreturn_t mace_txdma_intr(int irq, void *dev_id)
{
	return IRQ_HANDLED;
}
static int __init mace_init(void)
{
	return macio_register_driver(&mace_driver);
}
static void macvlan_set_lockdep_class_one(struct net_device *dev,
					  struct netdev_queue *txq,
					  void *_unused)
{
	lockdep_set_class(&txq->_xmit_lock,
			  &macvlan_netdev_xmit_lock_key);
}
static void __exit meth_exit_module(void)
{
	platform_driver_unregister(&meth_driver);
}
static void __exit mipsnet_exit_module(void)
{
	platform_driver_unregister(&mipsnet_driver);
}
void mlx4_bitmap_free(struct mlx4_bitmap *bitmap, u32 obj)
{
	mlx4_bitmap_free_range(bitmap, obj, 1);
}
void mlx4_bitmap_cleanup(struct mlx4_bitmap *bitmap)
{
	kfree(bitmap->table);
}
void mlx4_catas_cleanup(void)
{
	destroy_workqueue(catas_wq);
}
int __mlx4_cmd(struct mlx4_dev *dev, u64 in_param, u64 *out_param,
	       int out_is_imm, u32 in_modifier, u8 op_modifier,
	       u16 op, unsigned long timeout)
{
	if (mlx4_priv(dev)->cmd.use_events)
		return mlx4_cmd_wait(dev, in_param, out_param, out_is_imm,
				     in_modifier, op_modifier, op, timeout);
	else
		return mlx4_cmd_poll(dev, in_param, out_param, out_is_imm,
				     in_modifier, op_modifier, op, timeout);
}
static int mlx4_SW2HW_CQ(struct mlx4_dev *dev, struct mlx4_cmd_mailbox *mailbox,
			 int cq_num)
{
	return mlx4_cmd(dev, mailbox->dma, cq_num, 0, MLX4_CMD_SW2HW_CQ,
			MLX4_CMD_TIME_CLASS_A);
}
static int mlx4_MODIFY_CQ(struct mlx4_dev *dev, struct mlx4_cmd_mailbox *mailbox,
			 int cq_num, u32 opmod)
{
	return mlx4_cmd(dev, mailbox->dma, cq_num, opmod, MLX4_CMD_MODIFY_CQ,
			MLX4_CMD_TIME_CLASS_A);
}
static int mlx4_HW2SW_CQ(struct mlx4_dev *dev, struct mlx4_cmd_mailbox *mailbox,
			 int cq_num)
{
	return mlx4_cmd_box(dev, 0, mailbox ? mailbox->dma : 0, cq_num,
			    mailbox ? 0 : 1, MLX4_CMD_HW2SW_CQ,
			    MLX4_CMD_TIME_CLASS_A);
}
void mlx4_cleanup_cq_table(struct mlx4_dev *dev)
{
	mlx4_bitmap_cleanup(&mlx4_priv(dev)->cq_table.bitmap);
}
static void mlx4_en_cq_event(struct mlx4_cq *cq, enum mlx4_event event)
{
	return;
}
int mlx4_en_set_cq_moder(struct mlx4_en_priv *priv, struct mlx4_en_cq *cq)
{
	return mlx4_cq_modify(priv->mdev->dev, &cq->mcq,
			      cq->moder_cnt, cq->moder_time);
}
static int __init mlx4_en_init(void)
{
	return mlx4_register_interface(&mlx4_en_interface);
}
static void __exit mlx4_en_cleanup(void)
{
	mlx4_unregister_interface(&mlx4_en_interface);
}
static u32 mlx4_en_get_tso(struct net_device *dev)
{
	return (dev->features & NETIF_F_TSO) != 0;
}
static u32 mlx4_en_get_msglevel(struct net_device *dev)
{
	return ((struct mlx4_en_priv *) netdev_priv(dev))->msg_enable;
}
static void mlx4_en_set_msglevel(struct net_device *dev, u32 val)
{
	((struct mlx4_en_priv *) netdev_priv(dev))->msg_enable = val;
}
int mlx4_SET_MCAST_FLTR(struct mlx4_dev *dev, u8 port,
			u64 mac, u64 clear, u8 mode)
{
	return mlx4_cmd(dev, (mac | (clear << 63)), port, mode,
			MLX4_CMD_SET_MCAST_FLTR, MLX4_CMD_TIME_CLASS_B);
}
static void mlx4_en_srq_event(struct mlx4_srq *srq, enum mlx4_event type)
{
	return;
}
static inline void mlx4_en_update_rx_prod_db(struct mlx4_en_rx_ring *ring)
{
	*ring->wqres.db.db = cpu_to_be32(ring->prod & 0xffff);
}
static void mlx4_en_sqp_event(struct mlx4_qp *qp, enum mlx4_event event)
{
    return;
}
static int inline_size(struct sk_buff *skb)
{
	if (skb->len + CTRL_SIZE + sizeof(struct mlx4_wqe_inline_seg)
	    <= MLX4_INLINE_ALIGN)
		return ALIGN(skb->len + CTRL_SIZE +
			     sizeof(struct mlx4_wqe_inline_seg), 16);
	else
		return ALIGN(skb->len + CTRL_SIZE + 2 *
			     sizeof(struct mlx4_wqe_inline_seg), 16);
}
static int mlx4_MAP_EQ(struct mlx4_dev *dev, u64 event_mask, int unmap,
			int eq_num)
{
	return mlx4_cmd(dev, event_mask, (unmap << 31) | eq_num,
			0, MLX4_CMD_MAP_EQ, MLX4_CMD_TIME_CLASS_B);
}
static int mlx4_SW2HW_EQ(struct mlx4_dev *dev, struct mlx4_cmd_mailbox *mailbox,
			 int eq_num)
{
	return mlx4_cmd(dev, mailbox->dma, eq_num, 0, MLX4_CMD_SW2HW_EQ,
			MLX4_CMD_TIME_CLASS_A);
}
static int mlx4_HW2SW_EQ(struct mlx4_dev *dev, struct mlx4_cmd_mailbox *mailbox,
			 int eq_num)
{
	return mlx4_cmd_box(dev, 0, mailbox->dma, eq_num, 0, MLX4_CMD_HW2SW_EQ,
			    MLX4_CMD_TIME_CLASS_A);
}
static int mlx4_num_eq_uar(struct mlx4_dev *dev)
{
	return (dev->caps.num_comp_vectors + 1 + dev->caps.reserved_eqs) / 4 -
		dev->caps.reserved_eqs / 4 + 1;
}
void mlx4_free_eq_table(struct mlx4_dev *dev)
{
	kfree(mlx4_priv(dev)->eq_table.eq);
}
int mlx4_MAP_FA(struct mlx4_dev *dev, struct mlx4_icm *icm)
{
	return mlx4_map_cmd(dev, MLX4_CMD_MAP_FA, icm, -1);
}
int mlx4_UNMAP_FA(struct mlx4_dev *dev)
{
	return mlx4_cmd(dev, 0, 0, 0, MLX4_CMD_UNMAP_FA, MLX4_CMD_TIME_CLASS_B);
}
int mlx4_RUN_FW(struct mlx4_dev *dev)
{
	return mlx4_cmd(dev, 0, 0, 0, MLX4_CMD_RUN_FW, MLX4_CMD_TIME_CLASS_A);
}
int mlx4_CLOSE_PORT(struct mlx4_dev *dev, int port)
{
	return mlx4_cmd(dev, 0, port, 0, MLX4_CMD_CLOSE_PORT, 1000);
}
int mlx4_CLOSE_HCA(struct mlx4_dev *dev, int panic)
{
	return mlx4_cmd(dev, 0, 0, panic, MLX4_CMD_CLOSE_HCA, 1000);
}
int mlx4_NOP(struct mlx4_dev *dev)
{
	return mlx4_cmd(dev, 0, 0x1f, 0, MLX4_CMD_NOP, 100);
}
static int mlx4_MAP_ICM(struct mlx4_dev *dev, struct mlx4_icm *icm, u64 virt)
{
	return mlx4_map_cmd(dev, MLX4_CMD_MAP_ICM, icm, virt);
}
int mlx4_UNMAP_ICM(struct mlx4_dev *dev, u64 virt, u32 page_count)
{
	return mlx4_cmd(dev, virt, page_count, 0, MLX4_CMD_UNMAP_ICM,
			MLX4_CMD_TIME_CLASS_B);
}
int mlx4_MAP_ICM_AUX(struct mlx4_dev *dev, struct mlx4_icm *icm)
{
	return mlx4_map_cmd(dev, MLX4_CMD_MAP_ICM_AUX, icm, -1);
}
int mlx4_UNMAP_ICM_AUX(struct mlx4_dev *dev)
{
	return mlx4_cmd(dev, 0, 0, 0, MLX4_CMD_UNMAP_ICM_AUX, MLX4_CMD_TIME_CLASS_B);
}
static int mlx4_READ_MCG(struct mlx4_dev *dev, int index,
			 struct mlx4_cmd_mailbox *mailbox)
{
	return mlx4_cmd_box(dev, 0, mailbox->dma, index, 0, MLX4_CMD_READ_MCG,
			    MLX4_CMD_TIME_CLASS_A);
}
static int mlx4_WRITE_MCG(struct mlx4_dev *dev, int index,
			  struct mlx4_cmd_mailbox *mailbox)
{
	return mlx4_cmd(dev, mailbox->dma, index, 0, MLX4_CMD_WRITE_MCG,
			MLX4_CMD_TIME_CLASS_A);
}
void mlx4_cleanup_mcg_table(struct mlx4_dev *dev)
{
	mlx4_bitmap_cleanup(&mlx4_priv(dev)->mcg_table.bitmap);
}
u64 mlx4_mtt_addr(struct mlx4_dev *dev, struct mlx4_mtt *mtt)
{
	return (u64) mtt->first_seg * dev->caps.mtt_entry_sz;
}
static u32 hw_index_to_key(u32 ind)
{
	return (ind >> 24) | (ind << 8);
}
static u32 key_to_hw_index(u32 key)
{
	return (key << 24) | (key >> 8);
}
static int mlx4_SW2HW_MPT(struct mlx4_dev *dev, struct mlx4_cmd_mailbox *mailbox,
			  int mpt_index)
{
	return mlx4_cmd(dev, mailbox->dma, mpt_index, 0, MLX4_CMD_SW2HW_MPT,
			MLX4_CMD_TIME_CLASS_B);
}
static int mlx4_HW2SW_MPT(struct mlx4_dev *dev, struct mlx4_cmd_mailbox *mailbox,
			  int mpt_index)
{
	return mlx4_cmd_box(dev, 0, mailbox ? mailbox->dma : 0, mpt_index,
			    !mailbox, MLX4_CMD_HW2SW_MPT, MLX4_CMD_TIME_CLASS_B);
}
int mlx4_SYNC_TPT(struct mlx4_dev *dev)
{
	return mlx4_cmd(dev, 0, 0, 0, MLX4_CMD_SYNC_TPT, 1000);
}
void mlx4_pd_free(struct mlx4_dev *dev, u32 pdn)
{
	mlx4_bitmap_free(&mlx4_priv(dev)->pd_bitmap, pdn);
}
void mlx4_cleanup_pd_table(struct mlx4_dev *dev)
{
	mlx4_bitmap_cleanup(&mlx4_priv(dev)->pd_bitmap);
}
void mlx4_uar_free(struct mlx4_dev *dev, struct mlx4_uar *uar)
{
	mlx4_bitmap_free(&mlx4_priv(dev)->uar_table.bitmap, uar->index);
}
void mlx4_cleanup_uar_table(struct mlx4_dev *dev)
{
	mlx4_bitmap_cleanup(&mlx4_priv(dev)->uar_table.bitmap);
}
static int mlx4_CONF_SPECIAL_QP(struct mlx4_dev *dev, u32 base_qpn)
{
	return mlx4_cmd(dev, 0, base_qpn, 0, MLX4_CMD_CONF_SPECIAL_QP,
			MLX4_CMD_TIME_CLASS_B);
}
static int mlx4_SW2HW_SRQ(struct mlx4_dev *dev, struct mlx4_cmd_mailbox *mailbox,
			  int srq_num)
{
	return mlx4_cmd(dev, mailbox->dma, srq_num, 0, MLX4_CMD_SW2HW_SRQ,
			MLX4_CMD_TIME_CLASS_A);
}
static int mlx4_HW2SW_SRQ(struct mlx4_dev *dev, struct mlx4_cmd_mailbox *mailbox,
			  int srq_num)
{
	return mlx4_cmd_box(dev, 0, mailbox ? mailbox->dma : 0, srq_num,
			    mailbox ? 0 : 1, MLX4_CMD_HW2SW_SRQ,
			    MLX4_CMD_TIME_CLASS_A);
}
static int mlx4_ARM_SRQ(struct mlx4_dev *dev, int srq_num, int limit_watermark)
{
	return mlx4_cmd(dev, limit_watermark, srq_num, 0, MLX4_CMD_ARM_SRQ,
			MLX4_CMD_TIME_CLASS_B);
}
static int mlx4_QUERY_SRQ(struct mlx4_dev *dev, struct mlx4_cmd_mailbox *mailbox,
			  int srq_num)
{
	return mlx4_cmd_box(dev, 0, mailbox->dma, srq_num, 0, MLX4_CMD_QUERY_SRQ,
			    MLX4_CMD_TIME_CLASS_A);
}
int mlx4_srq_arm(struct mlx4_dev *dev, struct mlx4_srq *srq, int limit_watermark)
{
	return mlx4_ARM_SRQ(dev, srq->srqn, limit_watermark);
}
void mlx4_cleanup_srq_table(struct mlx4_dev *dev)
{
	mlx4_bitmap_cleanup(&mlx4_priv(dev)->srq_table.bitmap);
}
static inline u32 rdl(struct mv643xx_eth_private *mp, int offset)
{
	return readl(mp->shared->base + offset);
}
static inline u32 rdlp(struct mv643xx_eth_private *mp, int offset)
{
	return readl(mp->base + offset);
}
static inline void wrl(struct mv643xx_eth_private *mp, int offset, u32 data)
{
	writel(data, mp->shared->base + offset);
}
static inline void wrlp(struct mv643xx_eth_private *mp, int offset, u32 data)
{
	writel(data, mp->base + offset);
}
static struct mv643xx_eth_private *rxq_to_mp(struct rx_queue *rxq)
{
	return container_of(rxq, struct mv643xx_eth_private, rxq[rxq->index]);
}
static struct mv643xx_eth_private *txq_to_mp(struct tx_queue *txq)
{
	return container_of(txq, struct mv643xx_eth_private, txq[txq->index]);
}
static inline __be16 sum16_as_be(__sum16 sum)
{
	return (__force __be16)sum;
}
static int smi_is_done(struct mv643xx_eth_shared_private *msp)
{
	return !(readl(msp->base + SMI_REG) & SMI_BUSY);
}
static inline u32 mib_read(struct mv643xx_eth_private *mp, int offset)
{
	return rdl(mp, MIB_COUNTERS(mp->port_num) + offset);
}
static int
mv643xx_eth_set_settings_phyless(struct net_device *dev,
				 struct ethtool_cmd *cmd)
{
	return -EINVAL;
}
static int mv643xx_eth_nway_reset_phyless(struct net_device *dev)
{
	return -EINVAL;
}
static u32 mv643xx_eth_get_link(struct net_device *dev)
{
	return !!netif_carrier_ok(dev);
}
static void m147lance_writerap(struct lance_private *lp, unsigned short value)
{
	out_be16(lp->base + LANCE_RAP, value);
}
static void m147lance_writerdp(struct lance_private *lp, unsigned short value)
{
	out_be16(lp->base + LANCE_RDP, value);
}
static unsigned short m147lance_readrdp(struct lance_private *lp)
{
	return in_be16(lp->base + LANCE_RDP);
}
static inline void put_be32(__be32 val, __be32 __iomem * p)
{
	__raw_writel((__force __u32) val, (__force void __iomem *)p);
}
static void dump_ehdr(struct ethhdr *ehdr)
{
	printk("ehdr[h_dst(%pM)"
	       "h_source(%pM)"
	       "h_proto(%04x)]\n",
	       ehdr->h_dest, ehdr->h_source, ehdr->h_proto);
}
void myri_header_cache_update(struct hh_cache *hh,
			      const struct net_device *dev,
			      const unsigned char * haddr)
{
	memcpy(((u8*)hh->hh_data) + HH_DATA_OFF(sizeof(struct ethhdr)),
	       haddr, dev->addr_len);
}
static int __init myri_sbus_init(void)
{
	return of_register_driver(&myri_sbus_driver, &of_bus_type);
}
static void __exit myri_sbus_exit(void)
{
	of_unregister_driver(&myri_sbus_driver);
}
static inline void __iomem *ns_ioaddr(struct net_device *dev)
{
	return (void __iomem *) dev->base_addr;
}
static int get_regs_len(struct net_device *dev)
{
	return NATSEMI_REGS_SIZE;
}
static void __exit natsemi_exit_mod (void)
{
	pci_unregister_driver (&natsemi_driver);
}
static void __exit ne2k_pci_cleanup(void)
{
	pci_unregister_driver (&ne2k_driver);
}
static int ne3210_init(void)
{
	return eisa_driver_register (&ne3210_eisa_driver);
}
static void ne3210_cleanup(void)
{
	eisa_driver_unregister (&ne3210_eisa_driver);
}
static void __exit dynamic_netconsole_exit(void)
{
	configfs_unregister_subsystem(&netconsole_subsys);
}
static int __init dynamic_netconsole_init(void)
{
	return 0;
}
static struct netconsole_target *to_target(struct config_item *item)
{
	return item ?
		container_of(item, struct netconsole_target, item) :
		NULL;
}
static ssize_t show_enabled(struct netconsole_target *nt, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%d\n", nt->enabled);
}
static ssize_t show_dev_name(struct netconsole_target *nt, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%s\n", nt->np.dev_name);
}
static ssize_t show_local_port(struct netconsole_target *nt, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%d\n", nt->np.local_port);
}
static ssize_t show_remote_port(struct netconsole_target *nt, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%d\n", nt->np.remote_port);
}
static ssize_t show_local_ip(struct netconsole_target *nt, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%d.%d.%d.%d\n",
			HIPQUAD(nt->np.local_ip));
}
static ssize_t show_remote_ip(struct netconsole_target *nt, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%d.%d.%d.%d\n",
			HIPQUAD(nt->np.remote_ip));
}
static ssize_t show_remote_mac(struct netconsole_target *nt, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%pM\n", nt->np.remote_mac);
}
static void netconsole_target_release(struct config_item *item)
{
	kfree(to_target(item));
}
static void __exit netx_eth_cleanup(void)
{
	platform_driver_unregister(&netx_eth_driver);
}
static int netxen_nic_get_eeprom_len(struct net_device *dev)
{
	return NETXEN_FLASH_TOTAL_SIZE;
}
static int netxen_nic_get_regs_len(struct net_device *dev)
{
	return NETXEN_NIC_REGS_LEN;
}
void netxen_nic_reg_write(struct netxen_adapter *adapter, u64 off, u32 val)
{
	adapter->hw_write_wx(adapter, off, &val, 4);
}
void netxen_nic_write_w0(struct netxen_adapter *adapter, u32 index, u32 value)
{
	adapter->hw_write_wx(adapter, index, &value, 4);
}
void netxen_nic_read_w0(struct netxen_adapter *adapter, u32 index, u32 *value)
{
	adapter->hw_read_wx(adapter, index, value, 4);
}
void netxen_nic_write_w1(struct netxen_adapter *adapter, u32 index, u32 value)
{
	adapter->hw_write_wx(adapter, index, &value, 4);
}
void netxen_nic_read_w1(struct netxen_adapter *adapter, u32 index, u32 *value)
{
	adapter->hw_read_wx(adapter, index, value, 4);
}
u32 netxen_nic_pci_read_immediate_128M(struct netxen_adapter *adapter, u64 off)
{
	return readl((void __iomem *)(pci_base_offset(adapter, off)));
}
void netxen_nic_pci_write_normalize_128M(struct netxen_adapter *adapter,
		u64 off, u32 data)
{
	writel(data, NETXEN_CRB_NORMALIZE(adapter, off));
}
u32 netxen_nic_pci_read_normalize_128M(struct netxen_adapter *adapter, u64 off)
{
	return readl(NETXEN_CRB_NORMALIZE(adapter, off));
}
void netxen_nic_pci_write_normalize_2M(struct netxen_adapter *adapter,
		u64 off, u32 data)
{
	adapter->hw_write_wx(adapter, off, &data, 4);
}
void
netxen_crb_writelit_adapter(struct netxen_adapter *adapter,
		unsigned long off, int data)
{
	adapter->hw_write_wx(adapter, off, &data, 4);
}
void
netxen_nic_update_cmd_producer(struct netxen_adapter *adapter,
		uint32_t crb_producer)
{
	adapter->pci_write_normalize(adapter,
			adapter->crb_addr_cmd_producer, crb_producer);
}
static inline void
netxen_nic_update_cmd_consumer(struct netxen_adapter *adapter,
		u32 crb_consumer)
{
	adapter->pci_write_normalize(adapter,
			adapter->crb_addr_cmd_consumer, crb_consumer);
}
static inline void netxen_nic_disable_int(struct netxen_adapter *adapter)
{
	adapter->pci_write_normalize(adapter, adapter->crb_intr_mask, 0);
}
static void chipset_init(struct net_device *dev, int startp)
{
	PRINTK3((KERN_DEBUG "%s: doing NOTHING in chipset_init\n", dev->name));
}
static struct net_device_stats *ni65_get_stats(struct net_device *dev)
{
	return &((struct priv *)dev->ml_priv)->stats;
}
static u64 readq(void __iomem *reg)
{
	return ((u64) readl(reg)) | (((u64) readl(reg + 4UL)) << 32);
}
static u32 phy_encode(u32 type, int port)
{
	return (type << (port * 2));
}
static u32 phy_decode(u32 val, int port)
{
	return (val >> (port * 2)) & PORT_TYPE_MASK;
}
static int niu_num_alt_addr(struct niu *np)
{
	if (np->flags & NIU_FLAGS_XMAC)
		return XMAC_NUM_ALT_ADDR;
	else
		return BMAC_NUM_ALT_ADDR;
}
static int niu_set_primary_mac_rdc_table(struct niu *np, int table_num,
					 int mac_pref)
{
	return __set_rdc_table_num(np, 17, 0, table_num, mac_pref);
}
static int niu_set_multicast_mac_rdc_table(struct niu *np, int table_num,
					   int mac_pref)
{
	return __set_rdc_table_num(np, 16, 8, table_num, mac_pref);
}
static u64 hash_addr_regval(unsigned long index, unsigned long num_entries)
{
	return ((u64)index | (num_entries == 1 ?
			      HASH_TBL_ADDR_AUTOINC : 0));
}
static int niu_rx_channel_reset(struct niu *np, int channel)
{
	return niu_set_and_wait_clear(np, RXDMA_CFIG1(channel),
				      RXDMA_CFIG1_RST, 1000, 10,
				      "RXDMA_CFIG1");
}
static int niu_ipp_reset(struct niu *np)
{
	return niu_set_and_wait_clear_ipp(np, IPP_CFIG, IPP_CFIG_SOFT_RST,
					  1000, 100, "IPP_CFIG");
}
static int niu_reset_tx_xmac(struct niu *np)
{
	return niu_set_and_wait_clear_mac(np, XTXMAC_SW_RST,
					  (XTXMAC_SW_RST_REG_RS |
					   XTXMAC_SW_RST_SOFT_RST),
					  1000, 100, "XTXMAC_SW_RST");
}
static int niu_reset_tx_mac(struct niu *np)
{
	if (np->flags & NIU_FLAGS_XMAC)
		return niu_reset_tx_xmac(np);
	else
		return niu_reset_tx_bmac(np);
}
static int niu_reset_rx_mac(struct niu *np)
{
	if (np->flags & NIU_FLAGS_XMAC)
		return niu_reset_rx_xmac(np);
	else
		return niu_reset_rx_bmac(np);
}
static void niu_stop_one_tx_channel(struct niu *np, struct tx_ring_info *rp)
{
	(void) niu_tx_channel_stop(np, rp->tx_channel);
}
static void niu_reset_one_tx_channel(struct niu *np, struct tx_ring_info *rp)
{
	(void) niu_tx_channel_reset(np, rp->tx_channel);
}
static void niu_stop_one_rx_channel(struct niu *np, struct rx_ring_info *rp)
{
	(void) niu_enable_rx_channel(np, rp->rx_channel, 0);
}
static int niu_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
{
	return -EOPNOTSUPP;
}
static int niu_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
{
	return -EINVAL;
}
static u64 niu_led_state_save(struct niu *np)
{
	if (np->flags & NIU_FLAGS_XMAC)
		return nr64_mac(XMAC_CONFIG);
	else
		return nr64_mac(BMAC_XIF_CONFIG);
}
static ssize_t show_rxchan_per_port(struct device *dev,
				    struct device_attribute *attr, char *buf)
{
	return __show_chan_per_port(dev, attr, buf, 1);
}
static ssize_t show_txchan_per_port(struct device *dev,
				    struct device_attribute *attr, char *buf)
{
	return __show_chan_per_port(dev, attr, buf, 1);
}
static void niu_pci_free_coherent(struct device *dev, size_t size,
				  void *cpu_addr, u64 handle)
{
	dma_free_coherent(dev, size, cpu_addr, handle);
}
static u64 niu_pci_map_page(struct device *dev, struct page *page,
			    unsigned long offset, size_t size,
			    enum dma_data_direction direction)
{
	return dma_map_page(dev, page, offset, size, direction);
}
static void niu_pci_unmap_page(struct device *dev, u64 dma_address,
			       size_t size, enum dma_data_direction direction)
{
	dma_unmap_page(dev, dma_address, size, direction);
}
static u64 niu_pci_map_single(struct device *dev, void *cpu_addr,
			      size_t size,
			      enum dma_data_direction direction)
{
	return dma_map_single(dev, cpu_addr, size, direction);
}
static void niu_pci_unmap_single(struct device *dev, u64 dma_address,
				 size_t size,
				 enum dma_data_direction direction)
{
	dma_unmap_single(dev, dma_address, size, direction);
}
static u64 niu_phys_map_page(struct device *dev, struct page *page,
			     unsigned long offset, size_t size,
			     enum dma_data_direction direction)
{
	return page_to_phys(page) + offset;
}
static u64 niu_phys_map_single(struct device *dev, void *cpu_addr,
			       size_t size,
			       enum dma_data_direction direction)
{
	return __pa(cpu_addr);
}
static unsigned long res_size(struct resource *r)
{
	return r->end - r->start + 1UL;
}
static inline struct ns83820 *PRIV(struct net_device *dev)
{
	return netdev_priv(dev);
}
static void rx_refill_atomic(struct net_device *ndev)
{
	rx_refill(ndev, GFP_ATOMIC);
}
static inline void clear_rx_desc(struct ns83820 *dev, unsigned i)
{
	build_rx_desc(dev, dev->rx_info.descs + (DESC_SIZE * i), 0, 0, CMDSTS_OWN, 0);
}
static void __exit ns83820_exit(void)
{
	pci_unregister_driver(&driver);
}
static int translation_enabled(void)
{
	return 1;
}
static void write_iob_reg(unsigned int reg, unsigned int val)
{
	pasemi_write_iob_reg(reg, val);
}
static unsigned int read_mac_reg(const struct pasemi_mac *mac, unsigned int reg)
{
	return pasemi_read_mac_reg(mac->dma_if, reg);
}
static void write_mac_reg(const struct pasemi_mac *mac, unsigned int reg,
			  unsigned int val)
{
	pasemi_write_mac_reg(mac->dma_if, reg, val);
}
static unsigned int read_dma_reg(unsigned int reg)
{
	return pasemi_read_dma_reg(reg);
}
static void write_dma_reg(unsigned int reg, unsigned int val)
{
	pasemi_write_dma_reg(reg, val);
}
static struct pasemi_mac_rxring *rx_ring(const struct pasemi_mac *mac)
{
	return mac->rx;
}
static struct pasemi_mac_txring *tx_ring(const struct pasemi_mac *mac)
{
	return mac->tx;
}
static void __exit pasemi_mac_cleanup_module(void)
{
	pci_unregister_driver(&pasemi_mac_driver);
}
static void pasemi_mac_get_strings(struct net_device *netdev, u32 stringset,
				   u8 *data)
{
	memcpy(data, ethtool_stats_keys, sizeof(ethtool_stats_keys));
}
static void __exit netdrv_cleanup_module (void)
{
	pci_unregister_driver (&netdrv_pci_driver);
}
static void tc574_release(struct pcmcia_device *link)
{
	pcmcia_disable_device(link);
}
static void netdev_get_drvinfo(struct net_device *dev,
			       struct ethtool_drvinfo *info)
{
	strcpy(info->driver, "3c574_cs");
}
static int __init init_tc574(void)
{
	return pcmcia_register_driver(&tc574_driver);
}
static void __exit exit_tc574(void)
{
	pcmcia_unregister_driver(&tc574_driver);
}
static void tc589_release(struct pcmcia_device *link)
{
	pcmcia_disable_device(link);
}
static u32 netdev_get_msglevel(struct net_device *dev)
{
	return pc_debug;
}
static void netdev_set_msglevel(struct net_device *dev, u32 level)
{
	pc_debug = level;
}
static int __init init_tc589(void)
{
	return pcmcia_register_driver(&tc589_driver);
}
static void __exit exit_tc589(void)
{
	pcmcia_unregister_driver(&tc589_driver);
}
static void axnet_release(struct pcmcia_device *link)
{
	pcmcia_disable_device(link);
}
static void netdev_get_drvinfo(struct net_device *dev,
			       struct ethtool_drvinfo *info)
{
	strcpy(info->driver, "axnet_cs");
}
static int __init init_axnet_cs(void)
{
	return pcmcia_register_driver(&axnet_cs_driver);
}
static void __exit exit_axnet_cs(void)
{
	pcmcia_unregister_driver(&axnet_cs_driver);
}
static int __init init_com20020_cs(void)
{
	return pcmcia_register_driver(&com20020_cs_driver);
}
static void __exit exit_com20020_cs(void)
{
	pcmcia_unregister_driver(&com20020_cs_driver);
}
static int __init init_fmvj18x_cs(void)
{
	return pcmcia_register_driver(&fmvj18x_cs_driver);
}
static void __exit exit_fmvj18x_cs(void)
{
	pcmcia_unregister_driver(&fmvj18x_cs_driver);
}
static u32 netdev_get_msglevel(struct net_device *dev)
{
	return pc_debug;
}
static void netdev_set_msglevel(struct net_device *dev, u32 level)
{
	pc_debug = level;
}
static int fjn_config(struct net_device *dev, struct ifmap *map){
    return 0;
}
static void netdev_get_drvinfo(struct net_device *dev,
			       struct ethtool_drvinfo *info)
{
	strcpy(info->driver, "ibmtr_cs");
}
static int __init init_ibmtr_cs(void)
{
	return pcmcia_register_driver(&ibmtr_cs_driver);
}
static void __exit exit_ibmtr_cs(void)
{
	pcmcia_unregister_driver(&ibmtr_cs_driver);
}
static u32 netdev_get_msglevel(struct net_device *dev)
{
	return pc_debug;
}
static void netdev_set_msglevel(struct net_device *dev, u32 level)
{
	pc_debug = level;
}
static int __init init_nmclan_cs(void)
{
	return pcmcia_register_driver(&nmclan_cs_driver);
}
static void __exit exit_nmclan_cs(void)
{
	pcmcia_unregister_driver(&nmclan_cs_driver);
}
static void netdev_get_drvinfo(struct net_device *dev,
			       struct ethtool_drvinfo *info)
{
	strcpy(info->driver, "pcnet_cs");
}
static int __init init_pcnet_cs(void)
{
    return pcmcia_register_driver(&pcnet_driver);
}
static u32 smc_get_msglevel(struct net_device *dev)
{
	return pc_debug;
}
static void smc_set_msglevel(struct net_device *dev, u32 val)
{
	pc_debug = val;
}
static int __init init_smc91c92_cs(void)
{
	return pcmcia_register_driver(&smc91c92_cs_driver);
}
static void __exit exit_smc91c92_cs(void)
{
	pcmcia_unregister_driver(&smc91c92_cs_driver);
}
static int __init
init_xirc2ps_cs(void)
{
	return pcmcia_register_driver(&xirc2ps_cs_driver);
}
static void __exit
exit_xirc2ps_cs(void)
{
	pcmcia_unregister_driver(&xirc2ps_cs_driver);
}
static u16 pcnet32_wio_read_rap(unsigned long addr)
{
	return inw(addr + PCNET32_WIO_RAP);
}
static void pcnet32_wio_write_rap(unsigned long addr, u16 val)
{
	outw(val, addr + PCNET32_WIO_RAP);
}
static void pcnet32_wio_reset(unsigned long addr)
{
	inw(addr + PCNET32_WIO_RESET);
}
static u16 pcnet32_dwio_read_rap(unsigned long addr)
{
	return (inl(addr + PCNET32_DWIO_RAP) & 0xffff);
}
static void pcnet32_dwio_write_rap(unsigned long addr, u16 val)
{
	outl(val, addr + PCNET32_DWIO_RAP);
}
static void pcnet32_dwio_reset(unsigned long addr)
{
	inl(addr + PCNET32_DWIO_RESET);
}
static void pcnet32_get_strings(struct net_device *dev, u32 stringset,
				u8 * data)
{
	memcpy(data, pcnet32_gstrings_test, sizeof(pcnet32_gstrings_test));
}
static int bcm54xx_shadow_write(struct phy_device *phydev, u16 shadow, u16 val)
{
	return phy_write(phydev, MII_BCM54XX_SHD,
			 MII_BCM54XX_SHD_WRITE |
			 MII_BCM54XX_SHD_VAL(shadow) |
			 MII_BCM54XX_SHD_DATA(val));
}
static int bcm54xx_auxctl_write(struct phy_device *phydev, u16 regnum, u16 val)
{
	return phy_write(phydev, MII_BCM54XX_AUX_CTL, regnum | val);
}
static int __init et1011c_init(void)
{
	return phy_driver_register(&et1011c_driver);
}
static void __exit et1011c_exit(void)
{
	phy_driver_unregister(&et1011c_driver);
}
static int fixed_mdio_write(struct mii_bus *bus, int phy_id, int reg_num,
			    u16 val)
{
	return 0;
}
static int __init ip175c_init(void)
{
	return phy_driver_register(&ip175c_driver);
}
static void __exit ip175c_exit(void)
{
	phy_driver_unregister(&ip175c_driver);
}
static inline int __init mdio_ofgpio_init(void)
{
	return of_register_platform_driver(&mdio_ofgpio_driver);
}
static inline void __exit mdio_ofgpio_exit(void)
{
	of_unregister_platform_driver(&mdio_ofgpio_driver);
}
static inline int __init mdio_ofgpio_init(void) { return 0; }
static int __init ns_init(void)
{
	return phy_driver_register(&dp83865_driver);
}
static void __exit ns_exit(void)
{
	phy_driver_unregister(&dp83865_driver);
}
void phy_device_free(struct phy_device *phydev)
{
	kfree(phydev);
}
static void phy_device_release(struct device *dev)
{
	phy_device_free(to_phy_device(dev));
}
int phy_register_fixup_for_uid(u32 phy_uid, u32 phy_uid_mask,
		int (*run)(struct phy_device *))
{
	return phy_register_fixup(PHY_ANY_ID, phy_uid, phy_uid_mask, run);
}
int phy_register_fixup_for_id(const char *bus_id,
		int (*run)(struct phy_device *))
{
	return phy_register_fixup(bus_id, PHY_ANY_UID, 0xffffffff, run);
}
void phy_prepare_link(struct phy_device *phydev,
		void (*handler)(struct net_device *))
{
	phydev->adjust_link = handler;
}
void phy_driver_unregister(struct phy_driver *drv)
{
	driver_unregister(&drv->driver);
}
static int qs6612_config_init(struct phy_device *phydev)
{
	return phy_write(phydev, MII_QS6612_PCR, 0x0dc0);
}
static int __init qs6612_init(void)
{
	return phy_driver_register(&qs6612_driver);
}
static void __exit qs6612_exit(void)
{
	phy_driver_unregister(&qs6612_driver);
}
static void __exit realtek_exit(void)
{
	phy_driver_unregister(&rtl821x_driver);
}
static int smsc_phy_config_init(struct phy_device *phydev)
{
	return smsc_phy_ack_interrupt (phydev);
}
static int
plip_none(struct net_device *dev, struct net_local *nl,
	  struct plip_local *snd, struct plip_local *rcv)
{
	return OK;
}
static ssize_t
ppp_asynctty_read(struct tty_struct *tty, struct file *file,
		  unsigned char __user *buf, size_t count)
{
	return -EAGAIN;
}
static ssize_t
ppp_asynctty_write(struct tty_struct *tty, struct file *file,
		   const unsigned char *buf, size_t count)
{
	return -EAGAIN;
}
static unsigned int
ppp_asynctty_poll(struct tty_struct *tty, struct file *file, poll_table *wait)
{
	return 0;
}
int ppp_register_channel(struct ppp_channel *chan)
{
	return ppp_register_net_channel(current->nsproxy->net_ns, chan);
}
static struct ppp *
ppp_find_unit(struct ppp_net *pn, int unit)
{
	return unit_find(&pn->units_idr, unit);
}
static void unit_put(struct idr *p, int n)
{
	idr_remove(p, n);
}
static void *unit_find(struct idr *p, int n)
{
	return idr_find(p, n);
}
static int
mppe_comp_init(void *arg, unsigned char *options, int optlen, int unit,
	       int hdrlen, int debug)
{
	return mppe_init(arg, options, optlen, unit, debug, "mppe_comp_init");
}
static int
mppe_decomp_init(void *arg, unsigned char *options, int optlen, int unit,
		 int hdrlen, int mru, int debug)
{
	return mppe_init(arg, options, optlen, unit, debug, "mppe_decomp_init");
}
static void mppe_decomp_reset(void *arg)
{
	return;
}
static ssize_t
ppp_sync_read(struct tty_struct *tty, struct file *file,
	       unsigned char __user *buf, size_t count)
{
	return -EAGAIN;
}
static ssize_t
ppp_sync_write(struct tty_struct *tty, struct file *file,
		const unsigned char *buf, size_t count)
{
	return -EAGAIN;
}
static unsigned int
ppp_sync_poll(struct tty_struct *tty, struct file *file, poll_table *wait)
{
	return 0;
}
static inline bool stage_session(__be16 sid)
{
	return sid != 0;
}
static inline int cmp_2_addr(struct pppoe_addr *a, struct pppoe_addr *b)
{
	return a->sid == b->sid && !memcmp(a->remote, b->remote, ETH_ALEN);
}
static inline int cmp_addr(struct pppoe_addr *a, __be16 sid, char *addr)
{
	return a->sid == sid && !memcmp(a->remote, addr, ETH_ALEN);
}
static int pppoe_seq_open(struct inode *inode, struct file *file)
{
	return seq_open_net(inode, file, &pppoe_seq_ops,
			sizeof(struct seq_net_private));
}
static inline void pppol2tp_tunnel_inc_refcount(struct pppol2tp_tunnel *tunnel)
{
	atomic_inc(&tunnel->ref_count);
}
static void pppol2tp_sock_wfree(struct sk_buff *skb)
{
	sock_put(skb->sk);
}
static int pppol2tp_proc_open(struct inode *inode, struct file *file)
{
	return seq_open_net(inode, file, &pppol2tp_seq_ops,
			    sizeof(struct pppol2tp_seq_data));
}
static int __init pppox_init(void)
{
	return sock_register(&pppox_proto_family);
}
static void __exit pppox_exit(void)
{
	sock_unregister(PF_PPPOX);
}
static enum gelic_descr_dma_status
gelic_descr_get_status(struct gelic_descr *descr)
{
	return be32_to_cpu(descr->dmac_cmd_status) & GELIC_DESCR_DMA_STAT_MASK;
}
static int __init ps3_gelic_driver_init (void)
{
	return firmware_has_feature(FW_FEATURE_PS3_LV1)
		? ps3_system_bus_driver_register(&ps3_gelic_driver)
		: -ENODEV;
}
static void __exit ps3_gelic_driver_exit (void)
{
	ps3_system_bus_driver_unregister(&ps3_gelic_driver);
}
static inline int wpa2_capable(void)
{
	return (0 <= ps3_compare_firmware_version(2, 0, 0));
}
static inline int precise_ie(void)
{
	return (0 <= ps3_compare_firmware_version(2, 2, 0));
}
static inline const char *cmdstr(enum gelic_eurus_command ix)
{
	return "";
}
static const char *eventstr(enum gelic_lv1_wl_event event)
{
	return NULL;
}
static u32 ql_read_common_reg(struct ql3_adapter *qdev,
			      u32 __iomem * reg)
{
	return readl(reg);
}
static void ql_petbi_reset(struct ql3_adapter *qdev)
{
	ql_mii_write_reg(qdev, PETBI_CONTROL_REG, PETBI_CTRL_SOFT_RESET);
}
static void ql_petbi_reset_ex(struct ql3_adapter *qdev)
{
	ql_mii_write_reg_ex(qdev, PETBI_CONTROL_REG, PETBI_CTRL_SOFT_RESET,
			    PHYAddr[qdev->mac_index]);
}
static int ql_is_neg_pause(struct ql3_adapter *qdev)
{
	if (ql_is_fiber(qdev))
		return ql_is_petbi_neg_pause(qdev);
	else
		return ql_is_phy_neg_pause(qdev);
}
static u32 ql_get_link_speed(struct ql3_adapter *qdev)
{
	if (ql_is_fiber(qdev))
		return SPEED_1000;
	else
		return ql_phy_get_speed(qdev);
}
static int ql_is_link_full_dup(struct ql3_adapter *qdev)
{
	if (ql_is_fiber(qdev))
		return 1;
	else
		return ql_is_full_dup(qdev);
}
static void ql_phy_reset_ex(struct ql3_adapter *qdev)
{
	ql_mii_write_reg_ex(qdev, CONTROL_REG, PHY_CTRL_SOFT_RESET,
			    PHYAddr[qdev->mac_index]);
}
static int __init ql3xxx_init_module(void)
{
	return pci_register_driver(&ql3xxx_driver);
}
static void __exit ql3xxx_exit(void)
{
	pci_unregister_driver(&ql3xxx_driver);
}
static void ql_enable_interrupts(struct ql_adapter *qdev)
{
	ql_write32(qdev, INTR_EN, (INTR_EN_EI << 16) | INTR_EN_EI);
}
static void ql_disable_interrupts(struct ql_adapter *qdev)
{
	ql_write32(qdev, INTR_EN, (INTR_EN_EI << 16));
}
static void ql_write_cq_idx(struct rx_ring *rx_ring)
{
	ql_write_db_reg(rx_ring->cnsmr_idx, rx_ring->cnsmr_idx_db_reg);
}
static void qlge_shutdown(struct pci_dev *pdev)
{
	qlge_suspend(pdev, PMSG_SUSPEND);
}
static int __init qlge_init_module(void)
{
	return pci_register_driver(&qlge_driver);
}
static void __exit qlge_exit(void)
{
	pci_unregister_driver(&qlge_driver);
}
static int __init r6040_init(void)
{
	return pci_register_driver(&r6040_driver);
}
static void __exit r6040_cleanup(void)
{
	pci_unregister_driver(&r6040_driver);
}
static void mdio_patch(void __iomem *ioaddr, int reg_addr, int value)
{
	mdio_write(ioaddr, reg_addr, mdio_read(ioaddr, reg_addr) | value);
}
static unsigned int rtl8169_tbi_reset_pending(void __iomem *ioaddr)
{
	return RTL_R32(TBICSR) & TBIReset;
}
static unsigned int rtl8169_xmii_reset_pending(void __iomem *ioaddr)
{
	return mdio_read(ioaddr, MII_BMCR) & BMCR_RESET;
}
static unsigned int rtl8169_tbi_link_ok(void __iomem *ioaddr)
{
	return RTL_R32(TBICSR) & TBILinkOk;
}
static unsigned int rtl8169_xmii_link_ok(void __iomem *ioaddr)
{
	return RTL_R8(PHYstatus) & LinkStatus;
}
static void rtl8169_tbi_reset_enable(void __iomem *ioaddr)
{
	RTL_W32(TBICSR, RTL_R32(TBICSR) | TBIReset);
}
static int rtl8169_get_regs_len(struct net_device *dev)
{
	return R8169_REGS_SIZE;
}
static inline u32 rtl8169_tx_vlan_tag(struct rtl8169_private *tp,
				      struct sk_buff *skb)
{
	return (tp->vlgrp && vlan_tx_tag_present(skb)) ?
		TxVlanTag | swab16(vlan_tx_tag_get(skb)) : 0x00;
}
static inline u32 rtl8169_tx_vlan_tag(struct rtl8169_private *tp,
				      struct sk_buff *skb)
{
	return 0;
}
static int rtl8169_rx_vlan_skb(struct rtl8169_private *tp, struct RxDesc *desc,
			       struct sk_buff *skb)
{
	return -1;
}
static void rtl8169_print_mac_version(struct rtl8169_private *tp)
{
	dprintk("mac_version = 0x%02x\n", tp->mac_version);
}
static void rtl8168c_4_hw_phy_config(void __iomem *ioaddr)
{
	rtl8168c_3_hw_phy_config(ioaddr);
}
static int rtl_tbi_ioctl(struct rtl8169_private *tp, struct mii_ioctl_data *data, int cmd)
{
	return -EOPNOTSUPP;
}
static void rtl_set_rx_max_size(void __iomem *ioaddr)
{
	RTL_W16(RxMaxSize, 16383);
}
static void rtl_hw_start_8168c_3(void __iomem *ioaddr, struct pci_dev *pdev)
{
	rtl_hw_start_8168c_2(ioaddr, pdev);
}
static inline void rtl8169_mark_as_last_descriptor(struct RxDesc *desc)
{
	desc->opts1 |= cpu_to_le32(RingEnd);
}
static void rtl8169_init_ring_indexes(struct rtl8169_private *tp)
{
	tp->dirty_tx = tp->dirty_rx = tp->cur_tx = tp->cur_rx = 0;
}
static inline int rtl8169_fragmented_frame(u32 status)
{
	return (status & (FirstFrag | LastFrag)) != (FirstFrag | LastFrag);
}
static void rtl_shutdown(struct pci_dev *pdev)
{
	rtl8169_suspend(pdev, PMSG_SUSPEND);
}
static int __init rtl8169_init_module(void)
{
	return pci_register_driver(&rtl8169_pci_driver);
}
static void __exit rtl8169_cleanup_module(void)
{
	pci_unregister_driver(&rtl8169_pci_driver);
}
static int __init rionet_init(void)
{
	return rio_register_driver(&rionet_driver);
}
static void __exit rionet_exit(void)
{
	rio_unregister_driver(&rionet_driver);
}
static int __init rr_init_module(void)
{
	return pci_register_driver(&rr_driver);
}
static void __exit rr_cleanup_module(void)
{
	pci_unregister_driver(&rr_driver);
}
static inline int is_s2io_card_up(const struct s2io_nic * sp)
{
	return test_bit(__S2IO_STATE_CARD_UP, &sp->state);
}
static int s2io_link_fault_indication(struct s2io_nic *nic)
{
	if (nic->device_type == XFRAME_II_DEVICE)
		return LINK_UP_DOWN_INTERRUPT;
	else
		return MAC_RMAC_ERR_TIMER;
}
static int s2io_ethtool_get_regs_len(struct net_device *dev)
{
	return (XENA_REG_SPACE);
}
static int s2io_get_eeprom_len(struct net_device *dev)
{
	return (XENA_EEPROM_SPACE);
}
static u32 s2io_ethtool_op_get_tso(struct net_device *dev)
{
	return (dev->features & NETIF_F_TSO) != 0;
}
static int s2io_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
{
	return -EOPNOTSUPP;
}
static void s2io_card_down(struct s2io_nic * sp)
{
	do_s2io_card_down(sp, 1);
}
static int __init s2io_starter(void)
{
	return pci_register_driver(&s2io_driver);
}
static inline int get_l4_pyld_length(struct iphdr *ip, struct tcphdr *tcp)
{
	return(ntohs(ip->tot_len) - (ip->ihl << 2) - (tcp->doff << 2));
}
static int __init
sb1000_init(void)
{
	return pnp_register_driver(&sb1000_driver);
}
static void __exit
sb1000_exit(void)
{
	pnp_unregister_driver(&sb1000_driver);
}
static inline void _sc92031_dummy_read(void __iomem *port_base)
{
	ioread32(port_base + MAC0);
}
static void _sc92031_mii_scan(void __iomem *port_base)
{
	_sc92031_mii_cmd(port_base, Mii_SCAN, 0x1 << 6);
}
static u16 _sc92031_mii_read(void __iomem *port_base, unsigned reg)
{
	return _sc92031_mii_cmd(port_base, Mii_READ, reg << 6) >> 13;
}
static void _sc92031_mii_write(void __iomem *port_base, unsigned reg, u16 val)
{
	_sc92031_mii_cmd(port_base, Mii_WRITE, (reg << 6) | ((u32)val << 11));
}
static int __init sc92031_init(void)
{
	return pci_register_driver(&sc92031_pci_driver);
}
static void __exit sc92031_exit(void)
{
	pci_unregister_driver(&sc92031_pci_driver);
}
static void efx_fini_lm87(struct efx_nic *efx)
{
	i2c_unregister_device(efx->board_info.hwmon_client);
}
static inline int
efx_init_lm87(struct efx_nic *efx, struct i2c_board_info *info,
	      const u8 *reg_values)
{
	return 0;
}
static inline int efx_check_lm87(struct efx_nic *efx, unsigned mask)
{
	return 0;
}
static void sfe4002_fault_led(struct efx_nic *efx, bool state)
{
	xfp_set_led(efx, SFE4002_FAULT_LED, state ? QUAKE_LED_ON :
			QUAKE_LED_OFF);
}
void efx_schedule_slow_fill(struct efx_rx_queue *rx_queue, int delay)
{
	queue_delayed_work(refill_workqueue, &rx_queue->work, delay);
}
int efx_port_dummy_op_int(struct efx_nic *efx)
{
	return 0;
}
static u64 efx_get_uint_stat(void *field)
{
	return *(unsigned int *)field;
}
static u64 efx_get_ulong_stat(void *field)
{
	return *(unsigned long *)field;
}
static u64 efx_get_u64_stat(void *field)
{
	return *(u64 *) field;
}
static u64 efx_get_atomic_stat(void *field)
{
	return atomic_read((atomic_t *) field);
}
static inline efx_qword_t *falcon_event(struct efx_channel *channel,
					unsigned int index)
{
	return (((efx_qword_t *) (channel->eventq.addr)) + index);
}
static inline int falcon_event_present(efx_qword_t *event)
{
	return (!(EFX_DWORD_IS_ALL_ONES(event->dword[0]) |
		  EFX_DWORD_IS_ALL_ONES(event->dword[1])));
}
static inline efx_qword_t *falcon_tx_desc(struct efx_tx_queue *tx_queue,
					       unsigned int index)
{
	return (((efx_qword_t *) (tx_queue->txd.addr)) + index);
}
void falcon_remove_tx(struct efx_tx_queue *tx_queue)
{
	falcon_free_special_buffer(tx_queue->efx, &tx_queue->txd);
}
static inline efx_qword_t *falcon_rx_desc(struct efx_rx_queue *rx_queue,
					       unsigned int index)
{
	return (((efx_qword_t *) (rx_queue->rxd.addr)) + index);
}
void falcon_remove_rx(struct efx_rx_queue *rx_queue)
{
	falcon_free_special_buffer(rx_queue->efx, &rx_queue->rxd);
}
void falcon_remove_eventq(struct efx_channel *channel)
{
	falcon_free_special_buffer(channel->efx, &channel->eventq);
}
void falcon_disable_interrupts(struct efx_nic *efx)
{
	falcon_interrupts(efx, 0, 0);
}
void falcon_generate_interrupt(struct efx_nic *efx)
{
	falcon_interrupts(efx, 1, 1);
}
static size_t
falcon_spi_write_limit(const struct efx_spi_device *spi, size_t start)
{
	return min(FALCON_SPI_MAX_LEN,
		   (spi->block_size - (start & (spi->block_size - 1))));
}
static inline u8
efx_spi_munge_command(const struct efx_spi_device *spi,
		      const u8 command, const unsigned int address)
{
	return command | (((address >> 8) & spi->munge_address) << 3);
}
void falcon_remove_port(struct efx_nic *efx)
{
	falcon_free_buffer(efx, &efx->stats_buffer);
}
static bool efx_masked_compare_oword(const efx_oword_t *a, const efx_oword_t *b,
				     const efx_oword_t *mask)
{
	return ((a->u64[0] ^ b->u64[0]) & mask->u64[0]) ||
		((a->u64[1] ^ b->u64[1]) & mask->u64[1]);
}
static void falcon_xmac_irq(struct efx_nic *efx)
{
	efx->mac_up = false;
}
void mdio_clause45_transmit_disable(struct efx_nic *efx)
{
	mdio_clause45_set_flag(efx, efx->mii.phy_id, MDIO_MMD_PMAPMD,
			       MDIO_MMDREG_TXDIS, MDIO_MMDREG_TXDIS_GLOBAL_LBN,
			       efx->phy_mode & PHY_MODE_TX_DISABLED);
}
void mdio_clause45_get_settings(struct efx_nic *efx,
				struct ethtool_cmd *ecmd)
{
	mdio_clause45_get_settings_ext(efx, ecmd, 0, 0);
}
static inline unsigned int efx_rx_buf_offset(struct efx_rx_buffer *buf)
{
	return (__force unsigned long) buf->data & (PAGE_SIZE - 1);
}
static inline unsigned int efx_rx_buf_size(struct efx_nic *efx)
{
	return PAGE_SIZE << efx->rx_buffer_order;
}
static bool sfx7101_link_ok(struct efx_nic *efx)
{
	return mdio_clause45_links_ok(efx,
				      MDIO_MMDREG_DEVS_PMAPMD |
				      MDIO_MMDREG_DEVS_PCS |
				      MDIO_MMDREG_DEVS_PHYXS);
}
static void sfx7101_set_npage_adv(struct efx_nic *efx, u32 advertising)
{
	mdio_clause45_set_flag(efx, efx->mii.phy_id, MDIO_MMD_AN,
			       MDIO_AN_10GBT_CTRL,
			       MDIO_AN_10GBT_CTRL_ADV_10G_LBN,
			       advertising & ADVERTISED_10000baseT_Full);
}
static void xfp_phy_clear_interrupt(struct efx_nic *efx)
{
	xenpack_clear_lasi_irqs(efx);
}
static int xfp_link_ok(struct efx_nic *efx)
{
	return mdio_clause45_links_ok(efx, XFP_REQUIRED_DEVS);
}
static inline void dma_sync_desc_cpu(struct net_device *dev, void *addr)
{
	dma_cache_sync(dev->dev.parent, addr, sizeof(struct sgiseeq_rx_desc),
		       DMA_FROM_DEVICE);
}
static inline void dma_sync_desc_dev(struct net_device *dev, void *addr)
{
	dma_cache_sync(dev->dev.parent, addr, sizeof(struct sgiseeq_rx_desc),
		       DMA_TO_DEVICE);
}
static void __exit sgiseeq_module_exit(void)
{
	platform_driver_unregister(&sgiseeq_driver);
}
static void bb_set(u32 addr, u32 msk)
{
	ctrl_outl(ctrl_inl(addr) | msk, addr);
}
static void bb_clr(u32 addr, u32 msk)
{
	ctrl_outl((ctrl_inl(addr) & ~msk), addr);
}
static int bb_read(u32 addr, u32 msk)
{
	return (ctrl_inl(addr) & msk) != 0;
}
static int __init sh_eth_init(void)
{
	return platform_driver_register(&sh_eth_driver);
}
static void __exit sh_eth_cleanup(void)
{
	platform_driver_unregister(&sh_eth_driver);
}
static void mdio_write(void __iomem *ioaddr, int phy_id, int reg, int val)
{
	__mdio_cmd(ioaddr, EhnMIIreq | EhnMIIwrite |
		(((u32) reg) << EhnMIIregShift) | (phy_id << EhnMIIpmdShift) |
		(((u32) val) << EhnMIIdataShift));
}
static void sis190_mark_as_last_descriptor(struct RxDesc *desc)
{
	desc->size |= cpu_to_le32(RingEnd);
}
static void sis190_init_ring_indexes(struct sis190_private *tp)
{
	tp->dirty_tx = tp->dirty_rx = tp->cur_tx = tp->cur_rx = 0;
}
static void sis190_set_rgmii(struct sis190_private *tp, u8 reg)
{
	tp->features |= (reg & 0x80) ? F_HAS_RGMII : 0;
}
static int sis190_get_regs_len(struct net_device *dev)
{
	return SIS190_REGS_SIZE;
}
static int __init sis190_init_module(void)
{
	return pci_register_driver(&sis190_pci_driver);
}
static void __exit sis190_cleanup_module(void)
{
	pci_unregister_driver(&sis190_pci_driver);
}
static void __exit sis900_cleanup_module(void)
{
	pci_unregister_driver(&sis900_pci_driver);
}
int cfm_get_mac_input(struct s_smc *smc)
{
	return((smc->mib.fddiSMTCF_State == SC10_C_WRAP_B ||
		smc->mib.fddiSMTCF_State == SC5_THRU_B) ? PB : PA) ;
}
int cfm_get_mac_output(struct s_smc *smc)
{
	return((smc->mib.fddiSMTCF_State == SC10_C_WRAP_B ||
		smc->mib.fddiSMTCF_State == SC4_THRU_A) ? PB : PA) ;
}
int sm_pm_bypass_present(struct s_smc *smc)
{
	return(	(inp(ADDR(B0_DAS)) & DAS_BYP_ST) ? TRUE: FALSE) ;
}
void mac_do_pci_fix(struct s_smc *smc)
{
	SK_UNUSED(smc) ;
}
static void start_ecm_timer(struct s_smc *smc, u_long value, int event)
{
	smt_timer_start(smc,&smc->e.ecm_timer,value,EV_TOKEN(EVENT_ECM,event));
}
void ess_para_change(struct s_smc *smc)
{
	(void)process_bw_alloc(smc,(long)smc->mib.a[PATH0].fddiPATHSbaPayload,
		(long)smc->mib.a[PATH0].fddiPATHSbaOverhead) ;
}
void set_formac_tsync(struct s_smc *smc, long sync_bw)
{
	outpw(FM_A(FM_TSYNC),(unsigned int) (((-sync_bw) >> 5) & 0xffff) ) ;
}
int sm_mac_get_tx_state(struct s_smc *smc)
{
	return((inpw(FM_A(FM_STMCHN))>>4)&7) ;
}
void hwt_restart(struct s_smc *smc)
{
	hwt_stop(smc) ;
}
void init_plc(struct s_smc *smc)
{
	SK_UNUSED(smc) ;
}
void ev_init(struct s_smc *smc)
{
	smc->q.ev_put = smc->q.ev_get = smc->q.ev_queue ;
}
static void rmt_leave_actions(struct s_smc *smc)
{
	queue_event(smc,EVENT_ECM,EC_DISCONNECT) ;
}
 unsigned long mac_drv_virt2phys(struct s_smc *smc, void *virt)
{
	return (smc->os.SharedMemDMA +
		((char *) virt - (char *)smc->os.SharedMemAddr));
}				// mac_drv_virt2phys
 u_long dma_master(struct s_smc * smc, void *virt, int len, int flag)
{
	return (smc->os.SharedMemDMA +
		((char *) virt - (char *)smc->os.SharedMemAddr));
}				// dma_master
 unsigned long smt_get_time(void)
{
	return jiffies;
}				// smt_get_time
static int __init skfd_init(void)
{
	return pci_register_driver(&skfddi_pci_driver);
}
static void __exit skfd_exit(void)
{
	pci_unregister_driver(&skfddi_pci_driver);
}
static inline int is_my_addr(const struct s_smc *smc, 
			     const struct fddi_addr *addr)
{
	return(*(short *)(&addr->a[0]) ==
		*(short *)(&smc->mib.m[MAC0].fddiMACSMTAddress.a[0])
	  && *(short *)(&addr->a[2]) ==
		*(short *)(&smc->mib.m[MAC0].fddiMACSMTAddress.a[2])
	  && *(short *)(&addr->a[4]) ==
		*(short *)(&smc->mib.m[MAC0].fddiMACSMTAddress.a[4])) ;
}
static inline int is_broadcast(const struct fddi_addr *addr)
{
	return(*(u_short *)(&addr->a[0]) == 0xffff &&
	       *(u_short *)(&addr->a[2]) == 0xffff &&
	       *(u_short *)(&addr->a[4]) == 0xffff ) ;
}
static inline int is_individual(const struct fddi_addr *addr)
{
	return(!(addr->a[0] & GROUP_ADDR)) ;
}
static inline int is_equal(const struct fddi_addr *addr1, 
			   const struct fddi_addr *addr2)
{
	return(*(u_short *)(&addr1->a[0]) == *(u_short *)(&addr2->a[0]) &&
	       *(u_short *)(&addr1->a[2]) == *(u_short *)(&addr2->a[2]) &&
	       *(u_short *)(&addr1->a[4]) == *(u_short *)(&addr2->a[4]) ) ;
}
static int phy_con_resource_index(struct s_smc *smc, int phy)
{
	return(entity_to_index(smc,cem_get_downstream(smc,ENTITY_PHY(phy)))) ;
}
static int entity_to_index(struct s_smc *smc, int e)
{
	if (e == ENTITY_MAC)
		return(mac_index(smc,1)) ;
	else
		return(phy_index(smc,e - ENTITY_PHY(0))) ;
}
static int smt_swap_short(u_short s)
{
	return(((s>>8)&0xff)|((s&0xff)<<8)) ;
}
void smt_force_irq(struct s_smc *smc)
{
	smt_timer_start(smc,&smc->t.st_fast,32L, EV_TOKEN(EVENT_SMT,SM_FAST)); 
}
void smt_timer_done(struct s_smc *smc)
{
	timer_done(smc,1) ;
}
static int skge_get_regs_len(struct net_device *dev)
{
	return 0x4000;
}
static inline u32 hwkhz(const struct skge_hw *hw)
{
	return (hw->chip_id == CHIP_ID_GENESIS) ? 53125 : 78125;
}
static inline u32 skge_clk2usec(const struct skge_hw *hw, u32 ticks)
{
	return (ticks * 1000) / hwkhz(hw);
}
static inline u32 skge_usecs2clk(const struct skge_hw *hw, u32 usec)
{
	return hwkhz(hw) * usec / 1000;
}
static inline u16 phy_length(const struct skge_hw *hw, u32 status)
{
	if (hw->chip_id == CHIP_ID_GENESIS)
		return status >> XMR_FS_LEN_SHIFT;
	else
		return status >> GMR_FS_LEN_SHIFT;
}
static inline int bad_phy_status(const struct skge_hw *hw, u32 status)
{
	if (hw->chip_id == CHIP_ID_GENESIS)
		return (status & (XMR_FS_ERR | XMR_FS_2L_VLAN)) != 0;
	else
		return (status & GMR_FS_ANY_ERR) ||
			(status & GMR_FS_RX_OK) == 0;
}
static int skge_debug_open(struct inode *inode, struct file *file)
{
	return single_open(file, skge_debug_show, inode->i_private);
}
static inline struct tx_ring_info *tx_le_re(struct sky2_port *sky2,
					    struct sky2_tx_le *le)
{
	return sky2->tx_ring + (le - sky2->tx_le);
}
static inline void sky2_rx_update(struct sky2_port *sky2, unsigned rxq)
{
	sky2_put_idx(sky2->hw, rxq, sky2->rx_put);
}
static inline int tx_dist(unsigned tail, unsigned head)
{
	return (head - tail) & (TX_RING_SIZE - 1);
}
static inline int tx_avail(const struct sky2_port *sky2)
{
	return sky2->tx_pending - tx_dist(sky2->tx_cons, sky2->tx_prod);
}
static enum flow_control sky2_flow(int rx, int tx)
{
	if (rx)
		return tx ? FC_BOTH : FC_RX;
	else
		return tx ? FC_TX : FC_NONE;
}
static inline u32 sky2_us2clk(const struct sky2_hw *hw, u32 us)
{
	return sky2_mhz(hw) * us;
}
static inline u32 sky2_clk2us(const struct sky2_hw *hw, u32 clk)
{
	return clk / sky2_mhz(hw);
}
static inline u8 sky2_wol_supported(const struct sky2_hw *hw)
{
	return sky2_is_copper(hw) ? (WAKE_PHY | WAKE_MAGIC) : 0;
}
static int sky2_get_regs_len(struct net_device *dev)
{
	return 0x4000;
}
static int sky2_debug_open(struct inode *inode, struct file *file)
{
	return single_open(file, sky2_debug_show, inode->i_private);
}
static inline void sl_lock(struct slip *sl)
{
	netif_stop_queue(sl->dev);
}
static inline void sl_unlock(struct slip *sl)
{
	netif_wake_queue(sl->dev);
}
static void __exit ultramca_cleanup_module(void)
{
	mca_unregister_driver(&ultra_driver);
}
static int smc911x_ethtool_getregslen(struct net_device *dev)
{
	return (((E2P_CMD - ID_REV)/4 + 1) +
			(WUCSR - MAC_CR)+1 + 32) * sizeof(u32);
}
static int smc911x_ethtool_geteeprom_len(struct net_device *dev)
{
	 return SMC911X_EEPROM_LEN;
}
static int __init smc911x_init(void)
{
	return platform_driver_register(&smc911x_driver);
}
static void __exit smc911x_cleanup(void)
{
	platform_driver_unregister(&smc911x_driver);
}
static int smc_ethtool_geteeprom_len(struct net_device *dev)
{
	return 0x23 * 2;
}
static int __init smc_init(void)
{
	return platform_driver_register(&smc_driver);
}
static void __exit smc_cleanup(void)
{
	platform_driver_unregister(&smc_driver);
}
static unsigned int smsc911x_tx_get_txstatcount(struct smsc911x_data *pdata)
{
	return (smsc911x_reg_read(pdata, TX_FIFO_INF)
		& TX_FIFO_INF_TSUSED_) >> 16;
}
static unsigned int smsc911x_hash(char addr[ETH_ALEN])
{
	return (ether_crc(ETH_ALEN, addr) >> 26) & 0x3f;
}
static int smsc911x_ethtool_getregslen(struct net_device *dev)
{
	return (((E2P_DATA - ID_REV) / 4 + 1) + (WUCSR - MAC_CR) + 1 + 32) *
	    sizeof(u32);
}
static int smsc911x_ethtool_get_eeprom_len(struct net_device *dev)
{
	return SMSC911X_EEPROM_SIZE;
}
static int __init smsc911x_init_module(void)
{
	return platform_driver_register(&smsc911x_driver);
}
static void __exit smsc911x_cleanup_module(void)
{
	platform_driver_unregister(&smsc911x_driver);
}
static inline u32 smsc9420_reg_read(struct smsc9420_pdata *pd, u32 offset)
{
	return ioread32(pd->base_addr + offset);
}
static inline void
smsc9420_reg_write(struct smsc9420_pdata *pd, u32 offset, u32 value)
{
	iowrite32(value, pd->base_addr + offset);
}
static inline void smsc9420_pci_flush_write(struct smsc9420_pdata *pd)
{
	smsc9420_reg_read(pd, ID_REV);
}
static u32 smsc9420_hash(u8 addr[ETH_ALEN])
{
	return (ether_crc(ETH_ALEN, addr) >> 26) & 0x3f;
}
static int smsc9420_ethtool_getregslen(struct net_device *dev)
{
	return 0x100 + (32 * sizeof(u32));
}
static int smsc9420_ethtool_get_eeprom_len(struct net_device *dev)
{
	return SMSC9420_EEPROM_SIZE;
}
static void __exit smsc9420_exit_module(void)
{
	pci_unregister_driver(&smsc9420_driver);
}
static void __exit sni_82596_exit(void)
{
	platform_driver_unregister(&sni_82596_driver);
}
static inline u32
spider_net_read_reg(struct spider_net_card *card, u32 reg)
{
	return in_be32(card->regs + reg);
}
static inline void
spider_net_write_reg(struct spider_net_card *card, u32 reg, u32 value)
{
	out_be32(card->regs + reg, value);
}
static inline int
spider_net_get_descr_status(struct spider_net_hw_descr *hwdescr)
{
	return hwdescr->dmac_cmd_status & SPIDER_NET_DESCR_IND_PROC_MASK;
}
static inline void
spider_net_enable_rxchtails(struct spider_net_card *card)
{
	spider_net_write_reg(card, SPIDER_NET_GDADCHA ,
			     card->rx_chain.tail->bus_addr);
}
static inline void
spider_net_disable_rxdmac(struct spider_net_card *card)
{
	spider_net_write_reg(card, SPIDER_NET_GDADMACCNTR,
			     SPIDER_NET_DMA_RX_FEND_VALUE);
}
static void __exit spider_net_cleanup(void)
{
	pci_unregister_driver(&spider_net_driver);
}
static void spider_net_get_strings(struct net_device *netdev, u32 stringset,
				   u8 *data)
{
	memcpy(data, ethtool_stats_keys, sizeof(ethtool_stats_keys));
}
static u32 get_msglevel(struct net_device *dev)
{
	return debug;
}
static void set_msglevel(struct net_device *dev, u32 val)
{
	debug = val;
}
static void __exit starfire_cleanup (void)
{
	pci_unregister_driver (&starfire_driver);
}
static int __init bigmac_init(void)
{
	return of_register_driver(&bigmac_sbus_driver, &of_bus_type);
}
static void __exit bigmac_exit(void)
{
	of_unregister_driver(&bigmac_sbus_driver);
}
static void __exit sundance_exit(void)
{
	pci_unregister_driver(&sundance_driver);
}
static inline u16 phy_read(struct gem *gp, int reg)
{
	return __phy_read(gp, gp->mii_phy_addr, reg);
}
static inline void phy_write(struct gem *gp, int reg, u16 val)
{
	__phy_write(gp, gp->mii_phy_addr, reg, val);
}
static inline void gem_enable_ints(struct gem *gp)
{
	writel(GREG_STAT_TXDONE, gp->regs + GREG_IMASK);
}
static inline void gem_disable_ints(struct gem *gp)
{
	writel(GREG_STAT_NAPI | GREG_STAT_TXDONE, gp->regs + GREG_IMASK);
}
static void gem_poll_controller(struct net_device *dev)
{
	gem_interrupt(dev->irq, dev);
}
static int __init gem_init(void)
{
	return pci_register_driver(&gem_driver);
}
static void __exit gem_cleanup(void)
{
	pci_unregister_driver(&gem_driver);
}
static inline int __phy_read(struct mii_phy* phy, int id, int reg)
{
	return phy->mdio_read(phy->dev, id, reg);
}
static inline void __phy_write(struct mii_phy* phy, int id, int reg, int val)
{
	phy->mdio_write(phy->dev, id, reg, val);
}
static inline int phy_read(struct mii_phy* phy, int reg)
{
	return phy->mdio_read(phy->dev, phy->mii_id, reg);
}
static inline void phy_write(struct mii_phy* phy, int reg, int val)
{
	phy->mdio_write(phy->dev, phy->mii_id, reg, val);
}
static int bcm5400_suspend(struct mii_phy* phy)
{
	return 0;
}
static int bcm5401_suspend(struct mii_phy* phy)
{
	return 0;
}
static void sbus_hme_write32(void __iomem *reg, u32 val)
{
	sbus_writel(val, reg);
}
static u32 sbus_hme_read32(void __iomem *reg)
{
	return sbus_readl(reg);
}
static u32 sbus_hme_read_desc32(hme32 *p)
{
	return (__force u32)*p;
}
static void pci_hme_write32(void __iomem *reg, u32 val)
{
	writel(val, reg);
}
static u32 pci_hme_read32(void __iomem *reg)
{
	return readl(reg);
}
static u32 pci_hme_read_desc32(hme32 *p)
{
	return le32_to_cpup((__le32 *)p);
}
static inline u32 hme_read_desc32(struct happy_meal *hp, hme32 *p)
{
	return le32_to_cpup((__le32 *)p);
}
static int __init happy_meal_pci_init(void)
{
	return pci_register_driver(&hme_pci_driver);
}
static u32 sparc_lance_get_link(struct net_device *dev)
{
	return 1;
}
static int __init sparc_lance_init(void)
{
	return of_register_driver(&sunlance_sbus_driver, &of_bus_type);
}
static void __exit sparc_lance_exit(void)
{
	of_unregister_driver(&sunlance_sbus_driver);
}
static int __devinit qec_sbus_probe(struct of_device *op, const struct of_device_id *match)
{
	return qec_ether_init(op);
}
static int __init qec_init(void)
{
	return of_register_driver(&qec_sbus_driver, &of_bus_type);
}
static inline u32 vnet_tx_dring_avail(struct vio_dring_state *dr)
{
	return vio_dring_avail(dr, VNET_TX_RING_SIZE);
}
static int vnet_nack(struct vnet_port *port, void *msgbuf)
{
	return 0;
}
static int vnet_set_mac_addr(struct net_device *dev, void *p)
{
	return -EINVAL;
}
static int __init vnet_init(void)
{
	return vio_register_driver(&vnet_port_driver);
}
static void __exit vnet_exit(void)
{
	vio_unregister_driver(&vnet_port_driver);
}
static inline dma_addr_t fd_virt_to_bus(struct tc35815_local *lp, void *virt)
{
	return lp->fd_buf_dma + ((u8 *)virt - (u8 *)lp->fd_buf);
}
static inline void *fd_bus_to_virt(struct tc35815_local *lp, dma_addr_t bus)
{
	return (void *)((u8 *)lp->fd_buf + (bus - lp->fd_buf_dma));
}
static int __devinit tc35815_read_plat_dev_addr(struct net_device *dev)
{
	return -ENODEV;
}
static void tc35815_get_strings(struct net_device *dev, u32 stringset, u8 *data)
{
	memcpy(data, ethtool_stats_keys, sizeof(ethtool_stats_keys));
}
static int __init tc35815_init_module(void)
{
	return pci_register_driver(&tc35815_pci_driver);
}
static void __exit tc35815_cleanup_module(void)
{
	pci_unregister_driver(&tc35815_pci_driver);
}
static void print_fw_id(struct pci_nic *nic)
{
	printk(KERN_INFO "tehuti: fw 0x%x\n", readl(nic->regs + FW_VER));
}
static void print_eth_id(struct net_device *ndev)
{
	printk(KERN_INFO "%s: %s, Port %c\n", ndev->name, BDX_NIC_NAME,
	       (ndev->if_port == 0) ? 'A' : 'B');
}
static int bdx_range_check(struct bdx_priv *priv, u32 offset)
{
	return (offset > (u32) (BDX_REGS_SIZE / priv->nic->port_num)) ?
		-EINVAL : 0;
}
static void bdx_vlan_rx_add_vid(struct net_device *ndev, uint16_t vid)
{
	__bdx_vlan_rx_vid(ndev, vid, 1);
}
static void bdx_vlan_rx_kill_vid(struct net_device *ndev, unsigned short vid)
{
	__bdx_vlan_rx_vid(ndev, vid, 0);
}
static inline int bdx_rxdb_available(struct rxdb *db)
{
	return db->top;
}
 static void print_rxdd(struct rxd_desc *rxdd, u32 rxd_val1, u16 len,
		       u16 rxd_vlan)
{
	DBG("ERROR: rxdd bc %d rxfq %d to %d type %d err %d rxp %d "
}

static void print_rxfd(struct rxf_desc *rxfd)
{
	DBG("=== RxF desc CHIP ORDER/ENDIANESS =============\n"
}
static u32 bdx_get_rx_csum(struct net_device *netdev)
{
	return 1;		/* always on */
}
static u32 bdx_get_tx_csum(struct net_device *netdev)
{
	return (netdev->features & NETIF_F_IP_CSUM) != 0;
}
static inline int bdx_rx_fifo_size_to_packets(int rx_size)
{
	return ((FIFO_SIZE * (1 << rx_size)) / sizeof(struct rxf_desc));
}
static inline int bdx_tx_fifo_size_to_packets(int tx_size)
{
	return ((FIFO_SIZE * (1 << tx_size)) / BDX_TXF_DESC_SZ);
}
static void tg3_write32(struct tg3 *tp, u32 off, u32 val)
{
	writel(val, tp->regs + off);
}
static u32 tg3_read32(struct tg3 *tp, u32 off)
{
	return (readl(tp->regs + off));
}
static void tg3_ape_write32(struct tg3 *tp, u32 off, u32 val)
{
	writel(val, tp->aperegs + off);
}
static u32 tg3_ape_read32(struct tg3 *tp, u32 off)
{
	return (readl(tp->aperegs + off));
}
static u32 tg3_read32_mbox_5906(struct tg3 *tp, u32 off)
{
	return (readl(tp->regs + off + GRCMBOX_BASE));
}
static void tg3_write32_mbox_5906(struct tg3 *tp, u32 off, u32 val)
{
	writel(val, tp->regs + off + GRCMBOX_BASE);
}
static int tg3_mdio_reset(struct mii_bus *bp)
{
	return 0;
}
static int tg3_vlan_rx(struct tg3 *tp, struct sk_buff *skb, u16 vlan_tag)
{
	return vlan_hwaccel_receive_skb(skb, tp->vlgrp, vlan_tag);
}
static inline int tg3_irq_sync(struct tg3 *tp)
{
	return tp->irq_sync;
}
static inline void tg3_full_unlock(struct tg3 *tp)
{
	spin_unlock_bh(&tp->lock);
}
static void tg3_save_pci_state(struct tg3 *tp)
{
	pci_read_config_word(tp->pdev, PCI_COMMAND, &tp->pci_cmd);
}
static inline u64 get_estat64(tg3_stat64_t *val)
{
       return ((u64)val->high << 32) | ((u64)val->low);
}
static int tg3_get_regs_len(struct net_device *dev)
{
	return TG3_REGDUMP_LEN;
}
static int __init tg3_init(void)
{
	return pci_register_driver(&tg3_driver);
}
static void __exit tg3_cleanup(void)
{
	pci_unregister_driver(&tg3_driver);
}
static int __devinit tlan_init_one( struct pci_dev *pdev,
				    const struct pci_device_id *ent)
{
	return TLan_probe1( pdev, -1, -1, 0, ent);
}
static int __init xl_pci_init (void)
{
	return pci_register_driver(&xl_3c359_driver);
}
static void __exit xl_pci_cleanup (void)
{
	pci_unregister_driver (&xl_3c359_driver);
}
static unsigned short abyss_sifreadb(struct net_device *dev, unsigned short reg)
{
	return inb(dev->base_addr + reg);
}
static unsigned short abyss_sifreadw(struct net_device *dev, unsigned short reg)
{
	return inw(dev->base_addr + reg);
}
static void abyss_sifwriteb(struct net_device *dev, unsigned short val, unsigned short reg)
{
	outb(val, dev->base_addr + reg);
}
static void abyss_sifwritew(struct net_device *dev, unsigned short val, unsigned short reg)
{
	outw(val, dev->base_addr + reg);
}
static void __exit abyss_rmmod (void)
{
	pci_unregister_driver (&abyss_driver);
}
static int __init streamer_init_module(void) {
  return pci_register_driver(&streamer_pci_driver);
}
static void __exit streamer_cleanup_module(void) {
  pci_unregister_driver(&streamer_pci_driver);
}
static void madgemc_setcabletype(struct net_device *dev, int type)
{
	outb((type==0)?MC_CONTROL_REG7_CABLEUTP:MC_CONTROL_REG7_CABLESTP,
	     dev->base_addr + MC_CONTROL_REG7);
}
static int __init madgemc_init (void)
{
	return mca_register_driver (&madgemc_driver);
}
static void __exit madgemc_exit (void)
{
	mca_unregister_driver (&madgemc_driver);
}
static int __init olympic_pci_init(void) 
{
	return pci_register_driver(&olympic_driver) ;
}

static void __exit olympic_pci_cleanup(void)
{
	pci_unregister_driver(&olympic_driver) ; 
}	
static unsigned short proteon_sifreadb(struct net_device *dev, unsigned short reg)
{
	return inb(dev->base_addr + reg);
}
static unsigned short proteon_sifreadw(struct net_device *dev, unsigned short reg)
{
	return inw(dev->base_addr + reg);
}
static void proteon_sifwriteb(struct net_device *dev, unsigned short val, unsigned short reg)
{
	outb(val, dev->base_addr + reg);
}
static void proteon_sifwritew(struct net_device *dev, unsigned short val, unsigned short reg)
{
	outw(val, dev->base_addr + reg);
}
static unsigned short proteon_setnselout_pins(struct net_device *dev)
{
	return 0;
}
static unsigned short sk_isa_sifreadb(struct net_device *dev, unsigned short reg)
{
	return inb(dev->base_addr + reg);
}
static unsigned short sk_isa_sifreadw(struct net_device *dev, unsigned short reg)
{
	return inw(dev->base_addr + reg);
}
static void sk_isa_sifwriteb(struct net_device *dev, unsigned short val, unsigned short reg)
{
	outb(val, dev->base_addr + reg);
}
static void sk_isa_sifwritew(struct net_device *dev, unsigned short val, unsigned short reg)
{
	outw(val, dev->base_addr + reg);
}
static unsigned short sk_isa_setnselout_pins(struct net_device *dev)
{
	return 0;
}
static int smctr_disable_16bit(struct net_device *dev)
{
        return (0);
}
static void tms380tr_write_tpl_status(TPL *tpl, unsigned int Status)
{
	tpl->Status = Status;
}
void cleanup_module(void)
{
	TMS380_module = NULL;
}
static unsigned short tms_pci_sifreadb(struct net_device *dev, unsigned short reg)
{
	return inb(dev->base_addr + reg);
}
static unsigned short tms_pci_sifreadw(struct net_device *dev, unsigned short reg)
{
	return inw(dev->base_addr + reg);
}
static void tms_pci_sifwriteb(struct net_device *dev, unsigned short val, unsigned short reg)
{
	outb(val, dev->base_addr + reg);
}
static void tms_pci_sifwritew(struct net_device *dev, unsigned short val, unsigned short reg)
{
	outw(val, dev->base_addr + reg);
}
static int __init tms_pci_init (void)
{
	return pci_register_driver(&tms_pci_driver);
}
static void __exit tms_pci_rmmod (void)
{
	pci_unregister_driver (&tms_pci_driver);
}
static void tsi108_ether_exit(void)
{
	platform_driver_unregister(&tsi_eth_driver);
}
static inline int de_is_running (struct de_private *de)
{
	return (dr32(MacStatus) & (RxState | TxState)) ? 1 : 0;
}
static int de_get_regs_len(struct net_device *dev)
{
	return DE_REGS_SIZE;
}
static void __exit de_exit (void)
{
	pci_unregister_driver (&de_driver);
}
static int
dc21041_infoleaf(struct net_device *dev)
{
    return DE4X5_AUTOSENSE_MS;
}
static void __exit tulip_cleanup (void)
{
	pci_unregister_driver (&tulip_driver);
}
static void uli526x_poll(struct net_device *dev)
{
	uli526x_interrupt(dev->irq, dev);
}
static void free_ringdesc(struct netdev_private *np)
{
	pci_free_consistent(np->pci_dev,
			sizeof(struct w840_rx_desc)*RX_RING_SIZE +
			sizeof(struct w840_tx_desc)*TX_RING_SIZE,
			np->rx_ring, np->ring_dma_addr);
}
static u32 netdev_get_msglevel(struct net_device *dev)
{
	return debug;
}
static void netdev_set_msglevel(struct net_device *dev, u32 value)
{
	debug = value;
}
static void __exit w840_exit(void)
{
	pci_unregister_driver(&w840_driver);
}
static int __init xircom_init(void)
{
	return pci_register_driver(&xircom_ops);
}
static void __exit xircom_exit(void)
{
	pci_unregister_driver(&xircom_ops);
}
static inline struct tun_sock *tun_sk(struct sock *sk)
{
	return container_of(sk, struct tun_sock, sk);
}
static struct tun_struct *tun_get(struct file *file)
{
	return __tun_get(file->private_data);
}
static void tun_net_mclist(struct net_device *dev)
{
	return;
}
static int tun_validate(struct nlattr *tb[], struct nlattr *data[])
{
	return -EINVAL;
}
static void tun_sock_destruct(struct sock *sk)
{
	dev_put(container_of(sk, struct tun_sock, sk)->tun->dev);
}
static inline void
typhoon_inc_cmd_index(u32 *index, const int count)
{
	typhoon_inc_index(index, count, COMMAND_ENTRIES);
}
static inline void
typhoon_inc_resp_index(u32 *index, const int count)
{
	typhoon_inc_index(index, count, RESPONSE_ENTRIES);
}
static inline void
typhoon_inc_rxfree_index(u32 *index, const int count)
{
	typhoon_inc_index(index, count, RXFREE_ENTRIES);
}
static inline void
typhoon_inc_tx_index(u32 *index, const int count)
{
	typhoon_inc_index(index, count, TXLO_ENTRIES);
}
static inline int
typhoon_num_free_tx(struct transmit_ring *ring)
{
	return typhoon_num_free(ring->lastWrite, ring->lastRead, TXLO_ENTRIES);
}
static u32
typhoon_get_rx_csum(struct net_device *dev)
{
	return 1;
}
static int __init
typhoon_init(void)
{
	return pci_register_driver(&typhoon_driver);
}
static void __exit
typhoon_cleanup(void)
{
	pci_unregister_driver(&typhoon_driver);
}
static void put_enet_addr_container(struct enet_addr_container *enet_addr_cont)
{
	kfree(enet_addr_cont);
}
static inline int compare_addr(u8 **addr1, u8 **addr2)
{
	return memcmp(addr1, addr2, ENET_NUM_OCTETS_PER_ADDRESS);
}
static void __exit ucc_geth_exit(void)
{
	of_unregister_platform_driver(&ucc_geth_driver);
}
static int
uec_get_regs_len(struct net_device *netdev)
{
	return sizeof(struct ucc_geth);
}
void uec_set_ethtool_ops(struct net_device *netdev)
{
	SET_ETHTOOL_OPS(netdev, &uec_ethtool_ops);
}
static int __init asix_init(void)
{
 	return usb_register(&asix_driver);
}
static void __exit asix_exit(void)
{
 	usb_deregister(&asix_driver);
}
static void __exit catc_exit(void)
{
	usb_deregister(&catc_driver);
}
static int is_rndis(struct usb_interface_descriptor *desc)
{
	return desc->bInterfaceClass == USB_CLASS_COMM
		&& desc->bInterfaceSubClass == 2
		&& desc->bInterfaceProtocol == 0xff;
}
static int is_activesync(struct usb_interface_descriptor *desc)
{
	return desc->bInterfaceClass == USB_CLASS_MISC
		&& desc->bInterfaceSubClass == 1
		&& desc->bInterfaceProtocol == 1;
}
static int is_wireless_rndis(struct usb_interface_descriptor *desc)
{
	return desc->bInterfaceClass == USB_CLASS_WIRELESS_CONTROLLER
		&& desc->bInterfaceSubClass == 1
		&& desc->bInterfaceProtocol == 3;
}
static void __exit cdc_exit(void)
{
 	usb_deregister(&cdc_driver);
}
static int always_connected (struct usbnet *dev)
{
	return 0;
}
static int __init cdc_subset_init(void)
{
	return usb_register(&cdc_subset_driver);
}
static void __exit cdc_subset_exit(void)
{
	usb_deregister(&cdc_subset_driver);
}
static int dm_read_reg(struct usbnet *dev, u8 reg, u8 *value)
{
	return dm_read(dev, reg, 1, value);
}
static int dm_read_eeprom_word(struct usbnet *dev, u8 offset, void *value)
{
	return dm_read_shared_word(dev, 0, offset, value);
}
static int dm9601_get_eeprom_len(struct net_device *dev)
{
	return DM_EEPROM_LEN;
}
static void __dm9601_set_mac_address(struct usbnet *dev)
{
	dm_write_async(dev, DM_PHY_ADDR, ETH_ALEN, dev->net->dev_addr);
}
static int __init dm9601_init(void)
{
	return usb_register(&dm9601_driver);
}
static void __exit dm9601_exit(void)
{
	usb_deregister(&dm9601_driver);
}
static int __init usbnet_init(void)
{
 	return usb_register(&gl620a_driver);
}
static void __exit usbnet_exit(void)
{
 	usb_deregister(&gl620a_driver);
}
static inline struct hso_net *dev2net(struct hso_device *hso_dev)
{
	return hso_dev->port_data.dev_net;
}
static inline struct hso_serial *dev2ser(struct hso_device *hso_dev)
{
	return hso_dev->port_data.dev_serial;
}
static void hso_free_device(struct hso_device *hso_dev)
{
	kfree(hso_dev);
}
static void __exit kaweth_exit(void)
{
	usb_deregister(&kaweth_driver);
}
static int __init mcs7830_init(void)
{
	return usb_register(&mcs7830_driver);
}
static void __exit mcs7830_exit(void)
{
	usb_deregister(&mcs7830_driver);
}
static inline int
nc_register_read(struct usbnet *dev, u8 regnum, u16 *retval_ptr)
{
	return nc_vendor_read(dev, REQUEST_REGISTER, regnum, retval_ptr);
}
static void
nc_vendor_write(struct usbnet *dev, u8 req, u8 regnum, u16 value)
{
	usb_control_msg(dev->udev,
		usb_sndctrlpipe(dev->udev, 0),
		req,
		USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
		value, regnum,
		NULL, 0,			// data is in setup packet
		USB_CTRL_SET_TIMEOUT);
}
static inline void
nc_register_write(struct usbnet *dev, u8 regnum, u16 value)
{
	nc_vendor_write(dev, REQUEST_REGISTER, regnum, value);
}
static int __init net1080_init(void)
{
 	return usb_register(&net1080_driver);
}
static void __exit net1080_exit(void)
{
 	usb_deregister(&net1080_driver);
}
static struct net_device_stats *pegasus_netdev_stats(struct net_device *dev)
{
	return &((pegasus_t *) netdev_priv(dev))->stats;
}
static void __exit pegasus_exit(void)
{
	usb_deregister(&pegasus_driver);
}
static inline int
pl_vendor_req(struct usbnet *dev, u8 req, u8 val, u8 index)
{
	return usb_control_msg(dev->udev,
		usb_rcvctrlpipe(dev->udev, 0),
		req,
		USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
		val, index,
		NULL, 0,
		USB_CTRL_GET_TIMEOUT);
}
static inline int
pl_clear_QuickLink_features(struct usbnet *dev, int val)
{
	return pl_vendor_req(dev, 1, (u8) val, 0);
}
static inline int
pl_set_QuickLink_features(struct usbnet *dev, int val)
{
	return pl_vendor_req(dev, 3, (u8) val, 0);
}
static int __init plusb_init(void)
{
 	return usb_register(&plusb_driver);
}
static void __exit plusb_exit(void)
{
 	usb_deregister(&plusb_driver);
}
void rndis_status(struct usbnet *dev, struct urb *urb)
{
	devdbg(dev, "rndis status urb, len %d stat %d",
		urb->actual_length, urb->status);
}
static int rndis_bind(struct usbnet *dev, struct usb_interface *intf)
{
	return generic_rndis_bind(dev, intf, FLAG_RNDIS_PHYM_NOT_WIRELESS);
}
static int __init rndis_init(void)
{
	return usb_register(&rndis_driver);
}
static void __exit rndis_exit(void)
{
	usb_deregister(&rndis_driver);
}
static int get_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)
{
	return usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),
			       RTL8150_REQ_GET_REGS, RTL8150_REQT_READ,
			       indx, 0, data, size, 500);
}
static int set_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)
{
	return usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),
			       RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,
			       indx, 0, data, size, 500);
}
static struct net_device_stats *rtl8150_netdev_stats(struct net_device *dev)
{
	return &((rtl8150_t *)netdev_priv(dev))->stats;
}
static void __exit usb_rtl8150_exit(void)
{
	usb_deregister(&rtl8150_driver);
}
static unsigned int smsc95xx_hash(char addr[ETH_ALEN])
{
	return (ether_crc(ETH_ALEN, addr) >> 26) & 0x3f;
}
static int smsc95xx_ethtool_get_eeprom_len(struct net_device *net)
{
	return MAX_EEPROM_SIZE;
}
static int __init smsc95xx_init(void)
{
	return usb_register(&smsc95xx_driver);
}
static void __exit smsc95xx_exit(void)
{
	usb_deregister(&smsc95xx_driver);
}
static int always_connected (struct usbnet *dev)
{
	return 0;
}
static int __init zaurus_init(void)
{
	return usb_register(&zaurus_driver);
}
static void __exit zaurus_exit(void)
{
	usb_deregister(&zaurus_driver);
}
static u32 veth_get_tx_csum(struct net_device *dev)
{
	return (dev->features & NETIF_F_NO_CSUM) != 0;
}
static u32 netdev_get_msglevel(struct net_device *dev)
{
	return debug;
}
static void netdev_set_msglevel(struct net_device *dev, u32 value)
{
	debug = value;
}
static void __exit rhine_cleanup(void)
{
	pci_unregister_driver(&rhine_driver);
}
static void velocity_register_notifier(void)
{
	register_inetaddr_notifier(&velocity_inetaddr_notifier);
}
static void velocity_unregister_notifier(void)
{
	unregister_inetaddr_notifier(&velocity_inetaddr_notifier);
}
static void velocity_init_rx_ring_indexes(struct velocity_info *vptr)
{
	vptr->rx.dirty = vptr->rx.filled = vptr->rx.curr = 0;
}
static void velocity_set_rxbufsize(struct velocity_info *vptr, int mtu)
{
	vptr->rx.buf_sz = (mtu <= ETH_DATA_LEN) ? PKT_BUF_SZ : mtu + 32;
}
static u32 velocity_get_msglevel(struct net_device *dev)
{
	return msglevel;
}
static void velocity_set_msglevel(struct net_device *dev, u32 value)
{
	 msglevel = value;
}
static inline void *skb_vnet_hdr(struct sk_buff *skb)
{
	return (struct virtio_net_hdr *)skb->cb;
}
static int __init init(void)
{
	return register_virtio_driver(&virtio_net);
}
static void __exit fini(void)
{
	unregister_virtio_driver(&virtio_net);
}
static inline u8 sca_get_page(card_t *card)
{
	return card->page;
}
static inline struct channel_data* dev_to_chan(struct net_device *dev)
{
	return (struct channel_data *)dev_to_hdlc(dev)->priv;
}
static void debug_status_out(struct cosa_data *cosa, int status)
{
	printk(KERN_INFO "%s: IO: status <- 0x%02x (%s%s%s%s%s%s)\n",
		cosa->name,
		status,
		status & SR_RX_DMA_ENA  ? "RXDMA|":"!rxdma|",
		status & SR_TX_DMA_ENA  ? "TXDMA|":"!txdma|",
		status & SR_RST         ? "RESET|":"",
		status & SR_USR_INT_ENA ? "USRINT|":"!usrint|",
		status & SR_TX_INT_ENA  ? "TXINT|":"!txint|",
		status & SR_RX_INT_ENA  ? "RXINT":"!rxint");
}
static void debug_data_in(struct cosa_data *cosa, int data)
{
	printk(KERN_INFO "%s: IO: data -> 0x%04x\n", cosa->name, data);
}
static void debug_data_out(struct cosa_data *cosa, int data)
{
	printk(KERN_INFO "%s: IO: data <- 0x%04x\n", cosa->name, data);
}
static void debug_data_cmd(struct cosa_data *cosa, int data)
{
	printk(KERN_INFO "%s: IO: data <- 0x%04x (%s|%s)\n",
		cosa->name, data,
		data & SR_RDY_RCV ? "RX_RDY" : "!rx_rdy",
		data & SR_RDY_SND ? "TX_RDY" : "!tx_rdy");
}
static void cycx_inten(struct cycx_hw *hw)
{
	writeb(0, hw->dpmbase);
}
void cycx_intr(struct cycx_hw *hw)
{
	writew(0, hw->dpmbase + GEN_CYCX_INTR);
}
static void cycx_bootcfg(struct cycx_hw *hw)
{
	writeb(FIXED_BUFFERS, hw->dpmbase + CONF_OFFSET);
}
static void cycx_x25_chan_setup(struct net_device *dev)
{
	dev->init = cycx_netdevice_init;
}
static int cycx_netdevice_rebuild_header(struct sk_buff *skb)
{
	return 1;
}
static void cycx_x25_irq_spurious(struct cycx_device *card,
				  struct cycx_x25_cmd *cmd)
{
	printk(KERN_INFO "%s: spurious interrupt (0x%X)!\n",
			 card->devname, cmd->command);
}
static inline struct dscc4_dev_priv *dscc4_priv(struct net_device *dev)
{
	return dev_to_hdlc(dev)->priv;
}
static inline struct net_device *dscc4_to_dev(struct dscc4_dev_priv *p)
{
	return p->dev;
}
static inline u32 scc_readl(struct dscc4_dev_priv *dpriv, int offset)
{
	return dpriv->scc_regs[offset >> 2];
}
static inline unsigned int dscc4_tx_done(struct dscc4_dev_priv *dpriv)
{
	return dpriv->tx_current == dpriv->tx_dirty;
}
static inline unsigned int dscc4_tx_quiescent(struct dscc4_dev_priv *dpriv,
					      struct net_device *dev)
{
	return readl(dpriv->base_addr + CH0FTDA + dpriv->dev_id*4) == dpriv->ltda;
}
static void dscc4_tx_print(struct net_device *dev,
			   struct dscc4_dev_priv *dpriv,
			   char *msg)
{
	printk(KERN_DEBUG "%s: tx_current=%02d tx_dirty=%02d (%s)\n",
	       dev->name, dpriv->tx_current, dpriv->tx_dirty, msg);
}
static int __init dscc4_init_module(void)
{
	return pci_register_driver(&dscc4_driver);
}
static void __exit dscc4_cleanup_module(void)
{
	pci_unregister_driver(&dscc4_driver);
}
static inline struct net_device *port_to_dev(port_t *port)
{
	return port->dev;
}
static inline port_t* dev_to_port(struct net_device *dev)
{
	return dev_to_hdlc(dev)->priv;
}
static inline u16 next_desc(port_t *port, u16 desc, int transmit)
{
	return (desc + 1) % (transmit ? port_to_card(port)->tx_ring_buffers
			     : port_to_card(port)->rx_ring_buffers);
}
static inline u16 desc_offset(port_t *port, u16 desc, int transmit)
{
	return desc_abs_number(port, desc, transmit) * sizeof(pkt_desc);
}
static inline u32 buffer_offset(port_t *port, u16 desc, int transmit)
{
	return port_to_card(port)->buff_offset +
		desc_abs_number(port, desc, transmit) * (u32)HDLC_MAX_MRU;
}
static inline port_t* dev_to_port(struct net_device *dev)
{
	return dev_to_hdlc(dev)->priv;
}
static inline void enable_intr(port_t *port)
{
	sca_outl(sca_inl(IER0, port->card) |
		 (port->chan ? 0x08002200 : 0x00080022), IER0, port->card);
}
static inline void disable_intr(port_t *port)
{
	sca_outl(sca_inl(IER0, port->card) &
		 (port->chan ? 0x00FF00FF : 0xFF00FF00), IER0, port->card);
}
static inline u16 desc_offset(port_t *port, u16 desc, int transmit)
{
	return desc_abs_number(port, desc, transmit) * sizeof(pkt_desc);
}
static inline u32 buffer_offset(port_t *port, u16 desc, int transmit)
{
	return port->card->buff_offset +
		desc_abs_number(port, desc, transmit) * (u32)HDLC_MAX_MRU;
}
static inline struct cisco_state* state(hdlc_device *hdlc)
{
	return (struct cisco_state *)hdlc->state;
}
static void __exit mod_exit(void)
{
	unregister_hdlc_protocol(&proto);
}
static inline u16 q922_to_dlci(u8 *hdr)
{
	return ((hdr[0] & 0xFC) << 2) | ((hdr[1] & 0xF0) >> 4);
}
static inline struct frad_state* state(hdlc_device *hdlc)
{
	return(struct frad_state *)(hdlc->state);
}
static inline int pvc_is_used(pvc_device *pvc)
{
	return pvc->main || pvc->ether;
}
static inline struct net_device** get_dev_p(pvc_device *pvc, int type)
{
	if (type == ARPHRD_ETHER)
		return &pvc->ether;
	else
		return &pvc->main;
}
static inline void fr_log_dlci_active(pvc_device *pvc)
{
	printk(KERN_INFO "%s: DLCI %d [%s%s%s]%s %s\n",
	       pvc->frad->name,
	       pvc->dlci,
	       pvc->main ? pvc->main->name : "",
	       pvc->main && pvc->ether ? " " : "",
	       pvc->ether ? pvc->ether->name : "",
	       pvc->state.new ? " new" : "",
	       !pvc->state.exist ? "deleted" :
	       pvc->state.active ? "active" : "inactive");
}
static void __exit mod_exit(void)
{
	unregister_hdlc_protocol(&proto);
}
static inline struct ppp* get_ppp(struct net_device *dev)
{
	return (struct ppp *)dev_to_hdlc(dev)->state;
}
static void ppp_stop(struct net_device *dev)
{
	ppp_cp_event(dev, PID_LCP, STOP, 0, 0, 0, NULL);
}
static void __exit mod_exit(void)
{
	unregister_hdlc_protocol(&proto);
}
static __be16 raw_type_trans(struct sk_buff *skb, struct net_device *dev)
{
	return cpu_to_be16(ETH_P_IP);
}
static void __exit mod_exit(void)
{
	unregister_hdlc_protocol(&proto);
}
static void __exit mod_exit(void)
{
	unregister_hdlc_protocol(&proto);
}
static void x25_connected(struct net_device *dev, int reason)
{
	x25_connect_disconnect(dev, reason, 1);
}
static void x25_disconnected(struct net_device *dev, int reason)
{
	x25_connect_disconnect(dev, reason, 2);
}
static void x25_close(struct net_device *dev)
{
	lapb_unregister(dev);
}
static void __exit mod_exit(void)
{
	unregister_hdlc_protocol(&proto);
}
static inline struct z8530_dev* dev_to_sv(struct net_device *dev)
{
	return (struct z8530_dev *)dev_to_hdlc(dev)->priv;
}
static int hostess_ioctl(struct net_device *d, struct ifreq *ifr, int cmd)
{
	return hdlc_ioctl(d, ifr, cmd);
}
static int hostess_queue_xmit(struct sk_buff *skb, struct net_device *d)
{
	return z8530_queue_xmit(&dev_to_sv(d)->chanA, skb);
}
static inline struct port* dev_to_port(struct net_device *dev)
{
	return dev_to_hdlc(dev)->priv;
}
static inline void debug_desc(u32 phys, struct desc *desc)
{
	printk(KERN_DEBUG "%X: %X %3X %3X %08X %X %X\n",
	       phys, desc->next, desc->buf_len, desc->pkt_len,
	       desc->data, desc->status, desc->error_count);
}
static void __exit hss_cleanup_module(void)
{
	platform_driver_unregister(&ixp4xx_hss_driver);
}
static __inline__ int dev_is_ethdev(struct net_device *dev)
{
	return dev->type == ARPHRD_ETHER && strncmp(dev->name, "dummy", 5);
}
static int __init init_lmc(void)
{
    return pci_register_driver(&lmc_driver);
}
static void __exit exit_lmc(void)
{
    pci_unregister_driver(&lmc_driver);
}
static int
lmc_hssi_get_link_status (lmc_softc_t * const sc)
{
    return lmc_ssi_get_link_status(sc);
}
static __inline__ u8 sca_get_page(card_t *card)
{
	return inb(card->io + N2_PSR) & PSR_PAGEBITS;
}
static int __init cpc_init(void)
{
	return pci_register_driver(&cpc_driver);
}
static void __exit cpc_cleanup_module(void)
{
	pci_unregister_driver(&cpc_driver);
}
static void __exit pc300_cleanup_module(void)
{
	pci_unregister_driver(&pc300_pci_driver);
}
static void __exit pci200_cleanup_module(void)
{
	pci_unregister_driver(&pci200_pci_driver);
}
static struct net_device_stats *
sbni_get_stats( struct net_device  *dev )
{
	return  &((struct net_local *)netdev_priv(dev))->stats;
}
static void
set_multicast_list( struct net_device  *dev )
{
	return;		/* sbni always operate in promiscuos mode */
}
static inline struct slvl_device* dev_to_chan(struct net_device *dev)
{
	return (struct slvl_device *)dev_to_hdlc(dev)->priv;
}
static int sealevel_ioctl(struct net_device *d, struct ifreq *ifr, int cmd)
{
	return hdlc_ioctl(d, ifr, cmd);
}
static int sealevel_queue_xmit(struct sk_buff *skb, struct net_device *d)
{
	return z8530_queue_xmit(dev_to_chan(d)->chan, skb);
}
static inline port_t* dev_to_port(struct net_device *dev)
{
        return (port_t *)dev_to_hdlc(dev)->priv;
}
static inline port_status_t* get_status(port_t *port)
{
	return &port->card->status->port_status[port->node];
}
static void __exit wanxl_cleanup_module(void)
{
	pci_unregister_driver(&wanxl_pci_driver);
}
static inline void x25_asy_lock(struct x25_asy *sl)
{
	netif_stop_queue(sl->dev);
}
static inline void x25_asy_unlock(struct x25_asy *sl)
{
	netif_wake_queue(sl->dev);
}
static int x25_asy_data_indication(struct net_device *dev, struct sk_buff *skb)
{
	return netif_rx(skb);
}
static inline void write_zsctrl(struct z8530_channel *c, u8 val)
{
	z8530_write_port(c->ctrlio, val);
}
static inline void write_zsdata(struct z8530_channel *c, u8 val)
{
	z8530_write_port(c->dataio, val);
}
void z8530_describe(struct z8530_dev *dev, char *mapping, unsigned long io)
{
	printk(KERN_INFO "%s: %s found at %s 0x%lX, IRQ %d.\n",
		dev->name, 
		z8530_type_name[dev->type],
		mapping,
		Z8530_PORT_OF(io),
		dev->irq);
}
void z8530_null_rx(struct z8530_channel *c, struct sk_buff *skb)
{
	dev_kfree_skb_any(skb);
}
static
struct dentry *debugfs_create_netdev_queue_stopped(
	const char *name, struct dentry *parent, struct i2400m *i2400m)
{
	return debugfs_create_file(name, 0400, parent, i2400m,
				   &fops_netdev_queue_stopped);
}
static
struct dentry *debugfs_create_i2400m_suspend(
	const char *name, struct dentry *parent, struct i2400m *i2400m)
{
	return debugfs_create_file(name, 0200, parent, i2400m,
				   &fops_i2400m_suspend);
}
static
struct dentry *debugfs_create_i2400m_reset(
	const char *name, struct dentry *parent, struct i2400m *i2400m)
{
	return debugfs_create_file(name, 0200, parent, i2400m,
				   &fops_i2400m_reset);
}
void i2400m_debugfs_rm(struct i2400m *i2400m)
{
	debugfs_remove_recursive(i2400m->debugfs_dentry);
}
int i2400m_dev_reset_handle(struct i2400m *i2400m)
{
	return i2400m_schedule_work(i2400m, __i2400m_dev_reset_handle,
				    GFP_ATOMIC);
}
static
int __init i2400m_driver_init(void)
{
	return 0;
}
void i2400ms_tx_release(struct i2400ms *i2400ms)
{
	destroy_workqueue(i2400ms->tx_workqueue);
}
static
int __init i2400ms_driver_init(void)
{
	return sdio_register_driver(&i2400m_sdio_driver);
}
void i2400m_tx_release(struct i2400m *i2400m)
{
	kfree(i2400m->tx_buf);
}
static
void __i2400mu_bm_notif_cb(struct urb *urb)
{
	complete(urb->context);
}
void i2400mu_rx_release(struct i2400mu *i2400mu)
{
	kthread_stop(i2400mu->rx_kthread);
}
void i2400mu_tx_release(struct i2400mu *i2400mu)
{
	kthread_stop(i2400mu->tx_kthread);
}
static
int __init i2400mu_driver_init(void)
{
	return usb_register(&i2400mu_driver);
}
static int __init adm8211_init(void)
{
	return pci_register_driver(&adm8211_driver);
}
static void __exit adm8211_exit(void)
{
	pci_unregister_driver(&adm8211_driver);
}
static inline int bap_read(struct airo_info *ai, __le16 *pu16Dst, int bytelen,
			   int whichbap)
{
	return ai->bap_read(ai, pu16Dst, bytelen, whichbap);
}
static int readWepKeyRid(struct airo_info *ai, WepKeyRid *wkr, int temp, int lock)
{
	return PC4500_readrid(ai, temp ? RID_WEP_TEMP : RID_WEP_PERM,
				wkr, sizeof(*wkr), lock);
}
static int readSsidRid(struct airo_info*ai, SsidRid *ssidr)
{
	return PC4500_readrid(ai, RID_SSID, ssidr, sizeof(*ssidr), 1);
}
static int writeSsidRid(struct airo_info*ai, SsidRid *pssidr, int lock)
{
	return PC4500_writerid(ai, RID_SSID, pssidr, sizeof(*pssidr), lock);
}
static int readStatusRid(struct airo_info *ai, StatusRid *statr, int lock)
{
	return PC4500_readrid(ai, RID_STATUS, statr, sizeof(*statr), lock);
}
static int readAPListRid(struct airo_info *ai, APListRid *aplr)
{
	return PC4500_readrid(ai, RID_APLIST, aplr, sizeof(*aplr), 1);
}
static int writeAPListRid(struct airo_info *ai, APListRid *aplr, int lock)
{
	return PC4500_writerid(ai, RID_APLIST, aplr, sizeof(*aplr), lock);
}
static int readCapabilityRid(struct airo_info *ai, CapabilityRid *capr, int lock)
{
	return PC4500_readrid(ai, RID_CAPABILITIES, capr, sizeof(*capr), lock);
}
static int readStatsRid(struct airo_info*ai, StatsRid *sr, int rid, int lock)
{
	return PC4500_readrid(ai, rid, sr, sizeof(*sr), lock);
}
struct net_device *init_airo_card( unsigned short irq, int port, int is_pcmcia,
				  struct device *dmdev)
{
	return _init_airo_card ( irq, port, is_pcmcia, NULL, dmdev);
}
static void enable_interrupts( struct airo_info *ai ) {
	OUT4500( ai, EVINTEN, STATUS_INTS );
}
static void disable_interrupts( struct airo_info *ai ) {
	OUT4500( ai, EVINTEN, 0 );
}
static int proc_stats_open( struct inode *inode, struct file *file ) {
	return proc_stats_rid_open(inode, file, RID_STATS);
}
static inline int sniffing_mode(struct airo_info *ai)
{
	return le16_to_cpu(ai->config.rmode & RXMODE_MASK) >=
		le16_to_cpu(RXMODE_RFMON);
}
static inline int valid_index(struct airo_info *ai, int index)
{
	return (index >= 0) && (index <= ai->max_wep_idx);
}
static int airo_cs_init(void)
{
	return pcmcia_register_driver(&airo_driver);
}

static void airo_cs_cleanup(void)
{
	pcmcia_unregister_driver(&airo_driver);
}
static inline long us2ticks(int us)
{
	return us * (1000000 / HZ);
}
static inline short
ath5k_ieee2mhz(short chan)
{
	if (chan <= 14 || chan >= 27)
		return ieee80211chan2mhz(chan);
	else
		return 2212 + chan * 20;
}
static int ath5k_start(struct ieee80211_hw *hw)
{
	return ath5k_init(hw->priv);
}
static void ath5k_stop(struct ieee80211_hw *hw)
{
	ath5k_stop_hw(hw->priv);
}
static void *reg_start(struct seq_file *seq, loff_t *pos)
{
	return *pos < ARRAY_SIZE(regs) ? &regs[*pos] : NULL;
}
void
ath5k_debug_init(void)
{
	ath5k_global_debugfs = debugfs_create_dir("ath5k", NULL);
}
void
ath5k_debug_finish(void)
{
	debugfs_remove(ath5k_global_debugfs);
}
static int
ath5k_hw_setup_no_mrr(struct ath5k_hw *ah, struct ath5k_desc *desc,
	unsigned int tx_rate1, u_int tx_tries1, u_int tx_rate2,
	u_int tx_tries2, unsigned int tx_rate3, u_int tx_tries3)
{
	return 0;
}
u32 ath5k_hw_get_rxdp(struct ath5k_hw *ah)
{
	return ath5k_hw_reg_read(ah, AR5K_RXDP);
}
static void ath_ahb_read_cachesize(struct ath_softc *sc, int *csz)
{
	*csz = L1_CACHE_BYTES >> 2;
}
static void ath_ahb_cleanup(struct ath_softc *sc)
{
	iounmap(sc->mem);
}
int ath_ahb_init(void)
{
	return platform_driver_register(&ath_ahb_driver);
}
void ath_ahb_exit(void)
{
	platform_driver_unregister(&ath_ahb_driver);
}
bool ath9k_hw_phycounters(struct ath_hw *ah)
{
	return ah->has_hw_phycounters ? true : false;
}
static int ath9k_hw_4k_get_eeprom_ver(struct ath_hw *ah)
{
	return ((ah->eeprom.map4k.baseEepHeader.version >> 12) & 0xF);
}
static int ath9k_hw_4k_get_eeprom_rev(struct ath_hw *ah)
{
	return ((ah->eeprom.map4k.baseEepHeader.version) & 0xFFF);
}
static u8 ath9k_hw_4k_get_num_ant_config(struct ath_hw *ah,
					 enum ieee80211_band freq_band)
{
	return 1;
}
static int ath9k_hw_def_get_eeprom_ver(struct ath_hw *ah)
{
	return ((ah->eeprom.def.baseEepHeader.version >> 12) & 0xF);
}
static int ath9k_hw_def_get_eeprom_rev(struct ath_hw *ah)
{
	return ((ah->eeprom.def.baseEepHeader.version) & 0xFFF);
}
const char *ath9k_hw_probe(u16 vendorid, u16 devid)
{
	return vendorid == ATHEROS_VENDOR_ID ?
		ath9k_hw_devname(devid) : NULL;
}
static u32 ath9k_hw_ini_fixup(struct ath_hw *ah,
			      struct ar5416_eeprom_def *pEepData,
			      u32 reg, u32 value)
{
	if (ah->eep_map == EEP_MAP_4KBITS)
		return value;
	else
		return ath9k_hw_def_ini_fixup(ah, pEepData, reg, value);
}
static void ath9k_hw_mark_phy_inactive(struct ath_hw *ah)
{
	REG_WRITE(ah, AR_PHY_ACTIVE, AR_PHY_ACTIVE_DIS);
}
enum ath9k_int ath9k_hw_intrget(struct ath_hw *ah)
{
	return ah->mask_reg;
}
void ath9k_hw_set_gpio(struct ath_hw *ah, u32 gpio, u32 val)
{
	REG_RMW(ah, AR_GPIO_IN_OUT, ((val & 1) << gpio),
		AR_GPIO_BIT(gpio));
}
u32 ath9k_hw_getdefantenna(struct ath_hw *ah)
{
	return REG_READ(ah, AR_DEF_ANTENNA) & 0x7;
}
void ath9k_hw_setantenna(struct ath_hw *ah, u32 antenna)
{
	REG_WRITE(ah, AR_DEF_ANTENNA, (antenna & 0x7));
}
bool ath9k_hw_phy_disable(struct ath_hw *ah)
{
	return ath9k_hw_set_reset_reg(ah, ATH9K_RESET_WARM);
}
void ath9k_hw_setmac(struct ath_hw *ah, const u8 *mac)
{
	memcpy(ah->macaddr, mac, ETH_ALEN);
}
void ath9k_hw_setopmode(struct ath_hw *ah)
{
	ath9k_hw_set_operating_mode(ah, ah->opmode);
}
u32 ath9k_hw_gettxbuf(struct ath_hw *ah, u32 q)
{
	return REG_READ(ah, AR_QTXDP(q));
}
void ath9k_hw_putrxbuf(struct ath_hw *ah, u32 rxdp)
{
	REG_WRITE(ah, AR_RXDP, rxdp);
}
void ath9k_hw_rxena(struct ath_hw *ah)
{
	REG_WRITE(ah, AR_CR, AR_CR_RXE);
}
int __init ath_pci_init(void)
{
	return pci_register_driver(&ath_pci_driver);
}
void ath_pci_exit(void)
{
	pci_unregister_driver(&ath_pci_driver);
}
void
ath9k_hw_write_regs(struct ath_hw *ah, u32 modesIndex, u32 freqIndex,
		    int regWrites)
{
	REG_WRITE_ARRAY(&ah->iniBB_RfGain, freqIndex, regWrites);
}
static void *ath_rate_alloc(struct ieee80211_hw *hw, struct dentry *debugfsdir)
{
	return hw->priv;
}
static void ath_rate_free(void *priv)
{
	return;
}
int ath_rate_control_register(void)
{
	return ieee80211_rate_control_register(&ath_rate_ops);
}
void ath_rate_control_unregister(void)
{
	ieee80211_rate_control_unregister(&ath_rate_ops);
}
static u16 ath9k_regd_get_eepromRD(struct ath_hw *ah)
{
	return ah->regulatory.current_rd & ~WORLDWIDE_ROAMING_FLAG;
}
u16 ath9k_regd_get_rd(struct ath_hw *ah)
{
	return ath9k_regd_get_eepromRD(ah);
}
bool ath9k_is_world_regd(struct ath_hw *ah)
{
	return isWwrSKU(ah);
}
const struct ieee80211_regdomain *ath9k_default_world_regdomain(void)
{
	return &ath9k_world_regdom_64;
}
static bool ath9k_is_radar_freq(u16 center_freq)
{
	return (center_freq >= 5260 && center_freq <= 5700);
}
static u32 ath_txq_depth(struct ath_softc *sc, int qnum)
{
	return sc->tx.txq[qnum].axq_depth;
}
static inline u16 atmel_hi(struct atmel_private *priv, u16 offset)
{
	return priv->host_info_base + offset;
}
static inline u16 atmel_co(struct atmel_private *priv, u16 offset)
{
	return priv->host_info.command_pos + offset;
}
static inline u16 atmel_rx(struct atmel_private *priv, u16 offset, u16 desc)
{
	return priv->host_info.rx_desc_pos + (sizeof(struct rx_desc) * desc) + offset;
}
static inline u16 atmel_tx(struct atmel_private *priv, u16 offset, u16 desc)
{
	return priv->host_info.tx_desc_pos + (sizeof(struct tx_desc) * desc) + offset;
}
static inline u8 atmel_read8(struct net_device *dev, u16 offset)
{
	return inb(dev->base_addr + offset);
}
static inline void atmel_write8(struct net_device *dev, u16 offset, u8 data)
{
	outb(data, dev->base_addr + offset);
}
static inline u16 atmel_read16(struct net_device *dev, u16 offset)
{
	return inw(dev->base_addr + offset);
}
static inline void atmel_write16(struct net_device *dev, u16 offset, u16 data)
{
	outw(data, dev->base_addr + offset);
}
static int atmel_config_commit(struct net_device *dev,
			       struct iw_request_info *info,	/* NULL */
			       void *zwrq,			/* NULL */
			       char *extra)			/* NULL */
{
	return atmel_open(dev);
}
static int is_frame_from_current_bss(struct atmel_private *priv,
				     struct ieee80211_hdr *header)
{
	if (le16_to_cpu(header->frame_control) & IEEE80211_FCTL_FROMDS)
		return memcmp(header->addr3, priv->CurrentBSSID, 6) == 0;
	else
		return memcmp(header->addr2, priv->CurrentBSSID, 6) == 0;
}
static void atmel_set_gcr(struct net_device *dev, u16 mask)
{
	outw(inw(dev->base_addr + GCR) | mask, dev->base_addr + GCR);
}
static void atmel_clear_gcr(struct net_device *dev, u16 mask)
{
	outw(inw(dev->base_addr + GCR) & ~mask, dev->base_addr + GCR);
}
static int atmel_cs_init(void)
{
        return pcmcia_register_driver(&atmel_driver);
}

static void atmel_cs_cleanup(void)
{
        pcmcia_unregister_driver(&atmel_driver);
}
static void __devexit atmel_pci_remove(struct pci_dev *pdev)
{
	stop_atmel_card(pci_get_drvdata(pdev));
}
static int __init atmel_init_module(void)
{
	return pci_register_driver(&atmel_driver);
}
static void __exit atmel_cleanup_module(void)
{
	pci_unregister_driver(&atmel_driver);
}
void b43_debugfs_exit(void)
{
	debugfs_remove(rootdir);
}
static void op32_poke_tx(struct b43_dmaring *ring, int slot)
{
	b43_dma_write(ring, B43_DMA32_TXINDEX,
		      (u32) (slot * sizeof(struct b43_dmadesc32)));
}
static void op32_tx_suspend(struct b43_dmaring *ring)
{
	b43_dma_write(ring, B43_DMA32_TXCTL, b43_dma_read(ring, B43_DMA32_TXCTL)
		      | B43_DMA32_TXSUSPEND);
}
static void op32_tx_resume(struct b43_dmaring *ring)
{
	b43_dma_write(ring, B43_DMA32_TXCTL, b43_dma_read(ring, B43_DMA32_TXCTL)
		      & ~B43_DMA32_TXSUSPEND);
}
static void op32_set_current_rxslot(struct b43_dmaring *ring, int slot)
{
	b43_dma_write(ring, B43_DMA32_RXINDEX,
		      (u32) (slot * sizeof(struct b43_dmadesc32)));
}
static void op64_poke_tx(struct b43_dmaring *ring, int slot)
{
	b43_dma_write(ring, B43_DMA64_TXINDEX,
		      (u32) (slot * sizeof(struct b43_dmadesc64)));
}
static void op64_tx_suspend(struct b43_dmaring *ring)
{
	b43_dma_write(ring, B43_DMA64_TXCTL, b43_dma_read(ring, B43_DMA64_TXCTL)
		      | B43_DMA64_TXSUSPEND);
}
static void op64_tx_resume(struct b43_dmaring *ring)
{
	b43_dma_write(ring, B43_DMA64_TXCTL, b43_dma_read(ring, B43_DMA64_TXCTL)
		      & ~B43_DMA64_TXSUSPEND);
}
static void op64_set_current_rxslot(struct b43_dmaring *ring, int slot)
{
	b43_dma_write(ring, B43_DMA64_RXINDEX,
		      (u32) (slot * sizeof(struct b43_dmadesc64)));
}
static inline int free_slots(struct b43_dmaring *ring)
{
	return (ring->nr_slots - ring->used_slots);
}
static void b43_short_slot_timing_enable(struct b43_wldev *dev)
{
	b43_set_slot_time(dev, 9);
}
static void b43_short_slot_timing_disable(struct b43_wldev *dev)
{
	b43_set_slot_time(dev, 20);
}
static void b43_periodic_every30sec(struct b43_wldev *dev)
{
	b43_calculate_link_quality(dev);
}
int b43_pcmcia_init(void)
{
	return pcmcia_register_driver(&b43_pcmcia_driver);
}
void b43_pcmcia_exit(void)
{
	pcmcia_unregister_driver(&b43_pcmcia_driver);
}
static bool b43_aphy_op_supports_hwpctl(struct b43_wldev *dev)
{
	return (dev->phy.rev >= 5);
}
static unsigned int b43_aphy_op_get_default_chan(struct b43_wldev *dev)
{
	return 36; /* Default to channel 36 */
}
static enum b43_txpwr_result b43_aphy_op_recalc_txpower(struct b43_wldev *dev,
							bool ignore_tssi)
{//TODO
	return B43_TXPWR_RES_DONE;
}
void b43_radio_mask(struct b43_wldev *dev, u16 offset, u16 mask)
{
	b43_radio_write16(dev, offset,
			  b43_radio_read16(dev, offset) & mask);
}
void b43_radio_set(struct b43_wldev *dev, u16 offset, u16 set)
{
	b43_radio_write16(dev, offset,
			  b43_radio_read16(dev, offset) | set);
}
void b43_radio_maskset(struct b43_wldev *dev, u16 offset, u16 mask, u16 set)
{
	b43_radio_write16(dev, offset,
			  (b43_radio_read16(dev, offset) & mask) | set);
}
void b43_phy_mask(struct b43_wldev *dev, u16 offset, u16 mask)
{
	b43_phy_write(dev, offset,
		      b43_phy_read(dev, offset) & mask);
}
void b43_phy_set(struct b43_wldev *dev, u16 offset, u16 set)
{
	b43_phy_write(dev, offset,
		      b43_phy_read(dev, offset) | set);
}
void b43_phy_maskset(struct b43_wldev *dev, u16 offset, u16 mask, u16 set)
{
	b43_phy_write(dev, offset,
		      (b43_phy_read(dev, offset) & mask) | set);
}
void b43_phyop_switch_analog_generic(struct b43_wldev *dev, bool on)
{
	b43_write16(dev, B43_MMIO_PHY0, on ? 0 : 0xF4);
}
static s32 b43_tssi2dbm_ad(s32 num, s32 den)
{
	if (num < 0)
		return num / den;
	else
		return (num + den / 2) / den;
}
static void b43_gphy_op_exit(struct b43_wldev *dev)
{
	b43_lo_g_cleanup(dev);
}
static bool b43_gphy_op_supports_hwpctl(struct b43_wldev *dev)
{
	return (dev->phy.rev >= 6);
}
static unsigned int b43_gphy_op_get_default_chan(struct b43_wldev *dev)
{
	return 1; /* Default to channel 1 */
}
static void lpphy_baseband_rev0_1_init(struct b43_wldev *dev)
{
	B43_WARN_ON(1);//TODO rev < 2 not supported, yet.
}
static int b43_lpphy_op_switch_channel(struct b43_wldev *dev,
				       unsigned int new_channel)
{
	return 0;
}
static enum b43_txpwr_result b43_lpphy_op_recalc_txpower(struct b43_wldev *dev,
							 bool ignore_tssi)
{
	return B43_TXPWR_RES_DONE;
}
static enum b43_txpwr_result b43_nphy_op_recalc_txpower(struct b43_wldev *dev,
							bool ignore_tssi)
{//TODO
	return B43_TXPWR_RES_DONE;
}
void b43_nphy_radio_turn_on(struct b43_wldev *dev)
{
	b43_radio_init2055(dev);
}
void b43_nphy_radio_turn_off(struct b43_wldev *dev)
{
	b43_phy_mask(dev, B43_NPHY_RFCTL_CMD,
		     ~B43_NPHY_RFCTL_CMD_EN);
}
static int b43_nphy_op_init(struct b43_wldev *dev)
{
	return b43_phy_initn(dev);
}
static void b43_nphy_op_switch_analog(struct b43_wldev *dev, bool on)
{
	b43_phy_write(dev, B43_NPHY_AFECTL_OVER,
		      on ? 0 : 0x7FFF);
}
void b43_pio_rx(struct b43_pio_rxqueue *q)
{
	queue_work(q->dev->wl->hw->workqueue, &q->rx_work);
}
static void b43_wa_auxclipthr(struct b43_wldev *dev)
{
	b43_phy_write(dev, B43_PHY_OFDM(0x8E), 0x3800);
}
static void b43_wa_txdc_offset(struct b43_wldev *dev)
{
	b43_ofdmtab_write16(dev, B43_OFDMTAB_DC, 0, 0x0051);
}
static void b43_wa_txlna_gain(struct b43_wldev *dev)
{
	b43_ofdmtab_write16(dev, B43_OFDMTAB_DC, 13, 0x0000);
}
static void b43_wa_crs_reset(struct b43_wldev *dev)
{
	b43_phy_write(dev, 0x002C, 0x0064);
}
static void b43_wa_2060txlna_gain(struct b43_wldev *dev)
{
	b43_hf_write(dev, b43_hf_read(dev) |
			 B43_HF_2060W);
}
static void b43_wa_lms(struct b43_wldev *dev)
{
	b43_phy_write(dev, 0x0055,
		(b43_phy_read(dev, 0x0055) & 0xFFC0) | 0x0004);
}
static void b43_wa_mixedsignal(struct b43_wldev *dev)
{
	b43_ofdmtab_write16(dev, B43_OFDMTAB_DAC, 1, 3);
}
static void b43_wa_crs_thr(struct b43_wldev *dev)
{
	b43_phy_write(dev, B43_PHY_CRS0,
			(b43_phy_read(dev, B43_PHY_CRS0) & ~0x03C0) | 0xD000);
}
static void b43_wa_crs_blank(struct b43_wldev *dev)
{
	b43_phy_write(dev, B43_PHY_OFDM(0x2C), 0x005A);
}
static void b43_wa_cck_shiftbits(struct b43_wldev *dev)
{
	b43_phy_write(dev, B43_PHY_CCKSHIFTBITS, 0x0026);
}
static void b43_wa_tr_ltov(struct b43_wldev *dev) /* TR Lookup Table Original Values */
{
	b43_gtab_write(dev, B43_GTAB_ORIGTR, 0, 0xC480);
}
int b43legacy_debug(struct b43legacy_wldev *dev, enum b43legacy_dyndbg feature)
{
	return !!(dev->dfsentry && dev->dfsentry->dyn_debug[feature]);
}
void b43legacy_debugfs_exit(void)
{
	debugfs_remove(rootdir);
}
static void op32_poke_tx(struct b43legacy_dmaring *ring, int slot)
{
	b43legacy_dma_write(ring, B43legacy_DMA32_TXINDEX,
			    (u32)(slot * sizeof(struct b43legacy_dmadesc32)));
}
static void op32_tx_suspend(struct b43legacy_dmaring *ring)
{
	b43legacy_dma_write(ring, B43legacy_DMA32_TXCTL,
			    b43legacy_dma_read(ring, B43legacy_DMA32_TXCTL)
			    | B43legacy_DMA32_TXSUSPEND);
}
static void op32_tx_resume(struct b43legacy_dmaring *ring)
{
	b43legacy_dma_write(ring, B43legacy_DMA32_TXCTL,
			    b43legacy_dma_read(ring, B43legacy_DMA32_TXCTL)
			    & ~B43legacy_DMA32_TXSUSPEND);
}
static void op32_set_current_rxslot(struct b43legacy_dmaring *ring,
				    int slot)
{
	b43legacy_dma_write(ring, B43legacy_DMA32_RXINDEX,
			    (u32)(slot * sizeof(struct b43legacy_dmadesc32)));
}
static void op64_poke_tx(struct b43legacy_dmaring *ring, int slot)
{
	b43legacy_dma_write(ring, B43legacy_DMA64_TXINDEX,
			    (u32)(slot * sizeof(struct b43legacy_dmadesc64)));
}
static void op64_tx_suspend(struct b43legacy_dmaring *ring)
{
	b43legacy_dma_write(ring, B43legacy_DMA64_TXCTL,
			    b43legacy_dma_read(ring, B43legacy_DMA64_TXCTL)
			    | B43legacy_DMA64_TXSUSPEND);
}
static void op64_tx_resume(struct b43legacy_dmaring *ring)
{
	b43legacy_dma_write(ring, B43legacy_DMA64_TXCTL,
			    b43legacy_dma_read(ring, B43legacy_DMA64_TXCTL)
			    & ~B43legacy_DMA64_TXSUSPEND);
}
static void op64_set_current_rxslot(struct b43legacy_dmaring *ring,
				    int slot)
{
	b43legacy_dma_write(ring, B43legacy_DMA64_RXINDEX,
			    (u32)(slot * sizeof(struct b43legacy_dmadesc64)));
}
static inline int free_slots(struct b43legacy_dmaring *ring)
{
	return (ring->nr_slots - ring->used_slots);
}
static void free_ringmemory(struct b43legacy_dmaring *ring)
{
	ssb_dma_free_consistent(ring->dev->dev, B43legacy_DMA_RINGMEMSIZE,
				ring->descbase, ring->dmabase, GFP_KERNEL);
}
static void b43legacy_short_slot_timing_enable(struct b43legacy_wldev *dev)
{
	b43legacy_set_slot_time(dev, 9);
}
static void b43legacy_short_slot_timing_disable(struct b43legacy_wldev *dev)
{
	b43legacy_set_slot_time(dev, 20);
}
static void b43legacy_switch_analog(struct b43legacy_wldev *dev, int on)
{
	b43legacy_write16(dev, B43legacy_MMIO_PHY0, on ? 0 : 0xF4);
}
static void b43legacy_print_fw_helptext(struct b43legacy_wl *wl)
{
	b43legacyerr(wl, "You must go to http://linuxwireless.org/en/users/"
		     "Drivers/b43#devicefirmware "
		     "and download the correct firmware (version 3).\n");
}
static void b43legacy_periodic_every30sec(struct b43legacy_wldev *dev)
{
	b43legacy_calculate_link_quality(dev);
}
static int b43legacy_op_conf_tx(struct ieee80211_hw *hw, u16 queue,
				const struct ieee80211_tx_queue_params *params)
{
	return 0;
}
static void b43legacy_wireless_core_detach(struct b43legacy_wldev *dev)
{
	b43legacy_release_firmware(dev);
}
static inline
s32 b43legacy_tssi2dbm_ad(s32 num, s32 den)
{
	if (num < 0)
		return num/den;
	else
		return (num+den/2)/den;
}
static void tx_start(struct b43legacy_pioqueue *queue)
{
	b43legacy_pio_write(queue, B43legacy_PIO_TXCTL,
			    B43legacy_PIO_TXCTL_INIT);
}
int b43legacy_generate_txhdr(struct b43legacy_wldev *dev,
			      u8 *txhdr,
			      const unsigned char *fragment_data,
			      unsigned int fragment_len,
			      struct ieee80211_tx_info *info,
			      u16 cookie)
{
	return generate_txhdr_fw3(dev, (struct b43legacy_txhdr_fw3 *)txhdr,
			   fragment_data, fragment_len,
			   info, cookie);
}
void b43legacy_qos_init(struct b43legacy_wldev *dev)
{
return;
}
static int __init init_prism2_pccard(void)
{
	return pcmcia_register_driver(&hostap_driver);
}
static void __exit exit_prism2_pccard(void)
{
	pcmcia_unregister_driver(&hostap_driver);
}
static u16 hfa384x_read_reg(struct net_device *dev, u16 reg)
{
	return HFA384X_INW(reg);
}
static inline int hfa384x_cmd_no_wait(struct net_device *dev, u16 cmd,
				      u16 param0)
{
	return __hfa384x_cmd_no_wait(dev, cmd, param0, 6);
}
static void hfa384x_events_no_bap0(struct net_device *dev)
{
	HFA384X_OUTW(HFA384X_EVENT_MASK & ~HFA384X_BAP0_EVENTS,
		     HFA384X_INTEN_OFF);
}
static void hfa384x_events_all(struct net_device *dev)
{
	HFA384X_OUTW(HFA384X_EVENT_MASK, HFA384X_INTEN_OFF);
}
static void hfa384x_events_only_cmd(struct net_device *dev)
{
	HFA384X_OUTW(HFA384X_EV_CMD, HFA384X_INTEN_OFF);
}
static void prism2_schedule_reset(local_info_t *local)
{
	schedule_work(&local->reset_queue);
}
static void prism2_set_lockdep_class_one(struct net_device *dev,
					 struct netdev_queue *txq,
					 void *_unused)
{
	lockdep_set_class(&txq->_xmit_lock,
			  &hostap_netdev_xmit_lock_key);
}
static int prism2_ioctl_siwap(struct net_device *dev,
			      struct iw_request_info *info,
			      struct sockaddr *ap_addr, char *extra)
{
	return -EOPNOTSUPP;
}
static int prism2_ioctl_siwpower(struct net_device *dev,
				 struct iw_request_info *info,
				 struct iw_param *wrq, char *extra)
{
	return -EOPNOTSUPP;
}
static int prism2_ioctl_giwpower(struct net_device *dev,
				 struct iw_request_info *info,
				 struct iw_param *rrq, char *extra)
{
	return -EOPNOTSUPP;
}
static inline int prism2_request_hostscan(struct net_device *dev,
					  u8 *ssid, u8 ssid_len)
{
	return -EOPNOTSUPP;
}
static inline int prism2_request_scan(struct net_device *dev)
{
	return -EOPNOTSUPP;
}
static inline int prism2_ioctl_giwscan_sta(struct net_device *dev,
					   struct iw_request_info *info,
					   struct iw_point *data, char *extra)
{
	return -EOPNOTSUPP;
}
static int prism2_ioctl_siwgenie(struct net_device *dev,
				 struct iw_request_info *info,
				 struct iw_point *data, char *extra)
{
	return prism2_set_genericelement(dev, extra, data->length);
}
static int __init init_prism2_pci(void)
{
	return pci_register_driver(&prism2_pci_driver);
}
static void __exit exit_prism2_pci(void)
{
	pci_unregister_driver(&prism2_pci_driver);
}
static int __init init_prism2_plx(void)
{
	return pci_register_driver(&prism2_plx_driver);
}
static void __exit exit_prism2_plx(void)
{
	pci_unregister_driver(&prism2_plx_driver);
}
static inline void write_nic_auto_inc_address(struct net_device *dev, u32 addr)
{
	write_register(dev, IPW_REG_AUTOINCREMENT_ADDRESS,
		       addr & IPW_REG_INDIRECT_ADDR_MASK);
}
static inline void write_nic_dword_auto_inc(struct net_device *dev, u32 val)
{
	write_register(dev, IPW_REG_AUTOINCREMENT_DATA, val);
}
static inline int ipw2100_hw_is_adapter_in_system(struct net_device *dev)
{
	return (dev->base_addr &&
		(readl
		 ((void __iomem *)(dev->base_addr +
				   IPW_REG_DOA_DEBUG_AREA_START))
		 == IPW_DATA_DOA_DEBUG_VALUE));
}
static void ipw2100_scan_event_later(struct work_struct *work)
{
	send_scan_event(container_of(work, struct ipw2100_priv,
					scan_event_later.work));
}
static void ipw2100_scan_event_now(struct work_struct *work)
{
	send_scan_event(container_of(work, struct ipw2100_priv,
					scan_event_now));
}
static ssize_t show_debug_level(struct device_driver *d, char *buf)
{
	return sprintf(buf, "0x%08X\n", ipw2100_debug_level);
}
static void ipw_write_direct(struct ipw_priv *priv, u32 addr, void *buf,
			     int num)
{
	memcpy_toio((priv->hw_base + addr), buf, num);
}
static inline void ipw_set_bit(struct ipw_priv *priv, u32 reg, u32 mask)
{
	ipw_write32(priv, reg, ipw_read32(priv, reg) | mask);
}
static inline void ipw_clear_bit(struct ipw_priv *priv, u32 reg, u32 mask)
{
	ipw_write32(priv, reg, ipw_read32(priv, reg) & ~mask);
}
static inline int ipw_is_init(struct ipw_priv *priv)
{
	return (priv->status & STATUS_INIT) ? 1 : 0;
}
static void ipw_led_radio_on(struct ipw_priv *priv)
{
	ipw_led_link_on(priv);
}
static void ipw_led_link_up(struct ipw_priv *priv)
{
	ipw_led_link_on(priv);
}
static ssize_t show_debug_level(struct device_driver *d, char *buf)
{
	return sprintf(buf, "0x%08X\n", ipw_debug_level);
}
static inline u32 ipw_get_event_log_len(struct ipw_priv *priv)
{
	return ipw_read_reg32(priv, ipw_read32(priv, IPW_EVENT_LOG));
}
static int ipw_send_system_config(struct ipw_priv *priv)
{
	return ipw_send_cmd_pdu(priv, IPW_CMD_SYSTEM_CONFIG,
				sizeof(priv->sys_config),
				&priv->sys_config);
}
static int ipw_send_scan_request_ext(struct ipw_priv *priv,
				     struct ipw_scan_request_ext *request)
{
	return ipw_send_cmd_pdu(priv, IPW_CMD_SCAN_REQUEST_EXT,
				sizeof(*request), request);
}
static void eeprom_parse_mac(struct ipw_priv *priv, u8 * mac)
{
	memcpy(mac, &priv->eeprom[EEPROM_MAC_ADDRESS], 6);
}
static inline void ipw_fw_dma_reset_command_blocks(struct ipw_priv *priv)
{
	ipw_zero_memory(priv, IPW_SHARED_SRAM_DMA_CONTROL,
			CB_NUMBER_OF_ELEMENTS_SMALL *
			sizeof(struct command_block));
}
static inline int ipw_alive(struct ipw_priv *priv)
{
	return ipw_read32(priv, 0x90) == 0xd55555d5;
}
static inline int ipw_queue_inc_wrap(int index, int n_bd)
{
	return (++index == n_bd) ? 0 : index;
}
static void inline average_init(struct average *avg)
{
	memset(avg, 0, sizeof(*avg));
}
static s16 exponential_average(s16 prev_avg, s16 val, u8 depth)
{
	return ((depth-1)*prev_avg +  val)/depth;
}
static int ipw_passive_dwell_time(struct ipw_priv *priv)
{
	if (priv->status & STATUS_ASSOCIATED
	    && priv->assoc_network->beacon_interval > 10)
		return priv->assoc_network->beacon_interval - 10;
	else
		return 120;
}
static void ipw_wpa_assoc_frame(struct ipw_priv *priv, char *wpa_ie,
				int wpa_ie_len)
{
	ipw_wpa_enable(priv, 1);
}
static int ipw_send_qos_params_command(struct ipw_priv *priv, struct ieee80211_qos_parameters
				       *qos_param)
{
	return ipw_send_cmd_pdu(priv, IPW_CMD_QOS_PARAMETERS,
				sizeof(*qos_param) * 3, qos_param);
}
static int ipw_send_qos_info_command(struct ipw_priv *priv, struct ieee80211_qos_information_element
				     *qos_param)
{
	return ipw_send_cmd_pdu(priv, IPW_CMD_WME_INFO, sizeof(*qos_param),
				qos_param);
}
static int ipw_ethtool_get_eeprom_len(struct net_device *dev)
{
	return IPW_EEPROM_IMAGE_SIZE;
}
const struct ieee80211_geo *ieee80211_get_geo(struct ieee80211_device *ieee)
{
	return &ieee->geo;
}
static int show_debug_level(char *page, char **start, off_t offset,
			    int count, int *eof, void *data)
{
	return snprintf(page, count, "0x%08X\n", ieee80211_debug_level);
}
static inline int is_same_network(struct ieee80211_network *src,
				  struct ieee80211_network *dst)
{
	return ((src->ssid_len == dst->ssid_len) &&
		(src->channel == dst->channel) &&
		!compare_ether_addr(src->bssid, dst->bssid) &&
		!memcmp(src->ssid, dst->ssid, src->ssid_len));
}
static inline int is_beacon(__le16 fc)
{
	return (WLAN_FC_GET_STYPE(le16_to_cpu(fc)) == IEEE80211_STYPE_BEACON);
}
static int iwl3945_led_cmd_callback(struct iwl_priv *priv,
				    struct iwl_cmd *cmd,
				    struct sk_buff *skb)
{
	return 1;
}
static inline int iwl3945_brightness_to_idx(enum led_brightness brightness)
{
	return fls(0x000000FF & (u32)brightness);
}
static inline int is_rf_kill(struct iwl_priv *priv)
{
	return test_bit(STATUS_RF_KILL_HW, &priv->status) ||
		test_bit(STATUS_RF_KILL_SW, &priv->status);
}
static void *rs_alloc(struct ieee80211_hw *hw, struct dentry *debugfsdir)
{
	return hw->priv;
}
static void rs_free(void *priv)
{
	return;
}
int iwl3945_rate_control_register(void)
{
	return ieee80211_rate_control_register(&rs_ops);
}
void iwl3945_rate_control_unregister(void)
{
	ieee80211_rate_control_unregister(&rs_ops);
}
static inline const char *iwl3945_get_tx_fail_reason(u32 status)
{
	return "";
}
static int iwl3945_hw_reg_adjust_power_by_temp(int new_reading, int old_reading)
{
	return (new_reading - old_reading) * (-11) / 100;
}
static inline int iwl3945_hw_reg_temp_out_of_range(int temperature)
{
	return ((temperature < -260) || (temperature > 25)) ? 1 : 0;
}
int iwl3945_hw_get_temperature(struct iwl_priv *priv)
{
	return iwl_read32(priv, CSR_UCODE_DRV_GP2);
}
int iwl3945_hw_channel_switch(struct iwl_priv *priv, u16 channel)
{
	return 0;
}
void iwl3945_hw_setup_deferred_work(struct iwl_priv *priv)
{
	INIT_DELAYED_WORK(&priv->thermal_periodic,
			  iwl3945_bg_reg_txpower_periodic);
}
void iwl3945_hw_cancel_deferred_work(struct iwl_priv *priv)
{
	cancel_delayed_work(&priv->thermal_periodic);
}
static void iwl3945_eeprom_release_semaphore(struct iwl_priv *priv)
{
	return;
}
static int is_fat_channel(__le32 rxon_flags)
{
	return (rxon_flags & RXON_FLG_CHANNEL_MODE_PURE_40_MSK) ||
		(rxon_flags & RXON_FLG_CHANNEL_MODE_MIXED_MSK);
}
static u16 iwl4965_eeprom_calib_version(struct iwl_priv *priv)
{
	return iwl_eeprom_query16(priv, EEPROM_4965_CALIB_VERSION_OFFSET);
}
static void iwl4965_txq_set_sched(struct iwl_priv *priv, u32 mask)
{
	iwl_write_prph(priv, IWL49_SCD_TXFACT, mask);
}
static void iwl4965_tx_queue_stop_scheduler(struct iwl_priv *priv,
					    u16 txq_id)
{
	iwl_write_prph(priv,
		IWL49_SCD_QUEUE_STATUS_BITS(txq_id),
		(0 << IWL49_SCD_QUEUE_STTS_REG_POS_ACTIVE)|
		(1 << IWL49_SCD_QUEUE_STTS_REG_POS_SCD_ACT_EN));
}
static inline u32 iwl4965_get_scd_ssn(struct iwl4965_tx_resp *tx_resp)
{
	return le32_to_cpup(&tx_resp->u.status + tx_resp->frame_count) & MAX_SN;
}
static void iwl4965_setup_deferred_work(struct iwl_priv *priv)
{
	INIT_WORK(&priv->txpower_work, iwl4965_bg_txpower_work);
}
static void iwl4965_cancel_deferred_work(struct iwl_priv *priv)
{
	cancel_work_sync(&priv->txpower_work);
}
static void iwl5000_tx_queue_stop_scheduler(struct iwl_priv *priv, u16 txq_id)
{
	iwl_write_prph(priv,
		IWL50_SCD_QUEUE_STATUS_BITS(txq_id),
		(0 << IWL50_SCD_QUEUE_STTS_REG_POS_ACTIVE)|
		(1 << IWL50_SCD_QUEUE_STTS_REG_POS_SCD_ACT_EN));
}
static void iwl5000_txq_set_sched(struct iwl_priv *priv, u32 mask)
{
	iwl_write_prph(priv, IWL50_SCD_TXFACT, mask);
}
static inline u32 iwl5000_get_scd_ssn(struct iwl5000_tx_resp *tx_resp)
{
	return le32_to_cpup((__le32 *)&tx_resp->status +
			    tx_resp->frame_count) & MAX_SN;
}
u16 iwl5000_get_hcmd_size(u8 cmd_id, u16 len)
{
	return len;
}
static void iwl5000_setup_deferred_work(struct iwl_priv *priv)
{
	priv->disable_tx_power_cal = 1;
}
static int iwl5000_hw_valid_rtc_data_addr(u32 addr)
{
	return (addr >= IWL50_RTC_DATA_LOWER_BOUND) &&
		(addr < IWL50_RTC_DATA_UPPER_BOUND);
}
static void iwl5000_temperature(struct iwl_priv *priv)
{
	priv->temperature = le32_to_cpu(priv->statistics.general.temperature);
}
static inline u8 rs_extract_rate(u32 rate_n_flags)
{
	return (u8)(rate_n_flags & 0xFF);
}
static inline u8 rs_is_valid_ant(u8 valid_antenna, u8 ant_type)
{
	return (ant_type & valid_antenna) == ant_type;
}
static inline int get_num_of_ant_from_rate(u32 rate_n_flags)
{
	return !!(rate_n_flags & RATE_MCS_ANT_A_MSK) +
	       !!(rate_n_flags & RATE_MCS_ANT_B_MSK) +
	       !!(rate_n_flags & RATE_MCS_ANT_C_MSK);
}
static inline u8 rs_use_green(struct iwl_priv *priv, struct ieee80211_conf *conf)
{
	return 0;
}
static void *rs_alloc(struct ieee80211_hw *hw, struct dentry *debugfsdir)
{
	return hw->priv;
}
static void rs_free(void *priv_rate)
{
	return;
}
int iwlagn_rate_control_register(void)
{
	return ieee80211_rate_control_register(&rs_ops);
}
void iwlagn_rate_control_unregister(void)
{
	ieee80211_rate_control_unregister(&rs_ops);
}
static inline u8 iwl_tfd_get_num_tbs(struct iwl_tfd *tfd)
{
	return tfd->num_tbs & 0x1f;
}
static void iwl_nic_start(struct iwl_priv *priv)
{
	iwl_write32(priv, CSR_RESET, 0);
}
static bool is_single_rx_stream(struct iwl_priv *priv)
{
	return !priv->current_ht_config.is_ht ||
	       ((priv->current_ht_config.mcs.rx_mask[1] == 0) &&
		(priv->current_ht_config.mcs.rx_mask[2] == 0));
}
static bool iwl_is_monitor_mode(struct iwl_priv *priv)
{
	return !!(priv->staging_rxon.filter_flags & RXON_FILTER_PROMISC_MSK);
}
void iwlcore_eeprom_release_semaphore(struct iwl_priv *priv)
{
	iwl_clear_bit(priv, CSR_HW_IF_CONFIG_REG,
		CSR_HW_IF_CONFIG_REG_BIT_EEPROM_OWN_SEM);
}
const u8 *iwl_eeprom_query_addr(const struct iwl_priv *priv, size_t offset)
{
	return priv->cfg->ops->lib->eeprom_ops.query_addr(priv, offset);
}
u16 iwl_eeprom_query16(const struct iwl_priv *priv, size_t offset)
{
	return (u16)priv->eeprom[offset] | ((u16)priv->eeprom[offset + 1] << 8);
}
static inline int iwl_brightness_to_idx(enum led_brightness brightness)
{
	return fls(0x000000FF & (u32)brightness);
}
static int iwl_set_power(struct iwl_priv *priv, void *cmd)
{
	return iwl_send_cmd_pdu_async(priv, POWER_TABLE_CMD,
				      sizeof(struct iwl_powertable_cmd),
				      cmd, NULL);
}
void iwl_setup_power_deferred_work(struct iwl_priv *priv)
{
	INIT_DELAYED_WORK(&priv->set_power_save, iwl_bg_set_power_save);
}
void iwl_power_cancel_timeout(struct iwl_priv *priv)
{
	cancel_delayed_work(&priv->set_power_save);
}
static inline __le32 iwl_dma_addr2rbd_ptr(struct iwl_priv *priv,
					  dma_addr_t dma_addr)
{
	return cpu_to_le32((u32)(dma_addr >> 8));
}
static inline int iwl_calc_rssi(struct iwl_priv *priv,
				struct iwl_rx_phy_res *rx_resp)
{
	return priv->cfg->ops->utils->calc_rssi(priv, rx_resp);
}
inline u16 iwl_get_active_dwell_time(struct iwl_priv *priv,
				     enum ieee80211_band band,
				     u8 n_probes)
{
	if (band == IEEE80211_BAND_5GHZ)
		return IWL_ACTIVE_DWELL_TIME_52 +
			IWL_ACTIVE_DWELL_FACTOR_52GHZ * (n_probes + 1);
	else
		return IWL_ACTIVE_DWELL_TIME_24 +
			IWL_ACTIVE_DWELL_FACTOR_24GHZ * (n_probes + 1);
}
void iwl_setup_spectrum_handlers(struct iwl_priv *priv)
{
	priv->rx_handlers[SPECTRUM_MEASURE_NOTIFICATION] =
			iwl_rx_spectrum_measure_notif;
}
static int iwl3945_send_qos_params_command(struct iwl_priv *priv,
				       struct iwl_qosparam_cmd *qos)
{
	return iwl_send_cmd_pdu(priv, REPLY_QOS_PARAM,
				sizeof(struct iwl_qosparam_cmd), qos);
}
static inline __le32 iwl3945_dma_addr2rbd_ptr(struct iwl_priv *priv,
					  dma_addr_t dma_addr)
{
	return cpu_to_le32((u32)dma_addr);
}
static void iwl3945_nic_start(struct iwl_priv *priv)
{
	iwl_write32(priv, CSR_RESET, 0);
}
static ssize_t show_channels(struct device *d,
			     struct device_attribute *attr, char *buf)
{
	return 0;
}
static inline int match_bss_no_security(struct lbs_802_11_security *secinfo,
					struct bss_descriptor *match_bss)
{
	if (!secinfo->wep_enabled  && !secinfo->WPAenabled
	    && !secinfo->WPA2enabled
	    && match_bss->wpa_ie[0] != WLAN_EID_GENERIC
	    && match_bss->rsn_ie[0] != WLAN_EID_RSN
	    && !(match_bss->capability & WLAN_CAPABILITY_PRIVACY))
		return 1;
	else
		return 0;
}
static inline int match_bss_static_wep(struct lbs_802_11_security *secinfo,
				       struct bss_descriptor *match_bss)
{
	if (secinfo->wep_enabled && !secinfo->WPAenabled
	    && !secinfo->WPA2enabled
	    && (match_bss->capability & WLAN_CAPABILITY_PRIVACY))
		return 1;
	else
		return 0;
}
static inline int match_bss_wpa(struct lbs_802_11_security *secinfo,
				struct bss_descriptor *match_bss)
{
	if (!secinfo->wep_enabled && secinfo->WPAenabled
	    && (match_bss->wpa_ie[0] == WLAN_EID_GENERIC)
	   )
		return 1;
	else
		return 0;
}
static inline int match_bss_wpa2(struct lbs_802_11_security *secinfo,
				 struct bss_descriptor *match_bss)
{
	if (!secinfo->wep_enabled && secinfo->WPA2enabled &&
	    (match_bss->rsn_ie[0] == WLAN_EID_RSN)
	   )
		return 1;
	else
		return 0;
}
static inline int match_bss_dynamic_wep(struct lbs_802_11_security *secinfo,
					struct bss_descriptor *match_bss)
{
	if (!secinfo->wep_enabled && !secinfo->WPAenabled
	    && !secinfo->WPA2enabled
	    && (match_bss->wpa_ie[0] != WLAN_EID_GENERIC)
	    && (match_bss->rsn_ie[0] != WLAN_EID_RSN)
	    && (match_bss->capability & WLAN_CAPABILITY_PRIVACY))
		return 1;
	else
		return 0;
}
static int lbs_cmd_async_callback(struct lbs_private *priv, unsigned long extra,
		     struct cmd_header *resp)
{
	return 0;
}
static ssize_t write_file_dummy(struct file *file, const char __user *buf,
                                size_t count, loff_t *ppos)
{
        return -EINVAL;
}
static ssize_t lbs_lowrssi_read(struct file *file, char __user *userbuf,
				size_t count, loff_t *ppos)
{
	return lbs_threshold_read(TLV_TYPE_RSSI_LOW, CMD_SUBSCRIBE_RSSI_LOW,
				  file, userbuf, count, ppos);
}
static ssize_t lbs_lowrssi_write(struct file *file, const char __user *userbuf,
				 size_t count, loff_t *ppos)
{
	return lbs_threshold_write(TLV_TYPE_RSSI_LOW, CMD_SUBSCRIBE_RSSI_LOW,
				   file, userbuf, count, ppos);
}
static ssize_t lbs_lowsnr_read(struct file *file, char __user *userbuf,
			       size_t count, loff_t *ppos)
{
	return lbs_threshold_read(TLV_TYPE_SNR_LOW, CMD_SUBSCRIBE_SNR_LOW,
				  file, userbuf, count, ppos);
}
static ssize_t lbs_lowsnr_write(struct file *file, const char __user *userbuf,
				size_t count, loff_t *ppos)
{
	return lbs_threshold_write(TLV_TYPE_SNR_LOW, CMD_SUBSCRIBE_SNR_LOW,
				   file, userbuf, count, ppos);
}
static ssize_t lbs_failcount_read(struct file *file, char __user *userbuf,
				  size_t count, loff_t *ppos)
{
	return lbs_threshold_read(TLV_TYPE_FAILCOUNT, CMD_SUBSCRIBE_FAILCOUNT,
				  file, userbuf, count, ppos);
}
static ssize_t lbs_failcount_write(struct file *file, const char __user *userbuf,
				   size_t count, loff_t *ppos)
{
	return lbs_threshold_write(TLV_TYPE_FAILCOUNT, CMD_SUBSCRIBE_FAILCOUNT,
				   file, userbuf, count, ppos);
}
static ssize_t lbs_highrssi_read(struct file *file, char __user *userbuf,
				 size_t count, loff_t *ppos)
{
	return lbs_threshold_read(TLV_TYPE_RSSI_HIGH, CMD_SUBSCRIBE_RSSI_HIGH,
				  file, userbuf, count, ppos);
}
static ssize_t lbs_highrssi_write(struct file *file, const char __user *userbuf,
				  size_t count, loff_t *ppos)
{
	return lbs_threshold_write(TLV_TYPE_RSSI_HIGH, CMD_SUBSCRIBE_RSSI_HIGH,
				   file, userbuf, count, ppos);
}
static ssize_t lbs_highsnr_read(struct file *file, char __user *userbuf,
				size_t count, loff_t *ppos)
{
	return lbs_threshold_read(TLV_TYPE_SNR_HIGH, CMD_SUBSCRIBE_SNR_HIGH,
				  file, userbuf, count, ppos);
}
static ssize_t lbs_highsnr_write(struct file *file, const char __user *userbuf,
				 size_t count, loff_t *ppos)
{
	return lbs_threshold_write(TLV_TYPE_SNR_HIGH, CMD_SUBSCRIBE_SNR_HIGH,
				   file, userbuf, count, ppos);
}
static ssize_t lbs_bcnmiss_read(struct file *file, char __user *userbuf,
				size_t count, loff_t *ppos)
{
	return lbs_threshold_read(TLV_TYPE_BCNMISS, CMD_SUBSCRIBE_BCNMISS,
				  file, userbuf, count, ppos);
}
static ssize_t lbs_bcnmiss_write(struct file *file, const char __user *userbuf,
				 size_t count, loff_t *ppos)
{
	return lbs_threshold_write(TLV_TYPE_BCNMISS, CMD_SUBSCRIBE_BCNMISS,
				   file, userbuf, count, ppos);
}
static int lbs_ethtool_get_eeprom_len(struct net_device *dev)
{
	return LBS_EEPROM_LEN;
}
static inline int spu_write_u16(struct if_spi_card *card, u16 reg, u16 val)
{
	return spu_write(card, reg, (u8 *)&val, sizeof(u16));
}
static inline int spu_read_u16(struct if_spi_card *card, u16 reg, u16 *val)
{
	return spu_read(card, reg, (u8 *)val, sizeof(u16));
}
static int if_usb_submit_rx_urb_fwload(struct if_usb_card *cardp)
{
	return __if_usb_submit_rx_urb(cardp, &if_usb_receive_fwload);
}
static int if_usb_submit_rx_urb(struct if_usb_card *cardp)
{
	return __if_usb_submit_rx_urb(cardp, &if_usb_receive);
}
static inline void clear_bss_descriptor(struct bss_descriptor *bss)
{
	memset(bss, 0, offsetof(struct bss_descriptor, list));
}
static inline int is_same_network(struct bss_descriptor *src,
				  struct bss_descriptor *dst)
{
	return ((src->ssid_len == dst->ssid_len) &&
		(src->channel == dst->channel) &&
		!compare_ether_addr(src->bssid, dst->bssid) &&
		!memcmp(src->ssid, dst->ssid, src->ssid_len));
}
void lbtf_cmd_async(struct lbtf_private *priv, uint16_t command,
	struct cmd_header *in_cmd, int in_cmd_size)
{
	__lbtf_cmd_async(priv, command, in_cmd, in_cmd_size, NULL, 0);
}
static int if_usb_submit_rx_urb_fwload(struct if_usb_card *cardp)
{
	return __if_usb_submit_rx_urb(cardp, &if_usb_receive_fwload);
}
static int if_usb_submit_rx_urb(struct if_usb_card *cardp)
{
	return __if_usb_submit_rx_urb(cardp, &if_usb_receive);
}
static void __exit if_usb_exit_module(void)
{
	usb_deregister(&if_usb_driver);
}
static void __exit lbtf_exit_module(void)
{
	destroy_workqueue(lbtf_wq);
}
static inline unsigned short get_uint16(u_char __iomem *staddr) 
{
    return readw(staddr); /* Return only 16 bits */
}
static inline short get_int16(u_char __iomem * staddr)
{
    return readw(staddr);
}
static int __init init_netwave_cs(void)
{
	return pcmcia_register_driver(&netwave_driver);
}
static void __exit exit_netwave_cs(void)
{
	pcmcia_unregister_driver(&netwave_driver);
}
static int airport_hard_reset(struct orinoco_private *priv)
{
	return 0;
}
static void __exit
exit_airport(void)
{
	macio_unregister_driver(&airport_driver);
}
static inline u32
dblock_addr(const struct dblock *blk)
{
	return le32_to_cpu(blk->addr);
}
static inline u32
dblock_len(const struct dblock *blk)
{
	return le16_to_cpu(blk->len);
}
static inline u32
pdr_id(const struct pdr *pdr)
{
	return le32_to_cpu(pdr->id);
}
static inline u32
pdr_addr(const struct pdr *pdr)
{
	return le32_to_cpu(pdr->addr);
}
static inline u32
pdr_len(const struct pdr *pdr)
{
	return le32_to_cpu(pdr->len);
}
static inline u32
pdi_id(const struct pdi *pdi)
{
	return le16_to_cpu(pdi->id);
}
static inline u32
pdi_len(const struct pdi *pdi)
{
	return 2 * (le16_to_cpu(pdi->len) - 1);
}
static void __orinoco_ev_tick(struct net_device *dev, hermes_t *hw)
{
	printk(KERN_DEBUG "%s: TICK\n", dev->name);
}
static void __orinoco_ev_wterr(struct net_device *dev, hermes_t *hw)
{
	printk(KERN_DEBUG "%s: MAC controller error (WTERR). Ignoring.\n",
	       dev->name);
}
static inline fwtype_t determine_firmware_type(struct comp_id *nic_id)
{
	if (nic_id->id < 0x8000)
		return FIRMWARE_TYPE_AGERE;
	else if (nic_id->id == 0x8000 && nic_id->major == 0)
		return FIRMWARE_TYPE_SYMBOL;
	else
		return FIRMWARE_TYPE_INTERSIL;
}
static void __exit
exit_orinoco_cs(void)
{
	pcmcia_unregister_driver(&orinoco_driver);
}
static void __exit orinoco_nortel_exit(void)
{
	pci_unregister_driver(&orinoco_nortel_driver);
}
static void __exit orinoco_pci_exit(void)
{
	pci_unregister_driver(&orinoco_pci_driver);
}
static void __exit orinoco_plx_exit(void)
{
	pci_unregister_driver(&orinoco_plx_driver);
}
static void __exit orinoco_tmd_exit(void)
{
	pci_unregister_driver(&orinoco_tmd_driver);
}
static void __exit
exit_spectrum_cs(void)
{
	pcmcia_unregister_driver(&orinoco_driver);
}
static int __init p54_init(void)
{
	return 0;
}
static int __init p54p_init(void)
{
	return pci_register_driver(&p54p_driver);
}
static void __exit p54p_exit(void)
{
	pci_unregister_driver(&p54p_driver);
}
static inline void p54spi_write16(struct p54s_priv *priv, u8 addr, __le16 val)
{
	p54spi_spi_write(priv, addr, &val, sizeof(val));
}
static inline void p54spi_write32(struct p54s_priv *priv, u8 addr, __le32 val)
{
	p54spi_spi_write(priv, addr, &val, sizeof(val));
}
static inline void p54spi_int_ack(struct p54s_priv *priv, u32 val)
{
	p54spi_write32(priv, SPI_ADRS_HOST_INT_ACK, cpu_to_le32(val));
}
static inline void p54spi_sleep(struct p54s_priv *priv)
{
	p54spi_write32(priv, SPI_ADRS_ARM_INTERRUPTS,
		       cpu_to_le32(SPI_TARGET_INT_SLEEP));
}
static void __exit p54spi_exit(void)
{
	spi_unregister_driver(&p54spi_driver);
}
static int p54u_pre_reset(struct usb_interface *intf)
{
	return 0;
}
static int p54u_post_reset(struct usb_interface *intf)
{
	return 0;
}
static int __init p54u_init(void)
{
	return usb_register(&p54u_driver);
}
static void __exit p54u_exit(void)
{
	usb_deregister(&p54u_driver);
}
static int
prism54_set_scan(struct net_device *dev, struct iw_request_info *info,
		 struct iw_param *vwrq, char *extra)
{
	return 0;
}
void
prism54_acl_clean(struct islpci_acl *acl)
{
	prism54_clear_mac(acl);
}
static int
prism2_ioctl_mlme(struct net_device *dev, struct prism2_hostapd_param *param)
{
	return -EOPNOTSUPP;
}
static inline struct ccs __iomem *ccs_base(ray_dev_t *dev)
{
	return dev->sram + CCS_BASE;
}
static inline struct rcs __iomem *rcs_base(ray_dev_t *dev)
{
	return dev->sram + CCS_BASE;
}
static void netdev_get_drvinfo(struct net_device *dev,
			       struct ethtool_drvinfo *info)
{
	strcpy(info->driver, "ray_cs");
}
static int ray_commit(struct net_device *dev,
		      struct iw_request_info *info,	/* NULL */
		      void *zwrq,			/* NULL */
		      char *extra)			/* NULL */
{
	return 0;
}
static void clear_interrupt(ray_dev_t *local)
{
    writeb(0, local->amem + CIS_OFFSET + HCS_INTR_OFFSET);
}
static int ray_cs_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, ray_cs_proc_show, NULL);
}
static struct rndis_wext_private *get_rndis_wext_priv(struct usbnet *dev)
{
	return (struct rndis_wext_private *)dev->driver_priv;
}
static u32 get_bcm4320_power(struct rndis_wext_private *priv)
{
	return BCM4320_DEFAULT_TXPOWER *
		bcm4320_power_output[priv->param_power_output] / 100;
}
static int rndis_set_config_parameter_str(struct usbnet *dev,
						char *param, char *value)
{
	return(rndis_set_config_parameter(dev, param, 2, value));
}
static int get_association_info(struct usbnet *usbdev,
			struct ndis_80211_assoc_info *info, int len)
{
	return rndis_query_oid(usbdev, OID_802_11_ASSOCIATION_INFORMATION,
				info, &len);
}
static int rndis_iw_commit(struct net_device *dev,
    struct iw_request_info *info, union iwreq_data *wrqu, char *extra)
{
	return 0;
}
static int rndis_wext_reset(struct usbnet *usbdev)
{
	return deauthenticate(usbdev);
}
static int __init rndis_wlan_init(void)
{
	return usb_register(&rndis_wlan_driver);
}
static void __exit rndis_wlan_exit(void)
{
	usb_deregister(&rndis_wlan_driver);
}
static void rt2400pci_config_txpower(struct rt2x00_dev *rt2x00dev, int txpower)
{
	rt2400pci_bbp_write(rt2x00dev, 3, TXPOWER_TO_DEV(txpower));
}
static void rt2400pci_reset_tuner(struct rt2x00_dev *rt2x00dev,
				  struct link_qual *qual)
{
	rt2400pci_set_vgc(rt2x00dev, qual, 0x08);
}
static void rt2400pci_disable_radio(struct rt2x00_dev *rt2x00dev)
{
	rt2x00pci_register_write(rt2x00dev, PWRCSR0, 0);
}
static int __init rt2400pci_init(void)
{
	return pci_register_driver(&rt2400pci_driver);
}
static void __exit rt2400pci_exit(void)
{
	pci_unregister_driver(&rt2400pci_driver);
}
static void rt2500pci_reset_tuner(struct rt2x00_dev *rt2x00dev,
				  struct link_qual *qual)
{
	rt2500pci_set_vgc(rt2x00dev, qual, 0x48);
}
static void rt2500pci_disable_radio(struct rt2x00_dev *rt2x00dev)
{
	rt2x00pci_register_write(rt2x00dev, PWRCSR0, 0);
}
static int __init rt2500pci_init(void)
{
	return pci_register_driver(&rt2500pci_driver);
}
static void __exit rt2500pci_exit(void)
{
	pci_unregister_driver(&rt2500pci_driver);
}
static inline void rt2500usb_register_multiread(struct rt2x00_dev *rt2x00dev,
						const unsigned int offset,
						void *value, const u16 length)
{
	rt2x00usb_vendor_request_buff(rt2x00dev, USB_MULTI_READ,
				      USB_VENDOR_REQUEST_IN, offset,
				      value, length,
				      REGISTER_TIMEOUT16(length));
}
static inline void rt2500usb_register_multiwrite(struct rt2x00_dev *rt2x00dev,
						 const unsigned int offset,
						 void *value, const u16 length)
{
	rt2x00usb_vendor_request_buff(rt2x00dev, USB_MULTI_WRITE,
				      USB_VENDOR_REQUEST_OUT, offset,
				      value, length,
				      REGISTER_TIMEOUT16(length));
}
static void _rt2500usb_register_read(struct rt2x00_dev *rt2x00dev,
				     const unsigned int offset,
				     u32 *value)
{
	rt2500usb_register_read(rt2x00dev, offset, (u16 *)value);
}
static void _rt2500usb_register_write(struct rt2x00_dev *rt2x00dev,
				      const unsigned int offset,
				      u32 value)
{
	rt2500usb_register_write(rt2x00dev, offset, value);
}
static int __init rt2500usb_init(void)
{
	return usb_register(&rt2500usb_driver);
}
static void __exit rt2500usb_exit(void)
{
	usb_deregister(&rt2500usb_driver);
}
static void rt2x00link_antenna_reset(struct rt2x00_dev *rt2x00dev)
{
	rt2x00dev->link.ant.rssi_ant = 0;
}
void rt2x00link_stop_tuner(struct rt2x00_dev *rt2x00dev)
{
	cancel_delayed_work_sync(&rt2x00dev->link.work);
}
void rt2x00link_register(struct rt2x00_dev *rt2x00dev)
{
	INIT_DELAYED_WORK(&rt2x00dev->link.work, rt2x00link_tuner);
}
static void rt61pci_reset_tuner(struct rt2x00_dev *rt2x00dev,
				struct link_qual *qual)
{
	rt61pci_set_vgc(rt2x00dev, qual, 0x20);
}
static void rt61pci_disable_radio(struct rt2x00_dev *rt2x00dev)
{
	rt2x00pci_register_write(rt2x00dev, MAC_CSR10, 0x00001818);
}
static int __init rt61pci_init(void)
{
	return pci_register_driver(&rt61pci_driver);
}
static void __exit rt61pci_exit(void)
{
	pci_unregister_driver(&rt61pci_driver);
}
static void rt73usb_reset_tuner(struct rt2x00_dev *rt2x00dev,
				struct link_qual *qual)
{
	rt73usb_set_vgc(rt2x00dev, qual, 0x20);
}
static char *rt73usb_get_firmware_name(struct rt2x00_dev *rt2x00dev)
{
	return FIRMWARE_RT2571;
}
static int __init rt73usb_init(void)
{
	return usb_register(&rt73usb_driver);
}
static void __exit rt73usb_exit(void)
{
	usb_deregister(&rt73usb_driver);
}
static int __init rtl8180_init(void)
{
	return pci_register_driver(&rtl8180_driver);
}
static void __exit rtl8180_exit(void)
{
	pci_unregister_driver(&rtl8180_driver);
}
static void sa2400_rf_stop(struct ieee80211_hw *dev)
{
	write_sa2400(dev, 4, 0);
}
static void rtl8187_iowrite_async_cb(struct urb *urb)
{
	kfree(urb->context);
}
static int __init rtl8187_init(void)
{
	return usb_register(&rtl8187_driver);
}
static void __exit rtl8187_exit(void)
{
	usb_deregister(&rtl8187_driver);
}
static void strip_seq_stop(struct seq_file *seq, void *v)
{
	rcu_read_unlock();
}
static int strip_seq_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &strip_seq_ops);
}
static void strip_IdleTask(unsigned long parameter)
{
	strip_xmit(NULL, (struct net_device *) parameter);
}
 static inline u16 hasr_read(unsigned long ioaddr)
{
	return (inw(HASR(ioaddr)));
}				/* hasr_read */
 static inline void hacr_write(unsigned long ioaddr, u16 hacr)
{
	outw(hacr, HACR(ioaddr));
}				/* hacr_write */
 static inline void set_chan_attn(unsigned long ioaddr, u16 hacr)
{
	hacr_write(ioaddr, hacr | HACR_CA);
}				/* set_chan_attn */
 static inline u_char
hasr_read(u_long	base)
{
  return(inb(HASR(base)));
} /* hasr_read */
 static inline void
hacr_write(u_long	base,
	   u_char	hacr)
{
  outb(hacr, HACR(base));
} /* hacr_write */
 static inline int
wv_diag(struct net_device *	dev)
{
  return(wv_82593_cmd(dev, "wv_diag(): diagnose",
		      OP0_DIAGNOSE, SR0_DIAGNOSE_PASSED));
} /* wv_diag */
static void wl_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
{
	strncpy(info->driver, "wavelan_cs", sizeof(info->driver)-1);
}
static int __init
init_wavelan_cs(void)
{
	return pcmcia_register_driver(&wavelan_driver);
}
static void __exit
exit_wavelan_cs(void)
{
	pcmcia_unregister_driver(&wavelan_driver);
}
static void iw_copy_mgmt_info_element(struct iw_mgmt_info_element *to,
				      struct iw_mgmt_info_element *from)
{
	iw_set_mgmt_info_element(from->id, to, from->data, from->len);
}
static inline void wl3501_switch_page(struct wl3501_card *this, u8 page)
{
	wl3501_outb(page, this->base_addr + WL3501_NIC_BSS);
}
static inline int wl3501_fw_bss_type(struct wl3501_card *this)
{
	return this->net_type == IW_MODE_INFRA ? WL3501_NET_TYPE_INFRA :
						 WL3501_NET_TYPE_ADHOC;
}
static inline int wl3501_fw_cap_info(struct wl3501_card *this)
{
	return this->net_type == IW_MODE_INFRA ? WL3501_MGMT_CAPABILITY_ESS :
						 WL3501_MGMT_CAPABILITY_IBSS;
}
static inline void wl3501_ack_interrupt(struct wl3501_card *this)
{
	wl3501_outb(WL3501_GCR_ECINT, this->base_addr + WL3501_NIC_GCR);
}
static void wl3501_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
{
	strlcpy(info->driver, wl3501_dev_info, sizeof(info->driver));
}
static int wl3501_set_scan(struct net_device *dev, struct iw_request_info *info,
			   union iwreq_data *wrqu, char *extra)
{
	return wl3501_reset(dev);
}
static int __init wl3501_init_module(void)
{
	return pcmcia_register_driver(&wl3501_driver);
}
static void __exit wl3501_exit_module(void)
{
	pcmcia_unregister_driver(&wl3501_driver);
}
static int zd1201_set_scan(struct net_device *dev,
    struct iw_request_info *info, struct iw_point *srq, char *extra)
{
	return 0;
}
static int zd1201_set_retry(struct net_device *dev,
    struct iw_request_info *info, struct iw_param *rrq, char *extra)
{
	return 0;
}
static int zd1201_get_retry(struct net_device *dev,
    struct iw_request_info *info, struct iw_param *rrq, char *extra)
{
	return 0;
}
static int __init zd1201_init(void)
{
	return usb_register(&zd1201_usb);
}
static void __exit zd1201_cleanup(void)
{
	usb_deregister(&zd1201_usb);
}
static int read_pwr_cal_values(struct zd_chip *chip)
{
	return read_values(chip, chip->pwr_cal_values,
		        E2P_CHANNEL_COUNT, E2P_PWR_CAL_VALUE1,
			0);
}
static int read_pwr_int_values(struct zd_chip *chip)
{
	return read_values(chip, chip->pwr_int_values,
		        E2P_CHANNEL_COUNT, E2P_PWR_INT_VALUE1,
			E2P_PWR_INT_GUARD);
}
static int hw_reset_phy(struct zd_chip *chip)
{
	return zd_chip_is_zd1211b(chip) ? zd1211b_hw_reset_phy(chip) :
		                  zd1211_hw_reset_phy(chip);
}
static zd_addr_t fw_reg_addr(struct zd_chip *chip, u16 offset)
{
	return (zd_addr_t)((u16)chip->fw_regs_base + offset);
}
static int disable_hwint(struct zd_chip *chip)
{
	return zd_iowrite32_locked(chip, HWINT_DISABLED, CR_INTERRUPT);
}
static int cck_evm_db(u8 status_quality)
{
	return (20 * log10times100(status_quality)) / 100;
}
static inline u8 zd_rate_from_ofdm_plcp_header(const void *rx_frame)
{
	return ZD_OFDM | zd_ofdm_plcp_header_rate(rx_frame);
}
u8 zd_rx_qual_percent(const void *rx_frame, unsigned int size,
	              const struct rx_status *status)
{
	return (status->frame_status&ZD_RX_OFDM) ?
		ofdm_qual_percent(status->signal_quality_ofdm,
				  zd_rate_from_ofdm_plcp_header(rx_frame),
			          size) :
		cck_qual_percent(status->signal_quality_cck);
}
static void housekeeping_init(struct zd_mac *mac)
{
	INIT_DELAYED_WORK(&mac->housekeeping.link_led_work, link_led_handler);
}
int zd_rf_scnprint_id(struct zd_rf *rf, char *buffer, size_t size)
{
	return scnprintf(buffer, size, "%s", zd_rf_name(rf->type));
}
int zd_rf_generic_patch_6m(struct zd_rf *rf, u8 channel)
{
	return zd_chip_generic_patch_6m_band(zd_rf_to_chip(rf), channel);
}
static void uw2453_clear(struct zd_rf *rf)
{
	kfree(rf->priv);
}
static inline u16 get_bcdDevice(const struct usb_device *udev)
{
	return le16_to_cpu(udev->descriptor.bcdDevice);
}
static int scnprint_id(struct usb_device *udev, char *buffer, size_t size)
{
	return scnprintf(buffer, size, "%04hx:%04hx v%04hx %s",
		le16_to_cpu(udev->descriptor.idVendor),
		le16_to_cpu(udev->descriptor.idProduct),
		get_bcdDevice(udev),
		speed(udev->speed));
}
static int usb_int_regs_length(unsigned int count)
{
	return sizeof(struct usb_int_regs) + count * sizeof(struct reg_data);
}
static void skb_entry_set_link(union skb_entry *list, unsigned short id)
{
	list->link = id;
}
static int xennet_rxidx(RING_IDX idx)
{
	return idx & (NET_RX_RING_SIZE - 1);
}
static int xennet_can_sg(struct net_device *dev)
{
	return dev->features & NETIF_F_SG;
}
static int netfront_tx_slot_available(struct netfront_info *np)
{
	return ((np->tx.req_prod_pvt - np->tx.rsp_cons) <
		(TX_MAX_TARGET - MAX_SKB_FRAGS - 2));
}
static int __init xtsonic_init(void)
{
	return platform_driver_register(&xtsonic_driver);
}
static void __exit xtsonic_cleanup(void)
{
	platform_driver_unregister(&xtsonic_driver);
}
static void __exit yellowfin_cleanup (void)
{
	pci_unregister_driver (&yellowfin_driver);
}
static int __init zorro8390_init_module(void)
{
    return zorro_register_driver(&zorro8390_driver);
}
static void __exit zorro8390_cleanup_module(void)
{
    zorro_unregister_driver(&zorro8390_driver);
}

static inline void *nubus_rom_addr(int slot)
{	
	return (void *)(0xF1000000+(slot<<24));
}
static int nubus_devices_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, nubus_devices_proc_show, NULL);
}
void of_device_unregister(struct of_device *ofdev)
{
	device_unregister(&ofdev->dev);
}
static int of_dev_node_match(struct device *dev, void *data)
{
        return dev_archdata_get_node(&dev->archdata) == data;
}
void of_unregister_driver(struct of_platform_driver *drv)
{
	driver_unregister(&drv->driver);
}
static inline int is_code(unsigned long val)
{
	return val == ESCAPE_CODE;
}
unsigned long oprofile_get_cpu_buffer_size(void)
{
	return oprofile_cpu_buffer_size;
}
int op_cpu_buffer_write_commit(struct op_entry *entry)
{
	return ring_buffer_unlock_commit(op_ring_buffer_write, entry->event);
}
unsigned long op_cpu_buffer_entries(int cpu)
{
	return ring_buffer_entries_cpu(op_ring_buffer_read, cpu)
		+ ring_buffer_entries_cpu(op_ring_buffer_write, cpu);
}
static inline void oprofile_begin_trace(struct oprofile_cpu_buffer *cpu_buf)
{
	cpu_buf->tracing = 1;
}
static inline void oprofile_end_trace(struct oprofile_cpu_buffer *cpu_buf)
{
	cpu_buf->tracing = 0;
}
void oprofile_add_ext_sample(unsigned long pc, struct pt_regs * const regs,
			     unsigned long event, int is_kernel)
{
	__oprofile_add_ext_sample(pc, regs, event, is_kernel);
}
static ssize_t depth_read(struct file *file, char __user *buf, size_t count, loff_t *offset)
{
	return oprofilefs_ulong_to_user(oprofile_backtrace_depth, buf, count,
					offset);
}
static ssize_t pointer_size_read(struct file *file, char __user *buf, size_t count, loff_t *offset)
{
	return oprofilefs_ulong_to_user(sizeof(void *), buf, count, offset);
}
static ssize_t cpu_type_read(struct file *file, char __user *buf, size_t count, loff_t *offset)
{
	return oprofilefs_str_to_user(oprofile_ops.cpu_type, buf, count, offset);
}
static ssize_t enable_read(struct file *file, char __user *buf, size_t count, loff_t *offset)
{
	return oprofilefs_ulong_to_user(oprofile_started, buf, count, offset);
}
ssize_t oprofilefs_str_to_user(char const *str, char __user *buf, size_t count, loff_t *offset)
{
	return simple_read_from_buffer(buf, count, offset, str, strlen(str));
}
static int oprofilefs_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_single(fs_type, flags, data, oprofilefs_fill_super, mnt);
}
int __init oprofilefs_register(void)
{
	return register_filesystem(&oprofilefs_type);
}
void __exit oprofilefs_unregister(void)
{
	unregister_filesystem(&oprofilefs_type);
}
static int timer_start(void)
{
	return register_timer_hook(timer_notify);
}
static void timer_stop(void)
{
	unregister_timer_hook(timer_notify);
}
static int ccio_proc_info_open(struct inode *inode, struct file *file)
{
	return single_open(file, &ccio_proc_info, NULL);
}
static int ccio_proc_bitmap_open(struct inode *inode, struct file *file)
{
	return single_open(file, &ccio_proc_bitmap_info, NULL);
}
void __init ccio_init(void)
{
	register_parisc_driver(&ccio_driver);
}
static void ccio_free_consistent(struct pci_dev *dev, size_t size,
			       void *vaddr, dma_addr_t handle)
{
	free_pages((unsigned long)vaddr, get_order(size));
}
static dma_addr_t ccio_map_single(struct pci_dev *dev, void *ptr, size_t size,
			  int direction)
{
	return virt_to_phys(ptr);
}
void __init ccio_init(void)
{
	register_parisc_driver(&ccio_driver);
}
static void __init
dino_bios_init(void)
{
	DBG("dino_bios_init\n");
}
void __init eisa_init(void)
{
	register_parisc_driver(&eisa_driver);
}
static int eisa_eeprom_ioctl(struct inode *inode, struct file *file, 
			   unsigned int cmd,
			   unsigned long arg)
{
	return -ENOTTY;
}
static int eisa_eeprom_release(struct inode *inode, struct file *file)
{
	return 0;
}
static inline u_int16_t get_16(const unsigned char *x)
{ 
	return (x[1] << 8) | x[0];
}
static inline u_int32_t get_32(const unsigned char *x)
{
	return (x[3] << 24) | (x[2] << 16) | (x[1] << 8) | x[0];
}
static inline u_int32_t get_24(const unsigned char *x)
{
	return (x[2] << 24) | (x[1] << 16) | (x[0] << 8);
}
void __init hppb_init(void)
{
        register_parisc_driver(&hppb_driver);
}
static inline void iosapic_eoi(void __iomem *addr, unsigned int data)
{
	__raw_writel(data, addr);
}
static unsigned int
iosapic_rd_version(struct iosapic_info *isi)
{
	return iosapic_read(isi->addr, IOSAPIC_REG_VERSION);
}
static void
lba_bios_init(void)
{
	DBG(MODULE_NAME ": lba_bios_init\n");
}
void __init lba_init(void)
{
	register_parisc_driver(&lba_driver);
}
 static __inline__ int led_get_net_activity(void)
{ 
	return 0;
}
static ssize_t pdcs_autoboot_read(struct kobject *kobj,
				  struct kobj_attribute *attr, char *buf)
{
	return pdcs_auto_read(kobj, attr, buf, PF_AUTOBOOT);
}
static ssize_t pdcs_autosearch_read(struct kobject *kobj,
				    struct kobj_attribute *attr, char *buf)
{
	return pdcs_auto_read(kobj, attr, buf, PF_AUTOSEARCH);
}
static ssize_t pdcs_autoboot_write(struct kobject *kobj,
				   struct kobj_attribute *attr,
				   const char *buf, size_t count)
{
	return pdcs_auto_write(kobj, attr, buf, count, PF_AUTOBOOT);
}
static ssize_t pdcs_autosearch_write(struct kobject *kobj,
				     struct kobj_attribute *attr,
				     const char *buf, size_t count)
{
	return pdcs_auto_write(kobj, attr, buf, count, PF_AUTOSEARCH);
}
static unsigned long ptr_to_pide(struct ioc *ioc, unsigned long *res_ptr,
				 unsigned int bitshiftcnt)
{
	return (((unsigned long)res_ptr - (unsigned long)ioc->res_map) << 3)
		+ bitshiftcnt;
}
static void __iomem *ioc_remap(struct sba_device *sba_dev, unsigned int offset)
{
	return ioremap_nocache(sba_dev->dev->hpa.start + offset, SBA_FUNC_SIZE);
}
static int
sba_proc_open(struct inode *i, struct file *f)
{
	return single_open(f, &sba_proc_info, NULL);
}
static int
sba_proc_bitmap_open(struct inode *i, struct file *f)
{
	return single_open(f, &sba_proc_bitmap_info, NULL);
}
void __init sba_init(void)
{
	register_parisc_driver(&sba_driver);
}
static int __init superio_modinit(void)
{
	return pci_register_driver(&superio_driver);
}
static void __exit superio_exit(void)
{
	pci_unregister_driver(&superio_driver);
}
void parport_close(struct pardevice *dev)
{
	parport_unregister_device(dev);
}
void parport_daisy_deselect_all(struct parport *port)
{
	cpp_daisy(port, 0x30);
}
static int mux_present(struct parport *port)
{
	return cpp_mux(port, 0x51) == 3;
}
static int num_mux_ports(struct parport *port)
{
	return cpp_mux(port, 0x58);
}
static void parport_ieee1284_wakeup (struct parport *port)
{
	up (&port->physport->ieee1284.irq);
}
static void timeout_waiting_on_port (unsigned long cookie)
{
	parport_ieee1284_wakeup (port_from_cookie[cookie % PARPORT_MAX]);
}
ssize_t parport_write (struct parport *port, const void *buffer, size_t len)
{
	return port->ops->compat_write_data (port, buffer, len, 0);
}
size_t parport_ieee1284_read_nibble (struct parport *port, 
				     void *buffer, size_t len,
				     int flags)
{
	return 0;
}
size_t parport_ieee1284_read_byte (struct parport *port,
				   void *buffer, size_t len,
				   int flags)
{
	return 0;
}
size_t parport_ieee1284_ecp_write_data (struct parport *port,
					const void *buffer, size_t len,
					int flags)
{
	return 0;
}
size_t parport_ieee1284_ecp_read_data (struct parport *port,
				       void *buffer, size_t len, int flags)
{
	return 0;
}
size_t parport_ieee1284_ecp_write_addr (struct parport *port,
					const void *buffer, size_t len,
					int flags)
{
	return 0;
}
static unsigned char amiga_read_data(struct parport *p)
{
	return ciaa.prb;
}
static unsigned char control_amiga_to_pc(unsigned char control)
{
	return PARPORT_CONTROL_SELECT |
	      PARPORT_CONTROL_AUTOFD | PARPORT_CONTROL_STROBE;
}
static void amiga_write_control(struct parport *p, unsigned char control)
{
	DPRINTK(KERN_DEBUG "write_control %02x\n",control);
}
static void amiga_enable_irq(struct parport *p)
{
	enable_irq(IRQ_AMIGA_CIAA_FLG);
}
static void amiga_disable_irq(struct parport *p)
{
	disable_irq(IRQ_AMIGA_CIAA_FLG);
}
static unsigned char
parport_atari_read_status(struct parport *p)
{
	return ((mfp.par_dt_reg & 1 ? 0 : PARPORT_STATUS_BUSY) |
		PARPORT_STATUS_SELECT | PARPORT_STATUS_ERROR);
}
static void
parport_atari_enable_irq(struct parport *p)
{
	enable_irq(IRQ_MFP_BUSY);
}
static void
parport_atari_disable_irq(struct parport *p)
{
	disable_irq(IRQ_MFP_BUSY);
}
static inline struct ax_drvdata *pp_to_drv(struct parport *p)
{
	return p->private_data;
}
static int __init parport_ax88796_init(void)
{
	return platform_driver_register(&axdrv);
}
static void __exit parport_ax88796_exit(void)
{
	platform_driver_unregister(&axdrv);
}
static int __init init_parport_cs(void)
{
	return pcmcia_register_driver(&parport_cs_driver);
}
static void __exit exit_parport_cs(void)
{
	pcmcia_unregister_driver(&parport_cs_driver);
}
void parport_gsc_init_state(struct pardevice *dev, struct parport_state *s)
{
	s->u.pc.ctr = 0xc | (dev->irq_func ? 0x10 : 0x0);
}
void parport_gsc_save_state(struct parport *p, struct parport_state *s)
{
	s->u.pc.ctr = parport_readb (CONTROL (p));
}
void parport_gsc_restore_state(struct parport *p, struct parport_state *s)
{
	parport_writeb (s->u.pc.ctr, CONTROL (p));
}
int __devinit parport_gsc_init(void)
{
	return register_parisc_driver(&parport_driver);
}
static void __devexit parport_gsc_exit(void)
{
	unregister_parisc_driver(&parport_driver);
}
static inline size_t parport_ip32_dma_get_residue(void)
{
	return parport_ip32_dma.left;
}
static inline void parport_ip32_disable_irq(struct parport *p)
{
	__parport_ip32_frob_control(p, DCR_IRQ, 0);
}
static inline void parport_ip32_enable_irq(struct parport *p)
{
	__parport_ip32_frob_control(p, DCR_IRQ, DCR_IRQ);
}
static inline void parport_ip32_data_forward(struct parport *p)
{
	__parport_ip32_frob_control(p, DCR_DIR, 0);
}
static inline void parport_ip32_data_reverse(struct parport *p)
{
	__parport_ip32_frob_control(p, DCR_DIR, DCR_DIR);
}
static void __init
parport_ip32_make_isa_registers(struct parport_ip32_regs *regs,
				void __iomem *base, void __iomem *base_hi,
				unsigned int regshift)
{
	*regs = (struct parport_ip32_regs){
		.data		= r_base(0),
		.dsr		= r_base(1),
		.dcr		= r_base(2),
		.eppAddr	= r_base(3),
		.eppData0	= r_base(4),
		.eppData1	= r_base(5),
		.eppData2	= r_base(6),
		.eppData3	= r_base(7),
		.ecpAFifo	= r_base(0),
		.fifo		= r_base_hi(0),
		.cnfgA		= r_base_hi(0),
		.cnfgB		= r_base_hi(1),
		.ecr		= r_base_hi(2)
	};
}
static void __exit parport_ip32_exit(void)
{
	parport_ip32_unregister_port(this_port);
}
static inline int DPRINTK(void *nothing, ...) {return 0;}
static unsigned char mfc3_read_data(struct parport *p)
{
	return pia(p)->pprb;
}
static void mfc3_enable_irq(struct parport *p)
{
	pia(p)->crb |= PIA_C1_ENABLE_IRQ;
}
static void mfc3_disable_irq(struct parport *p)
{
	pia(p)->crb &= ~PIA_C1_ENABLE_IRQ;
}
static __inline__ void frob_set_mode (struct parport *p, int mode)
{
	frob_econtrol (p, ECR_MODE_MASK, mode << 5);
}
static int __devinit parport_PS2_supported(struct parport *pb) { return 0; }
static int parport_ECP_supported(struct parport *pb) { return 0; }
static int __devinit parport_EPP_supported(struct parport *pb) { return 0; }
static int __devinit parport_ECPEPP_supported(struct parport *pb){return 0;}
static int __devinit parport_ECPPS2_supported(struct parport *pb){return 0;}
static int irq_probe_EPP(struct parport *pb)
{
	return PARPORT_IRQ_NONE;
}
static int irq_probe_SPP(struct parport *pb)
{
	return PARPORT_IRQ_NONE;
}
static int __init parport_pc_init_superio(int autoirq, int autodma) {return 0;}
static int __devinit parport_pc_platform_probe(struct platform_device *pdev)
{
	return 0;
}
static int __init parport_parse_irq(const char *irqstr, int *val)
{
	return parport_parse_param(irqstr, val, PARPORT_IRQ_AUTO,
				     PARPORT_IRQ_NONE, 0);
}
static int __init parport_parse_dma(const char *dmastr, int *val)
{
	return parport_parse_param(dmastr, val, PARPORT_DMA_AUTO,
				     PARPORT_DMA_NONE, PARPORT_DMA_NOFIFO);
}
static int __init parse_parport_params(void)
{
	return io[0] == PARPORT_DISABLE;
}
static int __init parport_serial_init (void)
{
	return pci_register_driver (&parport_serial_pci_driver);
}
static unsigned char parport_sunbpp_read_control(struct parport *p)
{
	return control_sunbpp_to_pc(p);
}
static unsigned char parport_sunbpp_read_status(struct parport *p)
{
	return status_sunbpp_to_pc(p);
}
static void parport_sunbpp_save_state(struct parport *p, struct parport_state *s)
{
	s->u.pc.ctr = parport_sunbpp_read_control(p);
}
static void parport_sunbpp_restore_state(struct parport *p, struct parport_state *s)
{
	parport_sunbpp_write_control(p, s->u.pc.ctr);
}
static int __init parport_sunbpp_init(void)
{
	return of_register_driver(&bpp_sbus_driver, &of_bus_type);
}
static void __exit parport_sunbpp_exit(void)
{
	of_unregister_driver(&bpp_sbus_driver);
}
int parport_proc_register(struct parport *pp)
{
	return 0;
}
int parport_proc_unregister(struct parport *pp)
{
	return 0;
}
int parport_device_proc_register(struct pardevice *device)
{
	return 0;
}
int parport_device_proc_unregister(struct pardevice *device)
{
	return 0;
}
static int __init parport_default_proc_register (void)
{
	return 0;
}
static unsigned char dead_read_lines (struct parport *p) { return 0; }
static unsigned char dead_frob_lines (struct parport *p, unsigned char b,
			     unsigned char c) { return 0; }
static size_t dead_write (struct parport *p, const void *b, size_t l, int f)
{ return 0; }
static size_t dead_read (struct parport *p, void *b, size_t l, int f)
{ return 0; }
static void get_lowlevel_driver (void)
{
	request_module ("parport_lowlevel");
}
static void pci_vpd_pci22_release(struct pci_dev *dev)
{
	kfree(container_of(dev->vpd, struct pci_vpd_pci22, base));
}
static void __init dmar_register_rmrr_unit(struct dmar_rmrr_unit *rmrr)
{
	list_add(&rmrr->list, &dmar_rmrr_units);
}
void  acpiphp_glue_exit(void)
{
	acpi_pci_unregister_driver(&acpi_pci_hp_driver);
}
u8 acpiphp_get_power_status(struct acpiphp_slot *slot)
{
	return (slot->flags & SLOT_POWEREDON);
}
static int
set_attention_status(struct hotplug_slot *hotplug_slot, u8 status)
{
	return cpci_set_attention_status(hotplug_slot->private, status);
}
static inline int is_slot64bit(struct slot *slot)
{
	return (readb(slot->p_sm_slot + SMBIOS_SLOT_WIDTH) == 0x06) ? 1 : 0;
}
static inline int is_slot66mhz(struct slot *slot)
{
	return (readb(slot->p_sm_slot + SMBIOS_SLOT_TYPE) == 0x0E) ? 1 : 0;
}
static void long_delay(int delay)
{
	msleep_interruptible(jiffies_to_msecs(delay));
}
static int is_bridge(struct pci_func * func)
{
	if (((func->config_space[0x03] >> 16) & 0xFF) == 0x01)
		return 1;
	else
		return 0;
}
void cpqhp_event_stop_thread(void)
{
	kthread_stop(cpqhp_event_thread);
}
static int PCI_ScanBusNonBridge (u8 bus, u8 device)
{
	return 0;
}
int cpqhp_get_bus_dev (struct controller *ctrl, u8 * bus_num, u8 * dev_num, u8 slot)
{
	return PCI_GetBusDevHelper(ctrl, bus_num, dev_num, slot, 0);	//plain (bridges allowed)
}
void cpqhp_shutdown_debugfs(void)
{
	debugfs_remove(root);
}
void cpqhp_create_debugfs_files(struct controller *ctrl)
{
	ctrl->dentry = debugfs_create_file(dev_name(&ctrl->pci_dev->dev),
					   S_IRUGO, root, ctrl, &debug_ops);
}
static inline void pci_rescan(void) {
	pci_rescan_buses(&pci_root_buses);
}
static void pci_rescan_worker(struct work_struct *work)
{
	pci_rescan();
}
static void __exit dummyphp_exit(void)
{
	cleanup_slots();
}
static struct ebda_hpc_list * __init alloc_ebda_hpc_list (void)
{
	return kzalloc(sizeof(struct ebda_hpc_list), GFP_KERNEL);
}
static struct ebda_rsrc_list * __init alloc_ebda_rsrc_list (void)
{
	return kzalloc(sizeof(struct ebda_rsrc_list), GFP_KERNEL);
}
static struct ebda_pci_rsrc *alloc_ebda_pci_rsrc (void)
{
	return kzalloc(sizeof(struct ebda_pci_rsrc), GFP_KERNEL);
}
u16 ibmphp_get_total_controllers (void)
{
	return hpc_list_ptr->num_ctlrs;
}
static void get_hpc_access (void)
{
	mutex_lock(&sem_hpcaccess);
}
void free_hpc_access (void)
{
	mutex_unlock(&sem_hpcaccess);
}
struct bus_node *ibmphp_find_res_bus (u8 bus_number)
{
	return find_bus_wprev (bus_number, NULL, 0);
}
static inline int cpci_hotplug_init(int debug) { return 0; }
static void __exit pci_hotplug_exit (void)
{
	cpci_hotplug_exit();
}
static void make_slot_name(struct slot *slot)
{
	snprintf(slot->hotplug_slot->name, SLOT_NAME_SIZE, "%d", slot->number);
}
static void __exit pcihp_skel_exit(void)
{
	cleanup_slots();
}
static ssize_t add_slot_show(struct kobject *kobj,
			     struct kobj_attribute *attr, char *buf)
{
	return sprintf(buf, "0\n");
}
static ssize_t remove_slot_show(struct kobject *kobj,
				struct kobj_attribute *attr, char *buf)
{
	return sprintf(buf, "0\n");
}
static void __exit rpaphp_exit(void)
{
	cleanup_slots();
}
static inline u8 shpc_readb(struct controller *ctrl, int reg)
{
	return readb(ctrl->creg + reg);
}
static inline void shpc_writeb(struct controller *ctrl, int reg, u8 val)
{
	writeb(val, ctrl->creg + reg);
}
static inline u16 shpc_readw(struct controller *ctrl, int reg)
{
	return readw(ctrl->creg + reg);
}
static inline void shpc_writew(struct controller *ctrl, int reg, u16 val)
{
	writew(val, ctrl->creg + reg);
}
static inline u32 shpc_readl(struct controller *ctrl, int reg)
{
	return readl(ctrl->creg + reg);
}
static inline void shpc_writel(struct controller *ctrl, int reg, u32 val)
{
	writel(val, ctrl->creg + reg);
}
static void hpc_set_green_led_on(struct slot *slot)
{
	shpc_write_cmd(slot, slot->hp_slot, SET_PWR_ON);
}
static void hpc_set_green_led_off(struct slot *slot)
{
	shpc_write_cmd(slot, slot->hp_slot, SET_PWR_OFF);
}
static void hpc_set_green_led_blink(struct slot *slot)
{
	shpc_write_cmd(slot, slot->hp_slot, SET_PWR_BLINK);
}
int __must_check shpchp_create_ctrl_files (struct controller *ctrl)
{
	return device_create_file (&ctrl->pci_dev->dev, &dev_attr_ctrl);
}
void shpchp_remove_ctrl_files(struct controller *ctrl)
{
	device_remove_file(&ctrl->pci_dev->dev, &dev_attr_ctrl);
}
int ht_create_irq(struct pci_dev *dev, int idx)
{
	return __ht_create_irq(dev, idx, NULL);
}
static inline bool root_present(struct root_entry *root)
{
	return (root->val & 1);
}
static inline void set_root_present(struct root_entry *root)
{
	root->val |= 1;
}
static inline void set_root_value(struct root_entry *root, unsigned long value)
{
	root->val |= value & VTD_PAGE_MASK;
}
static inline struct context_entry *
get_context_addr_from_root(struct root_entry *root)
{
	return (struct context_entry *)
		(root_present(root)?phys_to_virt(
		root->val & VTD_PAGE_MASK) :
		NULL);
}
static inline bool context_present(struct context_entry *context)
{
	return (context->lo & 1);
}
static inline void context_set_present(struct context_entry *context)
{
	context->lo |= 1;
}
static inline void context_set_fault_enable(struct context_entry *context)
{
	context->lo &= (((u64)-1) << 2) | 1;
}
static inline void context_set_address_root(struct context_entry *context,
					    unsigned long value)
{
	context->lo |= value & VTD_PAGE_MASK;
}
static inline void context_set_address_width(struct context_entry *context,
					     unsigned long value)
{
	context->hi |= value & 7;
}
static inline void context_set_domain_id(struct context_entry *context,
					 unsigned long value)
{
	context->hi |= (value & ((1 << 16) - 1)) << 8;
}
static inline void dma_clear_pte(struct dma_pte *pte)
{
	pte->val = 0;
}
static inline void dma_set_pte_readable(struct dma_pte *pte)
{
	pte->val |= DMA_PTE_READ;
}
static inline void dma_set_pte_writable(struct dma_pte *pte)
{
	pte->val |= DMA_PTE_WRITE;
}
static inline void dma_set_pte_prot(struct dma_pte *pte, unsigned long prot)
{
	pte->val = (pte->val & ~3) | (prot & 3);
}
static inline u64 dma_pte_addr(struct dma_pte *pte)
{
	return (pte->val & VTD_PAGE_MASK);
}
static inline void dma_set_pte_addr(struct dma_pte *pte, u64 addr)
{
	pte->val |= (addr & VTD_PAGE_MASK);
}
static inline bool dma_pte_present(struct dma_pte *pte)
{
	return (pte->val & 3) != 0;
}
static inline void free_pgtable_page(void *vaddr)
{
	free_page((unsigned long)vaddr);
}
static inline void *alloc_domain_mem(void)
{
	return iommu_kmem_cache_alloc(iommu_domain_cache);
}
static void free_domain_mem(void *vaddr)
{
	kmem_cache_free(iommu_domain_cache, vaddr);
}
static inline void * alloc_devinfo_mem(void)
{
	return iommu_kmem_cache_alloc(iommu_devinfo_cache);
}
static inline void free_devinfo_mem(void *vaddr)
{
	kmem_cache_free(iommu_devinfo_cache, vaddr);
}
struct iova *alloc_iova_mem(void)
{
	return iommu_kmem_cache_alloc(iommu_iova_cache);
}
void free_iova_mem(struct iova *iova)
{
	kmem_cache_free(iommu_iova_cache, iova);
}
static inline int agaw_to_level(int agaw)
{
	return agaw + 2;
}
static inline int agaw_to_width(int agaw)
{
	return 30 + agaw * LEVEL_STRIDE;
}
static inline int width_to_agaw(int width)
{
	return (width - 30) / LEVEL_STRIDE;
}
static inline unsigned int level_to_offset_bits(int level)
{
	return (12 + (level - 1) * LEVEL_STRIDE);
}
static inline int address_level_offset(u64 addr, int level)
{
	return ((addr >> level_to_offset_bits(level)) & LEVEL_MASK);
}
static inline u64 level_mask(int level)
{
	return ((u64)-1 << level_to_offset_bits(level));
}
static inline u64 level_size(int level)
{
	return ((u64)1 << level_to_offset_bits(level));
}
static inline u64 align_to_level(u64 addr, int level)
{
	return ((addr + level_size(level) - 1) & level_mask(level));
}
const char *dmar_get_fault_reason(u8 fault_reason)
{
	if (fault_reason > MAX_FAULT_REASON_IDX)
		return "Unknown";
	else
		return fault_reason_strings[fault_reason];
}
static void domain_reserve_special_ranges(struct dmar_domain *domain)
{
	copy_reserved_iova(&reserved_iova_list, &domain->iovad);
}
static inline void iommu_prepare_gfx_mapping(void)
{
	return;
}
static inline void iommu_prepare_isa(void)
{
	return;
}
static dma_addr_t intel_map_page(struct device *dev, struct page *page,
				 unsigned long offset, size_t size,
				 enum dma_data_direction dir,
				 struct dma_attrs *attrs)
{
	return __intel_map_single(dev, page_to_phys(page) + offset, size,
				  dir, to_pci_dev(dev)->dma_mask);
}
dma_addr_t intel_map_single(struct device *hwdev, phys_addr_t paddr,
			    size_t size, int dir)
{
	return __intel_map_single(hwdev, paddr, size, dir,
				  to_pci_dev(hwdev)->dma_mask);
}
void intel_unmap_single(struct device *dev, dma_addr_t dev_addr, size_t size,
			int dir)
{
	intel_unmap_page(dev, dev_addr, size, dir, NULL);
}
static struct irq_2_iommu *irq_2_iommu_alloc(unsigned int irq)
{
	return irq_2_iommu_alloc_cpu(irq, boot_cpu_id);
}
static struct irq_2_iommu *irq_2_iommu_alloc(unsigned int irq)
{
	return irq_2_iommu(irq);
}
int irq_remapped(int irq)
{
	return valid_irq_2_iommu(irq) != NULL;
}
int arch_msi_check_device(struct pci_dev *dev, int nvec, int type)
{
	return 0;
}
static void msi_set_enable(struct pci_dev *dev, int enable)
{
	__msi_set_enable(dev, pci_find_capability(dev, PCI_CAP_ID_MSI), enable);
}
static void msix_free_all_irqs(struct pci_dev *dev)
{
	msi_free_irqs(dev);
}
void pci_no_msi(void)
{
	pci_msi_enable = 0;
}
int pci_msi_enabled(void)
{
	return pci_msi_enable;
}
void pci_msi_init_pci_dev(struct pci_dev *dev)
{
	INIT_LIST_HEAD(&dev->msi_list);
}
static void pci_remove_newid_file(struct pci_driver *drv)
{
	driver_remove_file(&drv->driver, &driver_attr_new_id);
}
static inline int pci_create_newid_file(struct pci_driver *drv)
{
	return 0;
}
int pci_uevent(struct device *dev, struct kobj_uevent_env *env)
{
	return -ENODEV;
}
static int __init pci_driver_init(void)
{
	return bus_register(&pci_bus_type);
}
static int pci_stub_probe(struct pci_dev *dev, const struct pci_device_id *id)
{
	return 0;
}
static int __init pci_stub_init(void)
{
	return pci_register_driver(&stub_driver);
}

static void __exit pci_stub_exit(void)
{
	pci_unregister_driver(&stub_driver);
}
static ssize_t
numa_node_show(struct device *dev, struct device_attribute *attr, char *buf)
{
	return sprintf (buf, "%d\n", dev->numa_node);
}
static int
pci_mmap_resource_uc(struct kobject *kobj, struct bin_attribute *attr,
		     struct vm_area_struct *vma)
{
	return pci_mmap_resource(kobj, attr, vma, 0);
}
static int
pci_mmap_resource_wc(struct kobject *kobj, struct bin_attribute *attr,
		     struct vm_area_struct *vma)
{
	return pci_mmap_resource(kobj, attr, vma, 1);
}
static inline int pci_create_resource_files(struct pci_dev *dev) { return 0; }
static inline void pci_remove_resource_files(struct pci_dev *dev) { return; }
int __attribute__ ((weak)) pcibios_add_platform_entries(struct pci_dev *dev)
{
	return 0;
}
int pci_find_next_capability(struct pci_dev *dev, u8 pos, int cap)
{
	return __pci_find_next_cap(dev->bus, dev->devfn,
				   pos + PCI_CAP_LIST_NEXT, cap);
}
int pci_find_next_ht_capability(struct pci_dev *dev, int pos, int ht_cap)
{
	return __pci_find_next_ht_cap(dev, pos + PCI_CAP_LIST_NEXT, ht_cap);
}
static inline bool platform_pci_power_manageable(struct pci_dev *dev)
{
	return pci_platform_pm ? pci_platform_pm->is_manageable(dev) : false;
}
static inline int platform_pci_set_power_state(struct pci_dev *dev,
                                                pci_power_t t)
{
	return pci_platform_pm ? pci_platform_pm->set_state(dev, t) : -ENOSYS;
}
static inline pci_power_t platform_pci_choose_state(struct pci_dev *dev)
{
	return pci_platform_pm ?
			pci_platform_pm->choose_state(dev) : PCI_POWER_ERROR;
}
static inline bool platform_pci_can_wakeup(struct pci_dev *dev)
{
	return pci_platform_pm ? pci_platform_pm->can_wakeup(dev) : false;
}
static inline int platform_pci_sleep_wake(struct pci_dev *dev, bool enable)
{
	return pci_platform_pm ?
			pci_platform_pm->sleep_wake(dev, enable) : -ENODEV;
}
int pci_enable_device_io(struct pci_dev *dev)
{
	return __pci_enable_device_flags(dev, IORESOURCE_IO);
}
int pci_enable_device_mem(struct pci_dev *dev)
{
	return __pci_enable_device_flags(dev, IORESOURCE_MEM);
}
int pci_enable_device(struct pci_dev *dev)
{
	return __pci_enable_device_flags(dev, IORESOURCE_MEM | IORESOURCE_IO);
}
int __attribute__ ((weak)) pcibios_set_pcie_reset_state(struct pci_dev *dev,
							enum pcie_reset_state state)
{
	return -EINVAL;
}
int pci_set_pcie_reset_state(struct pci_dev *dev, enum pcie_reset_state state)
{
	return pcibios_set_pcie_reset_state(dev, state);
}
int pci_wake_from_d3(struct pci_dev *dev, bool enable)
{
	return pci_pme_capable(dev, PCI_D3cold) ?
			pci_enable_wake(dev, PCI_D3cold, enable) :
			pci_enable_wake(dev, PCI_D3hot, enable);
}
u8 pci_swizzle_interrupt_pin(struct pci_dev *dev, u8 pin)
{
	return (((pin - 1) + PCI_SLOT(dev->devfn)) % 4) + 1;
}
int pci_request_region(struct pci_dev *pdev, int bar, const char *res_name)
{
	return __pci_request_region(pdev, bar, res_name, 0);
}
int pci_request_region_exclusive(struct pci_dev *pdev, int bar, const char *res_name)
{
	return __pci_request_region(pdev, bar, res_name, IORESOURCE_EXCLUSIVE);
}
int pci_request_selected_regions(struct pci_dev *pdev, int bars,
				 const char *res_name)
{
	return __pci_request_selected_regions(pdev, bars, res_name, 0);
}
int pci_request_selected_regions_exclusive(struct pci_dev *pdev,
				 int bars, const char *res_name)
{
	return __pci_request_selected_regions(pdev, bars, res_name,
			IORESOURCE_EXCLUSIVE);
}
void pci_release_regions(struct pci_dev *pdev)
{
	pci_release_selected_regions(pdev, (1 << 6) - 1);
}
int pci_request_regions(struct pci_dev *pdev, const char *res_name)
{
	return pci_request_selected_regions(pdev, ((1 << 6) - 1), res_name);
}
int pci_request_regions_exclusive(struct pci_dev *pdev, const char *res_name)
{
	return pci_request_selected_regions_exclusive(pdev,
					((1 << 6) - 1), res_name);
}
void pci_clear_master(struct pci_dev *dev)
{
	__pci_set_master(dev, false);
}
int pci_set_mwi(struct pci_dev *dev)
{
	return 0;
}
int pci_try_set_mwi(struct pci_dev *dev)
{
	return 0;
}
int pci_set_dma_max_seg_size(struct pci_dev *dev, unsigned int size)
{
	return dma_set_max_seg_size(&dev->dev, size);
}
int pci_set_dma_seg_boundary(struct pci_dev *dev, unsigned long mask)
{
	return dma_set_seg_boundary(&dev->dev, mask);
}
int pci_execute_reset_function(struct pci_dev *dev)
{
	return __pci_reset_function(dev, 0);
}
static void __devinit pci_no_domains(void)
{
	pci_domains_supported = 0;
}
int __attribute__ ((weak)) pci_ext_cfg_avail(struct pci_dev *dev)
{
	return 1;
}
static int aer_suspend(struct pcie_device *dev, pm_message_t state)
{return 0;}
static int aer_resume(struct pcie_device *dev) {return 0;}
void pci_no_aer(void)
{
	pcie_aer_disable = 1;	/* has priority over 'forceload' */
}
static pci_ers_result_t aer_error_detected(struct pci_dev *dev,
			enum pci_channel_state error)
{
	return PCI_ERS_RESULT_CAN_RECOVER;
}
static void __exit aer_service_exit(void)
{
	pcie_port_service_unregister(&aerdriver);
}
int pcie_aspm_enabled(void)
{
       return !aspm_disabled;
}
int pcie_port_bus_register(void)
{
	return bus_register(&pcie_port_bus_type);
}
void pcie_port_bus_unregister(void)
{
	bus_unregister(&pcie_port_bus_type);
}
static void release_pcie_device(struct device *dev)
{
	kfree(to_pcie_device(dev));			
}
int pcie_port_device_suspend(struct pci_dev *dev, pm_message_t state)
{
	return device_for_each_child(&dev->dev, &state, suspend_iter);
}
int pcie_port_device_resume(struct pci_dev *dev)
{
	return device_for_each_child(&dev->dev, NULL, resume_iter);
}
void pcie_port_service_unregister(struct pcie_port_service_driver *drv)
{
	driver_unregister(&drv->driver);
}
static int pcie_portdrv_suspend(struct pci_dev *dev, pm_message_t state)
{
	return pcie_port_device_suspend(dev, state);
}
static int find_anything(struct device *dev, void *data)
{
	return 1;
}
static ssize_t inline pci_bus_show_cpumaskaffinity(struct device *dev,
					struct device_attribute *attr,
					char *buf)
{
	return pci_bus_show_cpuaffinity(dev, 0, attr, buf);
}
static ssize_t inline pci_bus_show_cpulistaffinity(struct device *dev,
					struct device_attribute *attr,
					char *buf)
{
	return pci_bus_show_cpuaffinity(dev, 1, attr, buf);
}
static int __init pcibus_class_init(void)
{
	return class_register(&pcibus_class);
}
static void pci_release_capabilities(struct pci_dev *dev)
{
	pci_vpd_release(dev);
}
static void pci_release_bus_bridge_dev(struct device *dev)
{
	kfree(dev);
}
void __init pci_sort_breadthfirst(void)
{
	bus_sort_breadthfirst(&pci_bus_type, &pci_sort_bf_cmp);
}
static int proc_bus_pci_dev_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &proc_bus_pci_devices_op);
}
static void __devinit quirk_mellanox_tavor(struct pci_dev *dev)
{
	dev->broken_parity_status = 1;	/* This device gives false positives */
}
static void __devinit quirk_citrine(struct pci_dev *dev)
{
	dev->cfg_size = 0xA0;
}
static void __devinit quirk_transparent_bridge(struct pci_dev *dev)
{
	dev->transparent = 1;
}
static void __init quirk_eisa_bridge(struct pci_dev *dev)
{
	dev->class = PCI_CLASS_BRIDGE_EISA << 8;
}
static void __devinit quirk_pcie_mch(struct pci_dev *pdev)
{
	pcie_mch_quirk = 1;
}
static void __devinit quirk_msi_intx_disable_bug(struct pci_dev *dev)
{
	dev->dev_flags |= PCI_DEV_FLAGS_MSI_INTX_DISABLE_BUG;
}
struct pci_dev *
pci_get_device(unsigned int vendor, unsigned int device, struct pci_dev *from)
{
	return pci_get_subsys(vendor, device, PCI_ANY_ID, PCI_ANY_ID, from);
}
static ssize_t address_read_file(struct pci_slot *slot, char *buf)
{
	if (slot->number == 0xff)
		return sprintf(buf, "%04x:%02x\n",
				pci_domain_nr(slot->bus),
				slot->bus->number);
	else
		return sprintf(buf, "%04x:%02x:%02x\n",
				pci_domain_nr(slot->bus),
				slot->bus->number,
				slot->number);
}
static inline int at91_cf_present(struct at91_cf_socket *cf)
{
	return !gpio_get_value(cf->board->det_pin);
}
static int at91_cf_ss_init(struct pcmcia_socket *s)
{
	return 0;
}
static int at91_cf_ss_suspend(struct pcmcia_socket *s)
{
	return at91_cf_set_socket(s, &dead_socket);
}
static int __init at91_cf_init(void)
{
	return platform_driver_probe(&at91_cf_driver, at91_cf_probe);
}
static void __exit at91_cf_exit(void)
{
	platform_driver_unregister(&at91_cf_driver);
}
static int au1x00_drv_pcmcia_suspend(struct platform_device *dev,
				     pm_message_t state)
{
	return pcmcia_socket_dev_suspend(&dev->dev, state);
}
static int au1x00_drv_pcmcia_resume(struct platform_device *dev)
{
	return pcmcia_socket_dev_resume(&dev->dev);
}
static void __exit au1x00_pcmcia_exit(void)
{
	platform_driver_unregister(&au1x00_pcmcia_driver);
}
static int xxs1500_pcmcia_init(struct pcmcia_init *init)
{
	return PCMCIA_NUM_SOCKS;
}
static int bfin_cf_ss_init(struct pcmcia_socket *s)
{
	return 0;
}
static int bfin_cf_ss_suspend(struct pcmcia_socket *s)
{
	return bfin_cf_set_socket(s, &dead_socket);
}
static int bfin_cf_suspend(struct platform_device *pdev, pm_message_t mesg)
{
	return pcmcia_socket_dev_suspend(&pdev->dev, mesg);
}
static int bfin_cf_resume(struct platform_device *pdev)
{
	return pcmcia_socket_dev_resume(&pdev->dev);
}
static int __init bfin_cf_init(void)
{
	return platform_driver_register(&bfin_cf_driver);
}
static void __exit bfin_cf_exit(void)
{
	platform_driver_unregister(&bfin_cf_driver);
}
int cs_debug_level(int level)
{
	return pc_debug > level;
}
static void pcmcia_release_socket_class(struct class *data)
{
	complete(&pcmcia_unload);
}
static inline int pcmcia_load_firmware(struct pcmcia_device *dev, char * filename)
{
	return -ENODEV;
}
static int pcmcia_bus_uevent(struct device *dev, struct kobj_uevent_env *env)
{
	return -ENODEV;
}
static int electra_cf_ss_init(struct pcmcia_socket *s)
{
	return 0;
}
static int electra_cf_set_io_map(struct pcmcia_socket *s,
				 struct pccard_io_map *io)
{
	return 0;
}
static int __init electra_cf_init(void)
{
	return of_register_platform_driver(&electra_cf_driver);
}
static void __exit electra_cf_exit(void)
{
	of_unregister_platform_driver(&electra_cf_driver);
}
static int i82092aa_socket_suspend (struct pci_dev *dev, pm_message_t state)
{
	return pcmcia_socket_dev_suspend(&dev->dev, state);
}
static int i82092aa_socket_resume (struct pci_dev *dev)
{
	return pcmcia_socket_dev_resume(&dev->dev);
}
static int to_cycles(int ns)
{
	if (cycle_time!=0)
		return ns/cycle_time;
	else
		return 0;
}
static int i82092aa_module_init(void)
{
	return pci_register_driver(&i82092aa_pci_driver);
}
static int to_cycles(int ns)
{
    return ns/cycle_time;
}
static int i82365_drv_pcmcia_suspend(struct platform_device *dev,
				     pm_message_t state)
{
	return pcmcia_socket_dev_suspend(&dev->dev, state);
}
static int i82365_drv_pcmcia_resume(struct platform_device *dev)
{
	return pcmcia_socket_dev_resume(&dev->dev);
}
static int cfc_drv_pcmcia_suspend(struct platform_device *dev,
				     pm_message_t state)
{
	return pcmcia_socket_dev_suspend(&dev->dev, state);
}
static int cfc_drv_pcmcia_resume(struct platform_device *dev)
{
	return pcmcia_socket_dev_resume(&dev->dev);
}
void pcc_ioread(int sock, unsigned long port, void *buf, size_t size, size_t nmemb, int flag) {
	pcc_iorw(sock, port, buf, size, nmemb, 0, flag);
}
void pcc_iowrite(int sock, unsigned long port, void *buf, size_t size, size_t nmemb, int flag) {
    pcc_iorw(sock, port, buf, size, nmemb, 1, flag);
}
static unsigned int pcc_get(u_short sock, unsigned int reg)
{
	return inl(socket[sock].base + reg);
}
static void pcc_set(u_short sock, unsigned int reg, unsigned int data)
{
  	outl(data, socket[sock].base + reg);
}
static int pcc_drv_pcmcia_suspend(struct platform_device *dev,
				     pm_message_t state)
{
	return pcmcia_socket_dev_suspend(&dev->dev, state);
}
static int pcc_drv_pcmcia_resume(struct platform_device *dev)
{
	return pcmcia_socket_dev_resume(&dev->dev);
}
static void hardware_enable(int slot)
{
	out_be32((u32 *) BCSR1, in_be32((u32 *) BCSR1) & ~BCSR1_PCCEN);
}
static void hardware_disable(int slot)
{
	out_be32((u32 *) BCSR1, in_be32((u32 *) BCSR1) | BCSR1_PCCEN);
}
static inline void hardware_enable(int slot)
{
	m8xx_pcmcia_ops.hw_ctrl(slot, 1);
}
static inline void hardware_disable(int slot)
{
	m8xx_pcmcia_ops.hw_ctrl(slot, 0);
}
static inline int voltage_set(int slot, int vcc, int vpp)
{
	return m8xx_pcmcia_ops.voltage_set(slot, vcc, vpp);
}
static int m8xx_sock_suspend(struct pcmcia_socket *sock)
{
	return m8xx_set_socket(sock, &dead_socket);
}
static int m8xx_suspend(struct platform_device *pdev, pm_message_t state)
{
	return pcmcia_socket_dev_suspend(&pdev->dev, state);
}
static int m8xx_resume(struct platform_device *pdev)
{
	return pcmcia_socket_dev_resume(&pdev->dev);
}
static int __init m8xx_init(void)
{
	return of_register_platform_driver(&m8xx_pcmcia_driver);
}
static void __exit m8xx_exit(void)
{
	of_unregister_platform_driver(&m8xx_pcmcia_driver);
}
static int omap_cf_ss_init(struct pcmcia_socket *s)
{
	return 0;
}
static int omap_cf_suspend(struct platform_device *pdev, pm_message_t mesg)
{
	return pcmcia_socket_dev_suspend(&pdev->dev, mesg);
}
static int omap_cf_resume(struct platform_device *pdev)
{
	return pcmcia_socket_dev_resume(&pdev->dev);
}
static inline int adjust_irq(struct pcmcia_socket *s, adjust_t *adj) {
	return 0;
}
static int queue_empty(user_info_t *user)
{
    return (user->event_head == user->event_tail);
}
static irqreturn_t test_action(int cpl, void *dev_id)
{
	return IRQ_NONE;
}
static int pd6729_socket_suspend(struct pci_dev *dev, pm_message_t state)
{
	return pcmcia_socket_dev_suspend(&dev->dev, state);
}
static int pd6729_socket_resume(struct pci_dev *dev)
{
	return pcmcia_socket_dev_resume(&dev->dev);
}
static int pd6729_module_init(void)
{
	return pci_register_driver(&pd6729_pci_driver);
}
static void pd6729_module_exit(void)
{
	pci_unregister_driver(&pd6729_pci_driver);
}
static inline u_int pxa2xx_pcmcia_cmd_time(u_int mem_clk_10khz,
					   u_int pcmcia_mcxx_asst)
{
	return (300000 * (pcmcia_mcxx_asst + 1) / mem_clk_10khz);
}
static int pxa2xx_drv_pcmcia_probe(struct platform_device *dev)
{
	return __pxa2xx_drv_pcmcia_probe(&dev->dev);
}
static int pxa2xx_drv_pcmcia_remove(struct platform_device *dev)
{
	return soc_common_drv_pcmcia_remove(&dev->dev);
}
static int pxa2xx_drv_pcmcia_suspend(struct platform_device *dev, pm_message_t state)
{
	return pcmcia_socket_dev_suspend(&dev->dev, state);
}
static int __init pxa2xx_pcmcia_init(void)
{
	return platform_driver_register(&pxa2xx_pcmcia_driver);
}
static void __exit pxa2xx_pcmcia_exit(void)
{
	platform_driver_unregister(&pxa2xx_pcmcia_driver);
}
void __exit cmx255_pcmcia_exit(void)
{
	platform_device_unregister(cmx255_pcmcia_device);
}
void __exit cmx270_pcmcia_exit(void)
{
	platform_device_unregister(cmx270_pcmcia_device);
}
static void e740_pcmcia_hw_shutdown(struct soc_pcmcia_socket *skt)
{
	soc_pcmcia_free_irqs(skt, &cd_irqs[skt->nr], 1);
}
static void e740_pcmcia_socket_init(struct soc_pcmcia_socket *skt)
{
	soc_pcmcia_enable_irqs(skt, cd_irqs, ARRAY_SIZE(cd_irqs));
}
static void e740_pcmcia_socket_suspend(struct soc_pcmcia_socket *skt)
{
	soc_pcmcia_disable_irqs(skt, cd_irqs, ARRAY_SIZE(cd_irqs));
}
static void __exit e740_pcmcia_exit(void)
{
	platform_device_unregister(e740_pcmcia_device);
}
static void mst_pcmcia_hw_shutdown(struct soc_pcmcia_socket *skt)
{
	soc_pcmcia_free_irqs(skt, irqs, ARRAY_SIZE(irqs));
}
static void __exit mst_pcmcia_exit(void)
{
	platform_device_unregister(mst_pcmcia_device);
}
static void __exit palmld_pcmcia_exit(void)
{
	platform_device_unregister(palmld_pcmcia_device);
}
static void __exit palmtx_pcmcia_exit(void)
{
	platform_device_unregister(palmtx_pcmcia_device);
}
static void sharpsl_pcmcia_socket_suspend(struct soc_pcmcia_socket *skt)
{
	sharpsl_pcmcia_init_reset(skt);
}
static void __exit sharpsl_pcmcia_exit(void)
{
	platform_device_unregister(sharpsl_pcmcia_device);
}
static void trizeps_pcmcia_socket_init(struct soc_pcmcia_socket *skt)
{
	board_pcmcia_power(0x9);
}
static void trizeps_pcmcia_socket_suspend(struct soc_pcmcia_socket *skt)
{
	board_pcmcia_power(0x0);
}
static void __exit trizeps_pcmcia_exit(void)
{
	platform_device_unregister(trizeps_pcmcia_device);
}
static void __exit viper_pcmcia_exit(void)
{
	platform_device_unregister(viper_pcmcia_device);
}
static int iodyn_adjust_io_region(struct resource *res, unsigned long r_start,
				      unsigned long r_end, struct pcmcia_socket *s)
{
	return adjust_resource(res, r_start, r_end - r_start + 1);
}
static inline int nonstatic_autoadd_resources(struct pcmcia_socket *s)
{
	return -ENODEV;
}
static int __init nonstatic_sysfs_init(void)
{
	return class_interface_register(&pccard_rsrc_interface);
}
static void __exit nonstatic_sysfs_exit(void)
{
	class_interface_unregister(&pccard_rsrc_interface);
}
static void assabet_pcmcia_hw_shutdown(struct soc_pcmcia_socket *skt)
{
	soc_pcmcia_free_irqs(skt, irqs, ARRAY_SIZE(irqs));
}
static void complain_about_jumpering(const char *whom,
				     const char *supply,
				     int given, int wanted)
{
	printk(KERN_ERR
	 "%s: %s %d.%dV wanted but board is jumpered for %s %d.%dV operation"
	 "; re-jumper the board and/or use pcmv=xx,xx,xx\n",
	       whom, supply,
	       wanted / 10, wanted % 10,
	       supply,
	       given / 10, given % 10);
}
static void cerf_pcmcia_hw_shutdown(struct soc_pcmcia_socket *skt)
{
	soc_pcmcia_free_irqs(skt, irqs, ARRAY_SIZE(irqs));
}
static void cerf_pcmcia_socket_init(struct soc_pcmcia_socket *skt)
{
	soc_pcmcia_enable_irqs(skt, irqs, ARRAY_SIZE(irqs));
}
static void cerf_pcmcia_socket_suspend(struct soc_pcmcia_socket *skt)
{
	soc_pcmcia_disable_irqs(skt, irqs, ARRAY_SIZE(irqs));
}
static int sa11x0_drv_pcmcia_remove(struct platform_device *dev)
{
	return soc_common_drv_pcmcia_remove(&dev->dev);
}
static int sa11x0_drv_pcmcia_suspend(struct platform_device *dev,
				     pm_message_t state)
{
	return pcmcia_socket_dev_suspend(&dev->dev, state);
}
static int sa11x0_drv_pcmcia_resume(struct platform_device *dev)
{
	return pcmcia_socket_dev_resume(&dev->dev);
}
static int __init sa11x0_pcmcia_init(void)
{
	return platform_driver_register(&sa11x0_pcmcia_driver);
}
static void __exit sa11x0_pcmcia_exit(void)
{
	platform_driver_unregister(&sa11x0_pcmcia_driver);
}
static void shannon_pcmcia_hw_shutdown(struct soc_pcmcia_socket *skt)
{
	soc_pcmcia_free_irqs(skt, irqs, ARRAY_SIZE(irqs));
}
static void shannon_pcmcia_socket_init(struct soc_pcmcia_socket *skt)
{
	soc_pcmcia_enable_irqs(skt, irqs, ARRAY_SIZE(irqs));
}
static void shannon_pcmcia_socket_suspend(struct soc_pcmcia_socket *skt)
{
	soc_pcmcia_disable_irqs(skt, irqs, ARRAY_SIZE(irqs));
}
static void simpad_pcmcia_socket_init(struct soc_pcmcia_socket *skt)
{
	soc_pcmcia_enable_irqs(skt, irqs, ARRAY_SIZE(irqs));
}
void sa1111_pcmcia_hw_shutdown(struct soc_pcmcia_socket *skt)
{
	soc_pcmcia_free_irqs(skt, irqs, ARRAY_SIZE(irqs));
}
void sa1111_pcmcia_socket_init(struct soc_pcmcia_socket *skt)
{
	soc_pcmcia_enable_irqs(skt, irqs, ARRAY_SIZE(irqs));
}
void sa1111_pcmcia_socket_suspend(struct soc_pcmcia_socket *skt)
{
	soc_pcmcia_disable_irqs(skt, irqs, ARRAY_SIZE(irqs));
}
static int pcmcia_suspend(struct sa1111_dev *dev, pm_message_t state)
{
	return pcmcia_socket_dev_suspend(&dev->dev, state);
}
static int pcmcia_resume(struct sa1111_dev *dev)
{
	return pcmcia_socket_dev_resume(&dev->dev);
}
static int __init sa1111_drv_pcmcia_init(void)
{
	return sa1111_driver_register(&pcmcia_driver);
}
static void __exit sa1111_drv_pcmcia_exit(void)
{
	sa1111_driver_unregister(&pcmcia_driver);
}
static unsigned int
sa1100_pcmcia_default_mecr_timing(struct soc_pcmcia_socket *skt,
				  unsigned int cpu_speed,
				  unsigned int cmd_time)
{
	return sa1100_pcmcia_mecr_bs(cmd_time, cpu_speed);
}
static int
sa1100_pcmcia_set_timing(struct soc_pcmcia_socket *skt)
{
	return sa1100_pcmcia_set_mecr(skt, cpufreq_get(0));
}
static int __init sa11xx_pcmcia_init(void)
{
	return 0;
}
static void soc_pcmcia_cpufreq_unregister(void)
{
	cpufreq_unregister_notifier(&soc_pcmcia_notifier_block, CPUFREQ_TRANSITION_NOTIFIER);
}
static int soc_pcmcia_cpufreq_register(void) { return 0; }
static int to_cycles(int ns)
{
    if (ns < 14)
	return 0;
    else
	return 2*(ns-14)/cycle_time;
}
static int tcic_drv_pcmcia_suspend(struct platform_device *dev,
				     pm_message_t state)
{
	return pcmcia_socket_dev_suspend(&dev->dev, state);
}
static int tcic_drv_pcmcia_resume(struct platform_device *dev)
{
	return pcmcia_socket_dev_resume(&dev->dev);
}
static inline uint8_t exca_readb(vrc4173_socket_t *socket, uint16_t offset)
{
	return readb(socket->base + EXCA_REGS_BASE + offset);
}
static inline void exca_writeb(vrc4173_socket_t *socket, uint16_t offset, uint8_t val)
{
	writeb(val, socket->base + EXCA_REGS_BASE + offset);
}
static inline uint32_t cardbus_socket_readl(vrc4173_socket_t *socket, u16 offset)
{
	return readl(socket->base + CARDBUS_SOCKET_REGS_BASE + offset);
}
static inline void cardbus_socket_writel(vrc4173_socket_t *socket, u16 offset, uint32_t val)
{
	writel(val, socket->base + CARDBUS_SOCKET_REGS_BASE + offset);
}
static void __devexit vrc4173_cardu_exit(void)
{
	pci_unregister_driver(&vrc4173_cardu_driver);
}
static int __init yenta_socket_init(void)
{
	return pci_register_driver (&yenta_cardbus_driver);
}
static void __exit yenta_socket_exit (void)
{
	pci_unregister_driver (&yenta_cardbus_driver);
}
static void mail_led_set(struct led_classdev *led_cdev,
enum led_brightness value)
{
	set_u32(value, ACER_CAP_MAILLED);
}
static int __devinit acer_led_init(struct device *dev)
{
	return led_classdev_register(dev, &mail_led);
}
static void acer_led_exit(void)
{
	led_classdev_unregister(&mail_led);
}
static void acer_backlight_exit(void)
{
	backlight_device_unregister(acer_backlight_device);
}
static int get_lcd_state(void)
{
	return read_status(LCD_ON);
}
static ssize_t show_ledd(struct device *dev,
			 struct device_attribute *attr, char *buf)
{
	return sprintf(buf, "0x%08x\n", hotk->ledd_status);
}
static ssize_t show_wlan(struct device *dev,
			 struct device_attribute *attr, char *buf)
{
	return sprintf(buf, "%d\n", read_status(WL_ON));
}
static ssize_t store_wlan(struct device *dev, struct device_attribute *attr,
			  const char *buf, size_t count)
{
	return store_status(buf, count, wl_switch_handle, WL_ON);
}
static ssize_t show_bluetooth(struct device *dev,
			      struct device_attribute *attr, char *buf)
{
	return sprintf(buf, "%d\n", read_status(BT_ON));
}
static ssize_t store_bluetooth(struct device *dev,
			       struct device_attribute *attr, const char *buf,
			       size_t count)
{
	return store_status(buf, count, bt_switch_handle, BT_ON);
}
static ssize_t show_disp(struct device *dev,
			 struct device_attribute *attr, char *buf)
{
	return sprintf(buf, "%d\n", read_display());
}
static ssize_t show_lssw(struct device *dev,
			 struct device_attribute *attr, char *buf)
{
	return sprintf(buf, "%d\n", hotk->light_switch);
}
static ssize_t show_lslvl(struct device *dev,
			  struct device_attribute *attr, char *buf)
{
	return sprintf(buf, "%d\n", hotk->light_level);
}
static ssize_t show_gps(struct device *dev,
			struct device_attribute *attr, char *buf)
{
	return sprintf(buf, "%d\n", read_status(GPS_ON));
}
static ssize_t store_gps(struct device *dev, struct device_attribute *attr,
			 const char *buf, size_t count)
{
	return store_status(buf, count, NULL, GPS_ON);
}
static int
proc_read_mled(char *page, char **start, off_t off, int count, int *eof,
	       void *data)
{
	return sprintf(page, "%d\n",
		       read_led(hotk->methods->mled_status, MLED_ON));
}
static int
proc_write_mled(struct file *file, const char __user *buffer,
		unsigned long count, void *data)
{
	return write_led(buffer, count, hotk->methods->mt_mled, MLED_ON, 1);
}
static int
proc_read_ledd(char *page, char **start, off_t off, int count, int *eof,
	       void *data)
{
	return sprintf(page, "0x%08x\n", hotk->ledd_status);
}
static int
proc_read_wled(char *page, char **start, off_t off, int count, int *eof,
	       void *data)
{
	return sprintf(page, "%d\n",
		       read_led(hotk->methods->wled_status, WLED_ON));
}
static int
proc_write_wled(struct file *file, const char __user *buffer,
		unsigned long count, void *data)
{
	return write_led(buffer, count, hotk->methods->mt_wled, WLED_ON, 0);
}
static int
proc_read_bluetooth(char *page, char **start, off_t off, int count, int *eof,
		    void *data)
{
	return sprintf(page, "%d\n", read_led(hotk->methods->bt_status, BT_ON));
}
static int
proc_write_bluetooth(struct file *file, const char __user *buffer,
		     unsigned long count, void *data)
{
	return write_led(buffer, count, hotk->methods->mt_bt_switch, BT_ON, 0);
}
static int
proc_read_tled(char *page, char **start, off_t off, int count, int *eof,
	       void *data)
{
	return sprintf(page, "%d\n",
		       read_led(hotk->methods->tled_status, TLED_ON));
}
static int
proc_write_tled(struct file *file, const char __user *buffer,
		unsigned long count, void *data)
{
	return write_led(buffer, count, hotk->methods->mt_tled, TLED_ON, 0);
}
static int
proc_read_lcd(char *page, char **start, off_t off, int count, int *eof,
	      void *data)
{
	return sprintf(page, "%d\n", get_lcd_state());
}
static int set_brightness_status(struct backlight_device *bd)
{
	return set_brightness(bd->props.brightness);
}
static int
proc_read_brn(char *page, char **start, off_t off, int count, int *eof,
	      void *data)
{
	return sprintf(page, "%d\n", read_brightness(NULL));
}
static int bl_get_brightness(struct backlight_device *b)
{
	return get_lcd_level();
}
static int bl_update_status(struct backlight_device *b)
{
	return set_lcd_level(b->props.brightness);
}
static int dell_wifi_set(void *data, enum rfkill_state state)
{
	return dell_rfkill_set(1, state);
}
static int dell_bluetooth_set(void *data, enum rfkill_state state)
{
	return dell_rfkill_set(2, state);
}
static int dell_wwan_set(void *data, enum rfkill_state state)
{
	return dell_rfkill_set(3, state);
}
static int dell_wifi_get(void *data, enum rfkill_state *state)
{
	return dell_rfkill_get(17, state);
}
static int dell_bluetooth_get(void *data, enum rfkill_state *state)
{
	return dell_rfkill_get(18, state);
}
static int dell_wwan_get(void *data, enum rfkill_state *state)
{
	return dell_rfkill_get(19, state);
}
static int read_brightness(struct backlight_device *bd)
{
	return get_acpi(CM_ASL_PANELBRIGHT);
}
static int update_bl_status(struct backlight_device *bd)
{
	return set_brightness(bd, bd->props.brightness);
}
static int eeepc_wlan_rfkill_set(void *data, enum rfkill_state state)
{
	if (state == RFKILL_STATE_SOFT_BLOCKED)
		return set_acpi(CM_ASL_WLAN, 0);
	else
		return set_acpi(CM_ASL_WLAN, 1);
}
static int eeepc_bluetooth_rfkill_set(void *data, enum rfkill_state state)
{
	if (state == RFKILL_STATE_SOFT_BLOCKED)
		return set_acpi(CM_ASL_BLUETOOTH, 0);
	else
		return set_acpi(CM_ASL_BLUETOOTH, 1);
}
static ssize_t show_sys_acpi(int cm, char *buf)
{
	return sprintf(buf, "%d\n", get_acpi(cm));
}
static ssize_t show_sys_hwmon(int (*get)(void), char *buf)
{
	return sprintf(buf, "%d\n", get());
}
static ssize_t
show_name(struct device *dev, struct device_attribute *attr, char *buf)
{
	return sprintf(buf, "eeepc\n");
}
static int bl_get_brightness(struct backlight_device *b)
{
	return get_lcd_level();
}
static ssize_t
ignore_store(struct device *dev,
	     struct device_attribute *attr, const char *buf, size_t count)
{
	return count;
}
static int hp_wmi_display_state(void)
{
	return hp_wmi_perform_query(HPWMI_DISPLAY_QUERY, 0, 0);
}
static int hp_wmi_hddtemp_state(void)
{
	return hp_wmi_perform_query(HPWMI_HDDTEMP_QUERY, 0, 0);
}
static int hp_wmi_als_state(void)
{
	return hp_wmi_perform_query(HPWMI_ALS_QUERY, 0, 0);
}
static int hp_wmi_dock_state(void)
{
	return hp_wmi_perform_query(HPWMI_DOCK_QUERY, 0, 0);
}
static int hp_wmi_wifi_set(void *data, enum rfkill_state state)
{
	if (state)
		return hp_wmi_perform_query(HPWMI_WIRELESS_QUERY, 1, 0x101);
	else
		return hp_wmi_perform_query(HPWMI_WIRELESS_QUERY, 1, 0x100);
}
static int hp_wmi_bluetooth_set(void *data, enum rfkill_state state)
{
	if (state)
		return hp_wmi_perform_query(HPWMI_WIRELESS_QUERY, 1, 0x202);
	else
		return hp_wmi_perform_query(HPWMI_WIRELESS_QUERY, 1, 0x200);
}
static int hp_wmi_wwan_set(void *data, enum rfkill_state state)
{
	if (state)
		return hp_wmi_perform_query(HPWMI_WIRELESS_QUERY, 1, 0x404);
	else
		return hp_wmi_perform_query(HPWMI_WIRELESS_QUERY, 1, 0x400);
}
static int bl_get_brightness(struct backlight_device *b)
{
	return get_lcd_level();
}
static int bl_update_status(struct backlight_device *b)
{
	return set_lcd_level(b->props.brightness);
}
static int read_brightness(struct backlight_device *bd)
{
	return (int)smread_s16(OQO_O2_SMB0_BL_HI, OQO_O2_SMB0_BL_LO);
}
static int update_bl_status(struct backlight_device *bd)
{
	return smwrite_s16(OQO_O2_SMB0_BL_HI,
			   OQO_O2_SMB0_BL_LO, (s16) bd->props.brightness);
}
static void __exit acpi_pcc_exit(void)
{
	acpi_bus_unregister_driver(&acpi_pcc_driver);
}
static int sony_backlight_update_status(struct backlight_device *bd)
{
	return acpi_callsetfunc(sony_nc_acpi_handle, "SBRT",
				bd->props.brightness + 1, NULL);
}
static int sony_pic_set_fanspeed(unsigned long value)
{
	return ec_write(SONY_PIC_FAN0_STATUS, value);
}
static int sony_pic_get_fanspeed(u8 *value)
{
	return ec_read(SONY_PIC_FAN0_STATUS, value);
}
static int sonypi_misc_fasync(int fd, struct file *filp, int on)
{
	return fasync_helper(fd, filp, on, &sonypi_compat.fifo_async);
}
static int sonypi_compat_init(void) { return 0; }
static int __init tpacpi_device_add(struct acpi_device *device)
{
	return 0;
}
static ssize_t tpacpi_driver_interface_version_show(
				struct device_driver *drv,
				char *buf)
{
	return snprintf(buf, PAGE_SIZE, "0x%08x\n", TPACPI_SYSFS_VERSION);
}
static ssize_t tpacpi_driver_debug_show(struct device_driver *drv,
						char *buf)
{
	return snprintf(buf, PAGE_SIZE, "0x%04x\n", dbg_level);
}
static ssize_t tpacpi_driver_version_show(struct device_driver *drv,
						char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%s v%s\n",
			TPACPI_DESC, TPACPI_VERSION);
}
static ssize_t tpacpi_driver_wlsw_emulstate_show(struct device_driver *drv,
						char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%d\n", !!tpacpi_wlsw_emulstate);
}
static ssize_t tpacpi_driver_bluetooth_emulstate_show(
					struct device_driver *drv,
					char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%d\n", !!tpacpi_bluetooth_emulstate);
}
static ssize_t tpacpi_driver_wwan_emulstate_show(
					struct device_driver *drv,
					char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%d\n", !!tpacpi_wwan_emulstate);
}
static ssize_t tpacpi_driver_uwb_emulstate_show(
					struct device_driver *drv,
					char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%d\n", !!tpacpi_uwb_emulstate);
}
static ssize_t hotkey_bios_enabled_show(struct device *dev,
			   struct device_attribute *attr,
			   char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%d\n", hotkey_orig_status);
}
static ssize_t hotkey_bios_mask_show(struct device *dev,
			   struct device_attribute *attr,
			   char *buf)
{
	return snprintf(buf, PAGE_SIZE, "0x%08x\n", hotkey_orig_mask);
}
static ssize_t hotkey_all_mask_show(struct device *dev,
			   struct device_attribute *attr,
			   char *buf)
{
	return snprintf(buf, PAGE_SIZE, "0x%08x\n",
				hotkey_all_mask | hotkey_source_mask);
}
static ssize_t hotkey_recommended_mask_show(struct device *dev,
					    struct device_attribute *attr,
					    char *buf)
{
	return snprintf(buf, PAGE_SIZE, "0x%08x\n",
			(hotkey_all_mask | hotkey_source_mask)
			& ~hotkey_reserved_mask);
}
static ssize_t hotkey_source_mask_show(struct device *dev,
			   struct device_attribute *attr,
			   char *buf)
{
	return snprintf(buf, PAGE_SIZE, "0x%08x\n", hotkey_source_mask);
}
static ssize_t hotkey_poll_freq_show(struct device *dev,
			   struct device_attribute *attr,
			   char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%d\n", hotkey_poll_freq);
}
static ssize_t hotkey_report_mode_show(struct device *dev,
			   struct device_attribute *attr,
			   char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%d\n",
		(hotkey_report_mode != 0) ? hotkey_report_mode : 1);
}
static ssize_t hotkey_wakeup_reason_show(struct device *dev,
			   struct device_attribute *attr,
			   char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%d\n", hotkey_wakeup_reason);
}
static ssize_t hotkey_wakeup_hotunplug_complete_show(struct device *dev,
			   struct device_attribute *attr,
			   char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%d\n", hotkey_autosleep_ack);
}
static void bluetooth_suspend(pm_message_t state)
{
	acpi_evalf(NULL, NULL, "\\BLTH", "vd",
		   TP_ACPI_BLTH_PWR_OFF_ON_RESUME);
}
static int tpacpi_bluetooth_rfk_set(void *data, enum rfkill_state state)
{
	return bluetooth_set_radiosw((state == RFKILL_STATE_UNBLOCKED), 0);
}
static void wan_suspend(pm_message_t state)
{
	acpi_evalf(NULL, NULL, "\\WGSV", "qvd",
		   TP_ACPI_WGSV_PWR_OFF_ON_RESUME);
}
static int tpacpi_wan_rfk_set(void *data, enum rfkill_state state)
{
	return wan_set_radiosw((state == RFKILL_STATE_UNBLOCKED), 0);
}
static int tpacpi_uwb_rfk_set(void *data, enum rfkill_state state)
{
	return uwb_set_radiosw((state == RFKILL_STATE_UNBLOCKED), 0);
}
static enum led_brightness light_sysfs_get(struct led_classdev *led_cdev)
{
	return (light_get_status() == 1)? LED_FULL : LED_OFF;
}
static void cmos_exit(void)
{
	device_remove_file(&tpacpi_pdev->dev, &dev_attr_cmos_command);
}
static void led_sysfs_set_status(unsigned int led,
				 enum led_brightness brightness)
{
	led_set_status(led,
			(brightness == LED_OFF) ?
			TPACPI_LED_OFF :
			(tpacpi_led_state_cache[led] == TPACPI_LED_BLINK) ?
				TPACPI_LED_BLINK : TPACPI_LED_ON);
}
static int brightness_update_status(struct backlight_device *bd)
{
	return brightness_set(
		(bd->props.fb_blank == FB_BLANK_UNBLANK &&
		 bd->props.power == FB_BLANK_UNBLANK) ?
				bd->props.brightness : 0);
}
static ssize_t fan_fan_watchdog_show(struct device_driver *drv,
				     char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%u\n", fan_watchdog_maxinterval);
}
static ssize_t thinkpad_acpi_pdev_name_show(struct device *dev,
			   struct device_attribute *attr,
			   char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%s\n", TPACPI_NAME);
}
static __inline__ void _set_bit(u32 * word, u32 mask, int value)
{
	*word = (*word & ~mask) | (mask * value);
}
static int set_lcd_status(struct backlight_device *bd)
{
	return set_lcd(bd->props.brightness);
}
bool wmi_has_guid(const char *guid_string)
{
	return find_guid(guid_string, NULL);
}
static void card_remove(struct pnp_dev *dev)
{
	dev->card_link = NULL;
}
static int __init pnp_init(void)
{
	return bus_register(&pnp_bus_type);
}
void pnp_unregister_driver(struct pnp_driver *drv)
{
	driver_unregister(&drv->driver);
}
static void pnp_print_port(pnp_info_buffer_t * buffer, char *space,
			   struct pnp_port *port)
{
	pnp_printf(buffer, "%sport %#llx-%#llx, align %#llx, size %#llx, "
		   "%i-bit address decoding\n", space,
		   (unsigned long long) port->min,
		   (unsigned long long) port->max,
		   port->align ? ((unsigned long long) port->align - 1) : 0,
		   (unsigned long long) port->size,
		   port->flags & IORESOURCE_IO_16BIT_ADDR ? 16 : 10);
}
static void pnp_convert_id(char *buf, unsigned short vendor,
			   unsigned short device)
{
	sprintf(buf, "%c%c%c%x%x%x%x",
		'A' + ((vendor >> 2) & 0x3f) - 1,
		'A' + (((vendor & 3) << 3) | ((vendor >> 13) & 7)) - 1,
		'A' + ((vendor >> 8) & 0x1f) - 1,
		(device >> 4) & 0x0f, device & 0x0f,
		(device >> 12) & 0x0f, (device >> 8) & 0x0f);
}
static inline void write_data(unsigned char x)
{
	outb(x, _PNPWRP);
}
static void isapnp_wait(void)
{
	isapnp_write_byte(0x02, 0x02);
}
static void isapnp_wake(unsigned char csn)
{
	isapnp_write_byte(0x03, csn);
}
static void isapnp_device(unsigned char logdev)
{
	isapnp_write_byte(0x07, logdev);
}
static void __init isapnp_skip_bytes(int count)
{
	isapnp_peek(NULL, count);
}
void pnp_init_resources(struct pnp_dev *dev)
{
	pnp_free_resources(dev);
}
static inline int __init is_exclusive_device(struct acpi_device *dev)
{
	return (!acpi_match_device_ids(dev, excluded_id_list));
}
static int pnpacpi_resume(struct pnp_dev *dev)
{
	return acpi_bus_set_power((acpi_handle) dev->data, ACPI_STATE_D0);
}
int pnp_bios_present(void)
{
	return (pnp_bios_install != NULL);
}
static __init void pnpbios_parse_dma_option(struct pnp_dev *dev,
					    unsigned char *p, int size,
					    unsigned int option_flags)
{
	pnp_register_dma_resource(dev, option_flags, p[1], p[2]);
}
static irqreturn_t pnp_test_handler(int irq, void *dev_id)
{
	return IRQ_HANDLED;
}
unsigned long pnp_resource_type(struct resource *res)
{
	return res->flags & (IORESOURCE_IO  | IORESOURCE_MEM |
			     IORESOURCE_IRQ | IORESOURCE_DMA);
}
int pnp_is_active(struct pnp_dev *dev)
{
	if (!pnp_port_start(dev, 0) && pnp_port_len(dev, 0) <= 1 &&
	    !pnp_mem_start(dev, 0) && pnp_mem_len(dev, 0) <= 1 &&
	    pnp_irq(dev, 0) == -1 && pnp_dma(dev, 0) == -1)
		return 0;
	else
		return 1;
}
static int __init pnp_system_init(void)
{
	return pnp_register_driver(&system_pnp_driver);
}
static void __exit apm_battery_exit(void)
{
	apm_get_power_status = NULL;
}
static void __exit bq27x00_battery_exit(void)
{
	i2c_del_driver(&bq27200_battery_driver);
}
static inline int da9030_reg_to_mV(int reg)
{
	return ((reg * 2650) >> 8) + 2650;
}
static inline int da9030_millivolt_to_reg(int mV)
{
	return ((mV - 2650) << 8) / 2650;
}
static inline int da9030_reg_to_mA(int reg)
{
	return ((reg * 24000) >> 8) / 15;
}
static int debug_open(struct inode *inode, struct file *file)
{
	return single_open(file, bat_debug_show, inode->i_private);
}
static void da9030_bat_remove_debugfs(struct da9030_charger *charger)
{
	debugfs_remove(charger->debug_file);
}
static inline struct dentry *da9030_bat_create_debugfs(struct da9030_charger *charger)
{
	return NULL;
}
static inline void da9030_read_adc(struct da9030_charger *charger,
				   struct da9030_adc_res *adc)
{
	da903x_reads(charger->master, DA9030_VBAT_RES,
		     sizeof(*adc), (uint8_t *)adc);
}
static int da903x_battery_init(void)
{
	return platform_driver_register(&da903x_battery_driver);
}
static void da903x_battery_exit(void)
{
	platform_driver_unregister(&da903x_battery_driver);
}
static int __init ds2760_battery_init(void)
{
	return platform_driver_register(&ds2760_battery_driver);
}
static void __exit ds2760_battery_exit(void)
{
	platform_driver_unregister(&ds2760_battery_driver);
}
static int __init pcf50633_mbc_init(void)
{
	return platform_driver_register(&pcf50633_mbc_driver);
}
static void __exit pcf50633_mbc_exit(void)
{
	platform_driver_unregister(&pcf50633_mbc_driver);
}
static int otg_is_usb_online(void)
{
	return (transceiver->state == OTG_STATE_B_PERIPHERAL);
}
static int __init pda_power_init(void)
{
	return platform_driver_register(&pda_power_pdrv);
}
static void __exit pda_power_exit(void)
{
	platform_driver_unregister(&pda_power_pdrv);
}
static void __exit power_supply_class_exit(void)
{
	class_destroy(power_supply_class);
}
static bool tosa_jacket_bat_is_present(struct tosa_bat *bat)
{
	return gpio_get_value(TOSA_GPIO_JACKET_DETECT) == 0;
}
static void tosa_bat_external_power_changed(struct power_supply *psy)
{
	schedule_work(&bat_work);
}
static int __init tosa_bat_init(void)
{
	return platform_driver_register(&tosa_bat_driver);
}
static void __exit tosa_bat_exit(void)
{
	platform_driver_unregister(&tosa_bat_driver);
}
static int wm8350_read_battery_uvolts(struct wm8350 *wm8350)
{
	return wm8350_read_auxadc(wm8350, WM8350_AUXADC_BATT, 0, 0)
		* WM8350_AUX_COEFF;
}
static int wm8350_read_line_uvolts(struct wm8350 *wm8350)
{
	return wm8350_read_auxadc(wm8350, WM8350_AUXADC_LINE, 0, 0)
		* WM8350_AUX_COEFF;
}
static int wm8350_read_usb_uvolts(struct wm8350 *wm8350)
{
	return wm8350_read_auxadc(wm8350, WM8350_AUXADC_USB, 0, 0)
		* WM8350_AUX_COEFF;
}
static inline int wm8350_charge_time_min(struct wm8350 *wm8350, int min)
{
	if (!wm8350->power.rev_g_coeff)
		return (((min - 30) / 15) & 0xf) << 8;
	else
		return (((min - 30) / 30) & 0xf) << 8;
}
static int __init wm8350_power_init(void)
{
	return platform_driver_register(&wm8350_power_driver);
}
static void __exit wm8350_power_exit(void)
{
	platform_driver_unregister(&wm8350_power_driver);
}
static unsigned long wm97xx_read_bat(struct power_supply *bat_ps)
{
	return wm97xx_read_aux_adc(bat_ps->dev->parent->driver_data,
					pdata->batt_aux) * pdata->batt_mult /
					pdata->batt_div;
}
static unsigned long wm97xx_read_temp(struct power_supply *bat_ps)
{
	return wm97xx_read_aux_adc(bat_ps->dev->parent->driver_data,
					pdata->temp_aux) * pdata->temp_mult /
					pdata->temp_div;
}
static void wm97xx_bat_external_power_changed(struct power_supply *bat_ps)
{
	schedule_work(&bat_work);
}
static void wm97xx_bat_work(struct work_struct *work)
{
	wm97xx_bat_update(&bat_ps);
}
static int __init wm97xx_bat_init(void)
{
	return platform_driver_register(&wm97xx_bat_driver);
}
static void __exit wm97xx_bat_exit(void)
{
	platform_driver_unregister(&wm97xx_bat_driver);
}
void __init wm97xx_bat_set_pdata(struct wm97xx_batt_info *data)
{
	pdata = data;
}
u32 ps3_read_pm07_control(u32 cpu, u32 ctr)
{
	return 0;
}
static u64 pm_translate_signal_group_number_on_island4(u64 subgroup)
{
	return PM_ISLAND4_BASE_SIGNAL_GROUP_NUMBER + subgroup;
}
static u64 pm_translate_signal_group_number_on_island7(u64 subgroup)
{
	return PM_ISLAND7_BASE_SIGNAL_GROUP_NUMBER + subgroup;
}
static u64 pm_translate_signal_group_number_on_island8(u64 subgroup)
{
	return PM_ISLAND8_BASE_SIGNAL_GROUP_NUMBER + subgroup;
}
u32 ps3_get_hw_thread_id(int cpu)
{
	return get_hard_smp_processor_id(cpu);
}
u32 ps3_get_and_clear_pm_interrupts(u32 cpu)
{
	return ps3_read_pm(cpu, pm_status);
}
static void ps3_sys_manager_shutdown(struct ps3_system_bus_device *dev)
{
	dev_dbg(&dev->core, "%s:%d\n", __func__, __LINE__);
}
static void __maybe_unused _dump_ports_bmp(
	const struct ports_bmp *bmp, const char *func, int line)
{
	pr_debug("%s:%d: ports_bmp: %016llxh\n", func, line, bmp->status);
}
void ps3_vuart_cancel_async(struct ps3_system_bus_device *dev)
{
	to_port_priv(dev)->rx_list.work.trigger = 0;
}
static void __exit ps3_vuart_bus_exit(void)
{
	pr_debug("%s:%d:\n", __func__, __LINE__);
}
int ps3av_get_auto_mode(void)
{
	return ps3av_auto_videomode(&ps3av->av_hw_conf);
}
int ps3av_get_mode(void)
{
	return ps3av ? ps3av->ps3av_mode : 0;
}
int ps3av_video_mute(int mute)
{
	return ps3av_set_av_video_mute(mute ? PS3AV_CMD_MUTE_ON
					    : PS3AV_CMD_MUTE_OFF);
}
int ps3av_audio_mute(int mute)
{
	return ps3av_set_audio_mute(mute ? PS3AV_CMD_MUTE_ON
					 : PS3AV_CMD_MUTE_OFF);
}
static int ps3av_hdmi_range(void)
{
	if (ps3_compare_firmware_version(1, 8, 0) < 0)
		return 0;
	else
		return 1; /* supported */
}
static void ps3av_cnv_chstat(u8 *chstat, const u8 *cs_info)
{
	memcpy(chstat, cs_info, 5);
}
void rio_unregister_driver(struct rio_driver *rdrv)
{
	driver_unregister(&rdrv->driver);
}
static void rio_set_device_id(struct rio_mport *port, u16 destid, u8 hopcount, u16 did)
{
	rio_mport_write_config_32(port, destid, hopcount, RIO_DID_CSR,
				  RIO_SET_DID(port->sys_size, did));
}
static void rio_local_set_device_id(struct rio_mport *port, u16 did)
{
	rio_local_write_config_32(port, RIO_DID_CSR, RIO_SET_DID(port->sys_size,
				did));
}
static int rio_route_add_entry(struct rio_mport *mport, struct rio_switch *rswitch,
			       u16 table, u16 route_destid, u8 route_port)
{
	return rswitch->add_entry(mport, rswitch->destid,
					rswitch->hopcount, table,
					route_destid, route_port);
}
static int
rio_route_get_entry(struct rio_mport *mport, struct rio_switch *rswitch, u16 table,
		    u16 route_destid, u8 * route_port)
{
	return rswitch->get_entry(mport, rswitch->destid,
					rswitch->hopcount, table,
					route_destid, route_port);
}
static void rio_enum_timeout(unsigned long data)
{
	*(int *)data = 1;
}
void rio_remove_sysfs_dev_files(struct rio_dev *rdev)
{
	sysfs_remove_bin_file(&rdev->dev.kobj, &rio_config_attr);
}
struct rio_dev *rio_get_device(u16 vid, u16 did, struct rio_dev *from)
{
	return rio_get_asm(vid, did, RIO_ANY_ID, RIO_ANY_ID, from);
}
void rio_register_mport(struct rio_mport *port)
{
	list_add_tail(&port->node, &rio_mports);
}
static int __init bq24022_init(void)
{
	return platform_driver_probe(&bq24022_driver, bq24022_probe);
}
static void __exit bq24022_exit(void)
{
	platform_driver_unregister(&bq24022_driver);
}
static ssize_t regulator_print_state(char *buf, int state)
{
	if (state > 0)
		return sprintf(buf, "enabled\n");
	else if (state == 0)
		return sprintf(buf, "disabled\n");
	else
		return sprintf(buf, "unknown\n");
}
int regulator_is_enabled(struct regulator *regulator)
{
	return _regulator_is_enabled(regulator->rdev);
}
static int _regulator_get_voltage(struct regulator_dev *rdev)
{
	if (rdev->desc->ops->get_voltage)
		return rdev->desc->ops->get_voltage(rdev);
	else
		return -EINVAL;
}
int regulator_get_current_limit(struct regulator *regulator)
{
	return _regulator_get_current_limit(regulator->rdev);
}
unsigned int regulator_get_mode(struct regulator *regulator)
{
	return _regulator_get_mode(regulator->rdev);
}
int regulator_register_notifier(struct regulator *regulator,
			      struct notifier_block *nb)
{
	return blocking_notifier_chain_register(&regulator->rdev->notifier,
						nb);
}
int regulator_unregister_notifier(struct regulator *regulator,
				struct notifier_block *nb)
{
	return blocking_notifier_chain_unregister(&regulator->rdev->notifier,
						  nb);
}
void *rdev_get_drvdata(struct regulator_dev *rdev)
{
	return rdev->reg_data;
}
void *regulator_get_drvdata(struct regulator *regulator)
{
	return regulator->rdev->reg_data;
}
void regulator_set_drvdata(struct regulator *regulator, void *data)
{
	regulator->rdev->reg_data = data;
}
int rdev_get_id(struct regulator_dev *rdev)
{
	return rdev->desc->id;
}
struct device *rdev_get_dev(struct regulator_dev *rdev)
{
	return &rdev->dev;
}
void *regulator_get_init_drvdata(struct regulator_init_data *reg_init_data)
{
	return reg_init_data->driver_data;
}
static inline struct device *to_da903x_dev(struct regulator_dev *rdev)
{
	return rdev_get_dev(rdev)->parent->parent;
}
static int __init da903x_regulator_init(void)
{
	return platform_driver_register(&da903x_regulator_driver);
}
static void __exit da903x_regulator_exit(void)
{
	platform_driver_unregister(&da903x_regulator_driver);
}
static int fixed_voltage_is_enabled(struct regulator_dev *dev)
{
	return 1;
}
static int fixed_voltage_enable(struct regulator_dev *dev)
{
	return 0;
}
static int __init regulator_fixed_voltage_init(void)
{
	return platform_driver_register(&regulator_fixed_voltage_driver);
}
static void __exit regulator_fixed_voltage_exit(void)
{
	platform_driver_unregister(&regulator_fixed_voltage_driver);
}
static unsigned int down_voltage_value(u8 bits)
{
	return 625 + (bits * 25);
}
static int __init pcf50633_regulator_init(void)
{
	return platform_driver_register(&pcf50633_regulator_driver);
}
static void __exit pcf50633_regulator_exit(void)
{
	platform_driver_unregister(&pcf50633_regulator_driver);
}
static int __init regulator_virtual_consumer_init(void)
{
	return platform_driver_register(&regulator_virtual_consumer_driver);
}
static void __exit regulator_virtual_consumer_exit(void)
{
	platform_driver_unregister(&regulator_virtual_consumer_driver);
}
static inline int wm8350_ldo_val_to_mvolts(unsigned int val)
{
	if (val < 16)
		return (val * 50) + 900;
	else
		return ((val - 16) * 100) + 1800;
}
static inline unsigned int wm8350_ldo_mvolts_to_val(int mV)
{
	if (mV < 1800)
		return (mV - 900) / 50;
	else
		return ((mV - 1800) / 100) + 16;
}
static inline int wm8350_dcdc_val_to_mvolts(unsigned int val)
{
	return (val * 25) + 850;
}
static inline unsigned int wm8350_dcdc_mvolts_to_val(int mV)
{
	return (mV - 850) / 25;
}
static unsigned int wm8350_ldo_get_mode(struct regulator_dev *rdev)
{
	return REGULATOR_MODE_NORMAL;
}
static int __init wm8350_regulator_init(void)
{
	return platform_driver_register(&wm8350_regulator_driver);
}
static void __exit wm8350_regulator_exit(void)
{
	platform_driver_unregister(&wm8350_regulator_driver);
}
static unsigned int wm8400_dcdc_get_optimum_mode(struct regulator_dev *dev,
						 int input_uV, int output_uV,
						 int load_uA)
{
	return REGULATOR_MODE_NORMAL;
}
static int __init wm8400_regulator_init(void)
{
	return platform_driver_register(&wm8400_regulator_driver);
}
static void __exit wm8400_regulator_exit(void)
{
	platform_driver_unregister(&wm8400_regulator_driver);
}
static int __init at32_rtc_init(void)
{
	return platform_driver_probe(&at32_rtc_driver, at32_rtc_probe);
}
static void __exit at32_rtc_exit(void)
{
	platform_driver_unregister(&at32_rtc_driver);
}
static int __init at91_rtc_init(void)
{
	return platform_driver_probe(&at91_rtc_driver, at91_rtc_probe);
}
static void __exit at91_rtc_exit(void)
{
	platform_driver_unregister(&at91_rtc_driver);
}
static void __exit at91_rtc_exit(void)
{
	platform_driver_unregister(&at91_rtc_driver);
}
static int __init au1xtoy_rtc_init(void)
{
	return platform_driver_probe(&au1xrtc_driver, au1xtoy_rtc_probe);
}
static void __exit au1xtoy_rtc_exit(void)
{
	platform_driver_unregister(&au1xrtc_driver);
}
static inline unsigned long rtc_bfin_to_time(u32 rtc_bfin)
{
	return (((rtc_bfin >> SEC_BITS_OFF)  & 0x003F)) +
	       (((rtc_bfin >> MIN_BITS_OFF)  & 0x003F) * 60) +
	       (((rtc_bfin >> HOUR_BITS_OFF) & 0x001F) * 60 * 60) +
	       (((rtc_bfin >> DAY_BITS_OFF)  & 0x7FFF) * 60 * 60 * 24);
}
static inline void rtc_bfin_to_tm(u32 rtc_bfin, struct rtc_time *tm)
{
	rtc_time_to_tm(rtc_bfin_to_time(rtc_bfin), tm);
}
static void bfin_rtc_int_clear(u16 rtc_int)
{
	bfin_write_RTC_ICTL(bfin_read_RTC_ICTL() & rtc_int);
}
static void bfin_rtc_int_set_alarm(struct bfin_rtc *rtc)
{
	bfin_rtc_int_set(rtc->rtc_alarm.tm_yday == -1 ? RTC_ISTAT_ALARM : RTC_ISTAT_ALARM_DAY);
}
static int __init bfin_rtc_init(void)
{
	return platform_driver_register(&bfin_rtc_driver);
}
static void __exit bfin_rtc_exit(void)
{
	platform_driver_unregister(&bfin_rtc_driver);
}
static u8 bq4802_read_io(struct bq4802 *p, int off)
{
	return inb(p->ioport + off);
}
static void bq4802_write_io(struct bq4802 *p, int off, u8 val)
{
	outb(val, p->ioport + off);
}
static u8 bq4802_read_mem(struct bq4802 *p, int off)
{
	return readb(p->regs + off);
}
static void bq4802_write_mem(struct bq4802 *p, int off, u8 val)
{
	writeb(val, p->regs + off);
}
static int __init bq4802_init(void)
{
	return platform_driver_register(&bq4802_driver);
}
static void __exit bq4802_exit(void)
{
	platform_driver_unregister(&bq4802_driver);
}
static inline int is_hpet_enabled(void)
{
	return 0;
}
static inline int hpet_mask_rtc_irq_bit(unsigned long mask)
{
	return 0;
}
static inline int hpet_set_rtc_irq_bit(unsigned long mask)
{
	return 0;
}
static inline int
hpet_set_alarm_time(unsigned char hrs, unsigned char min, unsigned char sec)
{
	return 0;
}
static inline int hpet_set_periodic_freq(unsigned long freq)
{
	return 0;
}
static inline int hpet_rtc_dropped_irq(void)
{
	return 0;
}
static inline int hpet_rtc_timer_init(void)
{
	return 0;
}
static inline int hpet_register_irq_handler(irq_handler_t handler)
{
	return 0;
}
static inline int hpet_unregister_irq_handler(irq_handler_t handler)
{
	return 0;
}
static inline unsigned char cmos_read_bank2(unsigned char addr)
{
	return 0;
}
static int cmos_set_time(struct device *dev, struct rtc_time *t)
{
	return set_rtc_time(t);
}
static inline int cmos_poweroff(struct device *dev)
{
	return cmos_suspend(dev, PMSG_HIBERNATE);
}
static inline int cmos_poweroff(struct device *dev)
{
	return -ENOSYS;
}
static void rtc_wake_off(struct device *dev)
{
	acpi_disable_event(ACPI_EVENT_RTC, 0);
}
static void __exit cmos_pnp_remove(struct pnp_dev *pnp)
{
	cmos_do_remove(&pnp->dev);
}
static int cmos_pnp_suspend(struct pnp_dev *pnp, pm_message_t mesg)
{
	return cmos_suspend(&pnp->dev, mesg);
}
static int cmos_pnp_resume(struct pnp_dev *pnp)
{
	return cmos_resume(&pnp->dev);
}
int rtc_dev_update_irq_enable_emul(struct rtc_device *rtc, unsigned int enabled)
{
	if (enabled)
		return set_uie(rtc);
	else
		return clear_uie(rtc);
}
static int __init dm355evm_rtc_init(void)
{
	return platform_driver_register(&rtc_dm355evm_driver);
}
static void __exit dm355evm_rtc_exit(void)
{
	platform_driver_unregister(&rtc_dm355evm_driver);
}
static int __init ds1216_rtc_init(void)
{
	return platform_driver_probe(&ds1216_rtc_platform_driver, ds1216_rtc_probe);
}
static void __exit ds1216_rtc_exit(void)
{
	platform_driver_unregister(&ds1216_rtc_platform_driver);
}
static inline u8 ds1286_rtc_read(struct ds1286_priv *priv, int reg)
{
	return __raw_readl(&priv->rtcregs[reg]) & 0xff;
}
static inline void ds1286_rtc_write(struct ds1286_priv *priv, u8 data, int reg)
{
	__raw_writel(data, &priv->rtcregs[reg]);
}
static int __init ds1286_init(void)
{
	return platform_driver_register(&ds1286_platform_driver);
}
static void __exit ds1286_exit(void)
{
	platform_driver_unregister(&ds1286_platform_driver);
}
static int __init ds1302_rtc_init(void)
{
	return platform_driver_register(&ds1302_platform_driver);
}
static void __exit ds1302_rtc_exit(void)
{
	platform_driver_unregister(&ds1302_platform_driver);
}
static int __init ds1305_init(void)
{
	return spi_register_driver(&ds1305_driver);
}
static void __exit ds1305_exit(void)
{
	spi_unregister_driver(&ds1305_driver);
}
static int __init ds1307_init(void)
{
	return i2c_add_driver(&ds1307_driver);
}
static void __exit ds1307_exit(void)
{
	i2c_del_driver(&ds1307_driver);
}
static int __init ds1374_init(void)
{
	return i2c_add_driver(&ds1374_driver);
}
static void __exit ds1374_exit(void)
{
	i2c_del_driver(&ds1374_driver);
}
static __init int ds1390_init(void)
{
	return spi_register_driver(&ds1390_driver);
}
static __exit void ds1390_exit(void)
{
	spi_unregister_driver(&ds1390_driver);
}
 static noinline void
rtc_write(uint8_t val, uint32_t reg)
{
	writeb(val, ds1511_base + (reg * reg_spacing));
}
 static inline void
rtc_write_alarm(uint8_t val, enum ds1511reg reg)
{
	rtc_write((val | 0x80), reg);
}
 static noinline uint8_t
rtc_read(enum ds1511reg reg)
{
	return readb(ds1511_base + (reg * reg_spacing));
}
 static inline void
rtc_disable_update(void)
{
	rtc_write((rtc_read(RTC_CMD) & ~RTC_TE), RTC_CMD);
}
 static void
rtc_enable_update(void)
{
	rtc_write((rtc_read(RTC_CMD) | RTC_TE), RTC_CMD);
}
 static int __init
ds1511_rtc_init(void)
{
	return platform_driver_register(&ds1511_rtc_driver);
}
 static void __exit
ds1511_rtc_exit(void)
{
	platform_driver_unregister(&ds1511_rtc_driver);
}
static __init int ds1553_init(void)
{
	return platform_driver_register(&ds1553_rtc_driver);
}
static __exit void ds1553_exit(void)
{
	platform_driver_unregister(&ds1553_rtc_driver);
}
static int ds1672_rtc_read_time(struct device *dev, struct rtc_time *tm)
{
	return ds1672_get_datetime(to_i2c_client(dev), tm);
}
static int ds1672_rtc_set_mmss(struct device *dev, unsigned long secs)
{
	return ds1672_set_mmss(to_i2c_client(dev), secs);
}
static int __init ds1672_init(void)
{
	return i2c_add_driver(&ds1672_driver);
}
static void __exit ds1672_exit(void)
{
	i2c_del_driver(&ds1672_driver);
}
static __init int ds1742_init(void)
{
	return platform_driver_register(&ds1742_rtc_driver);
}
static __exit void ds1742_exit(void)
{
	platform_driver_unregister(&ds1742_rtc_driver);
}
static __init int ds3234_init(void)
{
	return spi_register_driver(&ds3234_driver);
}
static __exit void ds3234_exit(void)
{
	spi_unregister_driver(&ds3234_driver);
}
static int __init ep93xx_rtc_init(void)
{
	return platform_driver_register(&ep93xx_rtc_platform_driver);
}
static void __exit ep93xx_rtc_exit(void)
{
	platform_driver_unregister(&ep93xx_rtc_platform_driver);
}
static int __init fm3130_init(void)
{
	return i2c_add_driver(&fm3130_driver);
}
static void __exit fm3130_exit(void)
{
	i2c_del_driver(&fm3130_driver);
}
static int
isl1208_rtc_read_time(struct device *dev, struct rtc_time *tm)
{
	return isl1208_i2c_read_time(to_i2c_client(dev), tm);
}
static int
isl1208_rtc_set_time(struct device *dev, struct rtc_time *tm)
{
	return isl1208_i2c_set_time(to_i2c_client(dev), tm);
}
static int
isl1208_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)
{
	return isl1208_i2c_read_alarm(to_i2c_client(dev), alarm);
}
static int __init
isl1208_init(void)
{
	return i2c_add_driver(&isl1208_driver);
}
static void __exit
isl1208_exit(void)
{
	i2c_del_driver(&isl1208_driver);
}
int rtc_month_days(unsigned int month, unsigned int year)
{
	return rtc_days_in_month[month] + (LEAP_YEAR(year) && month == 1);
}
int rtc_year_days(unsigned int day, unsigned int month, unsigned int year)
{
	return rtc_ydays[LEAP_YEAR(year)][month] + day-1;
}
static int m41t80_rtc_read_time(struct device *dev, struct rtc_time *tm)
{
	return m41t80_get_datetime(to_i2c_client(dev), tm);
}
static int m41t80_rtc_set_time(struct device *dev, struct rtc_time *tm)
{
	return m41t80_set_datetime(to_i2c_client(dev), tm);
}
static int m41t80_sysfs_register(struct device *dev)
{
	return sysfs_create_group(&dev->kobj, &attr_group);
}
static int m41t80_sysfs_register(struct device *dev)
{
	return 0;
}
static ssize_t wdt_read(struct file *file, char __user *buf,
			size_t count, loff_t *ppos)
{
	return 0;
}
static int __init m41t80_rtc_init(void)
{
	return i2c_add_driver(&m41t80_driver);
}
static void __exit m41t80_rtc_exit(void)
{
	i2c_del_driver(&m41t80_driver);
}
static __init int m41t94_init(void)
{
	return spi_register_driver(&m41t94_driver);
}
static __exit void m41t94_exit(void)
{
	spi_unregister_driver(&m41t94_driver);
}
static int __init m48t35_init(void)
{
	return platform_driver_register(&m48t35_platform_driver);
}
static void __exit m48t35_exit(void)
{
	platform_driver_unregister(&m48t35_platform_driver);
}
static int __init m48t59_rtc_init(void)
{
	return platform_driver_register(&m48t59_rtc_driver);
}
static void __exit m48t59_rtc_exit(void)
{
	platform_driver_unregister(&m48t59_rtc_driver);
}
static int __init m48t86_rtc_init(void)
{
	return platform_driver_register(&m48t86_rtc_platform_driver);
}
static void __exit m48t86_rtc_exit(void)
{
	platform_driver_unregister(&m48t86_rtc_platform_driver);
}
static int max6900_rtc_read_time(struct device *dev, struct rtc_time *tm)
{
	return max6900_i2c_read_time(to_i2c_client(dev), tm);
}
static int max6900_rtc_set_time(struct device *dev, struct rtc_time *tm)
{
	return max6900_i2c_set_time(to_i2c_client(dev), tm);
}
static int __init max6900_init(void)
{
	return i2c_add_driver(&max6900_driver);
}
static void __exit max6900_exit(void)
{
	i2c_del_driver(&max6900_driver);
}
static __init int max6902_init(void)
{
	return spi_register_driver(&max6902_driver);
}
static __exit void max6902_exit(void)
{
	spi_unregister_driver(&max6902_driver);
}
static __init int mv_init(void)
{
	return platform_driver_probe(&mv_rtc_driver, mv_rtc_probe);
}
static __exit void mv_exit(void)
{
	platform_driver_unregister(&mv_rtc_driver);
}
static void omap_rtc_shutdown(struct platform_device *pdev)
{
	rtc_write(0, OMAP_RTC_INTERRUPTS_REG);
}
static int __init rtc_init(void)
{
	return platform_driver_probe(&omap_rtc_driver, omap_rtc_probe);
}
static void __exit rtc_exit(void)
{
	platform_driver_unregister(&omap_rtc_driver);
}
static int __init parisc_rtc_init(void)
{
	return platform_driver_register(&parisc_rtc_driver);
}
static void __exit parisc_rtc_fini(void)
{
	platform_driver_unregister(&parisc_rtc_driver);
}
static int __init pcf50633_rtc_init(void)
{
	return platform_driver_register(&pcf50633_rtc_driver);
}
static void __exit pcf50633_rtc_exit(void)
{
	platform_driver_unregister(&pcf50633_rtc_driver);
}
static int pcf8563_rtc_read_time(struct device *dev, struct rtc_time *tm)
{
	return pcf8563_get_datetime(to_i2c_client(dev), tm);
}
static int pcf8563_rtc_set_time(struct device *dev, struct rtc_time *tm)
{
	return pcf8563_set_datetime(to_i2c_client(dev), tm);
}
static int __init pcf8563_init(void)
{
	return i2c_add_driver(&pcf8563_driver);
}
static void __exit pcf8563_exit(void)
{
	i2c_del_driver(&pcf8563_driver);
}
static __init int pcf8583_init(void)
{
	return i2c_add_driver(&pcf8583_driver);
}
static __exit void pcf8583_exit(void)
{
	i2c_del_driver(&pcf8583_driver);
}
static int pl030_ioctl(struct device *dev, unsigned int cmd, unsigned long arg)
{
	return -ENOIOCTLCMD;
}
static int __init pl030_init(void)
{
	return amba_driver_register(&pl030_driver);
}
static void __exit pl030_exit(void)
{
	amba_driver_unregister(&pl030_driver);
}
static int __init pl031_init(void)
{
	return amba_driver_register(&pl031_driver);
}
static void __exit pl031_exit(void)
{
	amba_driver_unregister(&pl031_driver);
}
static int ppc_rtc_set_time(struct device *dev, struct rtc_time *tm)
{
	return ppc_md.set_rtc_time(tm);
}
static u32 ryxr_calc(struct rtc_time *tm)
{
	return ((tm->tm_year + 1900) << RYxR_YEAR_S)
		| ((tm->tm_mon + 1) << RYxR_MONTH_S)
		| tm->tm_mday;
}
static u32 rdxr_calc(struct rtc_time *tm)
{
	return (tm->tm_hour << RDxR_HOUR_S) | (tm->tm_min << RDxR_MIN_S)
		| tm->tm_sec;
}
static void __exit pxa_rtc_exit(void)
{
	platform_driver_unregister(&pxa_rtc_driver);
}
static __init int r9701_init(void)
{
	return spi_register_driver(&r9701_driver);
}
static __exit void r9701_exit(void)
{
	spi_unregister_driver(&r9701_driver);
}
static inline unsigned char rs5c313_read_cntreg(void)
{
	return rs5c313_read_reg(RS5C313_ADDR_CNTREG);
}
static inline void rs5c313_write_cntreg(unsigned char data)
{
	rs5c313_write_reg(RS5C313_ADDR_CNTREG, data);
}
static inline void rs5c313_write_intintvreg(unsigned char data)
{
	rs5c313_write_reg(RS5C313_ADDR_INTINTVREG, data);
}
static void __exit rs5c313_rtc_exit(void)
{
	platform_driver_unregister( &rs5c313_rtc_platform_driver );
}
static __init int rs5c348_init(void)
{
	return spi_register_driver(&rs5c348_driver);
}
static __exit void rs5c348_exit(void)
{
	spi_unregister_driver(&rs5c348_driver);
}
static int rs5c372_rtc_read_time(struct device *dev, struct rtc_time *tm)
{
	return rs5c372_get_datetime(to_i2c_client(dev), tm);
}
static int rs5c372_rtc_set_time(struct device *dev, struct rtc_time *tm)
{
	return rs5c372_set_datetime(to_i2c_client(dev), tm);
}
static int rs5c_sysfs_register(struct device *dev)
{
	return 0;
}
static __init int rs5c372_init(void)
{
	return i2c_add_driver(&rs5c372_driver);
}
static __exit void rs5c372_exit(void)
{
	i2c_del_driver(&rs5c372_driver);
}
static int rx8581_rtc_read_time(struct device *dev, struct rtc_time *tm)
{
	return rx8581_get_datetime(to_i2c_client(dev), tm);
}
static int rx8581_rtc_set_time(struct device *dev, struct rtc_time *tm)
{
	return rx8581_set_datetime(to_i2c_client(dev), tm);
}
static int __init rx8581_init(void)
{
	return i2c_add_driver(&rx8581_driver);
}
static void __exit rx8581_exit(void)
{
	i2c_del_driver(&rx8581_driver);
}
static int s35390a_rtc_read_time(struct device *dev, struct rtc_time *tm)
{
	return s35390a_get_datetime(to_i2c_client(dev), tm);
}
static int s35390a_rtc_set_time(struct device *dev, struct rtc_time *tm)
{
	return s35390a_set_datetime(to_i2c_client(dev), tm);
}
static int __init s35390a_rtc_init(void)
{
	return i2c_add_driver(&s35390a_driver);
}
static void __exit s35390a_rtc_exit(void)
{
	i2c_del_driver(&s35390a_driver);
}
static void __exit s3c_rtc_exit(void)
{
	platform_driver_unregister(&s3c2410_rtc_driver);
}
static inline int rtc_periodic_alarm(struct rtc_time *tm)
{
	return  (tm->tm_year == -1) ||
		((unsigned)tm->tm_mon >= 12) ||
		((unsigned)(tm->tm_mday - 1) >= 31) ||
		((unsigned)tm->tm_hour > 23) ||
		((unsigned)tm->tm_min > 59) ||
		((unsigned)tm->tm_sec > 59);
}
static int __init sa1100_rtc_init(void)
{
	return platform_driver_register(&sa1100_rtc_driver);
}
static void __exit sa1100_rtc_exit(void)
{
	platform_driver_unregister(&sa1100_rtc_driver);
}
static int __init sh_rtc_init(void)
{
	return platform_driver_register(&sh_rtc_platform_driver);
}
static void __exit sh_rtc_exit(void)
{
	platform_driver_unregister(&sh_rtc_platform_driver);
}
static int __init starfire_rtc_init(void)
{
	return platform_driver_probe(&starfire_rtc_driver, starfire_rtc_probe);
}
static void __exit starfire_rtc_exit(void)
{
	platform_driver_unregister(&starfire_rtc_driver);
}
static __init int stk17ta8_init(void)
{
	return platform_driver_register(&stk17ta8_rtc_driver);
}
static __exit void stk17ta8_exit(void)
{
	platform_driver_unregister(&stk17ta8_rtc_driver);
}
static int __init sun4v_rtc_init(void)
{
	return platform_driver_probe(&sun4v_rtc_driver, sun4v_rtc_probe);
}
static void __exit sun4v_rtc_exit(void)
{
	platform_driver_unregister(&sun4v_rtc_driver);
}
static ssize_t
rtc_sysfs_show_name(struct device *dev, struct device_attribute *attr,
		char *buf)
{
	return sprintf(buf, "%s\n", to_rtc_device(dev)->name);
}
static ssize_t
rtc_sysfs_show_max_user_freq(struct device *dev, struct device_attribute *attr,
		char *buf)
{
	return sprintf(buf, "%d\n", to_rtc_device(dev)->max_user_freq);
}
void __init rtc_sysfs_init(struct class *rtc_class)
{
	rtc_class->dev_attrs = rtc_attrs;
}
static int test_rtc_read_alarm(struct device *dev,
	struct rtc_wkalrm *alrm)
{
	return 0;
}
static int test_rtc_set_alarm(struct device *dev,
	struct rtc_wkalrm *alrm)
{
	return 0;
}
static ssize_t test_irq_show(struct device *dev,
				struct device_attribute *attr, char *buf)
{
	return sprintf(buf, "%d\n", 42);
}
static void twl4030_rtc_shutdown(struct platform_device *pdev)
{
	mask_rtc_irq_bit(BIT_RTC_INTERRUPTS_REG_IT_TIMER_M);
}
static int __init twl4030_rtc_init(void)
{
	return platform_driver_register(&twl4030rtc_driver);
}
static void __exit twl4030_rtc_exit(void)
{
	platform_driver_unregister(&twl4030rtc_driver);
}
static struct tx4939rtc_plat_data *get_tx4939rtc_plat_data(struct device *dev)
{
	return platform_get_drvdata(to_platform_device(dev));
}
static int __init tx4939rtc_init(void)
{
	return platform_driver_probe(&tx4939_rtc_driver, tx4939_rtc_probe);
}
static void __exit tx4939rtc_exit(void)
{
	platform_driver_unregister(&tx4939_rtc_driver);
}
static __init int v3020_init(void)
{
	return platform_driver_register(&rtc_device_driver);
}
static __exit void v3020_exit(void)
{
	platform_driver_unregister(&rtc_device_driver);
}
static int __init vr41xx_rtc_init(void)
{
	return platform_driver_register(&rtc_platform_driver);
}
static void __exit vr41xx_rtc_exit(void)
{
	platform_driver_unregister(&rtc_platform_driver);
}
static int __init wm8350_rtc_init(void)
{
	return platform_driver_register(&wm8350_rtc_driver);
}
static void __exit wm8350_rtc_exit(void)
{
	platform_driver_unregister(&wm8350_rtc_driver);
}
static int x1205_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)
{
	return x1205_set_datetime(to_i2c_client(dev),
		&alrm->time, 1, X1205_ALM0_BASE, alrm->enabled);
}
static int x1205_rtc_read_time(struct device *dev, struct rtc_time *tm)
{
	return x1205_get_datetime(to_i2c_client(dev),
		tm, X1205_CCR_BASE);
}
static int x1205_rtc_set_time(struct device *dev, struct rtc_time *tm)
{
	return x1205_set_datetime(to_i2c_client(dev),
		tm, 1, X1205_CCR_BASE, 0);
}
static int __init x1205_init(void)
{
	return i2c_add_driver(&x1205_driver);
}
static void __exit x1205_exit(void)
{
	i2c_del_driver(&x1205_driver);
}
void dasd_free_block(struct dasd_block *block)
{
	kfree(block);
}
static inline int _wait_for_device(struct dasd_device *device)
{
	return (device->state == device->target);
}
void dasd_device_clear_timer(struct dasd_device *device)
{
	del_timer(&device->timer);
}
static void dasd_wakeup_cb(struct dasd_ccw_req *cqr, void *data)
{
	wake_up((wait_queue_head_t *) data);
}
void dasd_block_clear_timer(struct dasd_block *block)
{
	del_timer(&block->timer);
}
static void dasd_return_cqr_cb(struct dasd_ccw_req *cqr, void *data)
{
	dasd_schedule_block_bh(cqr->block);
}
static void _dasd_wake_block_flush_cb(struct dasd_ccw_req *cqr, void *data)
{
	wake_up(&dasd_flush_wq);
}
static void _free_server(struct alias_server *server)
{
	kfree(server);
}
int
dasd_busid_known(const char *bus_id)
{
	return IS_ERR(dasd_find_busid(bus_id)) ? -ENOENT : 0;
}
void
dasd_put_device_wake(struct dasd_device *device)
{
	wake_up(&dasd_delete_wq);
}
int
dasd_add_sysfs_files(struct ccw_device *cdev)
{
	return sysfs_create_group(&cdev->dev.kobj, &dasd_attr_group);
}
void
dasd_remove_sysfs_files(struct ccw_device *cdev)
{
	sysfs_remove_group(&cdev->dev.kobj, &dasd_attr_group);
}
void
dasd_devmap_exit(void)
{
	dasd_forget_ranges();
}
static dasd_erp_fn_t
dasd_diag_erp_action(struct dasd_ccw_req * cqr)
{
	return dasd_default_erp_action;
}
static dasd_erp_fn_t
dasd_diag_erp_postaction(struct dasd_ccw_req * cqr)
{
	return dasd_default_erp_postaction;
}

static void dasd_diag_handle_terminated_request(struct dasd_ccw_req *cqr)
{
	cqr->status = DASD_CQR_FILLED;
}
static void
dasd_diag_dump_sense(struct dasd_device *device, struct dasd_ccw_req * req,
		     struct irb *stat)
{
	DEV_MESSAGE(KERN_ERR, device, "%s",
		    "dump sense not available for DIAG data");
}
static int
dasd_eckd_set_online(struct ccw_device *cdev)
{
	return dasd_generic_set_online(cdev, &dasd_eckd_discipline);
}
static inline unsigned int
ceil_quot(unsigned int d1, unsigned int d2)
{
	return (d1 + (d2 - 1)) / d2;
}

static int dasd_eckd_ready_to_online(struct dasd_device *device)
{
	return dasd_alias_add_device(device);
}

static int dasd_eckd_online_to_ready(struct dasd_device *device)
{
	return dasd_alias_remove_device(device);
}
static dasd_erp_fn_t
dasd_eckd_erp_postaction(struct dasd_ccw_req * cqr)
{
	return dasd_default_erp_postaction;
}
static void __exit
dasd_eckd_cleanup(void)
{
	ccw_driver_unregister(&dasd_eckd_driver);
}
static int
dasd_fba_probe(struct ccw_device *cdev)
{
	return dasd_generic_probe(cdev, &dasd_fba_discipline);
}
static int
dasd_fba_set_online(struct ccw_device *cdev)
{
	return dasd_generic_set_online(cdev, &dasd_fba_discipline);
}
static dasd_erp_fn_t
dasd_fba_erp_action(struct dasd_ccw_req * cqr)
{
	return dasd_default_erp_action;
}

static void dasd_fba_handle_terminated_request(struct dasd_ccw_req *cqr)
{
	cqr->status = DASD_CQR_FILLED;
}
static void __exit
dasd_fba_cleanup(void)
{
	ccw_driver_unregister(&dasd_fba_driver);
}
void dasd_gendisk_exit(void)
{
	unregister_blkdev(DASD_MAJOR, "dasd");
}
static int dasd_ioctl_reset_profile(struct dasd_block *block)
{
	return -ENOSYS;
}
static int dasd_ioctl_read_profile(struct dasd_block *block, void __user *argp)
{
	return -ENOSYS;
}
static int dasd_devices_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &dasd_devices_seq_ops);
}
static void
ctrlchar_handle_sysrq(struct work_struct *work)
{
	handle_sysrq(ctrlchar_sysrq_key, sysrq_tty);
}
static void
fs3270_wake_up(struct raw3270_request *rq, void *data)
{
	wake_up((wait_queue_head_t *) data);
}
static inline int
fs3270_working(struct fs3270 *fp)
{
	return fp->active && raw3270_request_final(fp->init);
}
static void __exit
fs3270_exit(void)
{
	unregister_chrdev(IBM_FS3270_MAJOR, "fs3270");
}
static inline unsigned long mon_mca_start(struct mon_msg *monmsg)
{
	return *(u32 *) &monmsg->msg.rmmsg;
}
static inline unsigned long mon_mca_end(struct mon_msg *monmsg)
{
	return *(u32 *) &monmsg->msg.rmmsg[4];
}
static inline u8 mon_mca_type(struct mon_msg *monmsg, u8 index)
{
	return *((u8 *) mon_mca_start(monmsg) + monmsg->mca_offset + index);
}
static inline u32 mon_mca_size(struct mon_msg *monmsg)
{
	return mon_mca_end(monmsg) - mon_mca_start(monmsg) + 1;
}
static inline u32 mon_rec_start(struct mon_msg *monmsg)
{
	return *((u32 *) (mon_mca_start(monmsg) + monmsg->mca_offset + 4));
}
static inline u32 mon_rec_end(struct mon_msg *monmsg)
{
	return *((u32 *) (mon_mca_start(monmsg) + monmsg->mca_offset + 8));
}
static int __init mon_init(void)
{
	if (MACHINE_IS_VM)
		return misc_register(&mon_dev);
	else
		return -ENODEV;
}
static void __exit mon_exit(void)
{
	WARN_ON(misc_deregister(&mon_dev) != 0);
}
void
raw3270_request_set_cmd(struct raw3270_request *rq, u8 cmd)
{
	rq->ccw.cmd_code = cmd;
}
static void
raw3270_wake_init(struct raw3270_request *rq, void *data)
{
	wake_up((wait_queue_head_t *) data);
}
static int
raw3270_probe (struct ccw_device *cdev)
{
	return 0;
}
static ssize_t
raw3270_model_show(struct device *dev, struct device_attribute *attr, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%i\n",
			((struct raw3270 *) dev->driver_data)->model);
}
static ssize_t
raw3270_rows_show(struct device *dev, struct device_attribute *attr, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%i\n",
			((struct raw3270 *) dev->driver_data)->rows);
}
static ssize_t
raw3270_columns_show(struct device *dev, struct device_attribute *attr, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%i\n",
			((struct raw3270 *) dev->driver_data)->cols);
}
static inline u64
sclp_tod_from_jiffies(unsigned long jiffies)
{
	return (u64) (jiffies / HZ) << 32;
}
static __init int sclp_initcall(void)
{
	return sclp_init();
}
unsigned long long sclp_get_rnmax(void)
{
	return rnmax;
}
unsigned long long sclp_get_rzm(void)
{
	return rzm;
}
int sclp_cpu_configure(u8 cpu)
{
	return do_cpu_configure(SCLP_CMDW_CONFIGURE_CPU | cpu << 8);
}
int sclp_cpu_deconfigure(u8 cpu)
{
	return do_cpu_configure(SCLP_CMDW_DECONFIGURE_CPU | cpu << 8);
}
static unsigned long long rn2addr(u16 rn)
{
	return (unsigned long long) (rn - 1) * rzm;
}
static int sclp_assign_storage(u16 rn)
{
	return do_assign_storage(0x000d0001, rn);
}
static int sclp_unassign_storage(u16 rn)
{
	return do_assign_storage(0x000c0001, rn);
}
int sclp_chp_configure(struct chp_id chpid)
{
	return do_chp_configure(SCLP_CMDW_CONFIGURE_CHPATH | chpid.id << 8);
}
int sclp_chp_deconfigure(struct chp_id chpid)
{
	return do_chp_configure(SCLP_CMDW_DECONFIGURE_CHPATH | chpid.id << 8);
}
static void
sclp_console_timeout(unsigned long data)
{
	sclp_conbuf_emit();
}
static void __ref sclp_cpu_change_notify(struct work_struct *work)
{
	smp_rescan_cpus();
}
static int __init cpi_module_init(void)
{
	return sclp_cpi_set_data(system_name, sysplex_name, "LINUX",
				 LINUX_VERSION_CODE);
}
static int __init
sclp_quiesce_init(void)
{
	return sclp_register(&sclp_quiesce_event);
}
void *
sclp_unmake_buffer(struct sclp_buffer *buffer)
{
	return buffer->sccb;
}
void
sclp_set_htab(struct sclp_buffer *buffer, unsigned short htab)
{
	buffer->htab = htab;
}
static void
sclp_vt220_timeout(unsigned long data)
{
	sclp_vt220_emit_current();
}
static int
sclp_vt220_write(struct tty_struct *tty, const unsigned char *buf, int count)
{
	return __sclp_vt220_write(buf, count, 1, 0, 1);
}
static int
sclp_vt220_put_char(struct tty_struct *tty, unsigned char ch)
{
	return __sclp_vt220_write(&ch, 1, 0, 0, 1);
}
static void
sclp_vt220_flush_buffer(struct tty_struct *tty)
{
	sclp_vt220_emit_current();
}
static void
sclp_vt220_con_write(struct console *con, const char *buf, unsigned int count)
{
	__sclp_vt220_write((const unsigned char *) buf, count, 1, 1, 0);
}
static int
tape_34xx_online(struct ccw_device *cdev)
{
	return tape_generic_online(
		cdev->dev.driver_data,
		&tape_discipline_34xx
	);
}
static int
tape_34xx_offline(struct ccw_device *cdev)
{
	return tape_generic_offline(cdev->dev.driver_data);
}
static int crypt_supported(struct tape_device *device)
{
	return TAPE390_CRYPT_SUPPORTED(TAPE_3590_CRYPT_INFO(device));
}
static int crypt_enabled(struct tape_device *device)
{
	return TAPE390_CRYPT_ON(TAPE_3590_CRYPT_INFO(device));
}
static int
tape_3590_erp_read_buf_log(struct tape_device *device,
			   struct tape_request *request, struct irb *irb)
{
	return tape_3590_erp_basic(device, request, irb, -EIO);
}
static int
tape_3590_erp_special_interrupt(struct tape_device *device,
				struct tape_request *request, struct irb *irb)
{
	return tape_3590_erp_basic(device, request, irb, -EIO);
}
static int
tape_3590_online(struct ccw_device *cdev)
{
	return tape_generic_online(cdev->dev.driver_data,
				   &tape_discipline_3590);
}
static int
tape_3590_offline(struct ccw_device *cdev)
{
	return tape_generic_offline(cdev->dev.driver_data);
}
void
tapeblock_exit(void)
{
	unregister_blkdev(tapeblock_major, "tBLK");
}
static int devid_to_int(struct ccw_dev_id *dev_id)
{
	return dev_id->devno + (dev_id->ssid << 16);
}
static int tape_proc_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &tape_proc_seq);
}
int
tape_std_mtload(struct tape_device *device, int count)
{
	return wait_event_interruptible(device->state_change_wq,
		(device->medium_state == MS_LOADED));
}
int
tape_std_mtunload(struct tape_device *device, int mt_count)
{
	return tape_mtop(device, MTOFFL, mt_count);
}
static int
tty3270_write_room(struct tty_struct *tty)
{
	return INT_MAX;
}
static void
tty3270_cr(struct tty3270 *tp)
{
	tp->cx = 0;
}
static inline int
tty3270_getpar(struct tty3270 *tp, int ix)
{
	return (tp->esc_par[ix] > 0) ? tp->esc_par[ix] : 1;
}
static int
tty3270_chars_in_buffer(struct tty_struct *tty)
{
	return 0;
}
static void urdev_get(struct urdev *urd)
{
	atomic_inc(&urd->ref_count);
}
static int ur_create_attributes(struct device *dev)
{
	return device_create_file(dev, &dev_attr_reclen);
}
static void ur_remove_attributes(struct device *dev)
{
	device_remove_file(dev, &dev_attr_reclen);
}
static void __exit vmwdt_exit(void)
{
	WARN_ON(misc_deregister(&vmwdt_dev) != 0);
}
static int memcpy_hsa_user(void __user *dest, unsigned long src, size_t count)
{
	return memcpy_hsa((void __force *) dest, src, count, TO_USER);
}
static int memcpy_hsa_kernel(void *dest, unsigned long src, size_t count)
{
	return memcpy_hsa(dest, src, count, TO_KERNEL);
}
static int zcore_open(struct inode *inode, struct file *filp)
{
	if (!hsa_available)
		return -ENODATA;
	else
		return capable(CAP_SYS_RAWIO) ? 0 : -EPERM;
}
static ssize_t zcore_memmap_read(struct file *filp, char __user *buf,
				 size_t count, loff_t *ppos)
{
	return simple_read_from_buffer(buf, count, ppos, filp->private_data,
				       MEMORY_CHUNKS * CHUNK_INFO_SIZE);
}
static int zcore_reipl_open(struct inode *inode, struct file *filp)
{
	return 0;
}
static int zcore_reipl_release(struct inode *inode, struct file *filp)
{
	return 0;
}
int
is_blacklisted (int ssid, int devno)
{
	return test_bit (devno, bl_dev[ssid]);
}
static int
cio_ignore_proc_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &cio_ignore_proc_seq_ops);
}
static int
ccwgroup_uevent (struct device *dev, struct kobj_uevent_env *env)
{
	return 0;
}
static int __init
init_ccwgroup (void)
{
	return bus_register (&ccwgroup_bus_type);
}
static void __exit
cleanup_ccwgroup (void)
{
	bus_unregister (&ccwgroup_bus_type);
}
static int
__ccwgroup_match_all(struct device *dev, void *data)
{
	return 1;
}
int ccwgroup_probe_ccwdev(struct ccw_device *cdev)
{
	return 0;
}
static inline struct channel_path *chpid_to_chp(struct chp_id chpid)
{
	return channel_subsystems[chpid.cssid]->chps[chpid.id];
}
static void set_chp_logically_online(struct chp_id chpid, int onoff)
{
	chpid_to_chp(chpid)->state = onoff;
}
int chp_get_status(struct chp_id chpid)
{
	return (chpid_to_chp(chpid) ? chpid_to_chp(chpid)->state : -ENODEV);
}
int chp_is_registered(struct chp_id chpid)
{
	return chpid_to_chp(chpid) != NULL;
}
static inline int info_bit_num(struct chp_id id)
{
	return id.id + id.cssid * (__MAX_CHPID + 1);
}
static enum cfg_task_t cfg_get_task(struct chp_id chpid)
{
	return chp_cfg_task[chpid.cssid][chpid.id];
}
static void cfg_set_task(struct chp_id chpid, enum cfg_task_t cfg)
{
	chp_cfg_task[chpid.cssid][chpid.id] = cfg;
}
static void chsc_subchannel_shutdown(struct subchannel *sch)
{
	cio_disable_subchannel(sch);
}
static int __init chsc_init_sch_driver(void)
{
	return css_driver_register(&chsc_subchannel_driver);
}
static void chsc_cleanup_sch_driver(void)
{
	css_driver_unregister(&chsc_subchannel_driver);
}
static int __init chsc_misc_init(void)
{
	return misc_register(&chsc_misc_device);
}
static void chsc_misc_cleanup(void)
{
	misc_deregister(&chsc_misc_device);
}
int
cio_start (struct subchannel *sch, struct ccw1 *cpa, __u8 lpm)
{
	return cio_start_key(sch, cpa, lpm, PAGE_DEFAULT_KEY);
}
static int cio_check_config(struct subchannel *sch, struct schib *schib)
{
	return (schib->pmcw.intparm == sch->config.intparm) &&
		(schib->pmcw.mbi == sch->config.mbi) &&
		(schib->pmcw.isc == sch->config.isc) &&
		(schib->pmcw.ena == sch->config.ena) &&
		(schib->pmcw.mme == sch->config.mme) &&
		(schib->pmcw.mp == sch->config.mp) &&
		(schib->pmcw.csense == sch->config.csense) &&
		(schib->pmcw.mbfc == sch->config.mbfc) &&
		(!sch->config.mbfc || (schib->mba == sch->config.mba));
}
void *cio_get_console_priv(void)
{
	return &console_priv;
}
static void __clear_chsc_subchannel_easy(void)
{
	udelay_simple(100);
}
static void cio_reset_pgm_check_handler(void)
{
	pgm_check_occured = 1;
}
static inline u64 time_to_nsec(u32 value)
{
	return ((u64)value) * 128000ull;
}
static void reset_cmb(struct ccw_device *cdev)
{
	cmf_generic_reset(cdev);
}
static void * align_cmb(void *area)
{
	return area;
}
static void reset_cmbe(struct ccw_device *cdev)
{
	cmf_generic_reset(cdev);
}
static void * align_cmbe(void *area)
{
	return cmbe_align(area);
}
static ssize_t cmb_show_attr(struct device *dev, char *buf, enum cmb_index idx)
{
	return sprintf(buf, "%lld\n",
		(unsigned long long) cmf_read(to_ccwdev(dev), idx));
}
static ssize_t cmb_enable_show(struct device *dev,
			       struct device_attribute *attr,
			       char *buf)
{
	return sprintf(buf, "%d\n", to_ccwdev(dev)->private->cmb ? 1 : 0);
}
u64 cmf_read(struct ccw_device *cdev, int index)
{
	return cmbops->read(cdev, index);
}
int cmf_readall(struct ccw_device *cdev, struct cmbdata *data)
{
	return cmbops->readall(cdev, data);
}
void css_wait_for_slow_path(void)
{
	flush_workqueue(slow_path_wq);
}
int sch_is_pseudo_sch(struct subchannel *sch)
{
	return sch == to_css(sch->dev.parent)->pseudo_subchannel;
}
void css_driver_unregister(struct css_driver *cdrv)
{
	driver_unregister(&cdrv->drv);
}
int ccw_device_is_orphan(struct ccw_device *cdev)
{
	return sch_is_pseudo_sch(to_subchannel(cdev->dev.parent));
}
static void recovery_func(unsigned long data)
{
	schedule_work(&recovery_work);
}
spinlock_t * cio_get_console_lock(void)
{
	return &ccw_console_lock;
}
void ccw_driver_unregister(struct ccw_driver *cdriver)
{
	driver_unregister(&cdriver->driver);
}
static void
ccw_device_recog_notoper(struct ccw_device *cdev, enum dev_event dev_event)
{
	ccw_device_recog_done(cdev, DEV_STATE_NOT_OPER);
}
static void
ccw_device_delay_verify(struct ccw_device *cdev, enum dev_event dev_event)
{
	cdev->private->flags.doverify = 1;
}
int ccw_device_start(struct ccw_device *cdev, struct ccw1 *cpa,
		     unsigned long intparm, __u8 lpm, unsigned long flags)
{
	return ccw_device_start_key(cdev, cpa, intparm, lpm,
				    PAGE_DEFAULT_KEY, flags);
}
int ccw_device_start_timeout(struct ccw_device *cdev, struct ccw1 *cpa,
			     unsigned long intparm, __u8 lpm,
			     unsigned long flags, int expires)
{
	return ccw_device_start_timeout_key(cdev, cpa, intparm, lpm,
					    PAGE_DEFAULT_KEY, flags,
					    expires);
}
void ccw_device_get_id(struct ccw_device *cdev, struct ccw_dev_id *dev_id)
{
	*dev_id = cdev->private->dev_id;
}
int ccw_device_tm_start(struct ccw_device *cdev, struct tcw *tcw,
			unsigned long intparm, u8 lpm)
{
	return ccw_device_tm_start_key(cdev, tcw, intparm, lpm,
				       PAGE_DEFAULT_KEY);
}
int ccw_device_tm_start_timeout(struct ccw_device *cdev, struct tcw *tcw,
			       unsigned long intparm, u8 lpm, int expires)
{
	return ccw_device_tm_start_timeout_key(cdev, tcw, intparm, lpm,
					       PAGE_DEFAULT_KEY, expires);
}
int
_ccw_device_get_subchannel_number(struct ccw_device *cdev)
{
	return cdev->private->schid.sch_no;
}
struct tcw *tcw_get_intrg(struct tcw *tcw)
{
	return (struct tcw *) ((addr_t) tcw->intrg);
}
struct tccb *tcw_get_tccb(struct tcw *tcw)
{
	return (struct tccb *) ((addr_t) tcw->tccb);
}
struct tsb *tcw_get_tsb(struct tcw *tcw)
{
	return (struct tsb *) ((addr_t) tcw->tsb);
}
static inline size_t tca_size(struct tccb *tccb)
{
	return tccb->tcah.tcal - 12;
}
void tcw_set_intrg(struct tcw *tcw, struct tcw *intrg_tcw)
{
	tcw->intrg = (u32) ((addr_t) intrg_tcw);
}
void tcw_set_tccb(struct tcw *tcw, struct tccb *tccb)
{
	tcw->tccb = (u64) ((addr_t) tccb);
}
void tcw_set_tsb(struct tcw *tcw, struct tsb *tsb)
{
	tcw->tsb = (u64) ((addr_t) tsb);
}
void tsb_init(struct tsb *tsb)
{
	memset(tsb, 0, sizeof(tsb));
}
static inline unsigned long bitmap_size(int num_ssid, int num_id)
{
	return __BITOPS_WORDS(num_ssid * num_id) * sizeof(unsigned long);
}
void idset_free(struct idset *set)
{
	vfree(set);
}
void idset_clear(struct idset *set)
{
	memset(set->bitmap, 0, bitmap_size(set->num_ssid, set->num_id));
}
void idset_fill(struct idset *set)
{
	memset(set->bitmap, 0xff, bitmap_size(set->num_ssid, set->num_id));
}
static inline void idset_add(struct idset *set, int ssid, int id)
{
	set_bit(ssid * set->num_id + id, set->bitmap);
}
static inline void idset_del(struct idset *set, int ssid, int id)
{
	clear_bit(ssid * set->num_id + id, set->bitmap);
}
static inline int idset_contains(struct idset *set, int ssid, int id)
{
	return test_bit(ssid * set->num_id + id, set->bitmap);
}
struct idset *idset_sch_new(void)
{
	return idset_new(__MAX_SSID + 1, __MAX_SUBCHANNEL + 1);
}
void idset_sch_add(struct idset *set, struct subchannel_id schid)
{
	idset_add(set, schid.ssid, schid.sch_no);
}
void idset_sch_del(struct idset *set, struct subchannel_id schid)
{
	idset_del(set, schid.ssid, schid.sch_no);
}
int idset_sch_contains(struct idset *set, struct subchannel_id schid)
{
	return idset_contains(set, schid.ssid, schid.sch_no);
}
struct tcw *itcw_get_tcw(struct itcw *itcw)
{
	return itcw->tcw;
}
struct dcw *itcw_add_dcw(struct itcw *itcw, u8 cmd, u8 flags, void *cd,
			 u8 cd_count, u32 count)
{
	return tccb_add_dcw(tcw_get_tccb(itcw->tcw), TCCB_MAX_SIZE, cmd,
			    flags, cd, cd_count, count);
}
void itcw_set_data(struct itcw *itcw, void *addr, int use_tidal)
{
	tcw_set_data(itcw->tcw, addr, use_tidal);
}
void itcw_finalize(struct itcw *itcw)
{
	tcw_finalize(itcw->tcw, itcw->num_tidaws);
}
static int qstat_seq_open(struct inode *inode, struct file *filp)
{
	return single_open(filp, qstat_show,
			   filp->f_path.dentry->d_inode->i_private);
}
inline int get_buf_state(struct qdio_q *q, unsigned int bufnr,
		  unsigned char *state, int auto_ack)
{
	return get_buf_states(q, bufnr, state, 1, auto_ack);
}
static inline int set_buf_state(struct qdio_q *q, int bufnr,
				unsigned char state)
{
	return set_buf_states(q, bufnr, state, 1);
}
inline int qdio_siga_sync_q(struct qdio_q *q)
{
	if (q->is_input_q)
		return qdio_siga_sync(q, 0, q->mask);
	else
		return qdio_siga_sync(q, q->mask, 0);
}
static inline int qdio_siga_sync_out(struct qdio_q *q)
{
	return qdio_siga_sync(q, ~0U, 0);
}
static inline int qdio_siga_sync_all(struct qdio_q *q)
{
	return qdio_siga_sync(q, ~0U, ~0U);
}
static inline int qdio_outbound_q_done(struct qdio_q *q)
{
	return atomic_read(&q->nr_buf_used) == 0;
}
static int qdio_perf_seq_open(struct inode *inode, struct file *filp)
{
	return single_open(filp, qdio_perf_proc_show, NULL);
}
static ssize_t qdio_perf_stats_show(struct bus_type *bus, char *buf)
{
	return sprintf(buf, "%i\n", qdio_performance_stats ? 1 : 0);
}
static inline int qebsm_possible(void)
{
	return css_general_characteristics.qebsm;
}
void qdio_setup_exit(void)
{
	kmem_cache_destroy(qdio_q_cache);
}
static inline int shared_ind(struct qdio_irq *irq_ptr)
{
	return irq_ptr->dsci == &q_indicators[TIQDIO_SHARED_IND].ind;
}
void tiqdio_free_memory(void)
{
	kfree(q_indicators);
}
int scsw_is_tm(union scsw *scsw)
{
	return css_general_characteristics.fcx && (scsw->tm.x == 1);
}
u32 scsw_key(union scsw *scsw)
{
	if (scsw_is_tm(scsw))
		return scsw->tm.key;
	else
		return scsw->cmd.key;
}
u32 scsw_eswf(union scsw *scsw)
{
	if (scsw_is_tm(scsw))
		return scsw->tm.eswf;
	else
		return scsw->cmd.eswf;
}
u32 scsw_cc(union scsw *scsw)
{
	if (scsw_is_tm(scsw))
		return scsw->tm.cc;
	else
		return scsw->cmd.cc;
}
u32 scsw_ectl(union scsw *scsw)
{
	if (scsw_is_tm(scsw))
		return scsw->tm.ectl;
	else
		return scsw->cmd.ectl;
}
u32 scsw_pno(union scsw *scsw)
{
	if (scsw_is_tm(scsw))
		return scsw->tm.pno;
	else
		return scsw->cmd.pno;
}
u32 scsw_fctl(union scsw *scsw)
{
	if (scsw_is_tm(scsw))
		return scsw->tm.fctl;
	else
		return scsw->cmd.fctl;
}
u32 scsw_actl(union scsw *scsw)
{
	if (scsw_is_tm(scsw))
		return scsw->tm.actl;
	else
		return scsw->cmd.actl;
}
u32 scsw_stctl(union scsw *scsw)
{
	if (scsw_is_tm(scsw))
		return scsw->tm.stctl;
	else
		return scsw->cmd.stctl;
}
u32 scsw_dstat(union scsw *scsw)
{
	if (scsw_is_tm(scsw))
		return scsw->tm.dstat;
	else
		return scsw->cmd.dstat;
}
u32 scsw_cstat(union scsw *scsw)
{
	if (scsw_is_tm(scsw))
		return scsw->tm.cstat;
	else
		return scsw->cmd.cstat;
}
int scsw_cmd_is_valid_key(union scsw *scsw)
{
	return (scsw->cmd.fctl & SCSW_FCTL_START_FUNC);
}
int scsw_cmd_is_valid_sctl(union scsw *scsw)
{
	return (scsw->cmd.fctl & SCSW_FCTL_START_FUNC);
}
int scsw_cmd_is_valid_eswf(union scsw *scsw)
{
	return (scsw->cmd.stctl & SCSW_STCTL_STATUS_PEND);
}
int scsw_cmd_is_valid_cc(union scsw *scsw)
{
	return (scsw->cmd.fctl & SCSW_FCTL_START_FUNC) &&
	       (scsw->cmd.stctl & SCSW_STCTL_STATUS_PEND);
}
int scsw_cmd_is_valid_fmt(union scsw *scsw)
{
	return (scsw->cmd.fctl & SCSW_FCTL_START_FUNC);
}
int scsw_cmd_is_valid_pfch(union scsw *scsw)
{
	return (scsw->cmd.fctl & SCSW_FCTL_START_FUNC);
}
int scsw_cmd_is_valid_isic(union scsw *scsw)
{
	return (scsw->cmd.fctl & SCSW_FCTL_START_FUNC);
}
int scsw_cmd_is_valid_alcc(union scsw *scsw)
{
	return (scsw->cmd.fctl & SCSW_FCTL_START_FUNC);
}
int scsw_cmd_is_valid_ssi(union scsw *scsw)
{
	return (scsw->cmd.fctl & SCSW_FCTL_START_FUNC);
}
int scsw_cmd_is_valid_zcc(union scsw *scsw)
{
	return (scsw->cmd.fctl & SCSW_FCTL_START_FUNC) &&
	       (scsw->cmd.stctl & SCSW_STCTL_INTER_STATUS);
}
int scsw_cmd_is_valid_ectl(union scsw *scsw)
{
	return (scsw->cmd.stctl & SCSW_STCTL_STATUS_PEND) &&
	       !(scsw->cmd.stctl & SCSW_STCTL_INTER_STATUS) &&
	       (scsw->cmd.stctl & SCSW_STCTL_ALERT_STATUS);
}
int scsw_cmd_is_valid_pno(union scsw *scsw)
{
	return (scsw->cmd.fctl != 0) &&
	       (scsw->cmd.stctl & SCSW_STCTL_STATUS_PEND) &&
	       (!(scsw->cmd.stctl & SCSW_STCTL_INTER_STATUS) ||
		 ((scsw->cmd.stctl & SCSW_STCTL_INTER_STATUS) &&
		  (scsw->cmd.actl & SCSW_ACTL_SUSPENDED)));
}
int scsw_cmd_is_valid_fctl(union scsw *scsw)
{
	return 1;
}
int scsw_cmd_is_valid_actl(union scsw *scsw)
{
	return 1;
}
int scsw_cmd_is_valid_stctl(union scsw *scsw)
{
	return 1;
}
int scsw_cmd_is_valid_dstat(union scsw *scsw)
{
	return (scsw->cmd.stctl & SCSW_STCTL_STATUS_PEND) &&
	       (scsw->cmd.cc != 3);
}
int scsw_cmd_is_valid_cstat(union scsw *scsw)
{
	return (scsw->cmd.stctl & SCSW_STCTL_STATUS_PEND) &&
	       (scsw->cmd.cc != 3);
}
int scsw_tm_is_valid_key(union scsw *scsw)
{
	return (scsw->tm.fctl & SCSW_FCTL_START_FUNC);
}
int scsw_tm_is_valid_eswf(union scsw *scsw)
{
	return (scsw->tm.stctl & SCSW_STCTL_STATUS_PEND);
}
int scsw_tm_is_valid_cc(union scsw *scsw)
{
	return (scsw->tm.fctl & SCSW_FCTL_START_FUNC) &&
	       (scsw->tm.stctl & SCSW_STCTL_STATUS_PEND);
}
int scsw_tm_is_valid_fmt(union scsw *scsw)
{
	return 1;
}
int scsw_tm_is_valid_x(union scsw *scsw)
{
	return 1;
}
int scsw_tm_is_valid_q(union scsw *scsw)
{
	return 1;
}
int scsw_tm_is_valid_ectl(union scsw *scsw)
{
	return (scsw->tm.stctl & SCSW_STCTL_STATUS_PEND) &&
	       !(scsw->tm.stctl & SCSW_STCTL_INTER_STATUS) &&
	       (scsw->tm.stctl & SCSW_STCTL_ALERT_STATUS);
}
int scsw_tm_is_valid_pno(union scsw *scsw)
{
	return (scsw->tm.fctl != 0) &&
	       (scsw->tm.stctl & SCSW_STCTL_STATUS_PEND) &&
	       (!(scsw->tm.stctl & SCSW_STCTL_INTER_STATUS) ||
		 ((scsw->tm.stctl & SCSW_STCTL_INTER_STATUS) &&
		  (scsw->tm.actl & SCSW_ACTL_SUSPENDED)));
}
int scsw_tm_is_valid_fctl(union scsw *scsw)
{
	return 1;
}
int scsw_tm_is_valid_actl(union scsw *scsw)
{
	return 1;
}
int scsw_tm_is_valid_stctl(union scsw *scsw)
{
	return 1;
}
int scsw_tm_is_valid_dstat(union scsw *scsw)
{
	return (scsw->tm.stctl & SCSW_STCTL_STATUS_PEND) &&
	       (scsw->tm.cc != 3);
}
int scsw_tm_is_valid_cstat(union scsw *scsw)
{
	return (scsw->tm.stctl & SCSW_STCTL_STATUS_PEND) &&
	       (scsw->tm.cc != 3);
}
int scsw_tm_is_valid_fcxs(union scsw *scsw)
{
	return 1;
}
int scsw_tm_is_valid_schxs(union scsw *scsw)
{
	return (scsw->tm.cstat & (SCHN_STAT_PROG_CHECK |
				  SCHN_STAT_INTF_CTRL_CHK |
				  SCHN_STAT_PROT_CHECK |
				  SCHN_STAT_CHN_DATA_CHK));
}
int scsw_is_valid_actl(union scsw *scsw)
{
	if (scsw_is_tm(scsw))
		return scsw_tm_is_valid_actl(scsw);
	else
		return scsw_cmd_is_valid_actl(scsw);
}
int scsw_is_valid_cc(union scsw *scsw)
{
	if (scsw_is_tm(scsw))
		return scsw_tm_is_valid_cc(scsw);
	else
		return scsw_cmd_is_valid_cc(scsw);
}
int scsw_is_valid_cstat(union scsw *scsw)
{
	if (scsw_is_tm(scsw))
		return scsw_tm_is_valid_cstat(scsw);
	else
		return scsw_cmd_is_valid_cstat(scsw);
}
int scsw_is_valid_dstat(union scsw *scsw)
{
	if (scsw_is_tm(scsw))
		return scsw_tm_is_valid_dstat(scsw);
	else
		return scsw_cmd_is_valid_dstat(scsw);
}
int scsw_is_valid_ectl(union scsw *scsw)
{
	if (scsw_is_tm(scsw))
		return scsw_tm_is_valid_ectl(scsw);
	else
		return scsw_cmd_is_valid_ectl(scsw);
}
int scsw_is_valid_eswf(union scsw *scsw)
{
	if (scsw_is_tm(scsw))
		return scsw_tm_is_valid_eswf(scsw);
	else
		return scsw_cmd_is_valid_eswf(scsw);
}
int scsw_is_valid_fctl(union scsw *scsw)
{
	if (scsw_is_tm(scsw))
		return scsw_tm_is_valid_fctl(scsw);
	else
		return scsw_cmd_is_valid_fctl(scsw);
}
int scsw_is_valid_key(union scsw *scsw)
{
	if (scsw_is_tm(scsw))
		return scsw_tm_is_valid_key(scsw);
	else
		return scsw_cmd_is_valid_key(scsw);
}
int scsw_is_valid_pno(union scsw *scsw)
{
	if (scsw_is_tm(scsw))
		return scsw_tm_is_valid_pno(scsw);
	else
		return scsw_cmd_is_valid_pno(scsw);
}
int scsw_is_valid_stctl(union scsw *scsw)
{
	if (scsw_is_tm(scsw))
		return scsw_tm_is_valid_stctl(scsw);
	else
		return scsw_cmd_is_valid_stctl(scsw);
}
int scsw_cmd_is_solicited(union scsw *scsw)
{
	return (scsw->cmd.cc != 0) || (scsw->cmd.stctl !=
		(SCSW_STCTL_STATUS_PEND | SCSW_STCTL_ALERT_STATUS));
}
int scsw_tm_is_solicited(union scsw *scsw)
{
	return (scsw->tm.cc != 0) || (scsw->tm.stctl !=
		(SCSW_STCTL_STATUS_PEND | SCSW_STCTL_ALERT_STATUS));
}
int scsw_is_solicited(union scsw *scsw)
{
	if (scsw_is_tm(scsw))
		return scsw_tm_is_solicited(scsw);
	else
		return scsw_cmd_is_solicited(scsw);
}
static inline int ap_using_interrupts(void)
{
	return ap_interrupt_indicator != NULL;
}
static ssize_t ap_modalias_show(struct device *dev,
				struct device_attribute *attr, char *buf)
{
	return sprintf(buf, "ap:t%02X", to_ap_dev(dev)->device_type);
}
void ap_driver_unregister(struct ap_driver *ap_drv)
{
	driver_unregister(&ap_drv->driver);
}
static ssize_t ap_domain_show(struct bus_type *bus, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%d\n", ap_domain_index);
}
static ssize_t ap_config_time_show(struct bus_type *bus, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%d\n", ap_config_time);
}
static ssize_t ap_interrupts_show(struct bus_type *bus, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%d\n",
			ap_using_interrupts() ? 1 : 0);
}
static ssize_t ap_poll_thread_show(struct bus_type *bus, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%d\n", ap_poll_kthread ? 1 : 0);
}
static ssize_t poll_timeout_show(struct bus_type *bus, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%llu\n", poll_timeout);
}
static void ap_interrupt_handler(void *unused1, void *unused2)
{
	tasklet_schedule(&ap_tasklet);
}
static int __ap_scan_bus(struct device *dev, void *data)
{
	return to_ap_dev(dev)->qid == (ap_qid_t)(unsigned long) data;
}
static int __ap_match_all(struct device *dev, void *data)
{
	return 1;
}
void zcrypt_device_get(struct zcrypt_device *zdev)
{
	kref_get(&zdev->refcount);
}
int zcrypt_device_put(struct zcrypt_device *zdev)
{
	return kref_put(&zdev->refcount, zcrypt_device_release);
}
static ssize_t zcrypt_read(struct file *filp, char __user *buf,
			   size_t count, loff_t *f_pos)
{
	return -EPERM;
}
static ssize_t zcrypt_write(struct file *filp, const char __user *buf,
			    size_t count, loff_t *f_pos)
{
	return -EPERM;
}
int __init zcrypt_cex2a_init(void)
{
	return ap_driver_register(&zcrypt_cex2a_driver, THIS_MODULE, "cex2a");
}
void __exit zcrypt_cex2a_exit(void)
{
	ap_driver_unregister(&zcrypt_cex2a_driver);
}
int __init zcrypt_pcica_init(void)
{
	return ap_driver_register(&zcrypt_pcica_driver, THIS_MODULE, "pcica");
}
void zcrypt_pcica_exit(void)
{
	ap_driver_unregister(&zcrypt_pcica_driver);
}
int __init zcrypt_pcicc_init(void)
{
	return ap_driver_register(&zcrypt_pcicc_driver, THIS_MODULE, "pcicc");
}
void zcrypt_pcicc_exit(void)
{
	ap_driver_unregister(&zcrypt_pcicc_driver);
}
int __init zcrypt_pcixcc_init(void)
{
	return ap_driver_register(&zcrypt_pcixcc_driver, THIS_MODULE, "pcixcc");
}
void zcrypt_pcixcc_exit(void)
{
	ap_driver_unregister(&zcrypt_pcixcc_driver);
}
static struct kvm_vqconfig *kvm_vq_config(const struct kvm_device_desc *desc)
{
	return (struct kvm_vqconfig *)(desc + 1);
}
static u8 *kvm_vq_features(const struct kvm_device_desc *desc)
{
	return (u8 *)(kvm_vq_config(desc) + desc->num_vq);
}
static u8 *kvm_vq_configspace(const struct kvm_device_desc *desc)
{
	return kvm_vq_features(desc) + desc->feature_len * 2;
}
static unsigned desc_size(const struct kvm_device_desc *desc)
{
	return sizeof(*desc)
		+ desc->num_vq * sizeof(struct kvm_vqconfig)
		+ desc->feature_len * 2
		+ desc->config_len;
}
static u8 kvm_get_status(struct virtio_device *vdev)
{
	return to_kvmdev(vdev)->desc->status;
}
static void kvm_reset(struct virtio_device *vdev)
{
	kvm_hypercall1(KVM_S390_VIRTIO_RESET,
		       (unsigned long) to_kvmdev(vdev)->desc);
}
void __init s390_virtio_console_init(void)
{
	virtio_cons_early_init(early_put_chars);
}
static void ctcm_chx_stopped(fsm_instance *fi, int event, void *arg)
{
	ctcm_chx_cleanup(fi, CTC_STATE_STOPPED, arg);
}
static void ctcm_chx_stop(fsm_instance *fi, int event, void *arg)
{
	fsm_newstate(fi, CTC_STATE_STOPPED);
}
static void ctcm_chx_fail(fsm_instance *fi, int event, void *arg)
{
	ctcm_chx_cleanup(fi, CTC_STATE_NOTOP, arg);
}
static struct net_device_stats *ctcm_stats(struct net_device *dev)
{
	return &((struct ctcm_priv *)dev->ml_priv)->stats;
}
static void print_banner(void)
{
	pr_info("CTCM driver initialized\n");
}
static void mpc_action_xside_xid(fsm_instance *fsm, int event, void *arg)
{
	mpc_action_side_xid(fsm, arg, XSIDE);
}
static void mpc_action_yside_xid(fsm_instance *fsm, int event, void *arg)
{
	mpc_action_side_xid(fsm, arg, YSIDE);
}
void ctcm_remove_attributes(struct device *dev)
{
	device_remove_file(dev, &dev_attr_stats);
}
int ctcm_add_files(struct device *dev)
{
	return sysfs_create_group(&dev->kobj, &ctcm_attr_group);
}
void ctcm_remove_files(struct device *dev)
{
	sysfs_remove_group(&dev->kobj, &ctcm_attr_group);
}
static int
lcs_wait_for_threads(struct lcs_card *card, unsigned long threads)
{
        return wait_event_interruptible(card->wait_q,
                        lcs_threads_running(card, threads) == 0);
}
static int
lcs_shutdown_device(struct ccwgroup_device *ccwgdev)
{
	return __lcs_shutdown_device(ccwgdev, 0);
}
static inline int iucv_dbf_passes(debug_info_t *dbf_grp, int level)
{
	return (level <= dbf_grp->level);
}
static void netiucv_banner(void)
{
	pr_info("driver initialized\n");
}
int qeth_wait_for_threads(struct qeth_card *card, unsigned long threads)
{
	return wait_event_interruptible(card->wait_q,
			qeth_threads_running(card, threads) == 0);
}
static int qeth_core_driver_group(const char *buf, struct device *root_dev,
				unsigned long driver_id)
{
	return ccwgroup_create_from_string(root_dev, driver_id,
					   &qeth_ccw_driver, 3, buf);
}
int qeth_core_get_stats_count(struct net_device *dev)
{
	return (sizeof(qeth_ethtool_stats_keys) / ETH_GSTRING_LEN);
}
static void qeth_eddp_get_context(struct qeth_eddp_context *ctx)
{
	atomic_inc(&ctx->refcnt);
}
static inline const char *qeth_get_bufsize_str(struct qeth_card *card)
{
	if (card->qdio.in_buf_size == 16384)
		return "16k";
	else if (card->qdio.in_buf_size == 24576)
		return "24k";
	else if (card->qdio.in_buf_size == 32768)
		return "32k";
	else if (card->qdio.in_buf_size == 40960)
		return "40k";
	else
		return "64k";
}
int qeth_core_create_osn_attributes(struct device *dev)
{
	return sysfs_create_group(&dev->kobj, &qeth_osn_device_attr_group);
}
static int qeth_l2_set_online(struct ccwgroup_device *gdev)
{
	return __qeth_l2_set_online(gdev, 0);
}
static int qeth_l2_set_offline(struct ccwgroup_device *cgdev)
{
	return __qeth_l2_set_offline(cgdev, 0);
}
static void __exit qeth_l2_exit(void)
{
	pr_info("unregister layer 2 discipline\n");
}
void qeth_l3_ipaddr4_to_string(const __u8 *addr, char *buf)
{
	sprintf(buf, "%i.%i.%i.%i", addr[0], addr[1], addr[2], addr[3]);
}
void qeth_l3_ipaddr6_to_string(const __u8 *addr, char *buf)
{
	sprintf(buf, "%02x%02x:%02x%02x:%02x%02x:%02x%02x"
		     ":%02x%02x:%02x%02x:%02x%02x:%02x%02x",
		     addr[0], addr[1], addr[2], addr[3],
		     addr[4], addr[5], addr[6], addr[7],
		     addr[8], addr[9], addr[10], addr[11],
		     addr[12], addr[13], addr[14], addr[15]);
}
int qeth_l3_string_to_ipaddr(const char *buf, enum qeth_prot_versions proto,
				__u8 *addr)
{
	if (proto == QETH_PROT_IPV4)
		return qeth_l3_string_to_ipaddr4(buf, addr);
	else if (proto == QETH_PROT_IPV6)
		return qeth_l3_string_to_ipaddr6(buf, addr);
	else
		return -EINVAL;
}
static void qeth_l3_vlan_rx_add_vid(struct net_device *dev, unsigned short vid)
{
	return;
}
static int qeth_l3_set_online(struct ccwgroup_device *gdev)
{
	return __qeth_l3_set_online(gdev, 0);
}
static int qeth_l3_set_offline(struct ccwgroup_device *cgdev)
{
	return __qeth_l3_set_offline(cgdev, 0);
}
static const char *qeth_l3_get_checksum_str(struct qeth_card *card)
{
	if (card->options.checksum_type == SW_CHECKSUMMING)
		return "sw";
	else if (card->options.checksum_type == HW_CHECKSUMMING)
		return "hw";
	else
		return "no";
}
static void zfcp_sysfs_unit_release(struct device *dev)
{
	kfree(container_of(dev, struct zfcp_unit, sysfs_device));
}
static void _zfcp_status_read_scheduler(struct work_struct *work)
{
	zfcp_status_read_refill(container_of(work, struct zfcp_adapter,
					     stat_work));
}
static void zfcp_sysfs_port_release(struct device *dev)
{
	kfree(container_of(dev, struct zfcp_port, sysfs_device));
}
int __init zfcp_ccw_register(void)
{
	return ccw_driver_register(&zfcp_ccw_driver);
}
static void zfcp_dbf_outs(char **buf, const char *s1, const char *s2)
{
	*buf += sprintf(*buf, "%-24s%s\n", s1, s2);
}
void zfcp_rec_dbf_event_adapter(u8 id, void *ref, struct zfcp_adapter *adapter)
{
	zfcp_rec_dbf_event_target(id, ref, adapter, &adapter->status,
				  &adapter->erp_counter, 0, 0, 0);
}
void zfcp_scsi_dbf_event_result(const char *tag, int level,
				struct zfcp_adapter *adapter,
				struct scsi_cmnd *scsi_cmnd,
				struct zfcp_fsf_req *fsf_req)
{
	zfcp_scsi_dbf_event("rslt", tag, level, adapter, scsi_cmnd, fsf_req, 0);
}
void zfcp_scsi_dbf_event_abort(const char *tag, struct zfcp_adapter *adapter,
			       struct scsi_cmnd *scsi_cmnd,
			       struct zfcp_fsf_req *new_fsf_req,
			       unsigned long old_req_id)
{
	zfcp_scsi_dbf_event("abrt", tag, 1, adapter, scsi_cmnd, new_fsf_req,
			    old_req_id);
}
void zfcp_scsi_dbf_event_devreset(const char *tag, u8 flag,
				  struct zfcp_unit *unit,
				  struct scsi_cmnd *scsi_cmnd)
{
	zfcp_scsi_dbf_event(flag == FCP_TARGET_RESET ? "trst" : "lrst", tag, 1,
			    unit->port->adapter, scsi_cmnd, NULL, 0);
}
static void zfcp_erp_adapter_block(struct zfcp_adapter *adapter, int mask)
{
	zfcp_erp_modify_adapter_status(adapter, 15, NULL,
				       ZFCP_STATUS_COMMON_UNBLOCKED | mask,
				       ZFCP_CLEAR);
}
static void zfcp_erp_port_block(struct zfcp_port *port, int clear)
{
	zfcp_erp_modify_port_status(port, 17, NULL,
				    ZFCP_STATUS_COMMON_UNBLOCKED | clear,
				    ZFCP_CLEAR);
}
static void zfcp_erp_unit_block(struct zfcp_unit *unit, int clear_mask)
{
	zfcp_erp_modify_unit_status(unit, 19, NULL,
				    ZFCP_STATUS_COMMON_UNBLOCKED | clear_mask,
				    ZFCP_CLEAR);
}
static int status_change_set(unsigned long mask, atomic_t *status)
{
	return (atomic_read(status) ^ mask) & mask;
}
static int status_change_clear(unsigned long mask, atomic_t *status)
{
	return atomic_read(status) & mask;
}
static void zfcp_erp_memwait_handler(unsigned long data)
{
	zfcp_erp_notify((struct zfcp_erp_action *)data, 0);
}
static void zfcp_erp_port_strategy_clearstati(struct zfcp_port *port)
{
	atomic_clear_mask(ZFCP_STATUS_COMMON_ACCESS_DENIED |
			  ZFCP_STATUS_PORT_PHYS_CLOSING |
			  ZFCP_STATUS_PORT_INVALID_WWPN,
			  &port->status);
}
static void zfcp_erp_unit_strategy_clearstati(struct zfcp_unit *unit)
{
	atomic_clear_mask(ZFCP_STATUS_COMMON_ACCESS_DENIED |
			  ZFCP_STATUS_UNIT_SHARED |
			  ZFCP_STATUS_UNIT_READONLY,
			  &unit->status);
}
void zfcp_erp_adapter_failed(struct zfcp_adapter *adapter, u8 id, void *ref)
{
	zfcp_erp_modify_adapter_status(adapter, id, ref,
				       ZFCP_STATUS_COMMON_ERP_FAILED, ZFCP_SET);
}
void zfcp_erp_port_failed(struct zfcp_port *port, u8 id, void *ref)
{
	zfcp_erp_modify_port_status(port, id, ref,
				    ZFCP_STATUS_COMMON_ERP_FAILED, ZFCP_SET);
}
void zfcp_erp_unit_failed(struct zfcp_unit *unit, u8 id, void *ref)
{
	zfcp_erp_modify_unit_status(unit, id, ref,
				    ZFCP_STATUS_COMMON_ERP_FAILED, ZFCP_SET);
}
void zfcp_erp_wait(struct zfcp_adapter *adapter)
{
	wait_event(adapter->erp_done_wqh,
		   !(atomic_read(&adapter->status) &
			ZFCP_STATUS_ADAPTER_ERP_PENDING));
}
void zfcp_erp_unit_access_denied(struct zfcp_unit *unit, u8 id, void *ref)
{
	zfcp_erp_modify_unit_status(unit, id, ref,
				    ZFCP_STATUS_COMMON_ERP_FAILED |
				    ZFCP_STATUS_COMMON_ACCESS_DENIED, ZFCP_SET);
}
void _zfcp_scan_ports_later(struct work_struct *work)
{
	zfcp_scan_ports(container_of(work, struct zfcp_adapter, scan_work));
}
static struct qdio_buffer_element *
zfcp_qdio_sbale(struct zfcp_qdio_queue *q, int sbal_idx, int sbale_idx)
{
	return &q->sbal[sbal_idx]->element[sbale_idx];
}
struct qdio_buffer_element *zfcp_qdio_sbale_req(struct zfcp_fsf_req *req)
{
	return zfcp_qdio_sbale(&req->adapter->req_q, req->sbal_last, 0);
}
struct qdio_buffer_element *zfcp_qdio_sbale_curr(struct zfcp_fsf_req *req)
{
	return zfcp_qdio_sbale(&req->adapter->req_q, req->sbal_last,
			       req->sbale_curr);
}
static void zfcp_set_rport_dev_loss_tmo(struct fc_rport *rport, u32 timeout)
{
	rport->dev_loss_tmo = timeout;
}
static int __init bbc_i2c_init(void)
{
	return of_register_driver(&bbc_i2c_driver, &of_bus_type);
}
static void __exit bbc_i2c_exit(void)
{
	of_unregister_driver(&bbc_i2c_driver);
}
static int __init d7s_init(void)
{
	return of_register_driver(&d7s_driver, &of_bus_type);
}
static void __exit d7s_exit(void)
{
	of_unregister_driver(&d7s_driver);
}
static int
envctrl_release(struct inode *inode, struct file *file)
{
	return 0;
}
static int __init envctrl_init(void)
{
	return of_register_driver(&envctrl_driver, &of_bus_type);
}
static void __exit envctrl_exit(void)
{
	of_unregister_driver(&envctrl_driver);
}
static int __init flash_init(void)
{
	return of_register_driver(&flash_driver, &of_bus_type);
}
static void __exit flash_cleanup(void)
{
	of_unregister_driver(&flash_driver);
}
static void jsf_outl(unsigned long addr, __u32 data)
{
	__asm__ __volatile__("sta %0, [%1] %2\n\t" : :
				"r" (data), "r" (addr), "i" (ASI_M_BYPASS) :
				"memory");
}
static ssize_t jsf_write(struct file * file, const char __user * buf,
    size_t count, loff_t *ppos)
{
	return -ENOSPC;
}
static int jsf_mmap(struct file * file, struct vm_area_struct * vma)
{
	return -ENXIO;
}
static void __exit openprom_cleanup(void)
{
	misc_deregister(&openprom_dev);
}
static irqreturn_t uctrl_interrupt(int irq, void *dev_id)
{
	return IRQ_HANDLED;
}
static int __init uctrl_init(void)
{
	return of_register_driver(&uctrl_driver, &of_bus_type);
}
static void __exit uctrl_exit(void)
{
	of_unregister_driver(&uctrl_driver);
}
/* This function is called on driver exit */
static void __exit twa_exit(void)
{
	pci_unregister_driver(&twa_driver);
} /* End twa_exit() */
static void tw_transfer_internal(TW_Device_Extension *tw_dev, int request_id,
				 void *data, unsigned int len)
{
	scsi_sg_copy_from_buffer(tw_dev->srb[request_id], data, len);
}
/* This function is called on driver exit */
static void __exit tw_exit(void)
{
	pci_unregister_driver(&tw_driver);
} /* End tw_exit() */
static inline __u8
NCR_700_identify(int can_disconnect, __u8 lun)
{
	return IDENTIFY_BASE |
		((can_disconnect) ? 0x40 : 0) |
		(lun & NCR_700_LUN_MASK);
}
static void __exit NCR_700_exit(void)
{
	spi_release_transport(NCR_700_transport_template);
}
static inline unsigned char
FlashPoint__ProbeHostAdapter(struct FlashPoint_Info *FlashPointInfo)
{
	return FlashPoint_ProbeHostAdapter((struct sccb_mgr_info *)
					   FlashPointInfo);
}

static inline FlashPoint_CardHandle_T
FlashPoint__HardwareResetHostAdapter(struct FlashPoint_Info *FlashPointInfo)
{
	return FlashPoint_HardwareResetHostAdapter((struct sccb_mgr_info *)
						   FlashPointInfo);
}

static inline void
FlashPoint__ReleaseHostAdapter(FlashPoint_CardHandle_T CardHandle)
{
	FlashPoint_ReleaseHostAdapter(CardHandle);
}

static inline void
FlashPoint__StartCCB(FlashPoint_CardHandle_T CardHandle,
		     struct BusLogic_CCB *CCB)
{
	FlashPoint_StartCCB(CardHandle, (struct sccb *)CCB);
}

static inline void
FlashPoint__AbortCCB(FlashPoint_CardHandle_T CardHandle,
		     struct BusLogic_CCB *CCB)
{
	FlashPoint_AbortCCB(CardHandle, (struct sccb *)CCB);
}

static inline bool
FlashPoint__InterruptPending(FlashPoint_CardHandle_T CardHandle)
{
	return FlashPoint_InterruptPending(CardHandle);
}

static inline int
FlashPoint__HandleInterrupt(FlashPoint_CardHandle_T CardHandle)
{
	return FlashPoint_HandleInterrupt(CardHandle);
}
static __inline__ int NCR53c406a_dma_write(unsigned char *src, unsigned int count)
{
	return NCR53c406a_dma_setup(src, count, DMA_MODE_WRITE);
}
static __inline__ int NCR53c406a_dma_read(unsigned char *src, unsigned int count)
{
	return NCR53c406a_dma_setup(src, count, DMA_MODE_READ);
}
static void __exit NCR_D700_exit(void)
{
	mca_unregister_driver(&NCR_D700_driver);
}
static int __init inia100_init(void)
{
	return pci_register_driver(&inia100_pci_driver);
}
static void __exit inia100_exit(void)
{
	pci_unregister_driver(&inia100_pci_driver);
}
static int setinqserial(struct aac_dev *dev, void *data, int cid)
{
	return snprintf((char *)(data), sizeof(struct scsi_inq) - 4, "%08X%02X",
			le32_to_cpu(dev->adapter_info.serial[0]), cid);
}
static int aac_bounds_64(struct aac_dev * dev, struct scsi_cmnd * cmd, u64 lba)
{
	return 0;
}
struct aac_driver_ident* aac_get_driver_ident(int devtype)
{
	return &aac_drivers[devtype];
}
static ssize_t aac_show_max_channel(struct device *device,
				    struct device_attribute *attr, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%d\n",
	  class_to_shost(device)->max_channel);
}
static ssize_t aac_show_max_id(struct device *device,
			       struct device_attribute *attr, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%d\n",
	  class_to_shost(device)->max_id);
}
ssize_t aac_get_serial_number(struct device *device, char *buf)
{
	return aac_show_serial_number(device, &aac_serial_number, buf);
}
static void aac_rx_disable_interrupt(struct aac_dev *dev)
{
	rx_writeb(dev, MUnit.OIMR, dev->OIMR = 0xff);
}
static void aac_rx_enable_interrupt_producer(struct aac_dev *dev)
{
	rx_writeb(dev, MUnit.OIMR, dev->OIMR = 0xfb);
}
static void aac_rx_enable_interrupt_message(struct aac_dev *dev)
{
	rx_writeb(dev, MUnit.OIMR, dev->OIMR = 0xf7);
}
static void aac_rx_interrupt_adapter(struct aac_dev *dev)
{
	rx_sync_cmd(dev, BREAKPOINT_REQUEST, 0, 0, 0, 0, 0, 0, NULL, NULL, NULL, NULL, NULL);
}
static void aac_sa_disable_interrupt (struct aac_dev *dev)
{
	sa_writew(dev, SaDbCSR.PRISETIRQMASK, 0xffff);
}
static void aac_sa_enable_interrupt (struct aac_dev *dev)
{
	sa_writew(dev, SaDbCSR.PRICLEARIRQMASK, (PrintfReady | DOORBELL_1 |
				DOORBELL_2 | DOORBELL_3 | DOORBELL_4));
}
static void aac_sa_interrupt_adapter (struct aac_dev *dev)
{
	sa_sync_cmd(dev, BREAKPOINT_REQUEST, 0, 0, 0, 0, 0, 0,
			NULL, NULL, NULL, NULL, NULL);
}
static int aac_sa_restart_adapter(struct aac_dev *dev, int bled)
{
	return -EINVAL;
}
static void __devinit AscWaitEEPRead(void)
{
	mdelay(1);
}
static void __devinit AscWaitEEPWrite(void)
{
	mdelay(20);
}
static int aha1740_eh_abort_handler (Scsi_Cmnd *dummy)
{
	return 0;
}
static __init int aha1740_init (void)
{
	return eisa_driver_register (&aha1740_driver);
}
static __exit void aha1740_exit (void)
{
	eisa_driver_unregister (&aha1740_driver);
}
int
ahc_linux_eisa_init(void)
{
	return eisa_driver_register(&aic7770_driver);
}
void
ahc_linux_eisa_exit(void)
{
	eisa_driver_unregister(&aic7770_driver);
}
int
ahd_is_paused(struct ahd_softc *ahd)
{
	return ((ahd_inb(ahd, HCNTRL) & PAUSE) != 0);
}
static void
ahd_sync_scb(struct ahd_softc *ahd, struct scb *scb, int op)
{
	ahd_dmamap_sync(ahd, ahd->scb_data.hscb_dmat,
			scb->hscb_map->dmamap,
			/*offset*/(uint8_t*)scb->hscb - scb->hscb_map->vaddr,
			/*len*/sizeof(*scb->hscb), op);
}
static void
ahd_sync_sense(struct ahd_softc *ahd, struct scb *scb, int op)
{
	ahd_dmamap_sync(ahd, ahd->scb_data.sense_dmat,
			scb->sense_map->dmamap,
			/*offset*/scb->sense_busaddr,
			/*len*/AHD_SENSE_BUFSIZE, op);
}
static uint32_t
ahd_targetcmd_offset(struct ahd_softc *ahd, u_int index)
{
	return (((uint8_t *)&ahd->targetcmds[index])
	       - (uint8_t *)ahd->qoutfifo);
}
uint32_t
ahd_inl(struct ahd_softc *ahd, u_int port)
{
	return ((ahd_inb(ahd, port))
	      | (ahd_inb(ahd, port+1) << 8)
	      | (ahd_inb(ahd, port+2) << 16)
	      | (ahd_inb(ahd, port+3) << 24));
}
uint64_t
ahd_inq(struct ahd_softc *ahd, u_int port)
{
	return ((ahd_inb(ahd, port))
	      | (ahd_inb(ahd, port+1) << 8)
	      | (ahd_inb(ahd, port+2) << 16)
	      | (ahd_inb(ahd, port+3) << 24)
	      | (((uint64_t)ahd_inb(ahd, port+4)) << 32)
	      | (((uint64_t)ahd_inb(ahd, port+5)) << 40)
	      | (((uint64_t)ahd_inb(ahd, port+6)) << 48)
	      | (((uint64_t)ahd_inb(ahd, port+7)) << 56));
}
static void
ahd_set_hnscb_qoff(struct ahd_softc *ahd, u_int value)
{
	ahd_outw_atomic(ahd, HNSCB_QOFF, value);
}
static void
ahd_set_hescb_qoff(struct ahd_softc *ahd, u_int value)
{
	ahd_outb(ahd, HESCB_QOFF, value);
}
u_int
ahd_inw_scbram(struct ahd_softc *ahd, u_int offset)
{
	return (ahd_inb_scbram(ahd, offset)
	      | (ahd_inb_scbram(ahd, offset+1) << 8));
}
static uint32_t
ahd_inl_scbram(struct ahd_softc *ahd, u_int offset)
{
	return (ahd_inw_scbram(ahd, offset)
	      | (ahd_inw_scbram(ahd, offset+2) << 16));
}
static uint64_t
ahd_inq_scbram(struct ahd_softc *ahd, u_int offset)
{
	return (ahd_inl_scbram(ahd, offset)
	      | ((uint64_t)ahd_inl_scbram(ahd, offset+4)) << 32);
}
static void
ahd_sync_qoutfifo(struct ahd_softc *ahd, int op)
{
	ahd_dmamap_sync(ahd, ahd->shared_data_dmat, ahd->shared_data_map.dmamap,
			/*offset*/0,
			/*len*/AHD_SCB_MAX * sizeof(struct ahd_completion), op);
}
static __inline void
ahd_assert_atn(struct ahd_softc *ahd)
{
	ahd_outb(ahd, SCSISIGO, ATNO);
}
static __inline void
ahd_unbusy_tcl(struct ahd_softc *ahd, u_int tcl)
{
	ahd_busy_tcl(ahd, tcl, SCB_LIST_NULL);
}
void
ahd_print_devinfo(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)
{
	printf("%s:%c:%d:%d: ", ahd_name(ahd), 'A',
	       devinfo->target, devinfo->lun);
}
void
ahd_set_unit(struct ahd_softc *ahd, int unit)
{
	ahd->unit = unit;
}
int
ahd_acquire_seeprom(struct ahd_softc *ahd)
{
	return (1);
}
void
ahd_print_path(struct ahd_softc *ahd, struct scb *scb)
{
	printk("(scsi%d:%c:%d:%d): ",
	       ahd->platform_data->host->host_no,
	       scb != NULL ? SCB_GET_CHANNEL(ahd, scb) : 'X',
	       scb != NULL ? SCB_GET_TARGET(ahd, scb) : -1,
	       scb != NULL ? SCB_GET_LUN(scb) : -1);
}
void
ahd_dma_tag_destroy(struct ahd_softc *ahd, bus_dma_tag_t dmat)
{
	free(dmat, M_DEVBUF);
}
void
ahd_dmamem_free(struct ahd_softc *ahd, bus_dma_tag_t dmat,
		void* vaddr, bus_dmamap_t map)
{
	pci_free_consistent(ahd->dev_softc, dmat->maxsize,
			    vaddr, map);
}
int
ahd_dmamap_unload(struct ahd_softc *ahd, bus_dma_tag_t dmat, bus_dmamap_t map)
{
	return (0);
}
void
ahd_platform_freeze_devq(struct ahd_softc *ahd, struct scb *scb)
{
	ahd_platform_abort_scbs(ahd, SCB_GET_TARGET(ahd, scb),
				SCB_GET_CHANNEL(ahd, scb),
				SCB_GET_LUN(scb), SCB_LIST_NULL,
				ROLE_UNKNOWN, CAM_REQUEUE_REQ);
}
int
ahd_platform_abort_scbs(struct ahd_softc *ahd, int target, char channel,
			int lun, u_int tag, role_t role, uint32_t status)
{
	return 0;
}
static void
ahd_freeze_simq(struct ahd_softc *ahd)
{
	scsi_block_requests(ahd->platform_data->host);
}
static void
ahd_release_simq(struct ahd_softc *ahd)
{
	scsi_unblock_requests(ahd->platform_data->host);
}
int
ahd_linux_pci_init(void)
{
	return pci_register_driver(&aic79xx_pci_driver);
}
void
ahd_linux_pci_exit(void)
{
	pci_unregister_driver(&aic79xx_pci_driver);
}
void
ahd_power_state_change(struct ahd_softc *ahd, ahd_power_state new_state)
{
	pci_set_power_state(ahd->dev_softc, new_state);
}
int
ahc_is_paused(struct ahc_softc *ahc)
{
	return ((ahc_inb(ahc, HCNTRL) & PAUSE) != 0);
}
static uint32_t
ahc_hscb_busaddr(struct ahc_softc *ahc, u_int index)
{
	return (ahc->scb_data->hscb_busaddr
		+ (sizeof(struct hardware_scb) * index));
}
static void
ahc_sync_scb(struct ahc_softc *ahc, struct scb *scb, int op)
{
	ahc_dmamap_sync(ahc, ahc->scb_data->hscb_dmat,
			ahc->scb_data->hscb_dmamap,
			/*offset*/(scb->hscb - ahc->hscbs) * sizeof(*scb->hscb),
			/*len*/sizeof(*scb->hscb), op);
}
static uint32_t
ahc_targetcmd_offset(struct ahc_softc *ahc, u_int index)
{
	return (((uint8_t *)&ahc->targetcmds[index]) - ahc->qoutfifo);
}
uint32_t
ahc_inl(struct ahc_softc *ahc, u_int port)
{
	return ((ahc_inb(ahc, port))
	      | (ahc_inb(ahc, port+1) << 8)
	      | (ahc_inb(ahc, port+2) << 16)
	      | (ahc_inb(ahc, port+3) << 24));
}
uint64_t
ahc_inq(struct ahc_softc *ahc, u_int port)
{
	return ((ahc_inb(ahc, port))
	      | (ahc_inb(ahc, port+1) << 8)
	      | (ahc_inb(ahc, port+2) << 16)
	      | (ahc_inb(ahc, port+3) << 24)
	      | (((uint64_t)ahc_inb(ahc, port+4)) << 32)
	      | (((uint64_t)ahc_inb(ahc, port+5)) << 40)
	      | (((uint64_t)ahc_inb(ahc, port+6)) << 48)
	      | (((uint64_t)ahc_inb(ahc, port+7)) << 56));
}
static void
ahc_sync_qoutfifo(struct ahc_softc *ahc, int op)
{
	ahc_dmamap_sync(ahc, ahc->shared_data_dmat, ahc->shared_data_dmamap,
			/*offset*/0, /*len*/256, op);
}
void
ahc_print_devinfo(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)
{
	printf("%s:%c:%d:%d: ", ahc_name(ahc), devinfo->channel,
	       devinfo->target, devinfo->lun);
}
void
ahc_set_unit(struct ahc_softc *ahc, int unit)
{
	ahc->unit = unit;
}
void
ahc_print_path(struct ahc_softc *ahc, struct scb *scb)
{
	printk("(scsi%d:%c:%d:%d): ",
	       ahc->platform_data->host->host_no,
	       scb != NULL ? SCB_GET_CHANNEL(ahc, scb) : 'X',
	       scb != NULL ? SCB_GET_TARGET(ahc, scb) : -1,
	       scb != NULL ? SCB_GET_LUN(scb) : -1);
}
void
ahc_dma_tag_destroy(struct ahc_softc *ahc, bus_dma_tag_t dmat)
{
	free(dmat, M_DEVBUF);
}
void
ahc_dmamem_free(struct ahc_softc *ahc, bus_dma_tag_t dmat,
		void* vaddr, bus_dmamap_t map)
{
	pci_free_consistent(ahc->dev_softc, dmat->maxsize,
			    vaddr, map);
}
int
ahc_dmamap_unload(struct ahc_softc *ahc, bus_dma_tag_t dmat, bus_dmamap_t map)
{
	return (0);
}
void
ahc_platform_freeze_devq(struct ahc_softc *ahc, struct scb *scb)
{
	ahc_platform_abort_scbs(ahc, SCB_GET_TARGET(ahc, scb),
				SCB_GET_CHANNEL(ahc, scb),
				SCB_GET_LUN(scb), SCB_LIST_NULL,
				ROLE_UNKNOWN, CAM_REQUEUE_REQ);
}
int
ahc_platform_abort_scbs(struct ahc_softc *ahc, int target, char channel,
			int lun, u_int tag, role_t role, uint32_t status)
{
	return 0;
}
int
ahc_linux_pci_init(void)
{
	return pci_register_driver(&aic7xxx_pci_driver);
}
void
ahc_linux_pci_exit(void)
{
	pci_unregister_driver(&aic7xxx_pci_driver);
}
void
ahc_release_seeprom(struct seeprom_descriptor *sd)
{
	SEEPROM_OUTB(sd, 0);
}
static inline void
aic7xxx_busy_target(struct aic7xxx_host *p, struct aic7xxx_scb *scb)
{
  p->untagged_scbs[scb->hscb->target_channel_lun] = scb->hscb->tag;
}
static int
aic7xxx_patch15_func(struct aic7xxx_host *p)
{
	return ((p->bugs & AHC_BUG_SCBCHAN_UPLOAD) != 0);
}
static int
aic7xxx_patch14_func(struct aic7xxx_host *p)
{
	return ((p->bugs & AHC_BUG_PCI_2_1_RETRY) != 0);
}
static int
aic7xxx_patch13_func(struct aic7xxx_host *p)
{
	return ((p->features & AHC_WIDE) != 0);
}
static int
aic7xxx_patch12_func(struct aic7xxx_host *p)
{
	return ((p->bugs & AHC_BUG_AUTOFLUSH) != 0);
}
static int
aic7xxx_patch11_func(struct aic7xxx_host *p)
{
	return ((p->features & AHC_ULTRA2) == 0);
}
static int
aic7xxx_patch10_func(struct aic7xxx_host *p)
{
	return ((p->features & AHC_CMD_CHAN) == 0);
}
static int
aic7xxx_patch9_func(struct aic7xxx_host *p)
{
	return ((p->chip & AHC_CHIPID_MASK) == AHC_AIC7895);
}
static int
aic7xxx_patch8_func(struct aic7xxx_host *p)
{
	return ((p->features & AHC_ULTRA) != 0);
}
static int
aic7xxx_patch7_func(struct aic7xxx_host *p)
{
	return ((p->features & AHC_ULTRA2) != 0);
}
static int
aic7xxx_patch6_func(struct aic7xxx_host *p)
{
	return ((p->flags & AHC_PAGESCBS) == 0);
}
static int
aic7xxx_patch5_func(struct aic7xxx_host *p)
{
	return ((p->flags & AHC_PAGESCBS) != 0);
}
static int
aic7xxx_patch4_func(struct aic7xxx_host *p)
{
	return ((p->features & AHC_QUEUE_REGS) != 0);
}
static int
aic7xxx_patch3_func(struct aic7xxx_host *p)
{
	return ((p->features & AHC_TWIN) != 0);
}
static int
aic7xxx_patch2_func(struct aic7xxx_host *p)
{
	return ((p->features & AHC_QUEUE_REGS) == 0);
}
static int
aic7xxx_patch1_func(struct aic7xxx_host *p)
{
	return ((p->features & AHC_CMD_CHAN) != 0);
}
static int
aic7xxx_patch0_func(struct aic7xxx_host *p)
{
	return (0);
}
static int asd_init_initiator_ddb(struct domain_device *dev)
{
	return -ENODEV;
}
static void asd_process_donelist_isr(struct asd_ha_struct *asd_ha)
{
	tasklet_schedule(&asd_ha->seq.dl_tasklet);
}
static void asd_unmap_ioport(struct asd_ha_struct *asd_ha)
{
	pci_release_region(asd_ha->pcidev, PCI_IOBAR_OFFSET);
}
static ssize_t asd_version_show(struct device_driver *driver, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%s\n", ASD_DRIVER_VERSION);
}
static int asd_create_driver_attrs(struct device_driver *driver)
{
	return driver_create_file(driver, &driver_attr_version);
}
static void asd_remove_driver_attrs(struct device_driver *driver)
{
	driver_remove_file(driver, &driver_attr_version);
}
static inline u32 asd_mem_offs_swa(void)
{
	return 0;
}
static inline u32 asd_mem_offs_swc(void)
{
	return asd_mem_offs_swa() + MBAR0_SWA_SIZE;
}
static inline u32 asd_mem_offs_swb(void)
{
	return asd_mem_offs_swc() + MBAR0_SWC_SIZE + 0x20;
}
static void asd_unbuild_ata_ascb(struct asd_ascb *a)
{
	asd_unmap_scatterlist(a);
}
static void asd_unbuild_ssp_ascb(struct asd_ascb *a)
{
	asd_unmap_scatterlist(a);
}
static ssize_t
arcmsr_attr_host_driver_version(struct device *dev,
				struct device_attribute *attr, char *buf)
{
	return snprintf(buf, PAGE_SIZE,
			"%s\n",
			ARCMSR_DRIVER_VERSION);
}
static void arcmsr_module_exit(void)
{
	pci_unregister_driver(&arcmsr_pci_driver);
}
static inline unsigned int dmac_address(AS_Host *host)
{
    return dmac_read(host, DMAC_TXADRHI) << 16 |
	   dmac_read(host, DMAC_TXADRMD) << 8 |
	   dmac_read(host, DMAC_TXADRLO);
}
static
unsigned char calc_sync_xfer(unsigned int period, unsigned int offset)
{
    return sync_xfer_table[round_period(period)].reg_value |
		((offset < SDTR_SIZE) ? offset : SDTR_SIZE);
}
static int __init acornscsi_init(void)
{
	return ecard_register_driver(&acornscsi_driver);
}
static void __exit acornscsi_exit(void)
{
	ecard_remove_driver(&acornscsi_driver);
}
static fasdmatype_t
arxescsi_dma_setup(struct Scsi_Host *host, struct scsi_pointer *SCp,
		       fasdmadir_t direction, fasdmatype_t min_type)
{
	return fasdma_pseudo;
}
static void arxescsi_pseudo_dma_write(unsigned char *addr, void __iomem *base)
{
       __asm__ __volatile__(
       "               stmdb   sp!, {r0-r12}\n"
       "               mov     r3, %0\n"
       "               mov     r1, %1\n"
       "               add     r2, r1, #512\n"
       "               mov     r4, #256\n"
       ".loop_1:       ldmia   r3!, {r6, r8, r10, r12}\n"
       "               mov     r5, r6, lsl #16\n"
       "               mov     r7, r8, lsl #16\n"
       ".loop_2:       ldrb    r0, [r1, #1536]\n"
       "               tst     r0, #1\n"
       "               beq     .loop_2\n"
       "               stmia   r2, {r5-r8}\n\t"
       "               mov     r9, r10, lsl #16\n"
       "               mov     r11, r12, lsl #16\n"
       ".loop_3:       ldrb    r0, [r1, #1536]\n"
       "               tst     r0, #1\n"
       "               beq     .loop_3\n"
       "               stmia   r2, {r9-r12}\n"
       "               subs    r4, r4, #16\n"
       "               bne     .loop_1\n"
       "               ldmia   sp!, {r0-r12}\n"
       :
       : "r" (addr), "r" (base));
}
static int __init init_arxe_scsi_driver(void)
{
	return ecard_register_driver(&arxescsi_driver);
}
static void __exit exit_arxe_scsi_driver(void)
{
	ecard_remove_driver(&arxescsi_driver);
}
const char *cumanascsi_info(struct Scsi_Host *spnt)
{
	return "";
}
static int __init cumanascsi_init(void)
{
	return ecard_register_driver(&cumanascsi1_driver);
}
static void __exit cumanascsi_exit(void)
{
	ecard_remove_driver(&cumanascsi1_driver);
}
static int __init cumanascsi2_init(void)
{
	return ecard_register_driver(&cumanascsi2_driver);
}
static void __exit cumanascsi2_exit(void)
{
	ecard_remove_driver(&cumanascsi2_driver);
}
static int __init eesox_init(void)
{
	return ecard_register_driver(&eesoxscsi_driver);
}
static void __exit eesox_exit(void)
{
	ecard_remove_driver(&eesoxscsi_driver);
}
static void print_SCp(struct scsi_pointer *SCp, const char *prefix, const char *suffix)
{
	printk("%sptr %p this_residual 0x%x buffer %p buffers_residual 0x%x%s",
		prefix, SCp->ptr, SCp->this_residual, SCp->buffer,
		SCp->buffers_residual, suffix);
}
static char fas216_target(FAS216_Info *info)
{
	if (info->SCpnt)
		return '0' + info->SCpnt->device->id;
	else
		return 'H';
}
static unsigned int fas216_get_ctc(FAS216_Info *info)
{
	return fas216_readb(info, REG_CTCL) +
	       (fas216_readb(info, REG_CTCM) << 8) +
	       (fas216_readb(info, REG_CTCH) << 16);
}
static int parity_test(FAS216_Info *info, int target)
{
	return info->device[target].parity_check;
}
int fas216_print_host(FAS216_Info *info, char *buffer)
{
	return sprintf(buffer,
			"\n"
			"Chip    : %s\n"
			" Address: 0x%p\n"
			" IRQ    : %d\n"
			" DMA    : %d\n",
			info->scsi.type, info->scsi.io_base,
			info->scsi.irq, info->scsi.dma);
}
const char * oakscsi_info (struct Scsi_Host *spnt)
{
	return "";
}
static int __init oakscsi_init(void)
{
	return ecard_register_driver(&oakscsi_driver);
}
static void __exit oakscsi_exit(void)
{
	ecard_remove_driver(&oakscsi_driver);
}
static int __init powertecscsi_init(void)
{
	return ecard_register_driver(&powertecscsi_driver);
}
static void __exit powertecscsi_exit(void)
{
	ecard_remove_driver(&powertecscsi_driver);
}
static long atari_scsi_dma_residual(struct Scsi_Host *instance)
{
	return atari_dma_residual;
}
static unsigned char atari_scsi_tt_reg_read(unsigned char reg)
{
	return tt_scsi_regp[reg * 2];
}
static void atari_scsi_tt_reg_write(unsigned char reg, unsigned char value)
{
	tt_scsi_regp[reg * 2] = value;
}
void scsi_show_result(int result)
{
	printk("Result: hostbyte=0x%02x driverbyte=0x%02x\n",
	       host_byte(result), driver_byte(result));
}
int cxgb3i_setup_conn_host_pagesize(struct t3cdev *tdev, unsigned int tid,
				    int reply)
{
	return setup_conn_pgidx(tdev, tid, page_idx, reply);
}
static inline void c3cn_hold(struct s3_conn *c3cn)
{
	atomic_inc(&c3cn->refcnt);
}
static inline unsigned int calc_opt0l(struct s3_conn *c3cn)
{
	return  V_ULP_MODE(ULP_MODE_ISCSI) |
		V_RCV_BUFSIZ(cxgb3_rcv_win>>10);
}
static inline unsigned int ulp_extra_len(const struct sk_buff *skb)
{
	return cxgb3_ulp_extra_len[skb_ulp_mode(skb) & 3];
}
static inline void reset_wr_list(struct s3_conn *c3cn)
{
	c3cn->wr_pending_head = NULL;
}
static inline struct sk_buff *peek_wr(const struct s3_conn *c3cn)
{
	return c3cn->wr_pending_head;
}
static inline void free_wr_skb(struct sk_buff *skb)
{
	kfree_skb(skb);
}
static void arp_failure_discard(struct t3cdev *cdev, struct sk_buff *skb)
{
	kfree_skb(skb);
}
static void __devinit eeprom_index_to_delay(struct NvRamType *eeprom)
{
	eeprom->delay_time = eeprom_index_to_delay_map[eeprom->delay_time];
}
static struct DeviceCtlBlk *find_dcb(struct AdapterCtlBlk *acb, u8 id, u8 lun)
{
	return acb->children[id][lun];
}
static void sg_subtract_one(struct ScsiReqBlk *srb)
{
	sg_update_list(srb, srb->total_xfer_length - 1);
}
static inline u8 tagq_blacklist(char *name)
{
	return 0;
}
static int __init dc395x_module_init(void)
{
	return pci_register_driver(&dc395x_driver);
}
static void __exit dc395x_module_exit(void)
{
	pci_unregister_driver(&dc395x_driver);
}
int scsi_dh_handler_exist(const char *name)
{
	return (get_device_handler(name) != NULL);
}
static void __exit alua_exit(void)
{
	scsi_unregister_device_handler(&alua_dh);
}
static void __exit clariion_exit(void)
{
	scsi_unregister_device_handler(&clariion_dh);
}
static int __init hp_sw_init(void)
{
	return scsi_register_device_handler(&hp_sw_dh);
}
static void __exit hp_sw_exit(void)
{
	scsi_unregister_device_handler(&hp_sw_dh);
}
static void __exit rdac_exit(void)
{
	scsi_unregister_device_handler(&rdac_dh);
}
static int __init dmx3191d_init(void)
{
	return pci_register_driver(&dmx3191d_pci_driver);
}
static void __exit dmx3191d_exit(void)
{
	pci_unregister_driver(&dmx3191d_pci_driver);
}
static inline int dpt_dma64(adpt_hba *pHba)
{
	return (sizeof(dma_addr_t) > 4 && (pHba)->dma64);
}
static inline u32 dma_high(dma_addr_t addr)
{
	return upper_32_bits(addr);
}
static inline u32 dma_low(dma_addr_t addr)
{
	return (u32)addr;
}
static u32 adpt_cmd_to_context(struct scsi_cmnd *cmd)
{
	return (u32)cmd->serial_number;
}
static u32 adpt_ioctl_to_context(adpt_hba * pHba, void *reply)
{
	return (u32)(unsigned long)reply;
}
static void *adpt_ioctl_from_context(adpt_hba *pHba, u32 context)
{
	return (void *)(unsigned long)context;
}
static void adpt_ia64_info(sysInfo_S* si)
{
	si->processorType = PROC_IA64;
}
static void adpt_sparc_info(sysInfo_S* si)
{
	si->processorType = PROC_ULTRASPARC;
}
static void adpt_alpha_info(sysInfo_S* si)
{
	si->processorType = PROC_ALPHA;
}
static void esp_put_ent(struct esp *esp, struct esp_cmd_entry *ent)
{
	list_add(&ent->list, &esp->esp_cmd_pool);
}
static unsigned int compose_result(unsigned int status, unsigned int message,
				   unsigned int driver_code)
{
	return (status | (message << 8) | (driver_code << 16));
}
void scsi_esp_unregister(struct esp *esp)
{
	scsi_remove_host(esp->host);
}
static const char *esp_info(struct Scsi_Host *host)
{
	return "esp";
}
static void __exit esp_exit(void)
{
	spi_release_transport(esp_transport_template);
}
struct fcoe_transport *fcoe_transport_default(void)
{
	return &fcoe_sw_transport;
}
static bool fcoe_sw_match(struct net_device *netdev)
{
	return false;
}
static void fcoe_dev_setup(void)
{
	register_netdevice_notifier(&fcoe_notifier);
}
static void fcoe_dev_cleanup(void)
{
	unregister_netdevice_notifier(&fcoe_notifier);
}
static inline struct Scsi_Host *libfc_host_alloc(
	struct scsi_host_template *sht, int priv_size)
{
	return scsi_host_alloc(sht, sizeof(struct fc_lport) + priv_size);
}
struct Scsi_Host *fcoe_host_alloc(struct scsi_host_template *sht, int priv_size)
{
	return libfc_host_alloc(sht, sizeof(struct fcoe_softc) + priv_size);
}
static const char *fd_mcs_info(struct Scsi_Host *shpnt)
{
	return adapter_name;
}
static void do_pause(unsigned amount)	/* Pause for amount*10 milliseconds */
{
	mdelay(10*amount);
}
void gvp11_setup (char *str, int *ints)
{
    gvp11_xfer_mask = ints[1];
}
static void scsi_host_cls_release(struct device *dev)
{
	put_device(&class_to_shost(dev)->shost_gendev);
}
void scsi_host_put(struct Scsi_Host *shost)
{
	put_device(&shost->shost_gendev);
}
int scsi_init_hosts(void)
{
	return class_register(&shost_class);
}
void scsi_exit_hosts(void)
{
	class_unregister(&shost_class);
}
int scsi_is_host_device(const struct device *dev)
{
	return dev->type == &scsi_host_type;
}
static int iop_wait_ready_mv(struct hptiop_hba *hba, u32 millisec)
{
	return iop_send_sync_msg(hba, IOPMU_INBOUND_MSG0_NOP, millisec);
}
static void hptiop_enable_intr_itl(struct hptiop_hba *hba)
{
	writel(~(IOPMU_OUTBOUND_INT_POSTQUEUE | IOPMU_OUTBOUND_INT_MSG0),
		&hba->u.itl.iop->outbound_intmask);
}
static void hptiop_enable_intr_mv(struct hptiop_hba *hba)
{
	writel(MVIOP_MU_OUTBOUND_INT_POSTQUEUE | MVIOP_MU_OUTBOUND_INT_MSG,
		&hba->u.mv.regs->outbound_intmask);
}
static void hptiop_unmap_pci_bar_itl(struct hptiop_hba *hba)
{
	iounmap(hba->u.itl.iop);
}
static const char *hptiop_info(struct Scsi_Host *host)
{
	return driver_name_long;
}
static ssize_t hptiop_show_version(struct device *dev,
				   struct device_attribute *attr, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%s\n", driver_ver);
}
static void __exit hptiop_module_exit(void)
{
	pci_unregister_driver(&hptiop_pci_driver);
}
static void __exit ibmmca_exit(void)
{
	mca_unregister_driver(&ibmmca_driver);
}
static inline u16 lun_from_dev(struct scsi_device *dev)
{
	return (0x2 << 14) | (dev->id << 8) | (dev->channel << 5) | dev->lun;
}
static struct vio_port *target_to_port(struct srp_target *target)
{
	return (struct vio_port *) target->ldata;
}
static inline union viosrp_iu *vio_iu(struct iu_entry *iue)
{
	return (union viosrp_iu *) (iue->sbuf->buf);
}
static ssize_t system_id_show(struct device *dev,
			      struct device_attribute *attr, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%s\n", system_id);
}
static ssize_t partition_number_show(struct device *dev,
				     struct device_attribute *attr, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%x\n", partition_number);
}
static int iseriesvscsi_reset_crq_queue(struct crq_queue *queue,
					struct ibmvscsi_host_data *hostdata)
{
	return 0;
}
static int iseriesvscsi_reenable_crq_queue(struct crq_queue *queue,
					   struct ibmvscsi_host_data *hostdata)
{
	return 0;
}
static inline imm_struct *imm_dev(struct Scsi_Host *host)
{
	return *(imm_struct **)&host->hostdata;
}
static inline void imm_pb_release(imm_struct *dev)
{
	parport_release(dev->dev);
}
static void imm_disconnect(imm_struct *dev)
{
	imm_cpp(dev->base, 0x30);	/* Disconnect all devices */
}
static void imm_attach(struct parport *pb)
{
	__imm_attach(pb);
}
static void __exit imm_driver_exit(void)
{
	parport_unregister_driver(&imm_driver);
}
static int __init initio_init_driver(void)
{
	return pci_register_driver(&initio_pci_driver);
}
static void __exit initio_exit_driver(void)
{
	pci_unregister_driver(&initio_pci_driver);
}
static void ipr_log_generic_error(struct ipr_ioa_cfg *ioa_cfg,
				  struct ipr_hostrcb *hostrcb)
{
	ipr_log_hex_data(ioa_cfg, hostrcb->hcam.u.raw.data,
			 be32_to_cpu(hostrcb->hcam.length));
}
static int ipr_free_dump(struct ipr_ioa_cfg *ioa_cfg) { return 0; }
static void __exit ipr_exit(void)
{
	pci_unregister_driver(&ipr_driver);
}
static void __exit iscsi_sw_tcp_exit(void)
{
	iscsi_unregister_transport(&iscsi_sw_tcp_transport);
}
static void jazz_esp_write8(struct esp *esp, u8 val, unsigned long reg)
{
	*(volatile u8 *)(esp->regs + reg) = val;
}
static u8 jazz_esp_read8(struct esp *esp, unsigned long reg)
{
	return *(volatile u8 *)(esp->regs + reg);
}
static dma_addr_t jazz_esp_map_single(struct esp *esp, void *buf,
				      size_t sz, int dir)
{
	return dma_map_single(esp->dev, buf, sz, dir);
}
static int jazz_esp_map_sg(struct esp *esp, struct scatterlist *sg,
				  int num_sg, int dir)
{
	return dma_map_sg(esp->dev, sg, num_sg, dir);
}
static void jazz_esp_unmap_single(struct esp *esp, dma_addr_t addr,
				  size_t sz, int dir)
{
	dma_unmap_single(esp->dev, addr, sz, dir);
}
static void jazz_esp_unmap_sg(struct esp *esp, struct scatterlist *sg,
			      int num_sg, int dir)
{
	dma_unmap_sg(esp->dev, sg, num_sg, dir);
}
static void jazz_esp_reset_dma(struct esp *esp)
{
	vdma_disable ((int)esp->dma_regs);
}
static void jazz_esp_dma_invalidate(struct esp *esp)
{
	vdma_disable ((int)esp->dma_regs);
}
static int __init jazz_esp_init(void)
{
	return platform_driver_register(&esp_jazz_driver);
}
static void __exit jazz_esp_exit(void)
{
	platform_driver_unregister(&esp_jazz_driver);
}
static int __init
lasi700_init(void)
{
	return register_parisc_driver(&lasi700_driver);
}
static void __exit
lasi700_exit(void)
{
	unregister_parisc_driver(&lasi700_driver);
}
static const char *fc_exch_rctl_name(unsigned int op)
{
	return fc_exch_name_lookup(op, fc_exch_rctl_names,
				   FC_TABLE_SIZE(fc_exch_rctl_names));
}
static void fc_exch_hold(struct fc_exch *ep)
{
	atomic_inc(&ep->ex_refcnt);
}
void fc_destroy_exch_mgr(void)
{
	kmem_cache_destroy(fc_em_cachep);
}
static void fc_fcp_pkt_hold(struct fc_fcp_pkt *fsp)
{
	atomic_inc(&fsp->ref_cnt);
}
static void fc_fcp_pkt_destroy(struct fc_seq *seq, void *fsp)
{
	fc_fcp_pkt_release(fsp);
}
static void fc_fcp_abort_io(struct fc_lport *lp)
{
	fc_fcp_cleanup_each_cmd(lp, -1, -1, FC_HRD_ERROR);
}
static void fc_fcp_cleanup(struct fc_lport *lp)
{
	fc_fcp_cleanup_each_cmd(lp, -1, -1, FC_ERROR);
}
static inline int fc_fcp_lport_queue_ready(struct fc_lport *lp)
{
	return (lp->state == LPORT_ST_READY) && (lp->link_status & FC_LINK_UP);
}
void fc_get_host_port_type(struct Scsi_Host *shost)
{
	fc_host_port_type(shost) = FC_PORTTYPE_NPORT;
}
static void fc_rport_flush_queue(void)
{
	flush_workqueue(rport_event_queue);
}
void fc_destroy_rport()
{
	destroy_workqueue(rport_event_queue);
}
static int iscsi_sna_lt(u32 n1, u32 n2)
{
	return n1 != n2 && ((n1 < n2 && (n2 - n1 < SNA32_CHECK)) ||
			    (n1 > n2 && (n2 - n1 < SNA32_CHECK)));
}
static int iscsi_sna_lte(u32 n1, u32 n2)
{
	return n1 == n2 || ((n1 < n2 && (n2 - n1 < SNA32_CHECK)) ||
			    (n1 > n2 && (n2 - n1 < SNA32_CHECK)));
}
void __iscsi_get_task(struct iscsi_task *task)
{
	atomic_inc(&task->refcount);
}
static void iscsi_notify_host_removed(struct iscsi_cls_session *cls_session)
{
	iscsi_session_failure(cls_session, ISCSI_ERR_INVALID_HOST);
}
inline int iscsi_tcp_recv_segment_is_hdr(struct iscsi_tcp_conn *tcp_conn)
{
	return tcp_conn->in.segment.done == iscsi_tcp_hdr_recv_done;
}
static int sas_discover_sata_pm(struct domain_device *dev)
{
	return -ENODEV;
}
void sas_dprint_porte(int phyid, enum port_event pe)
{
	SAS_DPRINTK("phy%d: port event: %s\n", phyid, sas_porte_str[pe]);
}
void sas_dprint_phye(int phyid, enum phy_event pe)
{
	SAS_DPRINTK("phy%d: phy event: %s\n", phyid, sas_phye_str[pe]);
}
void sas_dprint_hae(struct sas_ha_struct *sas_ha, enum ha_event he)
{
	SAS_DPRINTK("ha %s: %s event\n", dev_name(sas_ha->dev),
		    sas_hae_str[he]);
}
static inline void *alloc_smp_resp(int size)
{
	return kzalloc(size, GFP_KERNEL);
}
void sas_domain_release_transport(struct scsi_transport_template *stt)
{
	sas_release_transport(stt);
}
static void __exit sas_class_exit(void)
{
	kmem_cache_destroy(sas_task_cache);
}
void srp_iu_put(struct iu_entry *iue)
{
	kfifo_put(iue->target->iu_queue.queue, (void *) &iue, sizeof(void *));
}
static ssize_t
lpfc_drvr_version_show(struct device *dev, struct device_attribute *attr,
		       char *buf)
{
	return snprintf(buf, PAGE_SIZE, LPFC_MODULE_DESC "\n");
}
static void
lpfc_ct_unsol_buffer(struct lpfc_hba *phba, struct lpfc_iocbq *piocbq,
		     struct lpfc_dmabuf *mp, uint32_t size)
{
	lpfc_ct_ignore_hbq_buffer(phba, piocbq, mp, size);
}
static int
lpfc_filter_by_wwpn(struct lpfc_nodelist *ndlp, void *param)
{
	return memcmp(&ndlp->nlp_portname, param,
		      sizeof(ndlp->nlp_portname)) == 0;
}
struct lpfc_nodelist *
__lpfc_findnode_rpi(struct lpfc_vport *vport, uint16_t rpi)
{
	return __lpfc_find_node(vport, lpfc_filter_by_rpi, &rpi);
}
static void
lpfc_challenge_key(uint32_t * RandomChallenge, uint32_t * HashWorking)
{
	*HashWorking = (*RandomChallenge ^ *HashWorking);
}
static uint32_t
lpfc_cmpl_logo_unused_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,
			   void *arg, uint32_t evt)
{
	return NLP_STE_FREED_NODE;
}
static uint32_t
lpfc_device_rm_unused_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,
			   void *arg, uint32_t evt)
{
	return NLP_STE_FREED_NODE;
}
static uint32_t
lpfc_cmpl_logo_plogi_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,
			   void *arg, uint32_t evt)
{
	return ndlp->nlp_state;
}
static uint32_t
lpfc_cmpl_reglogin_plogi_issue(struct lpfc_vport *vport,
	struct lpfc_nodelist *ndlp, void *arg, uint32_t evt)
{
	return ndlp->nlp_state;
}
static inline unsigned
lpfc_cmd_blksize(struct scsi_cmnd *sc)
{
	return sc->device->sector_size;
}
void lpfc_poll_start_timer(struct lpfc_hba * phba)
{
	lpfc_poll_rearm_timer(phba);
}
static inline IOCB_t *
lpfc_cmd_iocb(struct lpfc_hba *phba, struct lpfc_sli_ring *pring)
{
	return (IOCB_t *) (((char *) pring->cmdringaddr) +
			   pring->cmdidx * phba->iocb_cmd_size);
}
static inline IOCB_t *
lpfc_resp_iocb(struct lpfc_hba *phba, struct lpfc_sli_ring *pring)
{
	return (IOCB_t *) (((char *) pring->rspringaddr) +
			   pring->rspidx * phba->iocb_rsp_size);
}
int
lpfc_sli_hbqbuf_add_hbqs(struct lpfc_hba *phba, uint32_t qno)
{
	return(lpfc_sli_hbqbuf_fill_hbqs(phba, qno,
					 lpfc_hbq_defs[qno]->add_count));
}
static int
lpfc_sli_hbqbuf_init_hbqs(struct lpfc_hba *phba, uint32_t qno)
{
	return(lpfc_sli_hbqbuf_fill_hbqs(phba, qno,
					 lpfc_hbq_defs[qno]->init_count));
}
int
lpfc_sli_hbq_count(void)
{
	return ARRAY_SIZE(lpfc_hbq_defs);
}
int
lpfc_sli_hbq_size(void)
{
	return lpfc_sli_hbq_entry_count() * sizeof(struct lpfc_hbq_entry);
}
int
lpfc_vport_disable(struct fc_vport *fc_vport, bool disable)
{
	if (disable)
		return disable_vport(fc_vport);
	else
		return enable_vport(fc_vport);
}
static int __init init_mac53c94(void)
{
	return macio_register_driver(&mac53c94_driver);
}
static void __exit exit_mac53c94(void)
{
	return macio_unregister_driver(&mac53c94_driver);
}
static inline void mac_esp_write8(struct esp *esp, u8 val, unsigned long reg)
{
	nubus_writeb(val, esp->regs + reg * 16);
}
static inline u8 mac_esp_read8(struct esp *esp, unsigned long reg)
{
	return nubus_readb(esp->regs + reg * 16);
}
static dma_addr_t mac_esp_map_single(struct esp *esp, void *buf,
				     size_t sz, int dir)
{
	return (dma_addr_t)buf;
}
static int mac_esp_dma_error(struct esp *esp)
{
	return MAC_ESP_GET_PRIV(esp)->error;
}
static u32 mac_esp_dma_length_limit(struct esp *esp, u32 dma_addr, u32 dma_len)
{
	return dma_len > 0xFFFF ? 0xFFFF : dma_len;
}
static __inline__ char macscsi_read(struct Scsi_Host *instance, int reg)
{
  return in_8(instance->io_port + (reg<<4));
}
static __inline__ void macscsi_write(struct Scsi_Host *instance, int reg, int value)
{
  out_8(instance->io_port + (reg<<4), value);
}
const char * macscsi_info (struct Scsi_Host *spnt) {
	return "";
}
static inline void
free_local_pdev(struct pci_dev *pdev)
{
	kfree(pdev);
}
static inline void *
mega_allocate_inquiry(dma_addr_t *dma_handle, struct pci_dev *pdev)
{
	return pci_alloc_consistent(pdev, sizeof(mega_inquiry3), dma_handle);
}
static inline void
mega_free_inquiry(void *inquiry, dma_addr_t dma_handle, struct pci_dev *pdev)
{
	pci_free_consistent(pdev, sizeof(mega_inquiry3), inquiry, dma_handle);
}
static u32
megasas_read_fw_status_reg_xscale(struct megasas_register_set __iomem * regs)
{
	return readl(&(regs)->outbound_msg_0);
}
static inline void 
megasas_fire_cmd_xscale(dma_addr_t frame_phys_addr,u32 frame_count, struct megasas_register_set __iomem *regs)
{
	writel((frame_phys_addr >> 3)|(frame_count),
	       &(regs)->inbound_queue_port);
}
static u32
megasas_read_fw_status_reg_ppc(struct megasas_register_set __iomem * regs)
{
	return readl(&(regs)->outbound_scratch_pad);
}
static inline void 
megasas_fire_cmd_ppc(dma_addr_t frame_phys_addr, u32 frame_count, struct megasas_register_set __iomem *regs)
{
	writel((frame_phys_addr | (frame_count<<1))|1, 
			&(regs)->inbound_queue_port);
}
static u32
megasas_read_fw_status_reg_gen2(struct megasas_register_set __iomem *regs)
{
	return readl(&(regs)->outbound_scratch_pad);
}
static inline void
megasas_fire_cmd_gen2(dma_addr_t frame_phys_addr, u32 frame_count,
			struct megasas_register_set __iomem *regs)
{
	writel((frame_phys_addr | (frame_count<<1))|1,
			&(regs)->inbound_queue_port);
}
static irqreturn_t megasas_isr(int irq, void *devp)
{
	return megasas_deplete_reply_queue((struct megasas_instance *)devp,
					   DID_OK);
}
static ssize_t megasas_sysfs_show_version(struct device_driver *dd, char *buf)
{
	return snprintf(buf, strlen(MEGASAS_VERSION) + 2, "%s\n",
			MEGASAS_VERSION);
}
static ssize_t
megasas_sysfs_show_release_date(struct device_driver *dd, char *buf)
{
	return snprintf(buf, strlen(MEGASAS_RELDATE) + 2, "%s\n",
			MEGASAS_RELDATE);
}
static ssize_t
megasas_sysfs_show_dbg_lvl(struct device_driver *dd, char *buf)
{
	return sprintf(buf, "%u\n", megasas_dbg_lvl);
}
static ssize_t
megasas_sysfs_show_poll_mode_io(struct device_driver *dd, char *buf)
{
	return sprintf(buf, "%u\n", poll_mode_io);
}
static inline void mesh_flush_io(volatile struct mesh_regs __iomem *mr)
{
	(void)in_8(&mr->mesh_id);
}
static void mesh_completed(struct mesh_state *ms, struct scsi_cmnd *cmd)
{
	(*cmd->scsi_done)(cmd);
}
static void __exit exit_mesh(void)
{
	return macio_unregister_driver(&mesh_driver);
}
static void dma_stop(struct Scsi_Host *instance, struct scsi_cmnd *SCpnt,
		      int status)
{
    m147_pcc->dma_cntrl = 0;
}
static void mvs_tag_free(struct mvs_info *mvi, u32 tag)
{
	mvs_tag_clear(mvi, tag);
}
static u32 mvs_read_port_cfg_data(struct mvs_info *mvi, u32 port)
{
	return mvs_read_port(mvi, MVS_P0_CFG_DATA, MVS_P4_CFG_DATA, port);
}
static void mvs_write_port_cfg_data(struct mvs_info *mvi, u32 port, u32 val)
{
	mvs_write_port(mvi, MVS_P0_CFG_DATA, MVS_P4_CFG_DATA, port, val);
}
static void mvs_write_port_cfg_addr(struct mvs_info *mvi, u32 port, u32 addr)
{
	mvs_write_port(mvi, MVS_P0_CFG_ADDR, MVS_P4_CFG_ADDR, port, addr);
}
static u32 mvs_read_port_vsr_data(struct mvs_info *mvi, u32 port)
{
	return mvs_read_port(mvi, MVS_P0_VSR_DATA, MVS_P4_VSR_DATA, port);
}
static void mvs_write_port_vsr_data(struct mvs_info *mvi, u32 port, u32 val)
{
	mvs_write_port(mvi, MVS_P0_VSR_DATA, MVS_P4_VSR_DATA, port, val);
}
static void mvs_write_port_vsr_addr(struct mvs_info *mvi, u32 port, u32 addr)
{
	mvs_write_port(mvi, MVS_P0_VSR_ADDR, MVS_P4_VSR_ADDR, port, addr);
}
static u32 mvs_read_port_irq_stat(struct mvs_info *mvi, u32 port)
{
	return mvs_read_port(mvi, MVS_P0_INT_STAT, MVS_P4_INT_STAT, port);
}
static void mvs_write_port_irq_stat(struct mvs_info *mvi, u32 port, u32 val)
{
	mvs_write_port(mvi, MVS_P0_INT_STAT, MVS_P4_INT_STAT, port, val);
}
static u32 mvs_read_port_irq_mask(struct mvs_info *mvi, u32 port)
{
	return mvs_read_port(mvi, MVS_P0_INT_MASK, MVS_P4_INT_MASK, port);
}
static void mvs_write_port_irq_mask(struct mvs_info *mvi, u32 port, u32 val)
{
	mvs_write_port(mvi, MVS_P0_INT_MASK, MVS_P4_INT_MASK, port, val);
}
static u32 mvs_is_sig_fis_received(u32 irq_status)
{
	return irq_status & PHYEV_SIG_FIS;
}
static int mvs_I_T_nexus_reset(struct domain_device *dev)
{
	return TMF_RESP_FUNC_FAILED;
}
static inline char *ncr_name (struct ncb *np)
{
	return np->inst_name;
}
static int __init ncr53c8xx_setup(char *str)
{
	return sym53c8xx__setup(str);
}
void ncr53c8xx_exit(void)
{
	spi_release_transport(ncr53c8xx_transport_template);
}
static void show_command(Scsi_Cmnd *SCpnt)
{
	print_commandk(SCpnt->cmnd);
}
static const char *_osd_ver_desc(struct osd_request *or)
{
	return osd_req_is_ver1(or) ? "OSD1" : "OSD2";
}
static unsigned _osd_req_cdb_len(struct osd_request *or)
{
	return osd_req_is_ver1(or) ? OSDv1_TOTAL_CDB_LEN : OSD_TOTAL_CDB_LEN;
}
static unsigned _osd_req_alist_elem_size(struct osd_request *or, unsigned len)
{
	return osd_req_is_ver1(or) ?
		osdv1_attr_list_elem_size(len) :
		osdv2_attr_list_elem_size(len);
}
static unsigned _osd_req_alist_size(struct osd_request *or, void *list_head)
{
	return osd_req_is_ver1(or) ?
		osdv1_list_size(list_head) :
		osdv2_list_size(list_head);
}
static unsigned _osd_req_sizeof_alist_header(struct osd_request *or)
{
	return osd_req_is_ver1(or) ?
		sizeof(struct osdv1_attributes_list_header) :
		sizeof(struct osdv2_attributes_list_header);
}
static osd_cdb_offset osd_req_encode_offset(struct osd_request *or,
	u64 offset, unsigned *padding)
{
	return __osd_encode_offset(offset, padding,
			osd_req_is_ver1(or) ?
				OSDv1_OFFSET_MIN_SHIFT : OSD_OFFSET_MIN_SHIFT,
			OSD_OFFSET_MAX_SHIFT);
}
void osd_dev_fini(struct osd_dev *osdd)
{
	osdd->scsi_device = NULL;
}
static void _osd_request_free(struct osd_request *or)
{
	kfree(or);
}
int osd_execute_request(struct osd_request *or)
{
	return blk_execute_rq(or->request->q, NULL, or->request, 0);
}
void osd_req_format(struct osd_request *or, u64 tot_capacity)
{
	_osd_req_encode_common(or, OSD_ACT_FORMAT_OSD, &osd_root_object, 0,
				tot_capacity);
}
int osd_req_list_dev_partitions(struct osd_request *or,
	osd_id initial_id, struct osd_obj_id_list *list, unsigned nelem)
{
	return osd_req_list_partition_objects(or, 0, initial_id, list, nelem);
}
void osd_req_create_partition(struct osd_request *or, osd_id partition)
{
	_osd_req_encode_partition(or, OSD_ACT_CREATE_PARTITION, partition);
}
void osd_req_remove_partition(struct osd_request *or, osd_id partition)
{
	_osd_req_encode_partition(or, OSD_ACT_REMOVE_PARTITION, partition);
}
int osd_req_list_collection_objects(struct osd_request *or,
	const struct osd_obj_id *obj, osd_id initial_id,
	struct osd_obj_id_list *list, unsigned nelem)
{
	return _osd_req_list_objects(or, OSD_ACT_LIST_COLLECTION, obj,
				     initial_id, list, nelem);
}
void osd_req_create_object(struct osd_request *or, struct osd_obj_id *obj)
{
	_osd_req_encode_common(or, OSD_ACT_CREATE, obj, 0, 0);
}
void osd_req_remove_object(struct osd_request *or, struct osd_obj_id *obj)
{
	_osd_req_encode_common(or, OSD_ACT_REMOVE, obj, 0, 0);
}
void osd_req_get_attributes(struct osd_request *or,
	const struct osd_obj_id *obj)
{
	_osd_req_encode_common(or, OSD_ACT_GET_ATTRIBUTES, obj, 0, 0);
}
void osd_req_set_attributes(struct osd_request *or,
	const struct osd_obj_id *obj)
{
	_osd_req_encode_common(or, OSD_ACT_SET_ATTRIBUTES, obj, 0, 0);
}
bool osd_is_sec_alldata(struct osd_security_parameters *sec_parms __unused)
{
	return false;
}
static do_test_fn *_find_ioctl(unsigned cmd)
{
	if (g_test_ioctl == cmd)
		return g_do_test;
	else
		return NULL;
}
static void __uld_get(struct osd_uld_device *oud)
{
	kref_get(&oud->kref);
}
static void __uld_put(struct osd_uld_device *oud)
{
	kref_put(&oud->kref, __remove);
}
static inline char *tape_name(struct osst_tape *tape)
{
	return tape->drive->disk_name;
}
static struct osst_request *osst_allocate_request(void)
{
	return kzalloc(sizeof(struct osst_request), GFP_KERNEL);
}
static void osst_release_request(struct osst_request *streq)
{
	kfree(streq);
}
static ssize_t osst_version_show(struct device_driver *ddd, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%s\n", osst_version);
}
static int osst_create_sysfs_files(struct device_driver *sysfs)
{
	return driver_create_file(sysfs, &driver_attr_version);
}
static void osst_remove_sysfs_files(struct device_driver *sysfs)
{
	driver_remove_file(sysfs, &driver_attr_version);
}
static void osst_sysfs_destroy(dev_t dev)
{
	device_destroy(osst_sysfs_class, dev);
}
static void osst_sysfs_cleanup(void)
{
	class_destroy(osst_sysfs_class);
}
static int __init init_aha152x_cs(void)
{
	return pcmcia_register_driver(&aha152x_cs_driver);
}
static int __init init_fdomain_cs(void)
{
	return pcmcia_register_driver(&fdomain_cs_driver);
}
static void __exit exit_fdomain_cs(void)
{
	pcmcia_unregister_driver(&fdomain_cs_driver);
}
static inline void nsp_inc_resid(struct scsi_cmnd *SCpnt, int residInc)
{
	scsi_set_resid(SCpnt, scsi_get_resid(SCpnt) + residInc);
}
static void show_command(struct scsi_cmnd *SCpnt)
{
	print_commandk(SCpnt->cmnd);
}
static int __init init_qlogic_cs(void)
{
	return pcmcia_register_driver(&qlogic_cs_driver);
}
static void __exit exit_qlogic_cs(void)
{
	pcmcia_unregister_driver(&qlogic_cs_driver);
}
static int __init
init_sym53c500_cs(void)
{
	return pcmcia_register_driver(&sym53c500_cs_driver);
}
static void __exit
exit_sym53c500_cs(void)
{
	pcmcia_unregister_driver(&sym53c500_cs_driver);
}
static inline ppa_struct *ppa_dev(struct Scsi_Host *host)
{
	return *(ppa_struct **)&host->hostdata;
}
static inline void ppa_pb_release(ppa_struct *dev)
{
	parport_release(dev->dev);
}
static void ppa_attach(struct parport *pb)
{
	__ppa_attach(pb);
}
static void __exit ppa_driver_exit(void)
{
	parport_unregister_driver(&ppa_driver);
}
static inline unsigned int srb10_lba(const struct scsi_cmnd *cmd)
{
	return cmd->cmnd[2] << 24 | cmd->cmnd[3] << 16 | cmd->cmnd[4] << 8 |
	       cmd->cmnd[5];
}
static inline unsigned int srb10_len(const struct scsi_cmnd *cmd)
{
	return cmd->cmnd[7] << 8 | cmd->cmnd[8];
}
static int __init ps3rom_init(void)
{
	return ps3_system_bus_driver_register(&ps3rom);
}
static void __exit ps3rom_exit(void)
{
	ps3_system_bus_driver_unregister(&ps3rom);
}
static void __exit
qla1280_exit(void)
{
	pci_unregister_driver(&qla1280_pci_driver);
}
static ssize_t
qla2x00_drvr_version_show(struct device *dev,
			  struct device_attribute *attr, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%s\n", qla2x00_version_str);
}
int
qla2x00_issue_iocb(scsi_qla_host_t *vha, void *buffer, dma_addr_t phys_addr,
    size_t size)
{
	return qla2x00_issue_iocb_timeout(vha, buffer, phys_addr, size,
	    MBX_TOV_SECONDS);
}
int
qla24xx_abort_target(struct fc_port *fcport, unsigned int l)
{
	return __qla24xx_issue_tmf("Target", TCF_TARGET_RESET, fcport, l);
}
int
qla24xx_lun_reset(struct fc_port *fcport, unsigned int l)
{
	return __qla24xx_issue_tmf("Lun", TCF_LUN_RESET, fcport, l);
}
static inline void
qla2x00_restart_timer(scsi_qla_host_t *vha, unsigned long interval)
{
	mod_timer(&vha->timer, jiffies + interval * HZ);
}
static void
qla2xxx_slave_destroy(struct scsi_device *sdev)
{
	sdev->hostdata = NULL;
}
static inline uint32_t
flash_conf_addr(struct qla_hw_data *ha, uint32_t faddr)
{
	return ha->flash_conf_off | faddr;
}
static inline uint32_t
flash_data_addr(struct qla_hw_data *ha, uint32_t faddr)
{
	return ha->flash_data_off | faddr;
}
static inline uint32_t
nvram_conf_addr(struct qla_hw_data *ha, uint32_t naddr)
{
	return ha->nvram_conf_off | naddr;
}
static inline uint32_t
nvram_data_addr(struct qla_hw_data *ha, uint32_t naddr)
{
	return ha->nvram_data_off | naddr;
}
static inline int eeprom_size(struct scsi_qla_host *ha)
{
	return is_qla4010(ha) ? FM93C66A_SIZE_16 : FM93C86A_SIZE_16;
}
static inline int eeprom_no_addr_bits(struct scsi_qla_host *ha)
{
	return is_qla4010(ha) ? FM93C56A_NO_ADDR_BITS_16 :
		FM93C86A_NO_ADDR_BITS_16 ;
}
static inline int eeprom_no_data_bits(struct scsi_qla_host *ha)
{
	return FM93C56A_DATA_BITS_16;
}
static void qla4xxx_slave_destroy(struct scsi_device *sdev)
{
	scsi_deactivate_tcq(sdev, 1);
}
static int __init qlogicfas408_init(void)
{
	return 0;
}
static inline void qlogicpti_enable_irqs(struct qlogicpti *qpti)
{
	sbus_writew(SBUS_CTRL_ERIRQ | SBUS_CTRL_GENAB,
		    qpti->qregs + SBUS_CTRL);
}
static inline void qlogicpti_disable_irqs(struct qlogicpti *qpti)
{
	sbus_writew(0, qpti->qregs + SBUS_CTRL);
}
static int __init qpti_init(void)
{
	return of_register_driver(&qpti_sbus_driver, &of_bus_type);
}
static void __exit qpti_exit(void)
{
	of_unregister_driver(&qpti_sbus_driver);
}
static __init int raid_init(void)
{
	return transport_class_register(&raid_class);
}
static __exit void raid_exit(void)
{
	transport_class_unregister(&raid_class);
}
static void scsi_done(struct scsi_cmnd *cmd)
{
	blk_complete_request(cmd->request);
}
static struct scsi_driver *scsi_cmd_to_driver(struct scsi_cmnd *cmd)
{
	return *(struct scsi_driver **)cmd->request->rq_disk->private_data;
}
static inline sector_t dif_offset(sector_t sector)
{
	return sector << 3;
}
static sector_t get_sdebug_capacity(void)
{
	if (scsi_debug_virtual_gb > 0)
		return 2048 * 1024 * scsi_debug_virtual_gb;
	else
		return sdebug_store_sectors;
}
static ssize_t sdebug_delay_show(struct device_driver * ddp, char * buf)
{
        return scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_delay);
}
static ssize_t sdebug_opts_show(struct device_driver * ddp, char * buf)
{
        return scnprintf(buf, PAGE_SIZE, "0x%x\n", scsi_debug_opts);
}
static ssize_t sdebug_ptype_show(struct device_driver * ddp, char * buf)
{
        return scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_ptype);
}
static ssize_t sdebug_dsense_show(struct device_driver * ddp, char * buf)
{
        return scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_dsense);
}
static ssize_t sdebug_fake_rw_show(struct device_driver * ddp, char * buf)
{
        return scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_fake_rw);
}
static ssize_t sdebug_no_lun_0_show(struct device_driver * ddp, char * buf)
{
        return scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_no_lun_0);
}
static ssize_t sdebug_num_tgts_show(struct device_driver * ddp, char * buf)
{
        return scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_num_tgts);
}
static ssize_t sdebug_dev_size_mb_show(struct device_driver * ddp, char * buf)
{
        return scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_dev_size_mb);
}
static ssize_t sdebug_num_parts_show(struct device_driver * ddp, char * buf)
{
        return scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_num_parts);
}
static ssize_t sdebug_every_nth_show(struct device_driver * ddp, char * buf)
{
        return scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_every_nth);
}
static ssize_t sdebug_max_luns_show(struct device_driver * ddp, char * buf)
{
        return scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_max_luns);
}
static ssize_t sdebug_scsi_level_show(struct device_driver * ddp, char * buf)
{
        return scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_scsi_level);
}
static ssize_t sdebug_virtual_gb_show(struct device_driver * ddp, char * buf)
{
        return scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_virtual_gb);
}
static ssize_t sdebug_add_host_show(struct device_driver * ddp, char * buf)
{
        return scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_add_host);
}
static ssize_t sdebug_vpd_use_hostno_show(struct device_driver * ddp,
					  char * buf)
{
	return scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_vpd_use_hostno);
}
static ssize_t sdebug_sector_size_show(struct device_driver * ddp, char * buf)
{
	return scnprintf(buf, PAGE_SIZE, "%u\n", scsi_debug_sector_size);
}
static ssize_t sdebug_dix_show(struct device_driver *ddp, char *buf)
{
	return scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_dix);
}
static ssize_t sdebug_dif_show(struct device_driver *ddp, char *buf)
{
	return scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_dif);
}
static ssize_t sdebug_guard_show(struct device_driver *ddp, char *buf)
{
	return scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_guard);
}
static ssize_t sdebug_ato_show(struct device_driver *ddp, char *buf)
{
	return scnprintf(buf, PAGE_SIZE, "%d\n", scsi_debug_ato);
}
static int pseudo_lld_bus_match(struct device *dev,
				struct device_driver *dev_driver)
{
	return 1;
}
static void * devinfo_seq_start(struct seq_file *m, loff_t *pos)
{
	return seq_list_start(&scsi_dev_info_list, *pos);
}
static void * devinfo_seq_next(struct seq_file *m, void *v, loff_t *pos)
{
	return seq_list_next(v, &scsi_dev_info_list, pos);
}
static int proc_scsi_devinfo_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &scsi_devinfo_seq_ops);
}
static int scsi_request_sense(struct scsi_cmnd *scmd)
{
	return scsi_send_eh_cmnd(scmd, NULL, 0, SENSE_TIMEOUT, ~0);
}
static void eh_lock_door_done(struct request *req, int uptodate)
{
	__blk_put_request(req->q, req);
}
int scsi_command_normalize_sense(struct scsi_cmnd *cmd,
				 struct scsi_sense_hdr *sshdr)
{
	return scsi_normalize_sense(cmd->sense_buffer,
			SCSI_SENSE_BUFFERSIZE, sshdr);
}
int scsi_queue_insert(struct scsi_cmnd *cmd, int reason)
{
	return __scsi_queue_insert(cmd, reason, 1);
}
static inline int scsi_target_is_busy(struct scsi_target *starget)
{
	return ((starget->can_queue > 0 &&
		 starget->target_busy >= starget->can_queue) ||
		 starget->target_blocked);
}
static void scsi_free_sgtable(struct scsi_data_buffer *sdb)
{
	__sg_free_table(&sdb->table, SCSI_MAX_SG_SEGMENTS, scsi_sg_free);
}
void scsi_release_buffers(struct scsi_cmnd *cmd)
{
	__scsi_release_buffers(cmd, 1);
}
void scsi_free_queue(struct request_queue *q)
{
	blk_cleanup_queue(q);
}
void scsi_block_requests(struct Scsi_Host *shost)
{
	shost->host_self_blocked = 1;
}
static void
device_quiesce_fn(struct scsi_device *sdev, void *data)
{
	scsi_device_quiesce(sdev);
}
void
scsi_target_quiesce(struct scsi_target *starget)
{
	starget_for_each_device(starget, NULL, device_quiesce_fn);
}
static void
device_resume_fn(struct scsi_device *sdev, void *data)
{
	scsi_device_resume(sdev);
}
void
scsi_target_resume(struct scsi_target *starget)
{
	starget_for_each_device(starget, NULL, device_resume_fn);
}
static void
device_block(struct scsi_device *sdev, void *data)
{
	scsi_internal_device_block(sdev);
}
static void
device_unblock(struct scsi_device *sdev, void *data)
{
	scsi_internal_device_unblock(sdev);
}
void scsi_kunmap_atomic_sg(void *virt)
{
	kunmap_atomic(virt, KM_BIO_SRC_IRQ);
}
static int proc_scsi_open(struct inode *inode, struct file *file)
{
	return single_open(file, proc_scsi_show, NULL);
}
int scsi_is_target_device(const struct device *dev)
{
	return dev->type == &scsi_target_type;
}
void scsi_exit_sysctl(void)
{
	unregister_sysctl_table(scsi_table_header);
}
static void sdev_store_delete_callback(struct device *dev)
{
	scsi_remove_device(to_scsi_device(dev));
}
static ssize_t
show_iostat_counterbits(struct device *dev, struct device_attribute *attr, 				char *buf)
{
	return snprintf(buf, 20, "%d\n", (int)sizeof(atomic_t) * 8);
}
int scsi_is_sdev_device(const struct device *dev)
{
	return dev->type == &scsi_dev_type;
}
static void scsi_unmap_user_pages(struct scsi_tgt_cmd *tcmd)
{
	blk_rq_unmap_user(tcmd->bio);
}
u32
fc_get_event_number(void)
{
	return atomic_add_return(1, &fc_event_seq);
}
int scsi_is_fc_rport(const struct device *dev)
{
	return dev->release == fc_rport_dev_release;
}
int scsi_is_fc_vport(const struct device *dev)
{
	return dev->release == fc_vport_dev_release;
}
static int iscsi_is_session_dev(const struct device *dev)
{
	return dev->release == iscsi_session_release;
}
void iscsi_host_for_each_session(struct Scsi_Host *shost,
				 void (*fn)(struct iscsi_cls_session *))
{
	device_for_each_child(&shost->shost_gendev, fn,
			      iscsi_iter_session_fn);
}
void iscsi_block_session(struct iscsi_cls_session *session)
{
	queue_work(iscsi_eh_timer_workq, &session->block_work);
}
static int iscsi_is_conn_dev(const struct device *dev)
{
	return dev->release == iscsi_conn_release;
}
static int
iscsi_broadcast_skb(struct sk_buff *skb, gfp_t gfp)
{
	return netlink_broadcast(nls, skb, 0, 1, gfp);
}
static void sas_host_smp_request(struct request_queue *q)
{
	sas_smp_request(q, (struct Scsi_Host *)q->queuedata, NULL);
}
void sas_remove_host(struct Scsi_Host *shost)
{
	sas_remove_children(&shost->shost_gendev);
}
static ssize_t
store_sas_link_reset(struct device *dev, struct device_attribute *attr,
		     const char *buf, size_t count)
{
	return do_sas_phy_reset(dev, count, 0);
}
static ssize_t
store_sas_hard_reset(struct device *dev, struct device_attribute *attr,
		     const char *buf, size_t count)
{
	return do_sas_phy_reset(dev, count, 1);
}
int scsi_is_sas_phy(const struct device *dev)
{
	return dev->release == sas_phy_release;
}
int scsi_is_sas_port(const struct device *dev)
{
	return dev->release == sas_port_release;
}
static void sas_rphy_initialize(struct sas_rphy *rphy)
{
	INIT_LIST_HEAD(&rphy->list);
}
int scsi_is_sas_rphy(const struct device *dev)
{
	return dev->release == sas_end_device_release ||
		dev->release == sas_expander_release;
}
static int scsi_is_srp_rport(const struct device *dev)
{
	return dev->release == srp_rport_release;
}
void srp_remove_host(struct Scsi_Host *shost)
{
	device_for_each_child(&shost->shost_gendev, NULL, do_srp_rport_del);
}
static inline int
sd_do_mode_sense(struct scsi_device *sdp, int dbd, int modepage,
		 unsigned char *buffer, int len, struct scsi_mode_data *data,
		 struct scsi_sense_hdr *sshdr)
{
	return scsi_mode_sense(sdp, dbd, modepage, buffer, len,
			       SD_TIMEOUT, SD_MAX_RETRIES, data,
			       sshdr);
}
static __u16 sd_dif_crc_fn(void *data, unsigned int len)
{
	return cpu_to_be16(crc_t10dif(data, len));
}
static __u16 sd_dif_ip_fn(void *data, unsigned int len)
{
	return ip_compute_csum(data, len);
}
static void sd_dif_type1_generate_crc(struct blk_integrity_exchg *bix)
{
	sd_dif_type1_generate(bix, sd_dif_crc_fn);
}
static void sd_dif_type1_generate_ip(struct blk_integrity_exchg *bix)
{
	sd_dif_type1_generate(bix, sd_dif_ip_fn);
}
static int sd_dif_type1_verify_crc(struct blk_integrity_exchg *bix)
{
	return sd_dif_type1_verify(bix, sd_dif_crc_fn);
}
static int sd_dif_type1_verify_ip(struct blk_integrity_exchg *bix)
{
	return sd_dif_type1_verify(bix, sd_dif_ip_fn);
}
static void sd_dif_type3_generate_crc(struct blk_integrity_exchg *bix)
{
	sd_dif_type3_generate(bix, sd_dif_crc_fn);
}
static void sd_dif_type3_generate_ip(struct blk_integrity_exchg *bix)
{
	sd_dif_type3_generate(bix, sd_dif_ip_fn);
}
static int sd_dif_type3_verify_crc(struct blk_integrity_exchg *bix)
{
	return sd_dif_type3_verify(bix, sd_dif_crc_fn);
}
static int sd_dif_type3_verify_ip(struct blk_integrity_exchg *bix)
{
	return sd_dif_type3_verify(bix, sd_dif_ip_fn);
}
static int ses_remove(struct device *dev)
{
	return 0;
}
static Sg_device *sg_lookup_dev(int dev)
{
	return idr_find(&sg_index_idr, dev);
}
static void sg_put_dev(struct sg_device *sdp)
{
	kref_put(&sdp->d_ref, sg_device_destroy);
}
static int sg_proc_single_open_adio(struct inode *inode, struct file *file)
{
	return single_open(file, sg_proc_seq_show_int, &sg_allow_dio);
}
static int sg_proc_single_open_dressz(struct inode *inode, struct file *file)
{
	return single_open(file, sg_proc_seq_show_int, &sg_big_buff);
}
static int sg_proc_single_open_version(struct inode *inode, struct file *file)
{
	return single_open(file, sg_proc_seq_show_version, NULL);
}
static int sg_proc_single_open_devhdr(struct inode *inode, struct file *file)
{
	return single_open(file, sg_proc_seq_show_devhdr, NULL);
}
static void dev_seq_stop(struct seq_file *s, void *v)
{
	kfree(s->private);
}
static int sg_proc_open_dev(struct inode *inode, struct file *file)
{
        return seq_open(file, &dev_seq_ops);
}
static int sg_proc_open_devstrs(struct inode *inode, struct file *file)
{
        return seq_open(file, &devstrs_seq_ops);
}
static int sg_proc_open_debug(struct inode *inode, struct file *file)
{
        return seq_open(file, &debug_seq_ops);
}
static int __init sgiwd93_module_init(void)
{
	return platform_driver_register(&sgiwd93_driver);
}
static void __exit sgiwd93_module_exit(void)
{
	return platform_driver_unregister(&sgiwd93_driver);
}
static int __init snirm710_init(void)
{
	return platform_driver_register(&snirm710_driver);
}
static void __exit snirm710_exit(void)
{
	platform_driver_unregister(&snirm710_driver);
}
static inline struct scsi_cd *scsi_cd(struct gendisk *disk)
{
	return container_of(disk->private_data, struct scsi_cd, driver);
}
int sr_reset(struct cdrom_device_info *cdi)
{
	return 0;
}
static inline char *tape_name(struct scsi_tape *tape)
{
	return tape->disk->disk_name;
}
static void st_release_request(struct st_request *streq)
{
	kfree(streq);
}
static ssize_t st_try_direct_io_show(struct device_driver *ddp, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%d\n", try_direct_io);
}
static ssize_t st_fixed_buffer_size_show(struct device_driver *ddp, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%d\n", st_fixed_buffer_size);
}
static ssize_t st_max_sg_segs_show(struct device_driver *ddp, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%d\n", st_max_sg_segs);
}
static ssize_t st_version_show(struct device_driver *ddd, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "[%s]\n", verstr);
}
static void
stex_slave_destroy(struct scsi_device *sdev)
{
	scsi_deactivate_tcq(sdev, 1);
}
static void __exit stex_exit(void)
{
	pci_unregister_driver(&stex_pci_driver);
}
static inline unsigned char sun3scsi_read(int reg)
{
	return( sun3_scsi_regp[reg] );
}
static inline void sun3scsi_write(int reg, int value)
{
	sun3_scsi_regp[reg] = value;
}
const char * sun3scsi_info (struct Scsi_Host *spnt) {
    return "";
}
static inline unsigned long sun3scsi_dma_residual(struct Scsi_Host *instance)
{
	return last_residual;
}
static inline unsigned long sun3scsi_dma_xfer_len(unsigned long wanted,
						  struct scsi_cmnd *cmd,
						  int write_flag)
{
	if(blk_fs_request(cmd->request))
 		return wanted;
	else
		return 0;
}
static inline unsigned char sun3scsi_read(int reg)
{
	return( sun3_scsi_regp[reg] );
}
static inline void sun3scsi_write(int reg, int value)
{
	sun3_scsi_regp[reg] = value;
}
static const char * sun3scsi_info (struct Scsi_Host *spnt) {
    return "";
}
static inline unsigned long sun3scsi_dma_residual(struct Scsi_Host *instance)
{
	return last_residual;
}
static inline unsigned long sun3scsi_dma_xfer_len(unsigned long wanted,
						  struct scsi_cmnd *cmd,
						  int write_flag)
{
	if(blk_fs_request(cmd->request))
 		return wanted;
	else
		return 0;
}
static void sun3x_esp_write8(struct esp *esp, u8 val, unsigned long reg)
{
	writeb(val, esp->regs + (reg * 4UL));
}
static u8 sun3x_esp_read8(struct esp *esp, unsigned long reg)
{
	return readb(esp->regs + (reg * 4UL));
}
static dma_addr_t sun3x_esp_map_single(struct esp *esp, void *buf,
				      size_t sz, int dir)
{
	return dma_map_single(esp->dev, buf, sz, dir);
}
static int sun3x_esp_map_sg(struct esp *esp, struct scatterlist *sg,
				  int num_sg, int dir)
{
	return dma_map_sg(esp->dev, sg, num_sg, dir);
}
static void sun3x_esp_unmap_single(struct esp *esp, dma_addr_t addr,
				  size_t sz, int dir)
{
	dma_unmap_single(esp->dev, addr, sz, dir);
}
static void sun3x_esp_unmap_sg(struct esp *esp, struct scatterlist *sg,
			      int num_sg, int dir)
{
	dma_unmap_sg(esp->dev, sg, num_sg, dir);
}
static int __init sun3x_esp_init(void)
{
	return platform_driver_register(&esp_sun3x_driver);
}
static void __exit sun3x_esp_exit(void)
{
	platform_driver_unregister(&esp_sun3x_driver);
}
static void sbus_esp_write8(struct esp *esp, u8 val, unsigned long reg)
{
	sbus_writeb(val, esp->regs + (reg * 4UL));
}
static u8 sbus_esp_read8(struct esp *esp, unsigned long reg)
{
	return sbus_readb(esp->regs + (reg * 4UL));
}
static int __init sunesp_init(void)
{
	return of_register_driver(&esp_sbus_driver, &of_bus_type);
}
static void __exit sunesp_exit(void)
{
	of_unregister_driver(&esp_sbus_driver);
}
struct sym_fw * 
sym_find_firmware(struct sym_chip *chip)
{
	if (chip->features & FE_LDSTR)
		return &sym_fw2;
	else if (!(chip->features & (FE_PFEN|FE_NOPM|FE_DAC)))
		return &sym_fw1;
	else
		return NULL;
}
static int sym53c8xx_eh_abort_handler(struct scsi_cmnd *cmd)
{
	return sym_eh_handler(SYM_EH_ABORT, "ABORT", cmd);
}
static int sym53c8xx_eh_device_reset_handler(struct scsi_cmnd *cmd)
{
	return sym_eh_handler(SYM_EH_DEVICE_RESET, "DEVICE RESET", cmd);
}
static int sym53c8xx_eh_bus_reset_handler(struct scsi_cmnd *cmd)
{
	return sym_eh_handler(SYM_EH_BUS_RESET, "BUS RESET", cmd);
}
static int sym53c8xx_eh_host_reset_handler(struct scsi_cmnd *cmd)
{
	return sym_eh_handler(SYM_EH_HOST_RESET, "HOST RESET", cmd);
}
static const char *sym53c8xx_info (struct Scsi_Host *host)
{
	return SYM_DRIVER_NAME;
}
static void sym_start_reset(struct sym_hcb *np)
{
	sym_reset_scsi_bus(np, 1);
}
static inline int sym_regtest(struct sym_hcb *np)
{
	return 0;
}
static inline int sym_read_parisc_pdc(struct sym_device *np,
					struct pdc_initiator *x)
{
	return 0;
}
static void
dc390_DataOutPhase( struct dc390_acb* pACB, struct dc390_srb* pSRB, u8 *psstatus)
{
    dc390_DataIO_Comm (pACB, pSRB, WRITE_DIRECTION);
}
static void
dc390_DataInPhase( struct dc390_acb* pACB, struct dc390_srb* pSRB, u8 *psstatus)
{
    dc390_DataIO_Comm (pACB, pSRB, READ_DIRECTION);
}
static void __exit dc390_module_exit(void)
{
	pci_unregister_driver(&dc390_driver);
}
static inline uchar
read_aux_stat(const wd33c93_regs regs)
{
	return inb(regs.SASR);
}
static inline uchar
read_aux_stat(const wd33c93_regs regs)
{
	return *regs.SASR;
}
static inline int scsi2int(unchar * scsi)
{
	return (scsi[0] << 16) | (scsi[1] << 8) | scsi[2];
}
static int __init zorro7xx_scsi_init(void)
{
	return zorro_register_driver(&zorro7xx_driver);
}
static void __exit zorro7xx_scsi_exit(void)
{
	zorro_unregister_driver(&zorro7xx_driver);
}
static unsigned int serial21285_tx_empty(struct uart_port *port)
{
	return (*CSR_UARTFLG & 8) ? 0 : TIOCSER_TEMT;
}
static unsigned int serial21285_get_mctrl(struct uart_port *port)
{
	return TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;
}
static const char *serial21285_type(struct uart_port *port)
{
	return port->type == PORT_21285 ? "DC21285" : NULL;
}
static void serial21285_release_port(struct uart_port *port)
{
	release_mem_region(port->mapbase, 32);
}
static int serial21285_request_port(struct uart_port *port)
{
	return request_mem_region(port->mapbase, 32, serial21285_name)
			 != NULL ? 0 : -EBUSY;
}
static void serial21285_setup_ports(void)
{
	serial21285_port.uartclk = mem_fclk_21285 / 4;
}
static void
serial21285_console_write(struct console *co, const char *s,
			  unsigned int count)
{
	uart_console_write(&serial21285_port, s, count, serial21285_console_putchar);
}
static void show_serial_version(void)
{
	printk("MC68328 serial driver version 1.00\n");
}
void
putDebugChar(char ch)
{
	my_console_write(0, &ch, 1);
}
static int serial_console_wait_key(struct console *co)
{
	return(my_console_wait_key(co->index, 0, NULL));
}
int
xmon_360_read_poll(void)
{
	return(my_console_wait_key(0, 1, NULL));
}
int
xmon_360_read_char(void)
{
	return(my_console_wait_key(0, 0, NULL));
}
static int serial_index(struct uart_port *port)
{
	return (serial8250_reg.minor - 64) + port->line;
}
static inline int _serial_dl_read(struct uart_8250_port *up)
{
	return serial_inp(up, UART_DLL) | serial_inp(up, UART_DLM) << 8;
}
static int serial_dl_read(struct uart_8250_port *up)
{
	if (up->port.iotype == UPIO_AU)
		return __raw_readl(up->port.membase + 0x28);
	else
		return _serial_dl_read(up);
}
static int serial_dl_read(struct uart_8250_port *up)
{
	return	(up->port.iotype == UPIO_RM9000) ?
		(((__raw_readl(up->port.membase + 0x10) << 8) |
		(__raw_readl(up->port.membase + 0x08) & 0xff)) & 0xffff) :
		_serial_dl_read(up);
}
static inline int poll_timeout(int timeout)
{
	return timeout > 6 ? (timeout / 2 - 2) : 1;
}
static int serial8250_console_early_setup(void)
{
	return serial8250_find_port_for_earlycon();
}
void serial8250_suspend_port(int line)
{
	uart_suspend_port(&serial8250_reg, &serial8250_ports[line].port);
}
static int __init accent_init(void)
{
	return platform_device_register(&accent_device);
}
static int __init serial_card_init(void)
{
	return ecard_register_driver(&serial_card_driver);
}
static void __exit serial_card_exit(void)
{
	ecard_remove_driver(&serial_card_driver);
}
static int __init boca_init(void)
{
	return platform_device_register(&boca_device);
}
static unsigned int __init serial_in(struct uart_port *port, int offset)
{
	if (port->iotype == UPIO_MEM)
		return readb(port->membase + offset);
	else
		return inb(port->iobase + offset);
}
static int __init exar_init(void)
{
	return platform_device_register(&exar_device);
}
static int __init fourport_init(void)
{
	return platform_device_register(&fourport_device);
}
static int __init hub6_init(void)
{
	return platform_device_register(&hub6_device);
}
static void moan_device(const char *str, struct pci_dev *dev)
{
	printk(KERN_WARNING "%s: %s\n"
	       KERN_WARNING "Please send the output of lspci -vv, this\n"
	       KERN_WARNING "message (0x%04x,0x%04x,0x%04x,0x%04x), the\n"
	       KERN_WARNING "manufacturer and name of serial board or\n"
	       KERN_WARNING "modem board to rmk+serial@arm.linux.org.uk.\n",
	       pci_name(dev), str, dev->vendor, dev->device,
	       dev->subsystem_vendor, dev->subsystem_device);
}
static inline int quirk_id_matches(u32 quirk_id, u32 dev_id)
{
	return quirk_id == PCI_ANY_ID || quirk_id == dev_id;
}
static inline int get_pci_irq(struct pci_dev *dev,
				const struct pciserial_board *board)
{
	if (board->flags & FL_NOIRQ)
		return 0;
	else
		return dev->irq;
}
static inline int
serial_pci_matches(const struct pciserial_board *board,
		   const struct pciserial_board *guessed)
{
	return
	    board->num_ports == guessed->num_ports &&
	    board->base_baud == guessed->base_baud &&
	    board->uart_offset == guessed->uart_offset &&
	    board->reg_shift == guessed->reg_shift &&
	    board->first_offset == guessed->first_offset;
}
static int __init serial8250_pci_init(void)
{
	return pci_register_driver(&serial_pci_driver);
}
static void __exit serial8250_pci_exit(void)
{
	pci_unregister_driver(&serial_pci_driver);
}
static int __init serial8250_pnp_init(void)
{
	return pnp_register_driver(&serial_pnp_driver);
}
static void __exit serial8250_pnp_exit(void)
{
	pnp_unregister_driver(&serial_pnp_driver);
}
static const char *pl010_type(struct uart_port *port)
{
	return port->type == PORT_AMBA ? "AMBA" : NULL;
}
static void pl010_release_port(struct uart_port *port)
{
	release_mem_region(port->mapbase, UART_PORT_SIZE);
}
static int pl010_request_port(struct uart_port *port)
{
	return request_mem_region(port->mapbase, UART_PORT_SIZE, "uart-pl010")
			!= NULL ? 0 : -EBUSY;
}
static const char *pl011_type(struct uart_port *port)
{
	return port->type == PORT_AMBA ? "AMBA/PL011" : NULL;
}
static void pl010_release_port(struct uart_port *port)
{
	release_mem_region(port->mapbase, SZ_4K);
}
static int pl010_request_port(struct uart_port *port)
{
	return request_mem_region(port->mapbase, SZ_4K, "uart-pl011")
			!= NULL ? 0 : -EBUSY;
}
static inline struct atmel_uart_port *
to_atmel_uart_port(struct uart_port *uart)
{
	return container_of(uart, struct atmel_uart_port, uart);
}
static bool atmel_use_dma_rx(struct uart_port *port)
{
	return false;
}
static bool atmel_use_dma_tx(struct uart_port *port)
{
	return false;
}
static u_int atmel_tx_empty(struct uart_port *port)
{
	return (UART_GET_CSR(port) & ATMEL_US_TXEMPTY) ? TIOCSER_TEMT : 0;
}
static void atmel_enable_ms(struct uart_port *port)
{
	UART_PUT_IER(port, ATMEL_US_RIIC | ATMEL_US_DSRIC
			| ATMEL_US_DCDIC | ATMEL_US_CTSIC);
}
static const char *atmel_type(struct uart_port *port)
{
	return (port->type == PORT_ATMEL) ? "ATMEL_SERIAL" : NULL;
}
static inline bool atmel_is_console_port(struct uart_port *port)
{
	return port->cons && port->cons->index == port->line;
}
static inline bool atmel_is_console_port(struct uart_port *port)
{
	return false;
}
static bool atmel_serial_clk_will_stop(void)
{
	return at91_suspend_entering_slow_clock();
}
static int bfin_serial_request_port(struct uart_port *port)
{
	return 0;
}
static int
bfin_serial_verify_port(struct uart_port *port, struct serial_struct *ser)
{
	return 0;
}
static void sport_set_mctrl(struct uart_port *port, unsigned int mctrl)
{
	pr_debug("%s enter\n", __func__);
}
static void sport_enable_ms(struct uart_port *port)
{
	pr_debug("%s enter\n", __func__);
}
static void sport_break_ctl(struct uart_port *port, int break_state)
{
	pr_debug("%s enter\n", __func__);
}
static void sport_release_port(struct uart_port *port)
{
	pr_debug("%s enter\n", __func__);
}
static void clps711xuart_stop_rx(struct uart_port *port)
{
	disable_irq(RX_IRQ(port));
}
static const char *clps711xuart_type(struct uart_port *port)
{
	return port->type == PORT_CLPS711X ? "CLPS711x" : NULL;
}
static int clps711xuart_request_port(struct uart_port *port)
{
	return 0;
}
static void cpm_uart_enable_ms(struct uart_port *port)
{
	pr_debug("CPM uart[%d]:enable ms\n", port->line);
}
void cpm_line_cr_cmd(struct uart_cpm_port *port, int cmd)
{
	cpm_command(port->command, cmd);
}
void __iomem *cpm_uart_map_pram(struct uart_cpm_port *port,
				struct device_node *np)
{
	return of_iomap(np, 1);
}
void cpm_uart_unmap_pram(struct uart_cpm_port *port, void __iomem *pram)
{
	iounmap(pram);
}
void cpm_line_cr_cmd(struct uart_cpm_port *port, int cmd)
{
	cpm_command(port->command, cmd);
}
static inline void
e100_disable_rx(struct e100_serial *info)
{
	info->ioport[REG_REC_CTRL] =
		(info->rx_ctrl &= ~IO_MASK(R_SERIAL0_REC_CTRL, rec_enable));
}
static inline void
e100_enable_rx(struct e100_serial *info)
{
	info->ioport[REG_REC_CTRL] =
		(info->rx_ctrl |= IO_MASK(R_SERIAL0_REC_CTRL, rec_enable));
}
static void
start_receive(struct e100_serial *info)
{
	return;
}
static void
show_serial_version(void)
{
	printk(KERN_INFO
	       "ETRAX 100LX serial-driver %s, (c) 2000-2004 Axis Communications AB\r\n",
	       &serial_version[11]); /* "$Revision: x.yy" */
}
static inline struct dz_port *to_dport(struct uart_port *uport)
{
	return container_of(uport, struct dz_port, port);
}
static const char *dz_type(struct uart_port *uport)
{
	return "DZ";
}
static const char *icom_type(struct uart_port *port)
{
	return "icom";
}
static int icom_request_port(struct uart_port *port)
{
	return 0;
}
static void icom_config_port(struct uart_port *port, int flags)
{
	port->type = PORT_ICOM;
}
static inline void trace(struct icom_port *icom_port, char *trace_pt,
		  unsigned long trace_data)
{
	dev_info(&icom_port->adapter->pci_dev->dev, ":%d:%s - %lx\n",
		 icom_port->port, trace_pt, trace_data);
}
static const char *ic3_type(struct uart_port *the_port)
{
	if (IS_RS232(the_port->line))
		return "SGI IOC3 Serial [rs232]";
	else
		return "SGI IOC3 Serial [rs422]";
}
static int ic3_request_port(struct uart_port *port)
{
	return 0;
}
static const char *ic4_type(struct uart_port *the_port)
{
	if (the_port->mapbase == PROTO_RS232)
		return "SGI IOC4 Serial [rs232]";
	else
		return "SGI IOC4 Serial [rs422]";
}
static int ic4_request_port(struct uart_port *port)
{
	return 0;
}
static const char *ip22zilog_type(struct uart_port *port)
{
	return "IP22-Zilog";
}
static int ip22zilog_request_port(struct uart_port *port)
{
	return 0;
}
static int ip22zilog_verify_port(struct uart_port *port, struct serial_struct *ser)
{
	return -EINVAL;
}
static void * __init alloc_one_table(unsigned long size)
{
	return kzalloc(size, GFP_KERNEL);
}
static inline void neo_pci_posting_flush(struct jsm_board *bd)
{
      readb(bd->re_map_membase + 0x8D);
}
static unsigned int jsm_tty_tx_empty(struct uart_port *port)
{
	return TIOCSER_TEMT;
}
static const char *jsm_tty_type(struct uart_port *port)
{
	return "jsm";
}
static int jsm_tty_request_port(struct uart_port *port)
{
	return 0;
}
static void jsm_config_port(struct uart_port *port, int flags)
{
	port->type = PORT_JSM;
}
static int kgdboc_get_char(void)
{
	return kgdb_tty_driver->ops->poll_get_char(kgdb_tty_driver,
						kgdb_tty_line);
}
static void kgdboc_put_char(u8 chr)
{
	kgdb_tty_driver->ops->poll_put_char(kgdb_tty_driver,
					kgdb_tty_line, chr);
}
static unsigned int sio_in(struct uart_sio_port *up, int offset)
{
	return __sio_in(up->port.iobase + offset);
}
static void sio_out(struct uart_sio_port *up, int offset, int value)
{
	__sio_out(value, up->port.iobase + offset);
}
static unsigned int m32r_sio_get_mctrl(struct uart_port *port)
{
	return 0;
}
static unsigned int m32r_sio_get_divisor(struct uart_port *port,
	unsigned int baud)
{
	return uart_get_divisor(port, baud);
}
void m32r_sio_suspend_port(int line)
{
	uart_suspend_port(&m32r_sio_reg, &m32r_sio_ports[line].port);
}
void m32r_sio_resume_port(int line)
{
	uart_resume_port(&m32r_sio_reg, &m32r_sio_ports[line].port);
}
static unsigned int mcf_tx_empty(struct uart_port *port)
{
	return (readb(port->membase + MCFUART_USR) & MCFUART_USR_TXEMPTY) ?
		TIOCSER_TEMT : 0;
}
static const char *mcf_type(struct uart_port *port)
{
	return (port->type == PORT_MCF) ? "ColdFire UART" : NULL;
}
static int mcf_request_port(struct uart_port *port)
{
	return 0;
}
static int mpc52xx_psc_raw_rx_rdy(struct uart_port *port)
{
	return in_be16(&PSC(port)->mpc52xx_psc_status)
	    & MPC52xx_PSC_SR_RXRDY;
}
static int mpc52xx_psc_raw_tx_rdy(struct uart_port *port)
{
	return in_be16(&PSC(port)->mpc52xx_psc_status)
	    & MPC52xx_PSC_SR_TXRDY;
}
static int mpc52xx_psc_rx_rdy(struct uart_port *port)
{
	return in_be16(&PSC(port)->mpc52xx_psc_isr)
	    & port->read_status_mask
	    & MPC52xx_PSC_IMR_RXRDY;
}
static int mpc52xx_psc_tx_rdy(struct uart_port *port)
{
	return in_be16(&PSC(port)->mpc52xx_psc_isr)
	    & port->read_status_mask
	    & MPC52xx_PSC_IMR_TXRDY;
}
static int mpc52xx_psc_tx_empty(struct uart_port *port)
{
	return in_be16(&PSC(port)->mpc52xx_psc_status)
	    & MPC52xx_PSC_SR_TXEMP;
}
static void mpc52xx_psc_write_char(struct uart_port *port, unsigned char c)
{
	out_8(&PSC(port)->mpc52xx_psc_buffer_8, c);
}
static unsigned char mpc52xx_psc_read_char(struct uart_port *port)
{
	return in_8(&PSC(port)->mpc52xx_psc_buffer_8);
}
static void mpc52xx_psc_cw_disable_ints(struct uart_port *port)
{
	out_be16(&PSC(port)->mpc52xx_psc_imr, 0);
}
static void mpc52xx_psc_cw_restore_ints(struct uart_port *port)
{
	out_be16(&PSC(port)->mpc52xx_psc_imr, port->read_status_mask);
}
static unsigned long mpc52xx_getuartclk(void *p)
{
	return mpc52xx_find_ipb_freq(p) / 2;
}
static int mpc512x_psc_raw_rx_rdy(struct uart_port *port)
{
	return !(in_be32(&FIFO_512x(port)->rxsr) & MPC512x_PSC_FIFO_EMPTY);
}
static int mpc512x_psc_raw_tx_rdy(struct uart_port *port)
{
	return !(in_be32(&FIFO_512x(port)->txsr) & MPC512x_PSC_FIFO_FULL);
}
static int mpc512x_psc_rx_rdy(struct uart_port *port)
{
	return in_be32(&FIFO_512x(port)->rxsr)
	    & in_be32(&FIFO_512x(port)->rximr)
	    & MPC512x_PSC_FIFO_ALARM;
}
static int mpc512x_psc_tx_rdy(struct uart_port *port)
{
	return in_be32(&FIFO_512x(port)->txsr)
	    & in_be32(&FIFO_512x(port)->tximr)
	    & MPC512x_PSC_FIFO_ALARM;
}
static int mpc512x_psc_tx_empty(struct uart_port *port)
{
	return in_be32(&FIFO_512x(port)->txsr)
	    & MPC512x_PSC_FIFO_EMPTY;
}
static void mpc512x_psc_rx_clr_irq(struct uart_port *port)
{
	out_be32(&FIFO_512x(port)->rxisr, in_be32(&FIFO_512x(port)->rxisr));
}
static void mpc512x_psc_tx_clr_irq(struct uart_port *port)
{
	out_be32(&FIFO_512x(port)->txisr, in_be32(&FIFO_512x(port)->txisr));
}
static void mpc512x_psc_write_char(struct uart_port *port, unsigned char c)
{
	out_8(&FIFO_512x(port)->txdata_8, c);
}
static unsigned char mpc512x_psc_read_char(struct uart_port *port)
{
	return in_8(&FIFO_512x(port)->rxdata_8);
}
static unsigned long mpc512x_getuartclk(void *p)
{
	return mpc512x_find_ips_freq(p);
}
static unsigned int
mpc52xx_uart_tx_empty(struct uart_port *port)
{
	return psc_ops->tx_empty(port) ? TIOCSER_TEMT : 0;
}
static void
mpc52xx_uart_stop_tx(struct uart_port *port)
{
	psc_ops->stop_tx(port);
}
static void
mpc52xx_uart_start_tx(struct uart_port *port)
{
	psc_ops->start_tx(port);
}
static void
mpc52xx_uart_stop_rx(struct uart_port *port)
{
	psc_ops->stop_rx(port);
}
static const char *
mpc52xx_uart_type(struct uart_port *port)
{
	return port->type == PORT_MPC52xx ? "MPC52xx PSC" : NULL;
}
static uint mpsc_sdma_tx_active(struct mpsc_port_info *pi)
{
	return readl(pi->sdma_base + SDMA_SDCM) & SDMA_SDCM_TXD;
}
static int mpsc_request_port(struct uart_port *port)
{
	return 0;
}
static void mpsc_resource_err(char *s)
{
	printk(KERN_WARNING "MPSC: Platform device resource error in %s\n", s);
}
 static unsigned int mux_tx_empty(struct uart_port *port)
{
	return UART_GET_FIFO_CNT(port) ? 0 : TIOCSER_TEMT;
} 
static unsigned int mux_get_mctrl(struct uart_port *port)
{ 
	return TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;
}
static void mux_shutdown(struct uart_port *port)
{
	mux_ports[port->line].enabled = 0;
}
static const char *mux_type(struct uart_port *port)
{
	return "Mux";
}
static int mux_request_port(struct uart_port *port)
{
	return 0;
}
static void mux_config_port(struct uart_port *port, int type)
{
	port->type = PORT_MUX;
}
static int mux_console_setup(struct console *co, char *options)
{
        return 0;
}
static unsigned int netx_tx_empty(struct uart_port *port)
{
	return readl(port->membase + UART_FR) & FR_BUSY ? 0 : TIOCSER_TEMT;
}
static const char *netx_type(struct uart_port *port)
{
	return port->type == PORT_NETX ? "NETX" : NULL;
}
static void netx_release_port(struct uart_port *port)
{
	release_mem_region(port->mapbase, UART_PORT_SIZE);
}
static int netx_request_port(struct uart_port *port)
{
	return request_mem_region(port->mapbase, UART_PORT_SIZE,
			DRIVER_NAME) != NULL ? 0 : -EBUSY;
}
static int nwpserial_request_port(struct uart_port *port)
{
	return 0;
}
static void nwpserial_config_port(struct uart_port *port, int flags)
{
	port->type = PORT_NWPSERIAL;
}
static int nwpserial_verify_port(struct uart_port *port,
			struct serial_struct *ser)
{
	return -EINVAL;
}
static const char *nwpserial_type(struct uart_port *port)
{
	return port->type == PORT_NWPSERIAL ? "nwpserial" : NULL;
}
static unsigned int nwpserial_get_mctrl(struct uart_port *port)
{
	return 0;
}
static int __init of_platform_serial_init(void)
{
	return of_register_platform_driver(&of_platform_serial_driver);
}

static void __exit of_platform_serial_exit(void)
{
	return of_unregister_platform_driver(&of_platform_serial_driver);
}
static void pmz_stop_tx(struct uart_port *port)
{
	to_pmz(port)->flags |= PMACZILOG_FLAG_TX_STOPPED;
}
static int pmz_request_port(struct uart_port *port)
{
	return 0;
}
static int pmz_verify_port(struct uart_port *port, struct serial_struct *ser)
{
	return -EINVAL;
}
static inline int serial_in(struct pnx8xxx_port *sport, int offset)
{
	return (__raw_readl(sport->port.membase + offset));
}
static inline void serial_out(struct pnx8xxx_port *sport, int offset, int value)
{
	__raw_writel(value, sport->port.membase + offset);
}
static int serial_pxa_request_port(struct uart_port *port)
{
	return 0;
}
static int
serial_pxa_verify_port(struct uart_port *port, struct serial_struct *ser)
{
	return -EINVAL;
}
static int s3c2400_serial_setsource(struct uart_port *port,
				    struct s3c24xx_uart_clksrc *clk)
{
	return 0;
}
static int s3c2400_serial_probe(struct platform_device *dev)
{
	return s3c24xx_serial_probe(dev, &s3c2400_uart_inf);
}
static inline int s3c2400_serial_init(void)
{
	return s3c24xx_serial_init(&s3c2400_serial_drv, &s3c2400_uart_inf);
}
static inline void s3c2400_serial_exit(void)
{
	platform_driver_unregister(&s3c2400_serial_drv);
}
static int s3c2410_serial_probe(struct platform_device *dev)
{
	return s3c24xx_serial_probe(dev, &s3c2410_uart_inf);
}
static int __init s3c2410_serial_init(void)
{
	return s3c24xx_serial_init(&s3c2410_serial_drv, &s3c2410_uart_inf);
}

static void __exit s3c2410_serial_exit(void)
{
	platform_driver_unregister(&s3c2410_serial_drv);
}
static inline int s3c2412_serial_init(void)
{
	return s3c24xx_serial_init(&s3c2412_serial_drv, &s3c2412_uart_inf);
}
static inline void s3c2412_serial_exit(void)
{
	platform_driver_unregister(&s3c2412_serial_drv);
}
static int __init s3c2440_serial_init(void)
{
	return s3c24xx_serial_init(&s3c2440_serial_drv, &s3c2440_uart_inf);
}
static void __exit s3c2440_serial_exit(void)
{
	platform_driver_unregister(&s3c2440_serial_drv);
}
static int s3c24a0_serial_probe(struct platform_device *dev)
{
	return s3c24xx_serial_probe(dev, &s3c24a0_uart_inf);
}
static int __init s3c24a0_serial_init(void)
{
	return s3c24xx_serial_init(&s3c24a0_serial_drv, &s3c24a0_uart_inf);
}

static void __exit s3c24a0_serial_exit(void)
{
	platform_driver_unregister(&s3c24a0_serial_drv);
}
static int __init s3c6400_serial_init(void)
{
	return s3c24xx_serial_init(&s3c6400_serial_drv, &s3c6400_uart_inf);
}
static void __exit s3c6400_serial_exit(void)
{
	platform_driver_unregister(&s3c6400_serial_drv);
}
static unsigned int sa1100_get_mctrl(struct uart_port *port)
{
	return TIOCM_CTS | TIOCM_DSR | TIOCM_CAR;
}
static inline struct s3c24xx_uart_port *to_ourport(struct uart_port *port)
{
	return container_of(port, struct s3c24xx_uart_port, port);
}
static inline const char *s3c24xx_serial_portname(struct uart_port *port)
{
	return to_platform_device(port->dev)->name;
}
static int s3c24xx_serial_txempty_nofifo(struct uart_port *port)
{
	return (rd_regl(port, S3C2410_UTRSTAT) & S3C2410_UTRSTAT_TXE);
}
static inline struct s3c24xx_uart_info *s3c24xx_port_to_info(struct uart_port *port)
{
	return to_ourport(port)->info;
}
static void s3c24xx_serial_release_port(struct uart_port *port)
{
	release_mem_region(port->mapbase, MAP_SIZE);
}
static inline void s3c24xx_serial_cpufreq_deregister(struct s3c24xx_uart_port *port)
{
	cpufreq_unregister_notifier(&port->freq_transition,
				    CPUFREQ_TRANSITION_NOTIFIER);
}
static inline int s3c24xx_serial_cpufreq_register(struct s3c24xx_uart_port *port)
{
	return 0;
}
static void __exit s3c24xx_serial_modexit(void)
{
	uart_unregister_driver(&s3c24xx_uart_drv);
}
static void
s3c24xx_serial_console_write(struct console *co, const char *s,
			     unsigned int count)
{
	uart_console_write(cons_uart, s, count, s3c24xx_serial_console_putchar);
}
static int sbd_receive_ready(struct sbd_port *sport)
{
	return read_sbdchn(sport, R_DUART_STATUS) & M_DUART_RX_RDY;
}
static int __maybe_unused sbd_transmit_ready(struct sbd_port *sport)
{
	return read_sbdchn(sport, R_DUART_STATUS) & M_DUART_TX_RDY;
}
static int sbd_transmit_empty(struct sbd_port *sport)
{
	return read_sbdchn(sport, R_DUART_STATUS) & M_DUART_TX_EMT;
}
static const char *sbd_type(struct uart_port *uport)
{
	return "SB1250 DUART";
}
static inline u8 read_sc_port(struct uart_port *p, u8 reg)
{
	return readb(p->membase + p->line * 0x20 + reg);
}
static inline void write_sc_port(struct uart_port *p, u8 reg, u8 val)
{
	writeb(val, p->membase + p->line * 0x20 + reg);
}
static unsigned int sc26xx_tx_empty(struct uart_port *port)
{
	return (READ_SC_PORT(port, SR) & SR_TXRDY) ? TIOCSER_TEMT : 0;
}
static void sc26xx_stop_tx(struct uart_port *port)
{
	return;
}
static const char *sc26xx_type(struct uart_port *port)
{
	return "SC26XX";
}
static int sc26xx_request_port(struct uart_port *port)
{
	return 0;
}
static int sc26xx_verify_port(struct uart_port *port, struct serial_struct *ser)
{
	return -EINVAL;
}
static int __init sc26xx_init(void)
{
	return platform_driver_register(&sc26xx_driver);
}
static void __exit sc26xx_exit(void)
{
	platform_driver_unregister(&sc26xx_driver);
}
static void uart_flush_chars(struct tty_struct *tty)
{
	uart_start(tty);
}
static void quirk_setup_brainboxes_0104(struct pcmcia_device *link, struct uart_port *port)
{
	port->uartclk = 14745600;
}
static int __init init_serial_cs(void)
{
	return pcmcia_register_driver(&serial_cs_driver);
}
static void __exit exit_serial_cs(void)
{
	pcmcia_unregister_driver(&serial_cs_driver);
}
static inline int tx_enabled(struct uart_port *port)
{
	return port->unused[0] & 1;
}
static inline int rx_enabled(struct uart_port *port)
{
	return port->unused[0] & 2;
}
static inline int ms_enabled(struct uart_port *port)
{
	return port->unused[0] & 4;
}
static unsigned int ks8695uart_tx_empty(struct uart_port *port)
{
	return (UART_GET_LSR(port) & URLS_URTE) ? TIOCSER_TEMT : 0;
}
static const char *ks8695uart_type(struct uart_port *port)
{
	return port->type == PORT_KS8695 ? "KS8695" : NULL;
}
static void ks8695uart_release_port(struct uart_port *port)
{
	release_mem_region(port->mapbase, UART_PORT_SIZE);
}
static int ks8695uart_request_port(struct uart_port *port)
{
	return request_mem_region(port->mapbase, UART_PORT_SIZE,
			"serial_ks8695") != NULL ? 0 : -EBUSY;
}
static void lh7a40xuart_stop_tx (struct uart_port* port)
{
	BIT_CLR (port, UART_R_INTEN, TxInt);
}
static void lh7a40xuart_start_tx (struct uart_port* port)
{
	BIT_SET (port, UART_R_INTEN, TxInt);
}
static void lh7a40xuart_stop_rx (struct uart_port* port)
{
	BIT_SET (port, UART_R_INTEN, RxTimeoutInt | RxInt);
}
static void lh7a40xuart_enable_ms (struct uart_port* port)
{
	BIT_SET (port, UART_R_INTEN, ModemInt);
}
static unsigned int lh7a40xuart_tx_empty (struct uart_port* port)
{
	return (UR (port, UART_R_STATUS) & TxEmpty) ? TIOCSER_TEMT : 0;
}
static const char* lh7a40xuart_type (struct uart_port* port)
{
	return port->type == PORT_LH7A40X ? "LH7A40X" : NULL;
}
static void lh7a40xuart_release_port (struct uart_port* port)
{
	release_mem_region (port->mapbase, UART_REG_SIZE);
}
static int lh7a40xuart_request_port (struct uart_port* port)
{
	return request_mem_region (port->mapbase, UART_REG_SIZE,
				   "serial_lh7a40x") != NULL
		? 0 : -EBUSY;
}
static inline void
sio_mask(struct uart_txx9_port *up, int offset, unsigned int value)
{
	sio_out(up, offset, sio_in(up, offset) & ~value);
}
static inline void
sio_set(struct uart_txx9_port *up, int offset, unsigned int value)
{
	sio_out(up, offset, sio_in(up, offset) | value);
}
static const char *
serial_txx9_type(struct uart_port *port)
{
	return "txx9";
}
static inline struct sci_port *
to_sci_port(struct uart_port *uart)
{
	return container_of(uart, struct sci_port, port);
}
static inline void handle_error(struct uart_port *port)
{
	sci_out(port, SCxSR, SCxSR_ERROR_CLEAR(port));
}
static inline void h8300_sci_enable(struct uart_port *port)
{
	h8300_sci_config(port, sci_enable);
}
static inline void h8300_sci_disable(struct uart_port *port)
{
	h8300_sci_config(port, sci_disable);
}
static inline int scif_txroom(struct uart_port *port)
{
	return SCIF_TXROOM_MAX - (sci_in(port, SCTFDR) & 0xff);
}
static inline int scif_rxroom(struct uart_port *port)
{
	return sci_in(port, SCRFDR) & 0xff;
}
static inline int scif_txroom(struct uart_port *port)
{
	return SCIF_TXROOM_MAX - (sci_in(port, SCFDR) >> 8);
}
static inline int scif_rxroom(struct uart_port *port)
{
	return sci_in(port, SCFDR) & SCIF_RFDC_MASK;
}
static inline int sci_txroom(struct uart_port *port)
{
	return (sci_in(port, SCxSR) & SCI_TDRE) != 0;
}
static inline int sci_rxroom(struct uart_port *port)
{
	return (sci_in(port, SCxSR) & SCxSR_RDxF(port)) != 0;
}
static unsigned int sci_tx_empty(struct uart_port *port)
{
	return TIOCSER_TEMT;
}
static unsigned int sci_get_mctrl(struct uart_port *port)
{
	return TIOCM_DTR | TIOCM_RTS | TIOCM_DSR;
}
static int sci_request_port(struct uart_port *port)
{
	return 0;
}
static int snt_intr_getc(void)
{
	return ia64_sn_console_readc();
}
static int snt_intr_input_pending(void)
{
	return ia64_sn_console_intr_status() & SAL_CONSOLE_INTR_RECV;
}
static int snt_hw_puts_raw(const char *s, int len)
{
	return ia64_sn_console_putb(s, len);
}
static int snt_hw_puts_buffered(const char *s, int len)
{
	return ia64_sn_console_xmit_chars((char *)s, len);
}
static const char *snp_type(struct uart_port *port)
{
	return ("SGI SN L1");
}
static unsigned int snp_tx_empty(struct uart_port *port)
{
	return 1;
}
static unsigned int snp_get_mctrl(struct uart_port *port)
{
	return TIOCM_CAR | TIOCM_RNG | TIOCM_DSR | TIOCM_CTS;
}
static int snp_startup(struct uart_port *port)
{
	return 0;
}
static int snp_request_port(struct uart_port *port)
{
	return 0;
}
static int sn_sal_console_setup(struct console *co, char *options)
{
	return 0;
}
static void __init
sn_sal_console_write_early(struct console *co, const char *s, unsigned count)
{
	puts_raw_fixed(sal_console_port.sc_ops->sal_puts_raw, s, count);
}
static int __init suncore_init(void)
{
	return 0;
}
static unsigned int sunhv_tx_empty(struct uart_port *port)
{
	return TIOCSER_TEMT;
}
static void sunhv_set_mctrl(struct uart_port *port, unsigned int mctrl)
{
	return;
}
static unsigned int sunhv_get_mctrl(struct uart_port *port)
{
	return TIOCM_DSR | TIOCM_CAR | TIOCM_CTS;
}
static void sunhv_stop_tx(struct uart_port *port)
{
	return;
}
static void sunhv_start_tx(struct uart_port *port)
{
	transmit_chars(port);
}
static int sunhv_startup(struct uart_port *port)
{
	return 0;
}
static const char *sunhv_type(struct uart_port *port)
{
	return "SUN4V HCONS";
}
static int sunhv_request_port(struct uart_port *port)
{
	return 0;
}
static int sunhv_verify_port(struct uart_port *port, struct serial_struct *ser)
{
	return -EINVAL;
}
static void __exit sunhv_exit(void)
{
	of_unregister_driver(&hv_driver);
}
static int sunsab_request_port(struct uart_port *port)
{
	return 0;
}
static int sunsab_verify_port(struct uart_port *port, struct serial_struct *ser)
{
	return -EINVAL;
}
static inline struct console *SUNSAB_CONSOLE(void)
{
	return &sunsab_console;
}
static int sunzilog_request_port(struct uart_port *port)
{
	return 0;
}
static int sunzilog_verify_port(struct uart_port *port, struct serial_struct *ser)
{
	return -EINVAL;
}
static inline struct console *SUNZILOG_CONSOLE(void)
{
	return &sunzilog_console_ops;
}
static unsigned int ulite_get_mctrl(struct uart_port *port)
{
	return TIOCM_CTS | TIOCM_DSR | TIOCM_CAR;
}
static void ulite_start_tx(struct uart_port *port)
{
	ulite_transmit(port, readb(port->membase + ULITE_STATUS));
}
static void ulite_stop_rx(struct uart_port *port)
{
	port->ignore_status_mask = ULITE_STATUS_RXVALID | ULITE_STATUS_PARITY
		| ULITE_STATUS_FRAME | ULITE_STATUS_OVERRUN;
}
static const char *ulite_type(struct uart_port *port)
{
	return port->type == PORT_UARTLITE ? "uartlite" : NULL;
}
static int ulite_verify_port(struct uart_port *port, struct serial_struct *ser)
{
	return -EINVAL;
}
static int __devexit ulite_remove(struct platform_device *pdev)
{
	return ulite_release(&pdev->dev);
}
static int __devexit ulite_of_remove(struct of_device *op)
{
	return ulite_release(&op->dev);
}
static inline void __exit ulite_of_unregister(void)
{
	of_unregister_platform_driver(&ulite_of_driver);
}
static inline int __init ulite_of_register(void) { return 0; }
static unsigned int qe_uart_get_mctrl(struct uart_port *port)
{
	return TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;
}
static const char *qe_uart_type(struct uart_port *port)
{
	return "QE";
}
static const char *siu_type(struct uart_port *port)
{
	return siu_type_name(port);
}
static int __init vr41xx_siu_init(void)
{
	return platform_driver_register(&siu_device_driver);
}
static void __exit vr41xx_siu_exit(void)
{
	platform_driver_unregister(&siu_device_driver);
}
static void recovery_delay(void)
{
	udelay(2);
}
static const char *zs_type(struct uart_port *uport)
{
	return "Z85C30 SCC";
}
static void write_8(unsigned long addr, unsigned long h, unsigned long data)
{
	__raw_writeb(set_field(0, data, h), addr);
}
static void write_16(unsigned long addr, unsigned long h, unsigned long data)
{
	__raw_writew(set_field(0, data, h), addr);
}
static void write_32(unsigned long addr, unsigned long h, unsigned long data)
{
	__raw_writel(set_field(0, data, h), addr);
}
static void intc_mode_field(unsigned long addr,
			    unsigned long handle,
			    void (*fn)(unsigned long,
				       unsigned long,
				       unsigned long),
			    unsigned int irq)
{
	fn(addr, handle, ((1 << _INTC_WIDTH(handle)) - 1));
}

static void intc_mode_zero(unsigned long addr,
			   unsigned long handle,
			   void (*fn)(unsigned long,
				       unsigned long,
				       unsigned long),
			   unsigned int irq)
{
	fn(addr, handle, 0);
}

static void intc_mode_prio(unsigned long addr,
			   unsigned long handle,
			   void (*fn)(unsigned long,
				       unsigned long,
				       unsigned long),
			   unsigned int irq)
{
	fn(addr, handle, intc_prio_level[irq]);
}
static void intc_enable(unsigned int irq)
{
	_intc_enable(irq, (unsigned long)get_irq_chip_data(irq));
}
void maple_driver_unregister(struct maple_driver *drv)
{
	driver_unregister(&drv->drv);
}
static int maple_dma_done(void)
{
	return (ctrl_inl(MAPLE_STATE) & 1) == 0;
}
static int maple_set_dma_interrupt_handler(void)
{
	return request_irq(HW_EVENT_MAPLE_DMA, maplebus_dma_interrupt,
		IRQF_SHARED, "maple bus DMA", &maple_dummy_driver);
}
static int maple_set_vblank_interrupt_handler(void)
{
	return request_irq(HW_EVENT_VSYNC, maplebus_vblank_interrupt,
		IRQF_SHARED, "maple bus VBLANK", &maple_dummy_driver);
}
static int maple_bus_uevent(struct device *dev,
			    struct kobj_uevent_env *env)
{
	return 0;
}
void superhyway_unregister_driver(struct superhyway_driver *drv)
{
	driver_unregister(&drv->drv);
}
static int __init superhyway_bus_init(void)
{
	return bus_register(&superhyway_bus_type);
}
static inline unsigned mcr_pack(unsigned pulse, unsigned sample)
{
	return (pulse << 10) | (sample << 2);
}
void ioc3_enable(struct ioc3_submodule *is,
				struct ioc3_driver_data *idd, unsigned int irqs)
{
	write_ireg(idd, irqs & is->irq_mask, IOC3_W_IES);
}
void ioc3_ack(struct ioc3_submodule *is, struct ioc3_driver_data *idd,
				unsigned int irqs)
{
	writel(irqs & is->irq_mask, &idd->vma->sio_ir);
}
void ioc3_disable(struct ioc3_submodule *is,
				struct ioc3_driver_data *idd, unsigned int irqs)
{
	write_ireg(idd, irqs & is->irq_mask, IOC3_W_IEC);
}
static void __devexit ioc3_exit(void)
{
	pci_unregister_driver(&ioc3_driver);
}
static bool atmel_spi_is_v2(void)
{
	return !cpu_is_at91rm9200();
}
static inline int atmel_spi_xfer_is_last(struct spi_message *msg,
					struct spi_transfer *xfer)
{
	return msg->transfers.prev == &xfer->transfer_list;
}
static inline int atmel_spi_xfer_can_be_chained(struct spi_transfer *xfer)
{
	return xfer->delay_usecs == 0 && !xfer->cs_change;
}
static int __init atmel_spi_init(void)
{
	return platform_driver_probe(&atmel_spi_driver, atmel_spi_probe);
}
static void __exit atmel_spi_exit(void)
{
	platform_driver_unregister(&atmel_spi_driver);
}
static void mpc52xx_psc_spi_cleanup(struct spi_device *spi)
{
	kfree(spi->controller_state);
}
static int __exit mpc52xx_psc_spi_of_remove(struct of_device *op)
{
	return mpc52xx_psc_spi_do_remove(&op->dev);
}
static int __init mpc52xx_psc_spi_init(void)
{
	return of_register_platform_driver(&mpc52xx_psc_spi_of_driver);
}
static void __exit mpc52xx_psc_spi_exit(void)
{
	of_unregister_platform_driver(&mpc52xx_psc_spi_of_driver);
}
static inline void uwire_write_reg(int idx, u16 val)
{
	__raw_writew(val, uwire_base + (idx << uwire_idx_shift));
}
static inline u16 uwire_read_reg(int idx)
{
	return __raw_readw(uwire_base + (idx << uwire_idx_shift));
}
static void uwire_cleanup(struct spi_device *spi)
{
	kfree(spi->controller_state);
}
static void __exit omap_uwire_exit(void)
{
	platform_driver_unregister(&uwire_driver);
}
static inline void __iomem *spi_reg(struct orion_spi *orion_spi, u32 reg)
{
	return orion_spi->base + reg;
}
static int __init pxa2xx_spi_init(void)
{
	return platform_driver_probe(&driver, pxa2xx_spi_probe);
}
static void __exit pxa2xx_spi_exit(void)
{
	platform_driver_unregister(&driver);
}
static void spi_complete(void *arg)
{
	complete(arg);
}
static int __init bfin5xx_spi_init(void)
{
	return platform_driver_probe(&bfin5xx_spi_driver, bfin5xx_spi_probe);
}
static void __exit bfin5xx_spi_exit(void)
{
	platform_driver_unregister(&bfin5xx_spi_driver);
}
void spi_bitbang_cleanup(struct spi_device *spi)
{
	kfree(spi->controller_state);
}
static inline struct butterfly *spidev_to_pp(struct spi_device *spi)
{
	return spi->controller_data;
}
static u32
butterfly_txrx_word_mode0(struct spi_device *spi,
		unsigned nsecs,
		u32 word, u8 bits)
{
	return bitbang_txrx_be_cpha0(spi, nsecs, 0, word, bits);
}
static int __init butterfly_init(void)
{
	return parport_register_driver(&butterfly_driver);
}
static void __exit butterfly_exit(void)
{
	parport_unregister_driver(&butterfly_driver);
}
static inline void setsck(const struct spi_device *spi, int is_on)
{
	gpio_set_value(SPI_SCK_GPIO, is_on);
}
static inline void setmosi(const struct spi_device *spi, int is_on)
{
	gpio_set_value(SPI_MOSI_GPIO, is_on);
}
static inline int getmiso(const struct spi_device *spi)
{
	return gpio_get_value(SPI_MISO_GPIO);
}
static u32 spi_gpio_txrx_word_mode0(struct spi_device *spi,
		unsigned nsecs, u32 word, u8 bits)
{
	return bitbang_txrx_be_cpha0(spi, nsecs, 0, word, bits);
}
static u32 spi_gpio_txrx_word_mode1(struct spi_device *spi,
		unsigned nsecs, u32 word, u8 bits)
{
	return bitbang_txrx_be_cpha1(spi, nsecs, 0, word, bits);
}
static u32 spi_gpio_txrx_word_mode2(struct spi_device *spi,
		unsigned nsecs, u32 word, u8 bits)
{
	return bitbang_txrx_be_cpha0(spi, nsecs, 1, word, bits);
}
static u32 spi_gpio_txrx_word_mode3(struct spi_device *spi,
		unsigned nsecs, u32 word, u8 bits)
{
	return bitbang_txrx_be_cpha1(spi, nsecs, 1, word, bits);
}
static int __init spi_gpio_init(void)
{
	return platform_driver_probe(&spi_gpio_driver, spi_gpio_probe);
}
static void __exit spi_gpio_exit(void)
{
	platform_driver_unregister(&spi_gpio_driver);
}
static inline u32 data_to_write(struct driver_data *drv_data)
{
	return ((u32)(drv_data->tx_end - drv_data->tx)) / drv_data->n_bytes;
}
static inline u32 data_to_read(struct driver_data *drv_data)
{
	return ((u32)(drv_data->rx_end - drv_data->rx)) / drv_data->n_bytes;
}
static inline u32 spi_speed_hz(struct driver_data *drv_data, u32 data_rate)
{
	return clk_get_rate(drv_data->clk) / (4 << ((data_rate) >> 13));
}
static void cleanup(struct spi_device *spi)
{
	kfree(spi_get_ctldata(spi));
}
static int __init spi_imx_init(void)
{
	return platform_driver_probe(&driver, spi_imx_probe);
}
static void __exit spi_imx_exit(void)
{
	platform_driver_unregister(&driver);
}
static inline struct spi_lm70llp *spidev_to_pp(struct spi_device *spi)
{
	return spi->controller_data;
}
static inline void spidelay(unsigned d)
{
	udelay(d);
}
static u32 lm70_txrx(struct spi_device *spi, unsigned nsecs, u32 word, u8 bits)
{
	return bitbang_txrx_be_cpha0(spi, nsecs, 0, word, bits);
}
static int __init init_spi_lm70llp(void)
{
	return parport_register_driver(&spi_lm70llp_drv);
}
static void __exit cleanup_spi_lm70llp(void)
{
	parport_unregister_driver(&spi_lm70llp_drv);
}
static inline void mpc83xx_spi_write_reg(__be32 __iomem * reg, u32 val)
{
	out_be32(reg, val);
}
static inline u32 mpc83xx_spi_read_reg(__be32 __iomem * reg)
{
	return in_be32(reg);
}
static void mpc83xx_spi_cleanup(struct spi_device *spi)
{
	kfree(spi->controller_state);
}
static int __init mpc83xx_spi_init(void)
{
	return platform_driver_probe(&mpc83xx_spi_driver, mpc83xx_spi_probe);
}
static void __exit mpc83xx_spi_exit(void)
{
	platform_driver_unregister(&mpc83xx_spi_driver);
}
static inline struct s3c24xx_spi *to_hw(struct spi_device *sdev)
{
	return spi_master_get_devdata(sdev->master);
}
static void s3c24xx_spi_gpiocs(struct s3c2410_spi_info *spi, int cs, int pol)
{
	gpio_set_value(spi->pin_cs, pol);
}
static inline unsigned int hw_txbyte(struct s3c24xx_spi *hw, int count)
{
	return hw->tx ? hw->tx[count] : 0;
}
static int __init s3c24xx_spi_init(void)
{
        return platform_driver_probe(&s3c24xx_spi_driver, s3c24xx_spi_probe);
}
static void __exit s3c24xx_spi_exit(void)
{
        platform_driver_unregister(&s3c24xx_spi_driver);
}
static inline struct s3c2410_spigpio *spidev_to_sg(struct spi_device *spi)
{
	return spi_master_get_devdata(spi->master);
}
static u32 s3c2410_spigpio_txrx_mode0(struct spi_device *spi,
				      unsigned nsecs, u32 word, u8 bits)
{
	return bitbang_txrx_be_cpha0(spi, nsecs, 0, word, bits);
}
static u32 s3c2410_spigpio_txrx_mode1(struct spi_device *spi,
				      unsigned nsecs, u32 word, u8 bits)
{
	return bitbang_txrx_be_cpha1(spi, nsecs, 0, word, bits);
}
static u32 s3c2410_spigpio_txrx_mode2(struct spi_device *spi,
				      unsigned nsecs, u32 word, u8 bits)
{
	return bitbang_txrx_be_cpha0(spi, nsecs, 1, word, bits);
}
static u32 s3c2410_spigpio_txrx_mode3(struct spi_device *spi,
				      unsigned nsecs, u32 word, u8 bits)
{
	return bitbang_txrx_be_cpha1(spi, nsecs, 1, word, bits);
}
static int __init s3c2410_spigpio_init(void)
{
        return platform_driver_register(&s3c2410_spigpio_drv);
}
static void __exit s3c2410_spigpio_exit(void)
{
        platform_driver_unregister(&s3c2410_spigpio_drv);
}
static inline void setsck(struct spi_device *dev, int on)
{
	setbits(spi_master_get_devdata(dev->master), PIN_SCK, on);
}
static inline void setmosi(struct spi_device *dev, int on)
{
	setbits(spi_master_get_devdata(dev->master), PIN_TXD, on);
}
static u32 sh_sci_spi_txrx_mode0(struct spi_device *spi,
				      unsigned nsecs, u32 word, u8 bits)
{
	return bitbang_txrx_be_cpha0(spi, nsecs, 0, word, bits);
}
static u32 sh_sci_spi_txrx_mode1(struct spi_device *spi,
				      unsigned nsecs, u32 word, u8 bits)
{
	return bitbang_txrx_be_cpha1(spi, nsecs, 0, word, bits);
}
static u32 sh_sci_spi_txrx_mode2(struct spi_device *spi,
				      unsigned nsecs, u32 word, u8 bits)
{
	return bitbang_txrx_be_cpha0(spi, nsecs, 1, word, bits);
}
static u32 sh_sci_spi_txrx_mode3(struct spi_device *spi,
				      unsigned nsecs, u32 word, u8 bits)
{
	return bitbang_txrx_be_cpha1(spi, nsecs, 1, word, bits);
}
static int __init sh_sci_spi_init(void)
{
	return platform_driver_register(&sh_sci_spi_drv);
}
static void __exit sh_sci_spi_exit(void)
{
	platform_driver_unregister(&sh_sci_spi_drv);
}
static u32 txx9spi_rd(struct txx9spi *c, int reg)
{
	return __raw_readl(c->membase + reg);
}
static void txx9spi_wr(struct txx9spi *c, u32 val, int reg)
{
	__raw_writel(val, c->membase + reg);
}
static int __init txx9spi_init(void)
{
	return platform_driver_probe(&txx9spi_driver, txx9spi_probe);
}
static void __exit txx9spi_exit(void)
{
	platform_driver_unregister(&txx9spi_driver);
}
static void spidev_complete(void *arg)
{
	complete(arg);
}
static __init int tle62x0_init(void)
{
	return spi_register_driver(&tle62x0_driver);
}
static __exit void tle62x0_exit(void)
{
	spi_unregister_driver(&tle62x0_driver);
}
static int __exit xilinx_spi_of_remove(struct of_device *op)
{
	return xilinx_spi_remove(op);
}
static int __init xilinx_spi_init(void)
{
	return of_register_platform_driver(&xilinx_spi_of_driver);
}
static void __exit xilinx_spi_exit(void)
{
	of_unregister_platform_driver(&xilinx_spi_of_driver);
}
int __init b43_pci_ssb_bridge_init(void)
{
	return ssb_pcihost_register(&b43_pci_bridge_driver);
}
void __exit b43_pci_ssb_bridge_exit(void)
{
	ssb_pcihost_unregister(&b43_pci_bridge_driver);
}
void ssb_chipco_watchdog_timer_set(struct ssb_chipcommon *cc, u32 ticks)
{
	chipco_write32(cc, SSB_CHIPCO_WATCHDOG, ticks);
}
void ssb_chipco_irq_mask(struct ssb_chipcommon *cc, u32 mask, u32 value)
{
	chipco_write32_masked(cc, SSB_CHIPCO_IRQMASK, mask, value);
}
u32 ssb_chipco_irq_status(struct ssb_chipcommon *cc, u32 mask)
{
	return chipco_read32(cc, SSB_CHIPCO_IRQSTAT) & mask;
}
u32 ssb_chipco_gpio_in(struct ssb_chipcommon *cc, u32 mask)
{
	return chipco_read32(cc, SSB_CHIPCO_GPIOIN) & mask;
}
u32 ssb_chipco_gpio_out(struct ssb_chipcommon *cc, u32 mask, u32 value)
{
	return chipco_write32_masked(cc, SSB_CHIPCO_GPIOOUT, mask, value);
}
u32 ssb_chipco_gpio_outen(struct ssb_chipcommon *cc, u32 mask, u32 value)
{
	return chipco_write32_masked(cc, SSB_CHIPCO_GPIOOUTEN, mask, value);
}
u32 ssb_chipco_gpio_control(struct ssb_chipcommon *cc, u32 mask, u32 value)
{
	return chipco_write32_masked(cc, SSB_CHIPCO_GPIOCTL, mask, value);
}
u32 ssb_chipco_gpio_intmask(struct ssb_chipcommon *cc, u32 mask, u32 value)
{
	return chipco_write32_masked(cc, SSB_CHIPCO_GPIOIRQ, mask, value);
}
u32 ssb_chipco_gpio_polarity(struct ssb_chipcommon *cc, u32 mask, u32 value)
{
	return chipco_write32_masked(cc, SSB_CHIPCO_GPIOPOL, mask, value);
}
static inline u32 extif_read32(struct ssb_extif *extif, u16 offset)
{
	return ssb_read32(extif->dev, offset);
}
static inline void extif_write32(struct ssb_extif *extif, u16 offset, u32 value)
{
	ssb_write32(extif->dev, offset, value);
}
void ssb_extif_watchdog_timer_set(struct ssb_extif *extif,
				  u32 ticks)
{
	extif_write32(extif, SSB_EXTIF_WATCHDOG, ticks);
}
u32 ssb_extif_gpio_in(struct ssb_extif *extif, u32 mask)
{
	return extif_read32(extif, SSB_EXTIF_GPIO_IN) & mask;
}
u32 ssb_extif_gpio_out(struct ssb_extif *extif, u32 mask, u32 value)
{
	return extif_write32_masked(extif, SSB_EXTIF_GPIO_OUT(0),
				   mask, value);
}
u32 ssb_extif_gpio_outen(struct ssb_extif *extif, u32 mask, u32 value)
{
	return extif_write32_masked(extif, SSB_EXTIF_GPIO_OUTEN(0),
				   mask, value);
}
u32 ssb_extif_gpio_polarity(struct ssb_extif *extif, u32 mask, u32 value)
{
	return extif_write32_masked(extif, SSB_EXTIF_GPIO_INTPOL, mask, value);
}
u32 ssb_extif_gpio_intmask(struct ssb_extif *extif, u32 mask, u32 value)
{
	return extif_write32_masked(extif, SSB_EXTIF_GPIO_INTMASK, mask, value);
}
static inline u8 gige_read8(struct ssb_gige *dev, u16 offset)
{
	return ssb_read8(dev->dev, offset);
}
static inline u16 gige_read16(struct ssb_gige *dev, u16 offset)
{
	return ssb_read16(dev->dev, offset);
}
static inline u32 gige_read32(struct ssb_gige *dev, u16 offset)
{
	return ssb_read32(dev->dev, offset);
}
static inline void gige_write8(struct ssb_gige *dev,
			       u16 offset, u8 value)
{
	ssb_write8(dev->dev, offset, value);
}
static inline void gige_write16(struct ssb_gige *dev,
				u16 offset, u16 value)
{
	ssb_write16(dev->dev, offset, value);
}
static inline void gige_write32(struct ssb_gige *dev,
				u16 offset, u32 value)
{
	ssb_write32(dev->dev, offset, value);
}
int ssb_gige_init(void)
{
	return ssb_driver_register(&ssb_gige_driver);
}
static inline u32 mips_read32(struct ssb_mipscore *mcore,
			      u16 offset)
{
	return ssb_read32(mcore->dev, offset);
}
static inline void mips_write32(struct ssb_mipscore *mcore,
				u16 offset,
				u32 value)
{
	ssb_write32(mcore->dev, offset, value);
}
static inline u32 ssb_irqflag(struct ssb_device *dev)
{
	return ssb_read32(dev, SSB_TPSFLAG) & SSB_TPSFLAG_BPFLAG;
}
static inline
u32 pcicore_read32(struct ssb_pcicore *pc, u16 offset)
{
	return ssb_read32(pc->dev, offset);
}
static inline
void pcicore_write32(struct ssb_pcicore *pc, u16 offset, u32 value)
{
	ssb_write32(pc->dev, offset, value);
}
static inline
u16 pcicore_read16(struct ssb_pcicore *pc, u16 offset)
{
	return ssb_read16(pc->dev, offset);
}
static inline
void pcicore_write16(struct ssb_pcicore *pc, u16 offset, u16 value)
{
	ssb_write16(pc->dev, offset, value);
}
static void ssb_pcicore_init_clientmode(struct ssb_pcicore *pc)
{
	ssb_write32(pc->dev, SSB_INTVEC, 0);
}
void ssb_driver_unregister(struct ssb_driver *drv)
{
	driver_unregister(&drv->drv);
}
static inline int ssb_pci_assert_buspower(struct ssb_bus *bus)
{
	return 0;
}
static int ssb_pcmcia_sprom_check_crc(const u16 *sprom, size_t size)
{
	return 0;
}
int agnx_hw_reset(struct agnx_priv *priv)
{
	return card_full_reset(priv);
}
void agnx_set_bssid(struct agnx_priv *priv, u8 *bssid)
{
	receiver_bssid_set(priv, bssid);
}
static inline void spi_sy_write(void __iomem *region, u32 chip_ids, u32 sw)
{
	spi_write(region, chip_ids, sw, 0x15, SPI_BUSY_CTL);
}
static inline void spi_rf_write(void __iomem *region, u32 chip_ids, u32 sw)
{
	/* FIXME the size 0xd is a magic value*/
	spi_write(region, chip_ids, sw, 0xd, SPI_BUSY_CTL);
} /* spi_rf_write */
inline void spi_rc_write(void __iomem *region, u32 chip_ids, u32 sw)
{
	spi_write(region, chip_ids, sw, 0xe5, SPI_BUSY_CTL|SPI_READ_CTL);
}
void handle_txm_irq(struct agnx_priv *priv)
{
	handle_tx_irq(priv, &priv->txm);
}
void handle_txd_irq(struct agnx_priv *priv)
{
	handle_tx_irq(priv, &priv->txd);
}
static inline void route_flag_set(struct agnx_hdr *txhdr)
{
 	txhdr->reg5 = (0xa << 0x0) | (0x7 << 0x18);
}
static size_t binder_buffer_size(
	struct binder_proc *proc, struct binder_buffer *buffer)
{
	if (list_is_last(&buffer->entry, &proc->buffers))
		return proc->buffer + proc->buffer_size - (void *)buffer->data;
	else
		return (size_t)list_entry(buffer->entry.next,
			struct binder_buffer, entry) - (size_t)buffer->data;
}
static void *buffer_start_page(struct binder_buffer *buffer)
{
	return (void *)((size_t)buffer & PAGE_MASK);
}
static void *buffer_end_page(struct binder_buffer *buffer)
{
	return (void *)(((size_t)(buffer + 1) - 1) & PAGE_MASK);
}
static int
binder_has_proc_work(struct binder_proc *proc, struct binder_thread *thread)
{
	return !list_empty(&proc->todo) || (thread->looper & BINDER_LOOPER_STATE_NEED_RETURN);
}
static int
binder_has_thread_work(struct binder_thread *thread)
{
	return !list_empty(&thread->todo) || thread->return_error != BR_OK ||
		(thread->looper & BINDER_LOOPER_STATE_NEED_RETURN);
}
static inline struct logger_log * file_get_log(struct file *file)
{
	if (file->f_mode & FMODE_READ) {
	} else
		return file->private_data;
}
static void __exit lowmem_exit(void)
{
	unregister_shrinker(&lowmem_shrinker);
}
static int __init ram_console_early_init(void)
{
	return ram_console_init((struct ram_console_buffer *)
		CONFIG_ANDROID_RAM_CONSOLE_EARLY_ADDR,
		CONFIG_ANDROID_RAM_CONSOLE_EARLY_SIZE,
		ram_console_old_log_init_buffer);
}
static ssize_t class_set_picture(struct device *device, struct device_attribute *attr, const char *buf, size_t count)
{
	return odev_set_picture((struct asus_oled_dev *) dev_get_drvdata(device), buf, count);
}
static ssize_t version_show(struct class *dev, char *buf)
{
	return sprintf(buf, ASUS_OLED_UNDERSCORE_NAME " %s\n", ASUS_OLED_VERSION);
}
static inline int at76_is_intersil(enum board_type board)
{
	return (board == BOARD_503_ISL3861 || board == BOARD_503_ISL3863);
}
static inline int at76_is_503rfmd(enum board_type board)
{
	return (board == BOARD_503 || board == BOARD_503_ACC);
}
static inline int at76_is_505a(enum board_type board)
{
	return (board == BOARD_505A || board == BOARD_505AMX);
}
static int at76_load_int_fw_block(struct usb_device *udev, int blockno,
				  void *block, int size)
{
	return usb_control_msg(udev, usb_sndctrlpipe(udev, 0), DFU_DNLOAD,
			       USB_TYPE_CLASS | USB_DIR_OUT |
			       USB_RECIP_INTERFACE, blockno, 0, block, size,
			       USB_CTRL_GET_TIMEOUT);
}
static inline unsigned long at76_get_timeout(struct dfu_status *s)
{
	return msecs_to_jiffies((s->poll_timeout[2] << 16)
				| (s->poll_timeout[1] << 8)
				| (s->poll_timeout[0]));
}
static inline int at76_load_ext_fw_block(struct usb_device *udev, int blockno,
					 void *block, int size)
{
	return usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0x0e,
			       USB_TYPE_VENDOR | USB_DIR_OUT | USB_RECIP_DEVICE,
			       0x0802, blockno, block, size,
			       USB_CTRL_GET_TIMEOUT);
}

static inline int at76_get_hw_cfg(struct usb_device *udev,
				  union at76_hwcfg *buf, int buf_size)
{
	return usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), 0x33,
			       USB_TYPE_VENDOR | USB_DIR_IN |
			       USB_RECIP_INTERFACE, 0x0a02, 0,
			       buf, buf_size, USB_CTRL_GET_TIMEOUT);
}
static inline int at76_get_hw_cfg_intersil(struct usb_device *udev,
					   union at76_hwcfg *buf, int buf_size)
{
	return usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), 0x33,
			       USB_TYPE_VENDOR | USB_DIR_IN |
			       USB_RECIP_INTERFACE, 0x0902, 0,
			       buf, buf_size, USB_CTRL_GET_TIMEOUT);
}
static inline void next_ie(struct ieee80211_info_element **ie)
{
	*ie = (struct ieee80211_info_element *)(&(*ie)->data[(*ie)->len]);
}
static u32 b3dfg_read32(struct b3dfg_dev *fgdev, u16 reg)
{
	return ioread32(fgdev->regs + reg);
}
static void b3dfg_write32(struct b3dfg_dev *fgdev, u16 reg, u32 value)
{
	iowrite32(value, fgdev->regs + reg);
}
static int be_get_stats_count(struct net_device *netdev)
{
	return BENET_STATS_LEN;
}
static void __exit be_exit_module(void)
{
	pci_unregister_driver(&be_driver);
}
long comedi_compat_ioctl(struct file *file, unsigned int cmd,
		unsigned long arg)
{
	return raw_ioctl(file, cmd, arg);
}
void comedi_error(const comedi_device *dev, const char *s)
{
	rt_printk("comedi%d: %s: %s\n", dev->minor, dev->driver->driver_name,
		  s);
}
int comedi_modprobe(int minor)
{
	return -EINVAL;
}
static int poll_invalid(comedi_device * dev, comedi_subdevice * s)
{
	return -EINVAL;
}
int insn_inval(comedi_device * dev, comedi_subdevice * s,
	comedi_insn * insn, lsampl_t * data)
{
	return -EINVAL;
}
void comedi_pci_auto_unconfig(struct pci_dev *pcidev)
{
	comedi_auto_unconfig(&pcidev->dev);
}
static int subdev_8255_cmd(comedi_device * dev, comedi_subdevice * s)
{
	return 0;
}
static int subdev_8255_cancel(comedi_device * dev, comedi_subdevice * s)
{
	return 0;
}
void fpu_begin(void)
{
	kernel_fpu_begin();
}
void fpu_end(void)
{
	kernel_fpu_end();
}
int i_APCI16XX_Reset(comedi_device * dev)
{
	return 0;
}

static inline unsigned int DAC_RANGE(unsigned int channel, unsigned int range)
{
	return (range & 0x3) << (8 + 2 * (channel & 0x1));
}
static inline unsigned int DAC_RANGE_MASK(unsigned int channel)
{
	return 0x3 << (8 + 2 * (channel & 0x1));
}

static inline unsigned int DAC_CHAN_EN(unsigned int channel)
{
	return 1 << (5 + (channel & 0x1));	// enable channel 0 or 1
}
static inline unsigned int DAC_DATA_REG(unsigned int channel)
{
	return 2 * (channel & 0x1);
}
static inline unsigned int cal_enable_bits(comedi_device * dev)
{
	return CAL_EN_BIT | CAL_SRC_BITS(devpriv->calibration_source);
}
static int dac08_write_insn(comedi_device * dev, comedi_subdevice * s,
	comedi_insn * insn, lsampl_t * data)
{
	return dac08_write(dev, data[0]);
}
static int __init init(void)
{
	return comedi_driver_register(&driver_bonding);
}
static void __exit cleanup(void)
{
	comedi_driver_unregister(&driver_bonding);
}
static int __init comedi_fc_init_module(void)
{
	return 0;
}
static sampl_t fake_flatline(comedi_device *dev, unsigned int range_index,
			     unsigned long current_time)
{
	return dev->read_subdev->maxdata / 2;
}
static void i8254_set_mode_low(unsigned int base, int channel,
	unsigned int mode)
{
	outb((channel << 6) | 0x30 | (mode & 0x0F), base + I8254_CTRL);
}
static inline struct usb_dt9812 *to_dt9812_dev(struct kref *d)
{
	return container_of(d, struct usb_dt9812, kref);
}
static int dt9812_detach(comedi_device *dev)
{
	return 0;
}
static int icp_multi_insn_read_ctr(comedi_device * dev, comedi_subdevice * s,
	comedi_insn * insn, lsampl_t * data)
{
	return 0;
}
static int icp_multi_insn_write_ctr(comedi_device * dev, comedi_subdevice * s,
	comedi_insn * insn, lsampl_t * data)
{
	return 0;
}
static void comedi_fw_release(struct device *dev)
{
	printk(KERN_DEBUG "firmware_sample_driver: ghost_release\n");
}
static int is_complete(volatile jr3_channel_t * channel)
{
	return get_s16(&channel->command_word0) == 0;
}
static void use_transform(volatile jr3_channel_t * channel, short transf_num)
{
	set_s16(&channel->command_word0, 0x0500 + (transf_num & 0x000f));
}
static void use_offset(volatile jr3_channel_t * channel, short offset_num)
{
	set_s16(&channel->command_word0, 0x0600 + (offset_num & 0x000f));
}
static void set_offset(volatile jr3_channel_t * channel)
{
	set_s16(&channel->command_word0, 0x0700);
}
static int me_ai_do_cmd_test(comedi_device *dev, comedi_subdevice *s,
			     comedi_cmd *cmd)
{
	return 0;
}
static int me_ai_do_cmd(comedi_device *dev, comedi_subdevice *subdevice)
{
	return 0;
}
int mite_setup(struct mite_struct *mite)
{
	return mite_setup2(mite, 0);
}
void __exit cleanup_module(void)
{
	mite_cleanup();
}
static inline unsigned int labpc_inb(unsigned long address)
{
	return inb(address);
}
static inline void labpc_outb(unsigned int byte, unsigned long address)
{
	outb(byte, address);
}
static inline unsigned int labpc_readb(unsigned long address)
{
	return readb((void *)address);
}
static inline void labpc_writeb(unsigned int byte, unsigned long address)
{
	writeb(byte, (void *)address);
}
static inline int labpc_counter_load(comedi_device * dev,
	unsigned long base_address, unsigned int counter_number,
	unsigned int count, unsigned int mode)
{
	if (thisboard->memory_mapped_io)
		return i8254_mm_load((void *)base_address, 0, counter_number,
			count, mode);
	else
		return i8254_load(base_address, 0, counter_number, count, mode);
}
static void cs_release(struct pcmcia_device *link)
{
	pcmcia_disable_device(link);
}
static inline unsigned Gi_Source_Select_Bits(unsigned source)
{
	return (source << Gi_Source_Select_Shift) & Gi_Source_Select_Mask;
}
static inline unsigned Gi_Gate_Select_Bits(unsigned gate_select)
{
	return (gate_select << Gi_Gate_Select_Shift) & Gi_Gate_Select_Mask;
}
static int __init ni_tio_init_module(void)
{
	return 0;
}
static void ni_tio_reset_count_and_disarm(struct ni_gpct *counter)
{
	write_register(counter, Gi_Reset_Bit(counter->counter_index),
		NITIO_Gxx_Joint_Reset_Reg(counter->counter_index));
}
static int __init ni_tiocmd_init_module(void)
{
	return 0;
}
static int s626_ai_insn_config(comedi_device * dev, comedi_subdevice * s,
	comedi_insn * insn, lsampl_t * data)
{
	return -EINVAL;
}
static void ResetCapFlags_A(comedi_device * dev, enc_private * k)
{
	DEBIreplace(dev, k->MyCRB, (uint16_t) (~CRBMSK_INTCTRL),
		CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
}
static void ResetCapFlags_B(comedi_device * dev, enc_private * k)
{
	DEBIreplace(dev, k->MyCRB, (uint16_t) (~CRBMSK_INTCTRL),
		CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B);
}
static void SetEnable_B(comedi_device * dev, enc_private * k, uint16_t enab)
{
	DEBIreplace(dev, k->MyCRB,
		(uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_B)),
		(uint16_t) (enab << CRBBIT_CLKENAB_B));
}
static uint16_t GetEnable_A(comedi_device * dev, enc_private * k)
{
	return (DEBIread(dev, k->MyCRB) >> CRBBIT_CLKENAB_A) & 1;
}
static uint16_t GetEnable_B(comedi_device * dev, enc_private * k)
{
	return (DEBIread(dev, k->MyCRB) >> CRBBIT_CLKENAB_B) & 1;
}
static void SetLoadTrig_A(comedi_device * dev, enc_private * k, uint16_t Trig)
{
	DEBIreplace(dev, k->MyCRA, (uint16_t) (~CRAMSK_LOADSRC_A),
		(uint16_t) (Trig << CRABIT_LOADSRC_A));
}
static void SetLoadTrig_B(comedi_device * dev, enc_private * k, uint16_t Trig)
{
	DEBIreplace(dev, k->MyCRB,
		(uint16_t) (~(CRBMSK_LOADSRC_B | CRBMSK_INTCTRL)),
		(uint16_t) (Trig << CRBBIT_LOADSRC_B));
}
static uint16_t GetLoadTrig_A(comedi_device * dev, enc_private * k)
{
	return (DEBIread(dev, k->MyCRA) >> CRABIT_LOADSRC_A) & 3;
}
static uint16_t GetLoadTrig_B(comedi_device * dev, enc_private * k)
{
	return (DEBIread(dev, k->MyCRB) >> CRBBIT_LOADSRC_B) & 3;
}
static uint16_t GetIntSrc_A(comedi_device * dev, enc_private * k)
{
	return (DEBIread(dev, k->MyCRA) >> CRABIT_INTSRC_A) & 3;
}
static uint16_t GetIntSrc_B(comedi_device * dev, enc_private * k)
{
	return (DEBIread(dev, k->MyCRB) >> CRBBIT_INTSRC_B) & 3;
}
static int skel_ns_to_timer(unsigned int *ns, int round)
{
	return *ns;
}
static int usbdux_counter_config(comedi_device *dev, comedi_subdevice *s,
				 comedi_insn *insn, lsampl_t *data)
{
	return 2;
}
static int usbdux_pwm_read(comedi_device *x1, comedi_subdevice *x2,
			   comedi_insn *x3, lsampl_t *x4)
{
	/* not needed */
	return -EINVAL;
}
int comedi_get_version_code(comedi_t * d)
{
	return COMEDI_VERSION_CODE;
}
int comedi_loglevel(int newlevel)
{
	return 0;
}
void comedi_perror(const char *message)
{
	rt_printk("%s: unknown error\n", message);
}
char *comedi_strerror(int err)
{
	return "unknown error";
}
void comedi_proc_cleanup(void)
{
	remove_proc_entry("comedi", 0);
}
void wake_up_int_handler(int arg1, void *arg2)
{
	wake_up_interruptible((wait_queue_head_t *) arg2);
}
void comedi_rt_pend_wakeup(wait_queue_head_t * q)
{
	rt_pend_call(wake_up_int_handler, 0, q);
}
static void handle_void_irq_ ## irq (void){ handle_void_irq(irq);}
void comedi_rt_init(void)
{
	rt_pend_tq_init();
}
void comedi_rt_cleanup(void)
{
	rt_pend_tq_cleanup();
}
void comedi_rt_init(void)
{
	rt_pend_tq_init();
}
void comedi_rt_cleanup(void)
{
	rt_pend_tq_cleanup();
}
static inline u64 dst_gen_iv(struct dst_trans *t)
{
	return t->gen;
}
static int dst_hash_iterator(struct dst_crypto_engine *e,
		struct scatterlist *sg_dst, struct scatterlist *sg_src)
{
	return crypto_hash_update(e->data, sg_src, sg_src->length);
}
static int dst_dev_match(struct device *dev, struct device_driver *drv)
{
	return 1;
}
static inline unsigned int dst_hash(char *str, unsigned int size)
{
	return (jhash(str, size, 0) % dst_hashtable_size);
}
static inline void dst_thread_network_cleanup(void *data)
{
	dprintk("%s: data: %p.\n", __func__, data);
}
static int __init dst_sysfs_init(void)
{
	return bus_register(&dst_dev_bus_type);
}
static void dst_sysfs_exit(void)
{
	bus_unregister(&dst_dev_bus_type);
}
void dst_export_exit(void)
{
	bioset_free(dst_bio_set);
}
int dst_state_schedule_receiver(struct dst_state *st)
{
	return thread_pool_schedule_private(st->node->pool, dst_thread_setup,
			dst_recv, st, MAX_SCHEDULE_TIMEOUT, st->node);
}
int thread_pool_schedule(struct thread_pool *p,
		int (* setup)(void *private, void *data),
		int (* action)(void *private, void *data),
		void *data, long timeout)
{
	return thread_pool_schedule_private(p, setup,
			action, data, timeout, NULL);
}
void oslec_adaption_mode(struct oslec_state *ec, int adaption_mode)
{
	ec->adaption_mode = adaption_mode;
}
void oslec_snapshot(struct oslec_state *ec)
{
	memcpy(ec->snapshot, ec->fir_taps16[0], ec->taps * sizeof(int16_t));
}
tEplKernel EplPdokAddInstance(void)
{
	return kEplSuccessful;
}
tEplKernel EplPdokDelInstance(void)
{
	return kEplSuccessful;
}
tEplKernel EplPdokCalDelInstance(void)
{
	return kEplSuccessful;
}
tEplKernel EplPdouAddInstance(void)
{
	return kEplSuccessful;
}
tEplKernel EplPdouDelInstance(void)
{
	return kEplSuccessful;
}
tShbError ShbIpcExit(void)
{
	return (kShbOk);
}
tShbError ShbIpcInit(void)
{
	return (kShbOk);
}
tShbError ShbIpcExit(void)
{
	return (kShbOk);
}
void ET1310_PhyReset(struct et131x_adapter *pAdapter)
{
	MiWrite(pAdapter, PHY_CONTROL, 0x8000);
}
static void __exit usb_alphatrack_exit(void)
{
	usb_deregister(&usb_alphatrack_driver);
}
static void __exit usb_tranzport_exit(void)
{
	usb_deregister(&usb_tranzport_driver);
}
static u32 go7007_functionality(struct i2c_adapter *adapter)
{
	return I2C_FUNC_SMBUS_BYTE_DATA;
}
static u32 go7007_usb_functionality(struct i2c_adapter *adapter)
{
	return (I2C_FUNC_SMBUS_EMUL) & ~I2C_FUNC_SMBUS_QUICK;
}
static int __init go7007_usb_init(void)
{
	return usb_register(&go7007_usb_driver);
}
static void __exit go7007_usb_cleanup(void)
{
	usb_deregister(&go7007_usb_driver);
}
static ssize_t go7007_read(struct file *file, char __user *data,
		size_t count, loff_t *ppos)
{
	return -EINVAL;
}
static int __init saa7134_go7007_mod_init(void)
{
	return saa7134_ts_register(&saa7134_go7007_ops);
}
static void __exit saa7134_go7007_mod_cleanup(void)
{
	saa7134_ts_unregister(&saa7134_go7007_ops);
}
static int go7007_snd_pcm_prepare(struct snd_pcm_substream *substream)
{
	return 0;
}
static struct page *go7007_snd_pcm_page(struct snd_pcm_substream *substream,
					unsigned long offset)
{
	return vmalloc_to_page(substream->runtime->dma_area + offset);
}
static int write_reg(struct i2c_client *client, u8 reg, u8 value)
{
	return i2c_smbus_write_byte_data(client, reg, value);
}
static int write_reg(struct i2c_client *client, u8 reg, u8 value)
{
	return i2c_smbus_write_byte_data(client, reg, value);
}
static int write_reg(struct i2c_client *client, u8 reg, u8 value, int channel)
{
	return i2c_smbus_write_byte_data(client, reg | (channel << 6), value);
}
static int write_reg(struct i2c_client *client, u8 reg, u8 value)
{
	return i2c_smbus_write_byte_data(client, reg, value);
}
static inline int me4000_buf_count(struct me4000_circ_buf buf, int size)
{
	return (buf.head - buf.tail) & (size - 1);
}
static inline int me4000_buf_space(struct me4000_circ_buf buf, int size)
{
	return (buf.tail - (buf.head + 1)) & (size - 1);
}
static int me4000_ao_synchronous_disable(struct me4000_ao_context *ao_context)
{
	return me4000_ao_simultaneous_disable(ao_context);
}
static void __exit me0600_exit(void)
{
	PDEBUG("executed.\n");
}
static void __exit me0900_exit(void)
{
	PDEBUG("executed.\n.");
}
static void __exit me1000_exit(void)
{
	PDEBUG("executed.\n");
}
static void __exit me1400_exit(void)
{
	PDEBUG("executed.\n");
}
static void __exit me8100_exit(void)
{
	PDEBUG("executed.\n.");
}
static void __exit me8200_exit(void)
{
	PDEBUG("executed.\n.");
}
static uint32_t me4600_get_val_reg(uint32_t reg_base, unsigned int me8254_idx,
				   unsigned int ctr_idx)
{
	return (reg_base + ME4600_8254_0_VAL_REG + ctr_idx);
}
static uint32_t me4600_get_ctrl_reg(uint32_t reg_base, unsigned int me8254_idx,
				    unsigned int ctr_idx)
{
	return (reg_base + ME4600_8254_CTRL_REG);
}
static uint32_t me8100_get_val_reg(uint32_t reg_base, unsigned int me8254_idx,
				   unsigned int ctr_idx)
{
	return (reg_base + ME8100_COUNTER_REG_0 + ctr_idx * 2);
}
static uint32_t me8100_get_ctrl_reg(uint32_t reg_base, unsigned int me8254_idx,
				    unsigned int ctr_idx)
{
	return (reg_base + ME8100_COUNTER_CTRL_REG);
}
void me_dlock_deinit(struct me_dlock *dlock)
{
	PDEBUG_LOCKS("executed.\n");
}
static void __exit dummy_exit(void)
{
	PDEBUG("executed.\n");
}
void me_slock_deinit(struct me_slock *slock)
{
	PDEBUG_LOCKS("executed.\n");
}
static void __exit metempl_exit(void)
{
	PDEBUG("executed.\n.");
}
static void __exit mimio_exit(void)
{
	usb_deregister(&mimio_driver);
}
u16_t   zfAggRecvDelba(zdev_t* dev, zbuf_t* buf)
{
    return ZM_SUCCESS;
}
u16_t zfiWlanGetStatistics(zdev_t* dev)
{
    return 0;
}
void zfiWlanQueryMonHalRxInfo(zdev_t* dev, struct zsMonHalRxInfo *monHalRxInfo)
{
    zfHpQueryMonHalRxInfo(dev, (u8_t *)monHalRxInfo);
}
void zfMemoryCopy(u8_t* dst, u8_t* src, u16_t length)
{
    zfwMemoryCopy(dst, src, length);
}
void zfMemoryMove(u8_t* dst, u8_t* src, u16_t length)
{
    zfwMemoryMove(dst, src, length);
}
void zfZeroMemory(u8_t* va, u16_t length)
{
    zfwZeroMemory(va, length);
}
u8_t zfMemoryIsEqual(u8_t* m1, u8_t* m2, u16_t length)
{
    return zfwMemoryIsEqual(m1, m2, length);
}
u16_t zfGetRandomNumber(zdev_t* dev, u16_t initValue)
{
    return 0;
}
u8_t zfPSDeviceSleep(zdev_t* dev)
{
    return 0;
}
void zfStaProcessAsocReq(zdev_t* dev, zbuf_t* buf, u16_t* src, u16_t apId)
{
    return;
}
void zfStaProcessProbeRsp(zdev_t* dev, zbuf_t* buf, struct zsAdditionInfo* AddInfo)
{
    zfProcessProbeRsp(dev, buf, AddInfo);
}
void zfiWlanSetPowerSaveMode(zdev_t* dev, u8_t mode)
{
    zfPowerSavingMgrSetMode(dev, mode);
}
u16_t zfiStaAddIeWpaRsn(zdev_t* dev, zbuf_t* buf, u16_t offset, u8_t frameType)
{
    return  zfStaAddIeWpaRsn(dev, buf, offset, frameType);
}
const char* zfiHpGetisoNamefromregionCode(zdev_t* dev, u16_t regionCode)
{
    return zfHpGetisoNamefromregionCode(dev, regionCode);
}
u16_t zfiWlanChannelToFrequency(zdev_t* dev, u8_t channel)
{
    return zfChNumToFreq(dev, channel, 0);
}
u32_t zfiWlanQueryHwCapability(zdev_t* dev)
{
    return zfHpCapability(dev);
}
u16_t zfSwap(u16_t num)
{
    return ((num >> 8) + ((num & 0xff) << 8));
}
void zfCoreSetFrequencyV2(zdev_t* dev, u16_t frequency, zfpFreqChangeCompleteCb cb)
{
    zfCoreSetFrequencyEx(dev, frequency, 0, 0, cb);
}
void zfCoreSetFrequencyEx(zdev_t* dev, u16_t frequency, u8_t bw40,
        u8_t extOffset, zfpFreqChangeCompleteCb cb)
{
    zfCoreSetFrequencyExV2(dev, frequency, bw40, extOffset, cb, 0);
}
void zfCoreSetFrequency(zdev_t* dev, u16_t frequency)
{
    zfCoreSetFrequencyV2(dev, frequency, NULL);
}
void zfiRxPerformanceFree(zdev_t* dev, zbuf_t* buf)
{
    zm_summary.rx_free++;
}
void zfiRxPerformanceFlush(zdev_t* dev)
{
    zm_summary.rx_flush++;
}
void zfiRxPerformanceReorder(zdev_t* dev)
{
    zm_summary.rx_reorder++;
}
u32_t zfRateCtrlUDPTP(zdev_t* dev, u16_t Rate, u32_t PER) {
    if ((PER < 100) && (Rate > 0) && PER)
        return 1168000/(((12304/Rate)+197)*(100+100*PER/(100-PER)));
    else
        return 0;
}
char hex(char v)
{
    if(isdigit(v))
        return v - '0';
    else if(isxdigit(v))
        return (tolower(v) - 'a' + 10);
    else
        return 0;
}
u16_t zfHpStopRecv(zdev_t* dev)
{
    return 0;
}
u32_t zfHpGetFreeTxdCount(zdev_t* dev)
{
    return zfwUsbGetFreeTxQSize(dev);
}
u32_t zfHpGetMaxTxdCount(zdev_t* dev)
{
    return zfwUsbGetMaxTxQSize(dev);
}
void zfiUsbRegOutComplete(zdev_t* dev)
{
    return;
}
int usbdrv_ioctl_setrts(struct net_device *dev, struct iw_param *rrq)
{
    return 0;
}
int usbdrvwext_siwsens(struct net_device *dev,
			struct iw_request_info *info,
			struct iw_param *sens, char *extra)
{
	return 0;
}
int usbdrvwext_iwaplist(struct net_device *dev,
			struct iw_request_info *info,
			struct iw_point *data, char *extra)
{
    return 0;
}
int usbdrvwext_siwnickn(struct net_device *dev,
			struct iw_request_info *info,
			struct iw_point *data, char *nickname)
{
	return 0;
}
int usbdrvwext_siwtxpow(struct net_device *dev,
			struct iw_request_info *info,
			struct iw_param *rrq, char *extra)
{
	return 0;
}
int usbdrvwext_giwtxpow(struct net_device *dev,
			struct iw_request_info *info,
			struct iw_param *rrq, char *extra)
{
	return 0;
}
int usbdrvwext_siwretry(struct net_device *dev,
			struct iw_request_info *info,
			struct iw_param *rrq, char *extra)
{
	return 0;
}
int usbdrvwext_giwretry(struct net_device *dev,
			struct iw_request_info *info,
			struct iw_param *rrq, char *extra)
{
	return 0;
}
int usbdrvwext_setmode(struct net_device *dev, struct iw_request_info *info,
		   	 void *w, char *extra)
{
	return 0;
}
void zfwBufFree(zdev_t* dev, zbuf_t* buf, u16_t status)
{
    dev_kfree_skb_any(buf);
}
u16_t zfwBufGetSize(zdev_t* dev, zbuf_t* buf)
{
    return buf->len;
}
void zfwDbgReadRegDone(zdev_t* dev, u32_t addr, u32_t val)
{
    printk("Read addr:%x = %x\n", addr, val);
}
void zfwDbgWriteRegDone(zdev_t* dev, u32_t addr, u32_t val)
{
    printk("Write addr:%x = %x\n", addr, val);
}
void zfwDbgReadFlashDone(zdev_t* dev, u32_t addr, u32_t* rspdata, u32_t datalen)
{
    printk("Read Flash addr:%x length:%x\n", addr, datalen);
}
void zfwDbgProgrameFlashDone(zdev_t* dev)
{
    printk("Program Flash Done\n");
}
void zfwDbgProgrameFlashChkDone(zdev_t* dev)
{
    printk("Program Flash Done\n");
}
void zfwDbgGetFlashChkSumDone(zdev_t* dev, u32_t* rspdata)
{
    printk("Get Flash ChkSum Done\n");
}
void zfwDbgDownloadFwInitDone(zdev_t* dev)
{
    printk("Download FW Init Done\n");
}
u16_t zfLnxAuthNotify(zdev_t* dev, u16_t* macAddr)
{
    return 0;
}
void zfLnxScanNotify(zdev_t* dev, struct zsScanResult* result)
{
    return;
}
void zfLnxStatisticsNotify(zdev_t* dev, struct zsStastics* result)
{
    return;
}
u16_t zfwGetVapId(zdev_t* dev)
{
    return zfLnxGetVapId(dev);
}
asmlinkage u8_t zfwBufReadByte(zdev_t* dev, zbuf_t* buf, u16_t offset)
{
    return *(u8_t*)((u8_t*)buf->data+offset);
}
asmlinkage u16_t zfwBufReadHalfWord(zdev_t* dev, zbuf_t* buf, u16_t offset)
{
    return zmw_cpu_to_le16(*(u16_t*)((u8_t*)buf->data+offset));
}
asmlinkage void zfwBufWriteByte(zdev_t* dev, zbuf_t* buf, u16_t offset, u8_t value)
{
    *(u8_t*)((u8_t*)buf->data+offset) = value;
}
asmlinkage void zfwBufWriteHalfWord(zdev_t* dev, zbuf_t* buf, u16_t offset, u16_t value)
{
    *(u16_t*)((u8_t*)buf->data+offset) = zmw_cpu_to_le16(value);
}
asmlinkage u8_t *zfwGetBuffer(zdev_t* dev, zbuf_t* buf)
{
    return (u8_t*)(buf->data);
}
u8_t zfwCencHandleBeaconProbrespon(zdev_t* dev, u8_t *pWIEc,
        u8_t *pPeerSSIDc, u8_t *pPeerAddrc)
{
    return 0;
}
u8_t zfwGetPktEncExemptionActionType(zdev_t* dev, zbuf_t* buf)
{
    return ZM_ENCRYPTION_EXEMPT_NO_EXEMPTION;
}
u32_t zfwUsbGetMaxTxQSize(zdev_t* dev)
{
    return ZM_MAX_TX_BUF_NUM;
}
int zfwUsbEnableRxEpt(zdev_t* dev, u8_t endpt)
{
    return 0;
}
u32_t zfwReadReg(zdev_t* dev, u32_t offset)
{
    return 0;
}
void zfLnxWatchDogNotify(zdev_t* dev)
{
    zfLnxSignalThread(dev, KEVENT_WATCHDOG);
}
void zfwGetActiveScanDur(zdev_t* dev, u8_t* Dur)
{
    *Dur = 30; // default 30 ms
}
void zfwGetShowZeroLengthSSID(zdev_t* dev, u8_t* Dur)
{
    *Dur = 0;
}
void __exit zfLnxExit(void)
{
    usb_deregister(&zd1221_driver);
}
static void lcd_gotoxy(void)
{
	lcd_write_cmd(0x80	/* set DDRAM address */
		      | (lcd_addr_y ? lcd_hwidth : 0)
		      | ((lcd_addr_x < lcd_bwidth) ? lcd_addr_x &
			 (lcd_hwidth - 1) : lcd_bwidth - 1));
}
static int __init panel_init_module(void)
{
	return panel_init();
}
static int phison_ide_init(void)
{
	return pci_register_driver(&phison_pci_driver);
}
static void phison_ide_exit(void)
{
	pci_unregister_driver(&phison_pci_driver);
}
static unsigned long npages(unsigned long bytes)
{
	if (bytes % PAGE_SIZE == 0)
		return bytes / PAGE_SIZE;
	else
		return (bytes / PAGE_SIZE) + 1;
}
int __init pohmelfs_config_init(void)
{
	return cn_add_callback(&pohmelfs_cn_id, "pohmelfs", pohmelfs_cn_callback);
}
static int pohmelfs_hash_iterator(struct pohmelfs_crypto_engine *e,
		struct scatterlist *sg_dst, struct scatterlist *sg_src)
{
	return crypto_hash_update(e->data, sg_src, sg_src->length);
}
static void __pohmelfs_name_del(struct pohmelfs_inode *parent, struct pohmelfs_name *node)
{
	rb_erase(&node->hash_node, &parent->hash_root);
}
static void pohmelfs_fix_offset(struct pohmelfs_inode *parent, struct pohmelfs_name *node)
{
	parent->total_len -= node->len;
}
static int pohmelfs_create(struct inode *dir, struct dentry *dentry, int mode,
		struct nameidata *nd)
{
	return pohmelfs_create_entry(dir, dentry, 0, mode);
}
static int pohmelfs_unlink(struct inode *dir, struct dentry *dentry)
{
	return pohmelfs_remove_entry(dir, dentry);
}
int pohmelfs_remove_child(struct pohmelfs_inode *pi, struct pohmelfs_name *n)
{
	return pohmelfs_meta_command_data(pi, pi->ino, NETFS_REMOVE, NULL, 0, NULL, NULL, 0);
}
int pohmelfs_meta_command(struct pohmelfs_inode *pi, unsigned int cmd_op, unsigned int flags,
		netfs_trans_complete_t complete, void *priv, u64 start)
{
	return pohmelfs_meta_command_data(pi, pi->ino, cmd_op, NULL, flags, complete, priv, start);
}
static int pohmelfs_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_nodev(fs_type, flags, data, pohmelfs_fill_super,
				mnt);
}
static void pohmelfs_destroy_inodecache(void)
{
	kmem_cache_destroy(pohmelfs_inode_cache);
}
void pohmelfs_ftrans_exit(void)
{
	vfree(pohmelfs_ftrans);
}
static void __exit piusb_exit(void)
{
	usb_deregister(&piusb_driver);
}
static INT __init rt2860_init_module(VOID)
{
	return pci_register_driver(&rt2860_driver);
}
static VOID __exit rt2860_cleanup_module(VOID)
{
    pci_unregister_driver(&rt2860_driver);
}
static inline struct reordering_mpdu  *ba_reordering_mpdu_dequeue(struct reordering_list *list)
{
	return(ba_dequeue(list));
}
CHAR *GetEapolMsgType(CHAR msg)
{
    if(msg == EAPOL_PAIR_MSG_1)
        return "Pairwise Message 1";
    else if(msg == EAPOL_PAIR_MSG_2)
        return "Pairwise Message 2";
	else if(msg == EAPOL_PAIR_MSG_3)
        return "Pairwise Message 3";
	else if(msg == EAPOL_PAIR_MSG_4)
        return "Pairwise Message 4";
	else if(msg == EAPOL_GROUP_MSG_1)
        return "Group Message 1";
	else if(msg == EAPOL_GROUP_MSG_2)
        return "Group Message 2";
    else
    	return "Invalid Message";
}
void RTMP_GetCurrentSystemTime(LARGE_INTEGER *time)
{
	time->u.LowPart = jiffies;
}
BOOLEAN OS_Need_Clone_Packet(void)
{
	return (FALSE);
}

void CfgInitHook(PRTMP_ADAPTER pAd)
{
	pAd->bBroadComHT = TRUE;
} /* End of CfgInitHook */
int rt_ioctl_giwsens(struct net_device *dev,
		   struct iw_request_info *info,
		   char *name, char *extra)
{
	return 0;
}
static inline struct reordering_mpdu  *ba_reordering_mpdu_dequeue(struct reordering_list *list)
{
	return(ba_dequeue(list));
}
CHAR *GetEapolMsgType(CHAR msg)
{
    if(msg == EAPOL_PAIR_MSG_1)
        return "Pairwise Message 1";
    else if(msg == EAPOL_PAIR_MSG_2)
        return "Pairwise Message 2";
	else if(msg == EAPOL_PAIR_MSG_3)
        return "Pairwise Message 3";
	else if(msg == EAPOL_PAIR_MSG_4)
        return "Pairwise Message 4";
	else if(msg == EAPOL_GROUP_MSG_1)
        return "Group Message 1";
	else if(msg == EAPOL_GROUP_MSG_2)
        return "Group Message 2";
    else
    	return "Invalid Message";
}
void RTUSB_FILL_BULK_URB (struct urb *pUrb,
	struct usb_device *pUsb_Dev,
	unsigned int bulkpipe,
	void *pTransferBuf,
	int BufSize,
	usb_complete_t Complete,
	void *pContext)
{
	usb_fill_bulk_urb(pUrb, pUsb_Dev, bulkpipe, pTransferBuf, BufSize, (usb_complete_t)Complete, pContext);
}
void RTMP_GetCurrentSystemTime(LARGE_INTEGER *time)
{
	time->u.LowPart = jiffies;
}
BOOLEAN OS_Need_Clone_Packet(void)
{
	return (FALSE);
}

void CfgInitHook(PRTMP_ADAPTER pAd)
{
	pAd->bBroadComHT = TRUE;
} /* End of CfgInitHook */
int rt_ioctl_giwsens(struct net_device *dev,
		   struct iw_request_info *info,
		   char *name, char *extra)
{
	return 0;
}
static void * ieee80211_crypt_null_init(int keyidx) { return (void *) 1; }
void ieee80211_ccmp_null(void)
{
	return;
}
int ieee80211_crypto_ccmp_init(void)
{
	return ieee80211_register_crypto_ops(&ieee80211_crypt_ccmp);
}
void ieee80211_crypto_ccmp_exit(void)
{
	ieee80211_unregister_crypto_ops(&ieee80211_crypt_ccmp);
}
static inline u16 RotR1(u16 val)
{
	return (val >> 1) | (val << 15);
}
static inline u8 Lo8(u16 val)
{
	return val & 0xff;
}
static inline u8 Hi8(u16 val)
{
	return val >> 8;
}
static inline u16 Lo16(u32 val)
{
	return val & 0xffff;
}
static inline u16 Hi16(u32 val)
{
	return val >> 16;
}
static inline u16 Mk16(u8 hi, u8 lo)
{
	return lo | (((u16) hi) << 8);
}
static inline u16 Mk16_le(u16 *v)
{
	return le16_to_cpu(*v);
}
int ieee80211_crypto_tkip_init(void)
{
	return ieee80211_register_crypto_ops(&ieee80211_crypt_tkip);
}
void ieee80211_crypto_tkip_exit(void)
{
	ieee80211_unregister_crypto_ops(&ieee80211_crypt_tkip);
}
void ieee80211_tkip_null(void)
{
        return;
}
int ieee80211_crypto_wep_init(void)
{
	return ieee80211_register_crypto_ops(&ieee80211_crypt_wep);
}
void ieee80211_crypto_wep_exit(void)
{
	ieee80211_unregister_crypto_ops(&ieee80211_crypt_wep);
}
void ieee80211_wep_null(void)
{
        return;
}
static inline int is_same_network(struct ieee80211_network *src,
				  struct ieee80211_network *dst,
				  struct ieee80211_device * ieee)
{

	return (((src->ssid_len == dst->ssid_len) || (ieee->iw_mode == IW_MODE_INFRA)) &&  //YJ,mod,080819,for hidden ap
		//((src->ssid_len == dst->ssid_len) &&
		(src->channel == dst->channel) &&
		!memcmp(src->bssid, dst->bssid, ETH_ALEN) &&
		(!memcmp(src->ssid, dst->ssid, src->ssid_len) || (ieee->iw_mode == IW_MODE_INFRA)) && //YJ,mod,080819,for hidden ap
		((src->capability & WLAN_CAPABILITY_IBSS) ==
		(dst->capability & WLAN_CAPABILITY_IBSS)) &&
		((src->capability & WLAN_CAPABILITY_BSS) ==
		(dst->capability & WLAN_CAPABILITY_BSS)));
}
short ieee80211_is_54g(struct ieee80211_network net)
{
	return ((net.rates_ex_len > 0) || (net.rates_len > 4));
}
short ieee80211_is_shortslot(struct ieee80211_network net)
{
	return (net.capability & WLAN_CAPABILITY_SHORT_SLOT);
}
void init_mgmt_queue(struct ieee80211_device *ieee)
{
	ieee->mgmt_queue_tail = ieee->mgmt_queue_head = 0;
}
void ieee80211_associate_abort_cb(unsigned long dev)
{
	ieee80211_associate_abort((struct ieee80211_device *) dev);
}
void ieee80211_ext_issue_disassoc(struct ieee80211_device *ieee, struct ieee80211_network *pstat, int reason, unsigned char extReason)
{
	return;
}
void ieee80211_ext_send_11s_beacon(struct ieee80211_device *ieee)
{
		queue_work(ieee->wq, &ieee->ext_send_beacon_wq);
}
inline void ieee80211_start_ibss(struct ieee80211_device *ieee)
{
	queue_delayed_work(ieee->wq, &ieee->start_ibss_wq, 100);
}
u8 read_nic_byte(struct net_device *dev, int x)
{
        return 0xff&inb(dev->base_addr +x);
}
u32 read_nic_dword(struct net_device *dev, int x)
{
        return inl(dev->base_addr +x);
}
u16 read_nic_word(struct net_device *dev, int x)
{
        return inw(dev->base_addr +x);
}
void write_nic_byte(struct net_device *dev, int x,u8 y)
{
        outb(y&0xff,dev->base_addr +x);
}
void write_nic_word(struct net_device *dev, int x,u16 y)
{
        outw(y,dev->base_addr +x);
}
void write_nic_dword(struct net_device *dev, int x,u32 y)
{
        outl(y,dev->base_addr +x);
}
u8 read_nic_byte(struct net_device *dev, int x)
{
        return 0xff&readb((u8*)dev->mem_start +x);
}
u32 read_nic_dword(struct net_device *dev, int x)
{
        return readl((u8*)dev->mem_start +x);
}
u16 read_nic_word(struct net_device *dev, int x)
{
        return readw((u8*)dev->mem_start +x);
}
void rtl8180_proc_module_remove(void)
{
        remove_proc_entry(RTL8180_MODULE_NAME, init_net.proc_net);
}
inline u8 rtl8180_IsWirelessBMode(u16 rate)
{
	if( ((rate <= 110) && (rate != 60) && (rate != 90)) || (rate == 220) )
		return 1;
	else return 0;
}
static void rtl8180_statistics_init(struct Stats *pstats)
{
	memset(pstats, 0, sizeof(struct Stats));
}
void rtl8185_rf_pins_enable(struct net_device *dev)
{
//	tmp = read_nic_word(dev, RFPinsEnable);
	write_nic_word(dev, RFPinsEnable, 0x1fff);// | tmp);
}
void rtl8180_irq_rx_tasklet(struct r8180_priv* priv)
{
	rtl8180_rx(priv->dev);
}
static u8 read_acadapter_file(char *filename)
{
	return 0;
}
void rtl8180_tx_pw_wq(struct net_device *dev)
{
	DoTxHighPower(dev);	
	
//	printk("<---- UpdateTxPowerWorkItemCallback()\n");
}
void rtl8180_rate_adapter(struct net_device *dev)
{
//    DMESG("---->rtl8180_rate_adapter");
        StaRateAdaptive87SE(dev);
//   DMESG("<----rtl8180_rate_adapter");
}
void rtl8225z4_rf_sleep(struct net_device *dev)
{
	MgntActSet_RF_State(dev, eRfSleep, RF_CHANGE_BY_PS);
}
void rtl8225z4_rf_wakeup(struct net_device *dev)
{
	MgntActSet_RF_State(dev, eRfOn, RF_CHANGE_BY_PS);
}
void sa2400_rf_close(struct net_device *dev)
{
	write_sa2400(dev, 4, 0);
}
static int dummy(struct net_device *dev, struct iw_request_info *a,
		 union iwreq_data *wrqu,char *b)
{
	return -1;
}
static inline int is_same_network(struct ieee80211_network *src,
                                  struct ieee80211_network *dst,
				  struct ieee80211_device *ieee)
{

        return (((src->ssid_len == dst->ssid_len)||(ieee->iw_mode == IW_MODE_INFRA)) &&  //YJ,mod, 080819,for hidden ap
			//((src->ssid_len == dst->ssid_len) &&
			(src->channel == dst->channel) &&
			!memcmp(src->bssid, dst->bssid, ETH_ALEN) &&
			(!memcmp(src->ssid, dst->ssid, src->ssid_len)||(ieee->iw_mode == IW_MODE_INFRA)) &&  //YJ,mod, 080819,for hidden ap
			((src->capability & WLAN_CAPABILITY_IBSS) ==
			(dst->capability & WLAN_CAPABILITY_IBSS)) &&
			((src->capability & WLAN_CAPABILITY_BSS) ==
			(dst->capability & WLAN_CAPABILITY_BSS)));
}
static void slic_if_stop_queue(struct adapter *adapter)
{
	netif_stop_queue(adapter->netdev);
}
static void slic_if_start_queue(struct adapter *adapter)
{
	netif_start_queue(adapter->netdev);
}
static int slic_debug_adapter_open(struct inode *inode, struct file *file)
{
	return single_open(file, slic_debug_adapter_show, inode->i_private);
}
static int slic_debug_card_open(struct inode *inode, struct file *file)
{
	return single_open(file, slic_debug_card_show, inode->i_private);
}
static int __init staging_init(void)
{
	return 0;
}
static void stlc45xx_write16(struct stlc45xx *stlc, unsigned long addr, u16 val)
{
	stlc45xx_spi_write(stlc, addr, &val, sizeof(val));
}
static void stlc45xx_write32(struct stlc45xx *stlc, unsigned long addr, u32 val)
{
	stlc45xx_spi_write(stlc, addr, &val, sizeof(val));
}
static void stlc45xx_op_remove_interface(struct ieee80211_hw *hw,
					 struct ieee80211_if_init_conf *conf)
{
	stlc45xx_debug(DEBUG_FUNC, "%s", __func__);
}
static void stlc45xx_op_configure_filter(struct ieee80211_hw *hw,
				      unsigned int changed_flags,
				      unsigned int *total_flags,
				      int mc_count,
				      struct dev_addr_list *mc_list)
{
	*total_flags = 0;
}
static void __exit sxg_module_cleanup(void)
{
	pci_unregister_driver(&sxg_driver);
}
static int sxg_nic_set_settings(struct net_device *netdev,
                              struct ethtool_cmd *ecmd)
{
	return -EOPNOTSUPP;
}
static int sxg_nic_get_regs_len(struct net_device *dev)
{
	return (SXG_HWREG_MEMSIZE + SXG_UCODEREG_MEMSIZE);
}
static int sxg_nic_get_eeprom_len(struct net_device *netdev)
{
	return (USER_VIEWABLE_EEPROM_SIZE);
}
static int ATEN2011_serial_probe(struct usb_serial *serial,
				 const struct usb_device_id *id)
{
	return 1;
}
static ssize_t show_flag(struct device *dev, struct device_attribute *attr,
								char *buf)
{
	return sprintf(buf, "%lx\n", usbip_debug_flag);
}
static void __exit usbip_common_exit(void)
{
	return;
}
static void the_pdev_release(struct device *dev)
{
	return;
}
void set_tx_power_per_channel_max2829(  struct hw_data * pHwData,  ChanInfo Channel)
{
	RFSynthesizer_SetPowerIndex( pHwData, 100 ); // 20060620.1 Modify
}
void hal_set_current_channel(  struct hw_data * pHwData,  ChanInfo channel )
{
	hal_set_current_channel_ex( pHwData, channel );
}
void hal_set_phy_type(  struct hw_data * pHwData,  u8 PhyType )
{
	pHwData->phy_type = PhyType;
}
void hal_set_rf_power(struct hw_data * pHwData, u8 PowerIndex)
{
	RFSynthesizer_SetPowerIndex( pHwData, PowerIndex );
}
static void wbsoft_remove_interface(struct ieee80211_hw *dev,
				     struct ieee80211_if_init_conf *conf)
{
	printk("wbsoft_remove interface called\n");
}
static void wbsoft_stop(struct ieee80211_hw *hw)
{
	printk(KERN_INFO "%s called\n", __func__);
}
static int __init wb35_init(void)
{
	return usb_register(&wb35_driver);
}
static void __exit wb35_exit(void)
{
	usb_deregister(&wb35_driver);
}
static inline hfa384x_usbctlx_t *get_active_ctlx(hfa384x_t *hw)
{
	return list_entry(hw->ctlxq.active.next, hfa384x_usbctlx_t, list);
}
static inline int hfa384x_docmd_wait(hfa384x_t *hw, hfa384x_metacmd_t *cmd)
{
	return hfa384x_docmd(hw, DOWAIT, cmd, NULL, NULL, NULL);
}
static inline int
hfa384x_docmd_async(hfa384x_t *hw,
		    hfa384x_metacmd_t *cmd,
		    ctlx_cmdcb_t cmdcb, ctlx_usercb_t usercb, void *usercb_data)
{
	return hfa384x_docmd(hw, DOASYNC, cmd, cmdcb, usercb, usercb_data);
}
static inline int
hfa384x_dorrid_wait(hfa384x_t *hw, u16 rid, void *riddata,
		    unsigned int riddatalen)
{
	return hfa384x_dorrid(hw, DOWAIT,
			      rid, riddata, riddatalen, NULL, NULL, NULL);
}
static inline int
hfa384x_dorrid_async(hfa384x_t *hw,
		     u16 rid, void *riddata, unsigned int riddatalen,
		     ctlx_cmdcb_t cmdcb,
		     ctlx_usercb_t usercb, void *usercb_data)
{
	return hfa384x_dorrid(hw, DOASYNC,
			      rid, riddata, riddatalen,
			      cmdcb, usercb, usercb_data);
}
static inline int
hfa384x_dowrid_wait(hfa384x_t *hw, u16 rid, void *riddata,
		    unsigned int riddatalen)
{
	return hfa384x_dowrid(hw, DOWAIT,
			      rid, riddata, riddatalen, NULL, NULL, NULL);
}
static inline int
hfa384x_dowrid_async(hfa384x_t *hw,
		     u16 rid, void *riddata, unsigned int riddatalen,
		     ctlx_cmdcb_t cmdcb,
		     ctlx_usercb_t usercb, void *usercb_data)
{
	return hfa384x_dowrid(hw, DOASYNC,
			      rid, riddata, riddatalen,
			      cmdcb, usercb, usercb_data);
}
static inline int
hfa384x_dormem_wait(hfa384x_t *hw,
		    u16 page, u16 offset, void *data, unsigned int len)
{
	return hfa384x_dormem(hw, DOWAIT,
			      page, offset, data, len, NULL, NULL, NULL);
}
static inline int
hfa384x_dormem_async(hfa384x_t *hw,
		     u16 page, u16 offset, void *data, unsigned int len,
		     ctlx_cmdcb_t cmdcb,
		     ctlx_usercb_t usercb, void *usercb_data)
{
	return hfa384x_dormem(hw, DOASYNC,
			      page, offset, data, len,
			      cmdcb, usercb, usercb_data);
}
static inline int
hfa384x_dowmem_wait(hfa384x_t *hw,
		    u16 page, u16 offset, void *data, unsigned int len)
{
	return hfa384x_dowmem(hw, DOWAIT,
			      page, offset, data, len, NULL, NULL, NULL);
}
static inline int
hfa384x_dowmem_async(hfa384x_t *hw,
		     u16 page,
		     u16 offset,
		     void *data,
		     unsigned int len,
		     ctlx_cmdcb_t cmdcb,
		     ctlx_usercb_t usercb, void *usercb_data)
{
	return hfa384x_dowmem(hw, DOASYNC,
			      page, offset, data, len,
			      cmdcb, usercb, usercb_data);
}
int
hfa384x_drvr_getconfig_async(hfa384x_t *hw,
			     u16 rid, ctlx_usercb_t usercb, void *usercb_data)
{
	return hfa384x_dorrid_async(hw, rid, NULL, 0,
				    hfa384x_cb_rrid, usercb, usercb_data);
}
int
hfa384x_drvr_setconfig_async(hfa384x_t *hw,
			     u16 rid,
			     void *buf,
			     u16 len, ctlx_usercb_t usercb, void *usercb_data)
{
	return hfa384x_dowrid_async(hw, rid, buf, len,
				    hfa384x_cb_status, usercb, usercb_data);
}
int hfa384x_drvr_setconfig(hfa384x_t *hw, u16 rid, void *buf, u16 len)
{
	return hfa384x_dowrid_wait(hw, rid, buf, len);
}
static void hfa384x_usbout_tx(wlandevice_t *wlandev, hfa384x_usbout_t *usbout)
{
	prism2sta_ev_alloc(wlandev);
}
static int p80211knetdev_init(netdevice_t *netdev)
{
	return 0;
}
void prism2mgmt_pstr2bytearea(u8 *bytearea, p80211pstrd_t *pstr)
{
	memcpy(bytearea, pstr->data, pstr->len);
}
static int prism2sta_open(wlandevice_t *wlandev)
{
	return 0;
}
static int prism2sta_close(wlandevice_t *wlandev)
{
	return 0;
}
static void prism2sta_reset(wlandevice_t *wlandev)
{
	return;
}
static int __init prism2usb_init(void)
{
	/* This call will result in calls to prism2sta_probe_usb. */
	return usb_register(&prism2_usb_driver);
}

static void __exit prism2usb_cleanup(void)
{
	usb_deregister(&prism2_usb_driver);
}
int tc_register_driver(struct tc_driver *tdrv)
{
	return driver_register(&tdrv->driver);
}
void tc_unregister_driver(struct tc_driver *tdrv)
{
	driver_unregister(&tdrv->driver);
}
static int __init tc_driver_init(void)
{
	return bus_register(&tc_bus_type);
}
static inline void ixj_fsk_free(IXJ *j) {;}
static inline void ixj_fsk_alloc(IXJ *j)
{
	j->fsksize = 8000;
}
static int Stub(IXJ * J, unsigned long arg)
{
	return 0;
}
static void ixj_testram(IXJ *j)
{
	ixj_WriteDSPCommand(0x3001, j);	/* Test External SRAM */
}
static void __exit ixj_exit(void)
{
        cleanup();
}
static int __init ixj_pcmcia_init(void)
{
	return pcmcia_register_driver(&ixj_driver);
}
static void ixj_pcmcia_exit(void)
{
	pcmcia_unregister_driver(&ixj_driver);
}
static void __exit telephony_exit(void)
{
	unregister_chrdev(PHONE_MAJOR, "telephony");
}
static int
thermal_add_hwmon_sysfs(struct thermal_zone_device *tz)
{
	return 0;
}
static ssize_t map_addr_show(struct uio_mem *mem, char *buf)
{
	return sprintf(buf, "0x%lx\n", mem->addr);
}
static ssize_t map_size_show(struct uio_mem *mem, char *buf)
{
	return sprintf(buf, "0x%lx\n", mem->size);
}
static ssize_t map_offset_show(struct uio_mem *mem, char *buf)
{
	return sprintf(buf, "0x%lx\n", mem->addr & ~PAGE_MASK);
}
static ssize_t portio_start_show(struct uio_port *port, char *buf)
{
	return sprintf(buf, "0x%lx\n", port->start);
}
static ssize_t portio_size_show(struct uio_port *port, char *buf)
{
	return sprintf(buf, "0x%lx\n", port->size);
}
static void uio_major_cleanup(void)
{
	unregister_chrdev(uio_major, "uio");
}
static int __init uio_init(void)
{
	return 0;
}
static void print_board_data(struct pci_dev *pdev, struct uio_info *i)
{
	dev_info(&pdev->dev, "PCI-TC board vendor: %x%x number: %x%x"
		" revision: %c%c\n",
		ioread8(i->priv + 0x01),
		ioread8(i->priv + 0x00),
		ioread8(i->priv + 0x03),
		ioread8(i->priv + 0x02),
		ioread8(i->priv + 0x06),
		ioread8(i->priv + 0x07));
}
static int __init aectc_init(void)
{
	return pci_register_driver(&pci_driver);
}
static void __exit aectc_exit(void)
{
	pci_unregister_driver(&pci_driver);
}
static int __init hilscher_init_module(void)
{
	return pci_register_driver(&hilscher_pci_driver);
}
static void __exit hilscher_exit_module(void)
{
	pci_unregister_driver(&hilscher_pci_driver);
}
static int __init uio_pdrv_init(void)
{
	return platform_driver_register(&uio_pdrv);
}
static void __exit uio_pdrv_exit(void)
{
	platform_driver_unregister(&uio_pdrv);
}
static int __init uio_pdrv_genirq_init(void)
{
	return platform_driver_register(&uio_pdrv_genirq);
}
static void __exit uio_pdrv_genirq_exit(void)
{
	platform_driver_unregister(&uio_pdrv_genirq);
}
static int __init sercos3_init_module(void)
{
	return pci_register_driver(&sercos3_pci_driver);
}
static void __exit sercos3_exit_module(void)
{
	pci_unregister_driver(&sercos3_pci_driver);
}
static int __init smx_ce_init_module(void)
{
	return platform_driver_register(&smx_ce_driver);
}
static void __exit smx_ce_exit_module(void)
{
	platform_driver_unregister(&smx_ce_driver);
}
static ssize_t cxacru_sysfs_showattr_u32(u32 value, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%u\n", value);
}
static ssize_t cxacru_sysfs_showattr_s8(s8 value, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%d\n", value);
}
static ssize_t cxacru_sysfs_showattr_dB(s16 value, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%d.%02u\n",
					value / 100, abs(value) % 100);
}
static void cxacru_blocking_completion(struct urb *urb)
{
	complete(urb->context);
}
static void cxacru_timeout_kill(unsigned long data)
{
	usb_unlink_urb((struct urb *) data);
}
static int cxacru_usb_probe(struct usb_interface *intf, const struct usb_device_id *id)
{
	return usbatm_usb_probe(intf, id, &cxacru_driver);
}
static int __init cxacru_init(void)
{
	return usb_register(&cxacru_usb_driver);
}
static void __exit cxacru_cleanup(void)
{
	usb_deregister(&cxacru_usb_driver);
}
static int speedtch_pre_reset(struct usb_interface *intf)
{
	return 0;
}
static int speedtch_post_reset(struct usb_interface *intf)
{
	return 0;
}
static int speedtch_usb_probe(struct usb_interface *intf, const struct usb_device_id *id)
{
	return usbatm_usb_probe(intf, id, &speedtch_usbatm_driver);
}
static void usbatm_tasklet_schedule(unsigned long data)
{
	tasklet_schedule((struct tasklet_struct *) data);
}
static void __exit usbatm_usb_exit(void)
{
	dbg("%s", __func__);
}
static int xusbatm_usb_probe(struct usb_interface *intf,
			     const struct usb_device_id *id)
{
	return usbatm_usb_probe(intf, id,
				xusbatm_drivers + (id - xusbatm_usb_ids));
}
static int __init c67x00_init(void)
{
	return platform_driver_register(&c67x00_driver);
}
static void __exit c67x00_exit(void)
{
	platform_driver_unregister(&c67x00_driver);
}
static inline u16 hpi_read_reg(struct c67x00_device *dev, int reg)
{
	return __raw_readw(dev->hpi.base + reg * dev->hpi.regstep);
}
static inline void hpi_write_reg(struct c67x00_device *dev, int reg, u16 value)
{
	__raw_writew(value, dev->hpi.base + reg * dev->hpi.regstep);
}
void c67x00_ll_hpi_enable_sofeop(struct c67x00_sie *sie)
{
	hpi_set_bits(sie->dev, HPI_IRQ_ROUTING_REG,
		     SOFEOP_TO_HPI_EN(sie->sie_num));
}
void c67x00_ll_hpi_disable_sofeop(struct c67x00_sie *sie)
{
	hpi_clear_bits(sie->dev, HPI_IRQ_ROUTING_REG,
		       SOFEOP_TO_HPI_EN(sie->sie_num));
}
u16 c67x00_ll_get_usb_ctl(struct c67x00_sie *sie)
{
	return hpi_read_word(sie->dev, USB_CTL_REG(sie->sie_num));
}
void c67x00_ll_usb_clear_status(struct c67x00_sie *sie, u16 bits)
{
	hpi_write_word(sie->dev, USB_STAT_REG(sie->sie_num), bits);
}
u16 c67x00_ll_usb_get_status(struct c67x00_sie *sie)
{
	return hpi_read_word(sie->dev, USB_STAT_REG(sie->sie_num));
}
void c67x00_ll_husb_set_current_td(struct c67x00_sie *sie, u16 addr)
{
	hpi_write_word(sie->dev, HUSB_SIE_pCurrentTDPtr(sie->sie_num), addr);
}
u16 c67x00_ll_husb_get_current_td(struct c67x00_sie *sie)
{
	return hpi_read_word(sie->dev, HUSB_SIE_pCurrentTDPtr(sie->sie_num));
}
u16 c67x00_ll_husb_get_frame(struct c67x00_sie *sie)
{
	return hpi_read_word(sie->dev, HOST_FRAME_REG(sie->sie_num));
}
static inline u16 c67x00_get_current_frame_number(struct c67x00_hcd *c67x00)
{
	return c67x00_ll_husb_get_frame(c67x00->sie) & HOST_FRAME_MASK;
}
static inline u16 frame_add(u16 a, u16 b)
{
	return (a + b) & HOST_FRAME_MASK;
}
static inline int frame_after(u16 a, u16 b)
{
	return ((HOST_FRAME_MASK + a - b) & HOST_FRAME_MASK) <
	    (HOST_FRAME_MASK / 2);
}
static inline int frame_after_eq(u16 a, u16 b)
{
	return ((HOST_FRAME_MASK + 1 + a - b) & HOST_FRAME_MASK) <
	    (HOST_FRAME_MASK / 2);
}
static inline int c67x00_all_tds_processed(struct c67x00_hcd *c67x00)
{
	return !c67x00_ll_husb_get_current_td(c67x00->sie);
}
void c67x00_sched_kick(struct c67x00_hcd *c67x00)
{
	tasklet_hi_schedule(&c67x00->tasklet);
}
void c67x00_sched_stop_scheduler(struct c67x00_hcd *c67x00)
{
	tasklet_kill(&c67x00->tasklet);
}
static void __exit wdm_exit(void)
{
	usb_deregister(&wdm_driver);
}
static void usblp_unlink_urbs(struct usblp *usblp)
{
	usb_kill_anchored_urbs(&usblp->urbs);
}
static int __init usblp_init(void)
{
	return usb_register(&usblp_driver);
}
static void __exit usblp_exit(void)
{
	usb_deregister(&usblp_driver);
}
static void __exit usbtmc_exit(void)
{
	usb_deregister(&usbtmc_driver);
}
static inline const char *plural(int n)
{
	return (n == 1 ? "" : "s");
}
static inline int connected(struct dev_state *ps)
{
	return (!list_empty(&ps->list) &&
			ps->dev->state != USB_STATE_NOTATTACHED);
}
static inline void destroy_all_async(struct dev_state *ps)
{
	destroy_async(ps, &ps->async_pending);
}
static int driver_probe(struct usb_interface *intf,
			const struct usb_device_id *id)
{
	return -ENODEV;
}
static int driver_suspend(struct usb_interface *intf, pm_message_t msg)
{
	return 0;
}
static int driver_resume(struct usb_interface *intf)
{
	return 0;
}
static int match_devt(struct device *dev, void *data)
{
	return dev->devt == (dev_t) (unsigned long) data;
}
static int proc_resetdevice(struct dev_state *ps)
{
	return usb_reset_device(ps->dev);
}
static inline int usb_create_newid_file(struct usb_driver *usb_drv)
{
	return 0;
}
static int usb_uevent(struct device *dev, struct kobj_uevent_env *env)
{
	return -ENODEV;
}
static inline int autosuspend_check(struct usb_device *udev, int reschedule)
{
	return 0;
}
static void usb_endpoint_major_cleanup(void)
{
	unregister_chrdev_region(MKDEV(usb_endpoint_major, 0),
				 MAX_ENDPOINT_MINORS);
}
static void endpoint_free_minor(struct ep_device *ep_dev)
{
	idr_remove(&endpoint_idr, ep_dev->minor);
}
void usb_major_cleanup(void)
{
	unregister_chrdev(USB_MAJOR, "usb");
}
static inline const char *plural(int n)
{
	return (n == 1 ? "" : "s");
}
static int is_rndis(struct usb_interface_descriptor *desc)
{
	return desc->bInterfaceClass == USB_CLASS_COMM
		&& desc->bInterfaceSubClass == 2
		&& desc->bInterfaceProtocol == 0xff;
}
static int is_activesync(struct usb_interface_descriptor *desc)
{
	return desc->bInterfaceClass == USB_CLASS_MISC
		&& desc->bInterfaceSubClass == 1
		&& desc->bInterfaceProtocol == 1;
}
static inline int is_root_hub(struct usb_device *udev)
{
	return (udev->parent == NULL);
}
static void rh_timer_func (unsigned long _hcd)
{
	usb_hcd_poll_rh_status((struct usb_hcd *) _hcd);
}
void usb_host_cleanup(void)
{
	class_destroy(usb_host_class);
}
static inline char *portspeed(int portstatus)
{
	if (portstatus & (1 << USB_PORT_FEAT_HIGHSPEED))
    		return "480 Mb/s";
	else if (portstatus & (1 << USB_PORT_FEAT_LOWSPEED))
		return "1.5 Mb/s";
	else
		return "12 Mb/s";
}
static inline struct usb_hub *hdev_to_hub(struct usb_device *hdev)
{
	return usb_get_intfdata(hdev->actconfig->interface[0]);
}
static int clear_hub_feature(struct usb_device *hdev, int feature)
{
	return usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),
		USB_REQ_CLEAR_FEATURE, USB_RT_HUB, feature, 0, NULL, 0, 1000);
}
static int clear_port_feature(struct usb_device *hdev, int port1, int feature)
{
	return usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),
		USB_REQ_CLEAR_FEATURE, USB_RT_PORT, feature, port1,
		NULL, 0, 1000);
}
static int set_port_feature(struct usb_device *hdev, int port1, int feature)
{
	return usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),
		USB_REQ_SET_FEATURE, USB_RT_PORT, feature, port1,
		NULL, 0, 1000);
}
void usb_kick_khubd(struct usb_device *hdev)
{
	kick_khubd(hdev_to_hub(hdev));
}
static inline int
hub_clear_tt_buffer (struct usb_device *hdev, u16 devinfo, u16 tt)
{
	return usb_control_msg(hdev, usb_rcvctrlpipe(hdev, 0),
			       HUB_CLEAR_TT_BUFFER, USB_RT_PORT, devinfo,
			       tt, NULL, 0, 1000);
}
int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
{
	return 0;
}
static inline int remote_wakeup(struct usb_device *udev)
{
	return 0;
}
static inline int remote_wakeup(struct usb_device *udev)
{
	return 0;
}
void usb_queue_reset_device(struct usb_interface *iface)
{
	schedule_work(&iface->reset_ws);
}
static inline int usbfs_positive (struct dentry *dentry)
{
	return dentry->d_inode && !d_unhashed(dentry);
}
static ssize_t default_read_file (struct file *file, char __user *buf,
				  size_t count, loff_t *ppos)
{
	return 0;
}
static ssize_t default_write_file (struct file *file, const char __user *buf,
				   size_t count, loff_t *ppos)
{
	return count;
}
static int usb_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_single(fs_type, flags, data, usbfs_fill_super, mnt);
}
int usb_interrupt_msg(struct usb_device *usb_dev, unsigned int pipe,
		      void *data, int len, int *actual_length, int timeout)
{
	return usb_bulk_msg(usb_dev, pipe, data, len, actual_length, timeout);
}
static int usb_if_uevent(struct device *dev, struct kobj_uevent_env *env)
{
	return -ENODEV;
}
void usb_register_notify(struct notifier_block *nb)
{
	blocking_notifier_chain_register(&usb_notifier_list, nb);
}
void usb_unregister_notify(struct notifier_block *nb)
{
	blocking_notifier_chain_unregister(&usb_notifier_list, nb);
}
void usb_notify_add_device(struct usb_device *udev)
{
	blocking_notifier_call_chain(&usb_notifier_list, USB_DEVICE_ADD, udev);
}
void usb_notify_add_bus(struct usb_bus *ubus)
{
	blocking_notifier_call_chain(&usb_notifier_list, USB_BUS_ADD, ubus);
}
void usb_notify_remove_bus(struct usb_bus *ubus)
{
	blocking_notifier_call_chain(&usb_notifier_list, USB_BUS_REMOVE, ubus);
}
static void remove_persist_attributes(struct device *dev)
{
	sysfs_remove_file_from_group(&dev->kobj,
			&dev_attr_persist.attr,
			power_group);
}
int usb_wait_anchor_empty_timeout(struct usb_anchor *anchor,
				  unsigned int timeout)
{
	return wait_event_timeout(anchor->wait, list_empty(&anchor->urb_list),
				  msecs_to_jiffies(timeout));
}
int usb_anchor_empty(struct usb_anchor *anchor)
{
	return list_empty(&anchor->urb_list);
}
static int usb_dev_uevent(struct device *dev, struct kobj_uevent_env *env)
{
	return -ENODEV;
}
static void ksuspend_usb_cleanup(void)
{
	destroy_workqueue(ksuspend_usb_wq);
}
static int usb_dev_prepare(struct device *dev)
{
	return 0;		/* Implement eventually? */
}
static void usb_dev_complete(struct device *dev)
{
	usb_resume(dev, PMSG_RESUME);	/* Message event is meaningless */
}
static int usb_dev_suspend(struct device *dev)
{
	return usb_suspend(dev, PMSG_SUSPEND);
}
static int usb_dev_resume(struct device *dev)
{
	return usb_resume(dev, PMSG_RESUME);
}
static int usb_dev_freeze(struct device *dev)
{
	return usb_suspend(dev, PMSG_FREEZE);
}
static int usb_dev_thaw(struct device *dev)
{
	return usb_resume(dev, PMSG_THAW);
}
static int usb_dev_poweroff(struct device *dev)
{
	return usb_suspend(dev, PMSG_HIBERNATE);
}
static int usb_dev_restore(struct device *dev)
{
	return usb_resume(dev, PMSG_RESTORE);
}
int usb_get_current_frame_number(struct usb_device *dev)
{
	return usb_hcd_get_frame_number(dev);
}
int usb_disabled(void)
{
	return nousb;
}
static int udc_get_frame(struct usb_gadget *gadget)
{
	return -EOPNOTSUPP;
}
static int __init init(void)
{
	return pci_register_driver(&udc_pci_driver);
}
static void __exit cleanup(void)
{
	pci_unregister_driver(&udc_pci_driver);
}
static int proc_udc_open(struct inode *inode, struct file *file)
{
	return single_open(file, proc_udc_show, PDE(inode)->data);
}
static void create_debug_file(struct at91_udc *udc)
{
	udc->pde = proc_create_data(debug_filename, 0, NULL, &proc_ops, udc);
}
static void at91udc_shutdown(struct platform_device *dev)
{
	pullup(platform_get_drvdata(dev), 0);
}
static int __init udc_init_module(void)
{
	return platform_driver_probe(&at91_udc_driver, at91udc_probe);
}
static void __exit udc_exit_module(void)
{
	platform_driver_unregister(&at91_udc_driver);
}
static void
usba_update_req(struct usba_ep *ep, struct usba_request *req, u32 status)
{
	req->req.actual = req->req.length - USBA_BFEXT(DMA_BUF_LEN, status);
}
static int __init udc_init(void)
{
	return platform_driver_probe(&udc_driver, usba_udc_probe);
}
static void __exit udc_exit(void)
{
	platform_driver_unregister(&udc_driver);
}
static int __init init(void)
{
	return usb_composite_register(&cdc_driver);
}
static void __exit cleanup(void)
{
	usb_composite_unregister(&cdc_driver);
}
static inline int hw_ep_bit(int num, int dir)
{
	return num + (dir ? 16 : 0);
}
static u32 hw_aread(u32 addr, u32 mask)
{
	return ioread32(addr + hw_bank.abs) & mask;
}
static void hw_awrite(u32 addr, u32 mask, u32 data)
{
	iowrite32(hw_aread(addr, ~mask) | (data & mask),
		  addr + hw_bank.abs);
}
static u32 hw_cread(u32 addr, u32 mask)
{
	return ioread32(addr + hw_bank.cap) & mask;
}
static void hw_cwrite(u32 addr, u32 mask, u32 data)
{
	iowrite32(hw_cread(addr, ~mask) | (data & mask),
		  addr + hw_bank.cap);
}
static int hw_test_and_clear_setup_status(int n)
{
	return hw_ctest_and_clear(CAP_ENDPTSETUPSTAT, BIT(n));
}
static int hw_port_is_high_speed(void)
{
	return hw_bank.lpm ? hw_cread(CAP_DEVLC, DEVLC_PSPD) :
		hw_cread(CAP_PORTSC, PORTSC_HSP);
}
static u8 hw_port_test_get(void)
{
	return hw_cread(CAP_PORTSC, PORTSC_PTC) >> ffs_nr(PORTSC_PTC);
}
static u32 hw_read_intr_enable(void)
{
	return hw_cread(CAP_USBINTR, ~0);
}
static u32 hw_read_intr_status(void)
{
	return hw_cread(CAP_USBSTS, ~0);
}
static int hw_test_and_clear_complete(int n)
{
	return hw_ctest_and_clear(CAP_ENDPTCOMPLETE, BIT(n));
}
static int hw_test_and_clear_setup_guard(void)
{
	return hw_ctest_and_write(CAP_USBCMD, USBCMD_SUTW, 0);
}
static int hw_test_and_set_setup_guard(void)
{
	return hw_ctest_and_write(CAP_USBCMD, USBCMD_SUTW, USBCMD_SUTW);
}
static void dbg_dec(unsigned *idx)
{
	*idx = (*idx - 1) & (DBG_DATA_MAX-1);
}
static void dbg_inc(unsigned *idx)
{
	*idx = (*idx + 1) & (DBG_DATA_MAX-1);
}
static inline u8 _usb_addr(struct ci13xxx_ep *ep)
{
	return ((ep->dir == TX) ? USB_ENDPOINT_DIR_MASK : 0) | ep->num;
}
static int __init ci13xxx_pci_init(void)
{
	return pci_register_driver(&ci13xxx_pci_driver);
}
static void __exit ci13xxx_pci_exit(void)
{
	pci_unregister_driver(&ci13xxx_pci_driver);
}
static inline struct dummy_ep *usb_ep_to_dummy_ep (struct usb_ep *_ep)
{
	return container_of (_ep, struct dummy_ep, ep);
}
static inline struct dummy_request *usb_request_to_dummy_request
		(struct usb_request *_req)
{
	return container_of (_req, struct dummy_request, req);
}
static inline struct dummy *hcd_to_dummy (struct usb_hcd *hcd)
{
	return (struct dummy *) (hcd->hcd_priv);
}
static inline struct usb_hcd *dummy_to_hcd (struct dummy *dum)
{
	return container_of((void *) dum, struct usb_hcd, hcd_priv);
}
static inline struct device *dummy_dev (struct dummy *dum)
{
	return dummy_to_hcd(dum)->self.controller;
}
static inline struct device *udc_dev (struct dummy *dum)
{
	return dum->gadget.dev.parent;
}
static inline struct dummy *ep_to_dummy (struct dummy_ep *ep)
{
	return container_of (ep->gadget, struct dummy, gadget);
}
static inline struct dummy *gadget_to_dummy (struct usb_gadget *gadget)
{
	return container_of (gadget, struct dummy, gadget);
}
static inline struct dummy *gadget_dev_to_dummy (struct device *dev)
{
	return container_of (dev, struct dummy, gadget.dev);
}
static int
dummy_set_halt(struct usb_ep *_ep, int value)
{
	return dummy_set_halt_and_wedge(_ep, value, 0);
}
int net2280_set_fifo_mode (struct usb_gadget *gadget, int mode)
{
	return -ENOSYS;
}
static int dummy_h_get_frame (struct usb_hcd *hcd)
{
	return dummy_g_get_frame (NULL);
}
static inline bool has_rndis(void)
{
	return true;
}
static int __init init(void)
{
	return usb_composite_register(&eth_driver);
}
static void __exit cleanup(void)
{
	usb_composite_unregister(&eth_driver);
}
static inline struct f_acm *func_to_acm(struct usb_function *f)
{
	return container_of(f, struct f_acm, port.func);
}
static inline struct f_acm *port_to_acm(struct gserial *p)
{
	return container_of(p, struct f_acm, port);
}
static inline struct f_ecm *func_to_ecm(struct usb_function *f)
{
	return container_of(f, struct f_ecm, port.func);
}
static inline unsigned ecm_bitrate(struct usb_gadget *g)
{
	if (gadget_is_dualspeed(g) && g->speed == USB_SPEED_HIGH)
		return 13 * 512 * 8 * 1000 * 8;
	else
		return 19 *  64 * 1 * 1000 * 8;
}
static inline struct f_loopback *func_to_loop(struct usb_function *f)
{
	return container_of(f, struct f_loopback, function);
}
static void
loopback_unbind(struct usb_configuration *c, struct usb_function *f)
{
	kfree(func_to_loop(f));
}
static inline struct f_obex *func_to_obex(struct usb_function *f)
{
	return container_of(f, struct f_obex, port.func);
}
static inline struct f_obex *port_to_obex(struct gserial *p)
{
	return container_of(p, struct f_obex, port);
}
static inline struct f_phonet *func_to_pn(struct usb_function *f)
{
	return container_of(f, struct f_phonet, function);
}
void gphonet_cleanup(void)
{
	unregister_netdev(dev);
}
static inline struct f_rndis *func_to_rndis(struct usb_function *f)
{
	return container_of(f, struct f_rndis, port.func);
}
static unsigned int bitrate(struct usb_gadget *g)
{
	if (gadget_is_dualspeed(g) && g->speed == USB_SPEED_HIGH)
		return 13 * 512 * 8 * 1000 * 8;
	else
		return 19 *  64 * 1 * 1000 * 8;
}
static inline struct f_gser *func_to_gser(struct usb_function *f)
{
	return container_of(f, struct f_gser, port.func);
}
static inline struct f_sourcesink *func_to_ss(struct usb_function *f)
{
	return container_of(f, struct f_sourcesink, function);
}
static void
sourcesink_unbind(struct usb_configuration *c, struct usb_function *f)
{
	kfree(func_to_ss(f));
}
static inline struct f_gether *func_to_geth(struct usb_function *f)
{
	return container_of(f, struct f_gether, port.func);
}
static struct lun *dev_to_lun(struct device *dev)
{
	return container_of(dev, struct lun, dev);
}
static int exception_in_progress(struct fsg_dev *fsg)
{
	return (fsg->state > FSG_STATE_IDLE);
}
static void dump_cdb(struct fsg_dev *fsg)
{
	print_hex_dump(KERN_DEBUG, "SCSI CDB: ", DUMP_PREFIX_NONE,
			16, 1, fsg->cmnd, fsg->cmnd_size, 0);
}
static u16 get_be16(u8 *buf)
{
	return ((u16) buf[0] << 8) | ((u16) buf[1]);
}
static u32 get_be32(u8 *buf)
{
	return ((u32) buf[0] << 24) | ((u32) buf[1] << 16) |
			((u32) buf[2] << 8) | ((u32) buf[3]);
}
static inline void qe_usb_enable(void)
{
	setbits8(&udc_controller->usb_regs->usb_usmod, USB_MODE_EN);
}
static inline void qe_usb_disable(void)
{
	clrbits8(&udc_controller->usb_regs->usb_usmod, USB_MODE_EN);
}
static int qe_wakeup(struct usb_gadget *gadget)
{
	return -ENOTSUPP;
}
static int qe_vbus_session(struct usb_gadget *gadget, int is_active)
{
	return -ENOTSUPP;
}
static int qe_vbus_draw(struct usb_gadget *gadget, unsigned mA)
{
	return -ENOTSUPP;
}
static int qe_pullup(struct usb_gadget *gadget, int is_on)
{
	return -ENOTSUPP;
}
static int bsy_irq(struct qe_udc *udc)
{
	return 0;
}
static int txe_irq(struct qe_udc *udc)
{
	return 0;
}
static int qe_udc_suspend(struct of_device *dev, pm_message_t state)
{
	return -ENOTSUPP;
}
static int qe_udc_resume(struct of_device *dev)
{
	return -ENOTSUPP;
}
static void __exit qe_udc_exit(void)
{
	of_unregister_platform_driver(&udc_driver);
}
static int fsl_get_frame(struct usb_gadget *gadget)
{
	return (int)(fsl_readl(&dr_regs->frindex) & USB_FRINDEX_MASKS);
}
static int can_pullup(struct fsl_udc *udc)
{
	return udc->driver && udc->softconnect && udc->vbus_active;
}
static int gmidi_snd_free(struct snd_device *device)
{
	return 0;
}
static int __init gmidi_init(void)
{
	return usb_gadget_register_driver(&gmidi_driver);
}
static void __exit gmidi_cleanup(void)
{
	usb_gadget_unregister_driver(&gmidi_driver);
}
static int goku_get_frame(struct usb_gadget *_gadget)
{
	return -EOPNOTSUPP;
}
static inline char *dmastr(void)
{
	if (use_dma == 0)
		return "(dma disabled)";
	else if (use_dma == 2)
		return "(dma IN and OUT)";
	else
		return "(dma IN)";
}
static int __init init (void)
{
	return pci_register_driver (&goku_pci_driver);
}
static void __exit cleanup (void)
{
	pci_unregister_driver (&goku_pci_driver);
}
static int imx_udc_wakeup(struct usb_gadget *_gadget)
{
	return 0;
}
static int __init udc_init(void)
{
	return platform_driver_probe(&udc_driver, imx_udc_probe);
}
static void __exit udc_exit(void)
{
	platform_driver_unregister(&udc_driver);
}
static inline void get_dev (struct dev_data *data)
{
	atomic_inc (&data->count);
}
static inline void get_ep (struct ep_data *data)
{
	atomic_inc (&data->count);
}
static int is_valid_config (struct usb_config_descriptor *config)
{
	return config->bDescriptorType == USB_DT_CONFIG
		&& config->bLength == USB_DT_CONFIG_SIZE
		&& config->bConfigurationValue != 0
		&& (config->bmAttributes & USB_CONFIG_ATT_ONE) != 0
		&& (config->bmAttributes & USB_CONFIG_ATT_WAKEUP) == 0;
}
static int
gadgetfs_get_sb (struct file_system_type *t, int flags,
		const char *path, void *opts, struct vfsmount *mnt)
{
	return get_sb_single (t, flags, opts, gadgetfs_fill_super, mnt);
}
static __inline__ void usb_set_index(u32 ep)
{
	*(volatile u32 *)io_p2v(USB_INDEX) = ep;
}
static __inline__ u32 usb_read(u32 port)
{
	return *(volatile u32 *)io_p2v(port);
}
static __inline__ void usb_write(u32 val, u32 port)
{
	*(volatile u32 *)io_p2v(port) = val;
}
static void lh7a40x_reset_intr(struct lh7a40x_udc *dev)
{
	dev->gadget.speed = USB_SPEED_FULL;
}
static int lh7a40x_udc_wakeup(struct usb_gadget *_gadget)
{
	return -ENOTSUPP;
}
static void nop_release(struct device *dev)
{
	DEBUG("%s %s\n", __func__, dev_name(dev));
}
static void __exit udc_exit(void)
{
	platform_driver_unregister(&udc_driver);
}
static inline u16 get_usb_speed(struct m66592 *m66592)
{
	return (m66592_read(m66592, M66592_DVSTCTR) & M66592_RHST);
}
static inline void pipe_start(struct m66592 *m66592, u16 pipenum)
{
	control_reg_set_pid(m66592, pipenum, M66592_PID_BUF);
}
static inline void pipe_stop(struct m66592 *m66592, u16 pipenum)
{
	control_reg_set_pid(m66592, pipenum, M66592_PID_NAK);
}
static inline void pipe_stall(struct m66592 *m66592, u16 pipenum)
{
	control_reg_set_pid(m66592, pipenum, M66592_PID_STALL);
}
static int __init m66592_udc_init(void)
{
	return platform_driver_probe(&m66592_driver, m66592_probe);
}
static void __exit m66592_udc_cleanup(void)
{
	platform_driver_unregister(&m66592_driver);
}
static int can_pullup(struct omap_udc *udc)
{
	return udc->driver && udc->softconnect && udc->vbus_active;
}
static inline int machine_without_vbus_sense(void)
{
	return (machine_is_omap_innovator()
		|| machine_is_omap_osk()
		|| machine_is_omap_apollon()
		|| machine_is_omap_h4()
		|| machine_is_sx1()
		);
}
static int proc_udc_open(struct inode *inode, struct file *file)
{
	return single_open(file, proc_udc_show, NULL);
}
static void create_proc_file(void)
{
	proc_create(proc_filename, 0, NULL, &proc_ops);
}
static void remove_proc_file(void)
{
	remove_proc_entry(proc_filename, NULL);
}
static void __exit udc_exit(void)
{
	platform_driver_unregister(&udc_driver);
}
static inline void udc_set_mask_UDCCR(int mask)
{
	UDCCR = (UDCCR & UDCCR_MASK_BITS) | (mask & UDCCR_MASK_BITS);
}
static inline void udc_clear_mask_UDCCR(int mask)
{
	UDCCR = (UDCCR & UDCCR_MASK_BITS) & ~(mask & UDCCR_MASK_BITS);
}
static inline void ep0_idle (struct pxa25x_udc *dev)
{
	dev->ep0state = EP0_IDLE;
}
static int pxa25x_udc_get_frame(struct usb_gadget *_gadget)
{
	return ((UFNRH & 0x07) << 8) | (UFNRL & 0xff);
}
static int
udc_debugfs_open(struct inode *inode, struct file *file)
{
	return single_open(file, udc_seq_show, inode->i_private);
}
static void nop_release (struct device *dev)
{
	DMSG("%s %s\n", __func__, dev_name(dev));
}
static void pxa25x_udc_shutdown(struct platform_device *_dev)
{
	pullup_off();
}
static void __exit udc_exit(void)
{
	platform_driver_unregister(&udc_driver);
}
static int eps_dbg_open(struct inode *inode, struct file *file)
{
	return single_open(file, eps_dbg_show, inode->i_private);
}
static int queues_dbg_open(struct inode *inode, struct file *file)
{
	return single_open(file, queues_dbg_show, inode->i_private);
}
static int state_dbg_open(struct inode *inode, struct file *file)
{
	return single_open(file, state_dbg_show, inode->i_private);
}
static void ep0_idle(struct pxa_udc *dev)
{
	set_ep0state(dev, WAIT_FOR_SETUP);
}
static void __exit udc_exit(void)
{
	platform_driver_unregister(&udc_driver);
}
void rndis_set_host_mac (int configNr, const u8 *addr)
{
	rndis_per_dev_params [configNr].host_mac = addr;
}
static int rndis_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, rndis_proc_show, PDE(inode)->data);
}
static inline u32 udc_read(u32 reg)
{
	return readb(base_addr + reg);
}
static inline void udc_write(u32 value, u32 reg)
{
	writeb(value, base_addr + reg);
}
static inline void udc_writeb(void __iomem *base, u32 value, u32 reg)
{
	writeb(value, base + reg);
}
static int dprintk(int level, const char *fmt, ...)
{
	return 0;
}
static int s3c2410_udc_debugfs_fops_open(struct inode *inode,
					 struct file *file)
{
	return single_open(file, s3c2410_udc_debugfs_seq_show, NULL);
}
static inline struct s3c2410_ep *to_s3c2410_ep(struct usb_ep *ep)
{
	return container_of(ep, struct s3c2410_ep, ep);
}
static inline struct s3c2410_udc *to_s3c2410_udc(struct usb_gadget *gadget)
{
	return container_of(gadget, struct s3c2410_udc, gadget);
}
static inline struct s3c2410_request *to_s3c2410_req(struct usb_request *req)
{
	return container_of(req, struct s3c2410_request, req);
}
static inline int qlen(struct usb_gadget *gadget)
{
	if (gadget_is_dualspeed(gadget) && gadget->speed == USB_SPEED_HIGH)
		return qmult * DEFAULT_QLEN;
	else
		return DEFAULT_QLEN;
}
static inline int is_promisc(u16 cdc_filter)
{
	return cdc_filter & USB_CDC_PACKET_TYPE_PROMISCUOUS;
}
static void gs_buf_clear(struct gs_buf *gb)
{
	gb->buf_get = gb->buf_put;
}
static unsigned gs_buf_data_avail(struct gs_buf *gb)
{
	return (gb->buf_size + gb->buf_put - gb->buf_get) % gb->buf_size;
}
static unsigned gs_buf_space_avail(struct gs_buf *gb)
{
	return (gb->buf_size + gb->buf_get - gb->buf_put - 1) % gb->buf_size;
}
static int __init init(void)
{
	return usb_composite_register(&zero_driver);
}
static void __exit cleanup(void)
{
	usb_composite_unregister(&zero_driver);
}
static int __maybe_unused
dbg_status_buf (char *buf, unsigned len, const char *label, u32 status)
{
	return scnprintf (buf, len,
		"%s%sstatus %04x%s%s%s%s%s%s%s%s%s%s",
		label, label [0] ? " " : "", status,
		(status & STS_ASS) ? " Async" : "",
		(status & STS_PSS) ? " Periodic" : "",
		(status & STS_RECL) ? " Recl" : "",
		(status & STS_HALT) ? " Halt" : "",
		(status & STS_IAA) ? " IAA" : "",
		(status & STS_FATAL) ? " FATAL" : "",
		(status & STS_FLR) ? " FLR" : "",
		(status & STS_PCD) ? " PCD" : "",
		(status & STS_ERR) ? " ERR" : "",
		(status & STS_INT) ? " INT" : ""
		);
}
static int __maybe_unused
dbg_intr_buf (char *buf, unsigned len, const char *label, u32 enable)
{
	return scnprintf (buf, len,
		"%s%sintrenable %02x%s%s%s%s%s%s",
		label, label [0] ? " " : "", enable,
		(enable & STS_IAA) ? " IAA" : "",
		(enable & STS_FATAL) ? " FATAL" : "",
		(enable & STS_FLR) ? " FLR" : "",
		(enable & STS_PCD) ? " PCD" : "",
		(enable & STS_ERR) ? " ERR" : "",
		(enable & STS_INT) ? " INT" : ""
		);
}
static int
dbg_command_buf (char *buf, unsigned len, const char *label, u32 command)
{
	return scnprintf (buf, len,
		"%s%scommand %06x %s=%d ithresh=%d%s%s%s%s period=%s%s %s",
		label, label [0] ? " " : "", command,
		(command & CMD_PARK) ? "park" : "(park)",
		CMD_PARK_CNT (command),
		(command >> 16) & 0x3f,
		(command & CMD_LRESET) ? " LReset" : "",
		(command & CMD_IAAD) ? " IAAD" : "",
		(command & CMD_ASE) ? " Async" : "",
		(command & CMD_PSE) ? " Periodic" : "",
		fls_strings [(command >> 2) & 0x3],
		(command & CMD_RESET) ? " Reset" : "",
		(command & CMD_RUN) ? "RUN" : "HALT"
		);
}
static inline int __maybe_unused
dbg_status_buf (char *buf, unsigned len, const char *label, u32 status)
{ return 0; }

static inline int __maybe_unused
dbg_command_buf (char *buf, unsigned len, const char *label, u32 command)
{ return 0; }

static inline int __maybe_unused
dbg_intr_buf (char *buf, unsigned len, const char *label, u32 enable)
{ return 0; }
static inline int __maybe_unused
dbg_port_buf (char *buf, unsigned len, const char *label, int port, u32 status)
{ return 0; }
static inline void ehci_qtd_free (struct ehci_hcd *ehci, struct ehci_qtd *qtd)
{
	dma_pool_free (ehci->qtd_pool, qtd, qtd->qtd_dma);
}
static int ps3_ehci_driver_register(struct ps3_system_bus_driver *drv)
{
	return firmware_has_feature(FW_FEATURE_PS3_LV1)
		? ps3_system_bus_driver_register(drv)
		: 0;
}
static int fhci_dfs_regs_open(struct inode *inode, struct file *file)
{
	return single_open(file, fhci_dfs_regs_show, inode->i_private);
}
static int fhci_dfs_irq_stat_open(struct inode *inode, struct file *file)
{
	return single_open(file, fhci_dfs_irq_stat_show, inode->i_private);
}
u16 fhci_get_sof_timer_count(struct fhci_usb *usb)
{
	return be16_to_cpu(in_be16(&usb->fhci->regs->usb_sof_tmr) / 12);
}
static int __devexit of_fhci_remove(struct of_device *ofdev)
{
	return fhci_remove(&ofdev->dev);
}
static int __init fhci_module_init(void)
{
	return of_register_platform_driver(&of_fhci_driver);
}
static void __exit fhci_module_exit(void)
{
	of_unregister_platform_driver(&of_fhci_driver);
}
static int status_to_error(u32 status)
{
	if (status == USB_TD_OK)
		return 0;
	else if (status & USB_TD_RX_ER_CRC)
		return -EILSEQ;
	else if (status & USB_TD_RX_ER_NONOCT)
		return -EPROTO;
	else if (status & USB_TD_RX_ER_OVERUN)
		return -ECOMM;
	else if (status & USB_TD_RX_ER_BITSTUFF)
		return -EPROTO;
	else if (status & USB_TD_RX_ER_PID)
		return -EILSEQ;
	else if (status & (USB_TD_TX_ER_NAK | USB_TD_TX_ER_TIMEOUT))
		return -ETIMEDOUT;
	else if (status & USB_TD_TX_ER_STALL)
		return -EPIPE;
	else if (status & USB_TD_TX_ER_UNDERUN)
		return -ENOSR;
	else if (status & USB_TD_RX_DATA_UNDERUN)
		return -EREMOTEIO;
	else if (status & USB_TD_RX_DATA_OVERUN)
		return -EOVERFLOW;
	else
		return -EINVAL;
}
void fhci_add_td_to_frame(struct fhci_time_frame *frame, struct td *td)
{
	list_add_tail(&td->frame_lh, &frame->tds_list);
}
static struct usb_td __iomem *next_bd(struct usb_td __iomem *base,
				      struct usb_td __iomem *td,
				      u16 status)
{
	if (status & TD_W)
		return base;
	else
		return ++td;
}
static void hwahc_init(struct hwahc *hwahc)
{
	wa_init(&hwahc->wa);
}
static int __init hwahc_driver_init(void)
{
	return usb_register(&hwahc_driver);
}
static void __exit hwahc_driver_exit(void)
{
	usb_deregister(&hwahc_driver);
}
static void dump_irq(struct seq_file *s, char *label, u16 mask)
{
	seq_printf(s, "%s %04x%s%s%s%s%s%s\n", label, mask,
		   mask & HCuPINT_CLKRDY ? " clkrdy" : "",
		   mask & HCuPINT_SUSP ? " susp" : "",
		   mask & HCuPINT_OPR ? " opr" : "",
		   mask & HCuPINT_AIIEOT ? " eot" : "",
		   mask & HCuPINT_ATL ? " atl" : "",
		   mask & HCuPINT_SOF ? " sof" : "");
}

static void dump_int(struct seq_file *s, char *label, u32 mask)
{
	seq_printf(s, "%s %08x%s%s%s%s%s%s%s\n", label, mask,
		   mask & HCINT_MIE ? " MIE" : "",
		   mask & HCINT_RHSC ? " rhsc" : "",
		   mask & HCINT_FNO ? " fno" : "",
		   mask & HCINT_UE ? " ue" : "",
		   mask & HCINT_RD ? " rd" : "",
		   mask & HCINT_SF ? " sof" : "", mask & HCINT_SO ? " so" : "");
}
static int isp116x_open_seq(struct inode *inode, struct file *file)
{
	return single_open(file, isp116x_show_dbg, inode->i_private);
}
static void remove_debug_file(struct isp116x *isp116x)
{
	debugfs_remove(isp116x->dentry);
}
static void __exit isp116x_cleanup(void)
{
	platform_driver_unregister(&isp116x_driver);
}
static inline struct isp1760_hcd *hcd_to_priv(struct usb_hcd *hcd)
{
	return (struct isp1760_hcd *) (hcd->hcd_priv);
}
static inline struct usb_hcd *priv_to_hcd(struct isp1760_hcd *priv)
{
	return container_of((void *) priv, struct usb_hcd, hcd_priv);
}
static unsigned int isp1760_readl(__u32 __iomem *regs)
{
	return readl(regs);
}
static void isp1760_writel(const unsigned int val, __u32 __iomem *regs)
{
	writel(val, regs);
}
static u32 base_to_chip(u32 base)
{
	return ((base - 0x400) >> 3);
}
static void isp1760_qtd_free(struct isp1760_qtd *qtd)
{
	kmem_cache_free(qtd_cachep, qtd);
}
static void isp1761_pci_shutdown(struct pci_dev *dev)
{
	printk(KERN_ERR "ips1761_pci_shutdown\n");
}
static void ohci_dump_intr_mask (
	struct ohci_hcd *ohci,
	char *label,
	u32 mask,
	char **next,
	unsigned *size)
{
	ohci_dbg_sw (ohci, next, size, "%s 0x%08x%s%s%s%s%s%s%s%s%s\n",
		label,
		mask,
		(mask & OHCI_INTR_MIE) ? " MIE" : "",
		(mask & OHCI_INTR_OC) ? " OC" : "",
		(mask & OHCI_INTR_RHSC) ? " RHSC" : "",
		(mask & OHCI_INTR_FNO) ? " FNO" : "",
		(mask & OHCI_INTR_UE) ? " UE" : "",
		(mask & OHCI_INTR_RD) ? " RD" : "",
		(mask & OHCI_INTR_SF) ? " SF" : "",
		(mask & OHCI_INTR_WDH) ? " WDH" : "",
		(mask & OHCI_INTR_SO) ? " SO" : ""
		);
}
static void ep93xx_start_hc(struct device *dev)
{
	clk_enable(usb_host_clock);
}
static void ep93xx_stop_hc(struct device *dev)
{
	clk_disable(usb_host_clock);
}
static inline void quirk_amd_pll(int state)
{
	return;
}
static inline void amd_iso_dev_put(void)
{
	return;
}
static int check_ed(struct ohci_hcd *ohci, struct ed *ed)
{
	return (hc32_to_cpu(ohci, ed->hwINFO) & ED_IN) != 0
		&& (hc32_to_cpu(ohci, ed->hwHeadP) & TD_MASK)
			== (hc32_to_cpu(ohci, ed->hwTailP) & TD_MASK)
		&& !list_empty(&ed->td_list);
}
static inline int ohci_rh_resume(struct ohci_hcd *ohci)
{
	return 0;
}
static void
ed_free (struct ohci_hcd *hc, struct ed *ed)
{
	dma_pool_free (hc->ed_cache, ed, ed->dma);
}
static inline int tps65010_set_gpio_out_value(unsigned gpio, unsigned value)
{
	return 0;
}
static int ohci_hcd_omap_drv_probe(struct platform_device *dev)
{
	return usb_hcd_omap_probe(&ohci_omap_hc_driver, dev);
}
static int isp1301_probe(struct i2c_client *client,
			 const struct i2c_device_id *id)
{
	return 0;
}
static int isp1301_remove(struct i2c_client *client)
{
	return 0;
}
static inline void isp1301_vbus_on(void)
{
	i2c_write(OTG1_VBUS_DRV, ISP1301_I2C_OTG_CONTROL_1);
}
static inline void isp1301_vbus_off(void)
{
	i2c_write(OTG1_VBUS_DRV,
		  ISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR);
}
static void pnx8550_stop_hc(struct platform_device *dev)
{
	udelay(10);
}
static int ps3_ohci_driver_register(struct ps3_system_bus_driver *drv)
{
	return firmware_has_feature(FW_FEATURE_PS3_LV1)
		? ps3_system_bus_driver_register(drv)
		: 0;
}
static struct s3c2410_hcd_info *to_s3c2410_info(struct usb_hcd *hcd)
{
	return hcd->self.controller->platform_data;
}
static int ohci_hcd_s3c2410_drv_probe(struct platform_device *pdev)
{
	return usb_hcd_s3c2410_probe(&ohci_s3c2410_hc_driver, pdev);
}
static int ohci_sm501_init(struct usb_hcd *hcd)
{
	return ohci_init(hcd_to_ohci(hcd));
}
static inline
struct ssb_ohci_device *hcd_to_ssb_ohci(struct usb_hcd *hcd)
{
	return (struct ssb_ohci_device *)(hcd->hcd_priv);
}
static void ssb_ohci_remove(struct ssb_device *dev)
{
	ssb_ohci_detach(dev);
}
static inline struct usb_hcd *oxu_to_hcd(struct oxu_hcd *oxu)
{
	return container_of((void *) oxu, struct usb_hcd, hcd_priv);
}
static inline struct oxu_hcd *hcd_to_oxu(struct usb_hcd *hcd)
{
	return (struct oxu_hcd *) (hcd->hcd_priv);
}
static int __attribute__((__unused__))
dbg_status_buf(char *buf, unsigned len, const char *label, u32 status)
{
	return scnprintf(buf, len, "%s%sstatus %04x%s%s%s%s%s%s%s%s%s%s",
		label, label[0] ? " " : "", status,
		(status & STS_ASS) ? " Async" : "",
		(status & STS_PSS) ? " Periodic" : "",
		(status & STS_RECL) ? " Recl" : "",
		(status & STS_HALT) ? " Halt" : "",
		(status & STS_IAA) ? " IAA" : "",
		(status & STS_FATAL) ? " FATAL" : "",
		(status & STS_FLR) ? " FLR" : "",
		(status & STS_PCD) ? " PCD" : "",
		(status & STS_ERR) ? " ERR" : "",
		(status & STS_INT) ? " INT" : ""
		);
}

static int __attribute__((__unused__))
dbg_intr_buf(char *buf, unsigned len, const char *label, u32 enable)
{
	return scnprintf(buf, len, "%s%sintrenable %02x%s%s%s%s%s%s",
		label, label[0] ? " " : "", enable,
		(enable & STS_IAA) ? " IAA" : "",
		(enable & STS_FATAL) ? " FATAL" : "",
		(enable & STS_FLR) ? " FLR" : "",
		(enable & STS_PCD) ? " PCD" : "",
		(enable & STS_ERR) ? " ERR" : "",
		(enable & STS_INT) ? " INT" : ""
		);
}
static int dbg_command_buf(char *buf, unsigned len,
				const char *label, u32 command)
{
	return scnprintf(buf, len,
		"%s%scommand %06x %s=%d ithresh=%d%s%s%s%s period=%s%s %s",
		label, label[0] ? " " : "", command,
		(command & CMD_PARK) ? "park" : "(park)",
		CMD_PARK_CNT(command),
		(command >> 16) & 0x3f,
		(command & CMD_LRESET) ? " LReset" : "",
		(command & CMD_IAAD) ? " IAAD" : "",
		(command & CMD_ASE) ? " Async" : "",
		(command & CMD_PSE) ? " Periodic" : "",
		fls_strings[(command >> 2) & 0x3],
		(command & CMD_RESET) ? " Reset" : "",
		(command & CMD_RUN) ? "RUN" : "HALT"
		);
}
static inline int __attribute__((__unused__))
dbg_status_buf(char *buf, unsigned len, const char *label, u32 status)
{ return 0; }

static inline int __attribute__((__unused__))
dbg_command_buf(char *buf, unsigned len, const char *label, u32 command)
{ return 0; }

static inline int __attribute__((__unused__))
dbg_intr_buf(char *buf, unsigned len, const char *label, u32 enable)
{ return 0; }

static inline int __attribute__((__unused__))
dbg_port_buf(char *buf, unsigned len, const char *label, int port, u32 status)
{ return 0; }
static inline u32 oxu_readl(void *base, u32 reg)
{
	return readl(base + reg);
}
static inline void oxu_writel(void *base, u32 reg, u32 val)
{
	writel(val, base + reg);
}
static inline void timer_action_done(struct oxu_hcd *oxu,
					enum ehci_timer_action action)
{
	clear_bit(action, &oxu->actions);
}
static inline void qh_put(struct ehci_qh *qh)
{
	kref_put(&qh->kref, qh_destroy);
}
static int oxu_bus_suspend(struct usb_hcd *hcd)
{
	return 0;
}
static int oxu_bus_resume(struct usb_hcd *hcd)
{
	return 0;
}
static void oxu_drv_shutdown(struct platform_device *pdev)
{
	oxu_drv_remove(pdev);
}
static void __exit oxu_module_cleanup(void)
{
	platform_driver_unregister(&oxu_driver);
}
static int __devinit mmio_resource_enabled(struct pci_dev *pdev, int idx)
{
	return pci_resource_start(pdev, idx) && mmio_enabled(pdev);
}
static int is_child_device(char *devpath)
{
	return (devpath[2] ? 1 : 0);
}
static int is_hub_limit(char *devpath)
{
	return ((strlen(devpath) >= 4) ? 1 : 0);
}
static void r8a66597_root_hub_start_polling(struct r8a66597 *r8a66597)
{
	mod_timer(&r8a66597->rh_timer,
			jiffies + msecs_to_jiffies(R8A66597_RH_POLL_TIME));
}
static int is_set_address(unsigned char *setup_packet)
{
	if (((setup_packet[0] & USB_TYPE_MASK) == USB_TYPE_STANDARD) &&
			setup_packet[1] == USB_REQ_SET_ADDRESS)
		return 1;
	else
		return 0;
}
static int r8a66597_suspend(struct platform_device *pdev, pm_message_t state)
{
	return 0;
}
static int r8a66597_resume(struct platform_device *pdev)
{
	return 0;
}
static void __exit r8a66597_cleanup(void)
{
	platform_driver_unregister(&r8a66597_driver);
}
static void dump_irq(struct seq_file *s, char *label, u8 mask)
{
	seq_printf(s, "%s %02x%s%s%s%s%s%s\n", label, mask,
		(mask & SL11H_INTMASK_DONE_A) ? " done_a" : "",
		(mask & SL11H_INTMASK_DONE_B) ? " done_b" : "",
		(mask & SL11H_INTMASK_SOFINTR) ? " sof" : "",
		(mask & SL11H_INTMASK_INSRMV) ? " ins/rmv" : "",
		(mask & SL11H_INTMASK_RD) ? " rd" : "",
		(mask & SL11H_INTMASK_DP) ? " dp" : "");
}
static int proc_sl811h_open(struct inode *inode, struct file *file)
{
	return single_open(file, proc_sl811h_show, PDE(inode)->data);
}
static void create_debug_file(struct sl811 *sl811)
{
	sl811->pde = proc_create_data(proc_filename, 0, NULL, &proc_ops, sl811);
}
static void __exit sl811h_cleanup(void)
{
	platform_driver_unregister(&sl811h_driver);
}
static int __init init_sl811_cs(void)
{
	return pcmcia_register_driver(&sl811_cs_driver);
}
static void __exit exit_sl811_cs(void)
{
	pcmcia_unregister_driver(&sl811_cs_driver);
}
static inline struct u132 *hcd_to_u132(struct usb_hcd *hcd)
{
	return (struct u132 *)(hcd->hcd_priv);
}
static inline struct usb_hcd *u132_to_hcd(struct u132 *u132)
{
	return container_of((void *)u132, struct usb_hcd, hcd_priv);
}
static inline void u132_disable(struct u132 *u132)
{
	u132_to_hcd(u132)->state = HC_STATE_HALT;
}
static inline void u132_u132_put_kref(struct u132 *u132)
{
	kref_put(&u132->kref, u132_hcd_delete);
}
static inline void u132_u132_init_kref(struct u132 *u132)
{
	kref_init(&u132->kref);
}
static inline void u132_udev_put_kref(struct u132 *u132, struct u132_udev *udev)
{
	kref_put(&udev->kref, u132_udev_delete);
}
static inline void u132_udev_get_kref(struct u132 *u132, struct u132_udev *udev)
{
	kref_get(&udev->kref);
}
static inline void u132_udev_init_kref(struct u132 *u132,
	struct u132_udev *udev)
{
	kref_init(&udev->kref);
}
static inline void u132_ring_put_kref(struct u132 *u132, struct u132_ring *ring)
{
	kref_put(&u132->kref, u132_hcd_delete);
}
static inline void u132_endp_put_kref(struct u132 *u132, struct u132_endp *endp)
{
	kref_put(&endp->kref, u132_endp_delete);
}
static inline void u132_endp_get_kref(struct u132 *u132, struct u132_endp *endp)
{
	kref_get(&endp->kref);
}
static inline void u132_monitor_put_kref(struct u132 *u132)
{
	kref_put(&u132->kref, u132_hcd_delete);
}
static void u132_hcd_forget_urb(struct u132 *u132, struct u132_endp *endp,
	struct urb *urb, int status)
{
	u132_endp_put_kref(u132, endp);
}
static inline int edset_input(struct u132 *u132, struct u132_ring *ring,
	struct u132_endp *endp, struct urb *urb, u8 address, u8 toggle_bits,
	void (*callback) (void *endp, struct urb *urb, u8 *buf, int len,
	int toggle_bits, int error_count, int condition_code, int repeat_number,
	 int halted, int skipped, int actual, int non_null))
{
	return usb_ftdi_elan_edset_input(u132->platform_dev, ring->number, endp,
		 urb, address, endp->usb_endp, toggle_bits, callback);
}
static inline int edset_setup(struct u132 *u132, struct u132_ring *ring,
	struct u132_endp *endp, struct urb *urb, u8 address, u8 toggle_bits,
	void (*callback) (void *endp, struct urb *urb, u8 *buf, int len,
	int toggle_bits, int error_count, int condition_code, int repeat_number,
	 int halted, int skipped, int actual, int non_null))
{
	return usb_ftdi_elan_edset_setup(u132->platform_dev, ring->number, endp,
		 urb, address, endp->usb_endp, toggle_bits, callback);
}
static inline int edset_single(struct u132 *u132, struct u132_ring *ring,
	struct u132_endp *endp, struct urb *urb, u8 address, u8 toggle_bits,
	void (*callback) (void *endp, struct urb *urb, u8 *buf, int len,
	int toggle_bits, int error_count, int condition_code, int repeat_number,
	 int halted, int skipped, int actual, int non_null))
{
	return usb_ftdi_elan_edset_single(u132->platform_dev, ring->number,
		endp, urb, address, endp->usb_endp, toggle_bits, callback);
}
static inline int edset_output(struct u132 *u132, struct u132_ring *ring,
	struct u132_endp *endp, struct urb *urb, u8 address, u8 toggle_bits,
	void (*callback) (void *endp, struct urb *urb, u8 *buf, int len,
	int toggle_bits, int error_count, int condition_code, int repeat_number,
	 int halted, int skipped, int actual, int non_null))
{
	return usb_ftdi_elan_edset_output(u132->platform_dev, ring->number,
		endp, urb, address, endp->usb_endp, toggle_bits, callback);
}
static void port_power(struct u132 *u132, int pn, int is_on)
{
	u132->port[pn].power = is_on;
}
static inline int uhci_show_qh(struct uhci_hcd *uhci,
		struct uhci_qh *qh, char *buf, int len, int space)
{
	return 0;
}
static inline int uhci_sprint_schedule(struct uhci_hcd *uhci,
		char *buf, int len)
{
	return 0;
}
static inline void uhci_clear_next_interrupt(struct uhci_hcd *uhci)
{
	uhci->term_td->status &= ~cpu_to_le32(TD_CTRL_IOC);
}
static void uhci_add_td_to_urbp(struct uhci_td *td, struct urb_priv *urbp)
{
	list_add_tail(&td->list, &urbp->td_list);
}
static void uhci_remove_td_from_urbp(struct uhci_td *td)
{
	list_del_init(&td->list);
}
static inline void link_iso(struct uhci_hcd *uhci, struct uhci_qh *qh)
{
	list_add_tail(&qh->node, &uhci->skel_iso_qh->node);
}
static int di_open(struct inode *inode, struct file *file)
{
	return single_open(file, di_print, inode->i_private);
}
static int asl_open(struct inode *inode, struct file *file)
{
	return single_open(file, asl_print, inode->i_private);
}
static int pzl_open(struct inode *inode, struct file *file)
{
	return single_open(file, pzl_print, inode->i_private);
}
static int whc_reset(struct usb_hcd *usb_hcd)
{
	return 0;
}
static int whc_get_frame_number(struct usb_hcd *usb_hcd)
{
	return -ENOSYS;
}
static int __init whci_hc_driver_init(void)
{
	return umc_driver_register(&whci_hc_driver);
}
static void __exit whci_hc_driver_exit(void)
{
	umc_driver_unregister(&whci_hc_driver);
}
void qset_free(struct whc *whc, struct whc_qset *qset)
{
	dma_pool_free(whc->qset_pool, qset, qset->qset_dma);
}
static int mdc800_endpoint_equals (struct usb_endpoint_descriptor *a,struct usb_endpoint_descriptor *b)
{
	return (
		   ( a->bEndpointAddress == b->bEndpointAddress )
		&& ( a->bmAttributes     == b->bmAttributes     )
		&& ( a->wMaxPacketSize   == b->wMaxPacketSize   )
	);
}
static int __init microtek_drv_init(void)
{
	return usb_register(&mts_usb_driver);
}
static void __exit microtek_drv_exit(void)
{
	usb_deregister(&mts_usb_driver);
}
static int __init berry_init(void)
{
	return usb_register(&berry_driver);
}
static void __exit berry_exit(void)
{
	usb_deregister(&berry_driver);
}
static ssize_t set_port0_handler(struct device *dev,
				 struct device_attribute *attr,
				 const char *buf, size_t count)
{
	return write_port(dev, attr, buf, count, 0, CYPRESS_WRITE_PORT_ID0);
}
static ssize_t set_port1_handler(struct device *dev,
				 struct device_attribute *attr,
				 const char *buf, size_t count)
{
	return write_port(dev, attr, buf, count, 1, CYPRESS_WRITE_PORT_ID1);
}
static ssize_t get_port0_handler(struct device *dev,
				 struct device_attribute *attr, char *buf)
{
	return read_port(dev, attr, buf, 0, CYPRESS_READ_PORT_ID0);
}
static ssize_t get_port1_handler(struct device *dev,
				 struct device_attribute *attr, char *buf)
{
	return read_port(dev, attr, buf, 1, CYPRESS_READ_PORT_ID1);
}
static void __exit cypress_exit(void)
{
	usb_deregister(&cypress_driver);
}
static int vendor_command(struct usb_device *dev, unsigned char request, 
			  unsigned char value, unsigned char index,
			  void *buf, int size)
{
	return usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
			       request, 
			       USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_OTHER,
			       value, 
			       index, buf, size,
			       USB_CTRL_GET_TIMEOUT);
}
static ssize_t set_temp(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
{
	return count;
}
static ssize_t set_button(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
{
	return count;
}
static void __exit usb_cytherm_exit(void)
{
	usb_deregister(&cytherm_driver);
}
static int __init emi26_init (void)
{
	return usb_register(&emi26_driver);
}
static void __exit emi26_exit (void)
{
	usb_deregister (&emi26_driver);
}
static void __exit emi62_exit (void)
{
	usb_deregister (&emi62_driver);
}
static void ftdi_elan_put_kref(struct usb_ftdi *ftdi)
{
        kref_put(&ftdi->kref, ftdi_elan_delete);
}
static void ftdi_elan_get_kref(struct usb_ftdi *ftdi)
{
        kref_get(&ftdi->kref);
}
static void ftdi_elan_init_kref(struct usb_ftdi *ftdi)
{
        kref_init(&ftdi->kref);
}
static void ftdi_release_platform_dev(struct device *dev)
{
        dev->parent = NULL;
}
static void __exit usb_idmouse_exit(void)
{
	usb_deregister(&idmouse_driver);
}
static int usb_get_report(struct usb_device *dev,
			  struct usb_host_interface *inter, unsigned char type,
			  unsigned char id, void *buf, int size)
{
	return usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
			       USB_REQ_GET_REPORT,
			       USB_DIR_IN | USB_TYPE_CLASS |
			       USB_RECIP_INTERFACE, (type << 8) + id,
			       inter->desc.bInterfaceNumber, buf, size,
			       GET_TIMEOUT*HZ);
}
static int usb_set_report(struct usb_interface *intf, unsigned char type,
			  unsigned char id, void *buf, int size)
{
	return usb_control_msg(interface_to_usbdev(intf),
			       usb_sndctrlpipe(interface_to_usbdev(intf), 0),
			       USB_REQ_SET_REPORT,
			       USB_TYPE_CLASS | USB_RECIP_INTERFACE,
			       (type << 8) + id,
			       intf->cur_altsetting->desc.bInterfaceNumber, buf,
			       size, HZ);
}
static int __init iowarrior_init(void)
{
	return usb_register(&iowarrior_driver);
}
static void __exit iowarrior_exit(void)
{
	usb_deregister(&iowarrior_driver);
}
static int __init isight_firmware_init(void)
{
	return usb_register(&isight_firmware_driver);
}
static void __exit isight_firmware_exit(void)
{
	usb_deregister(&isight_firmware_driver);
}
static void __exit ld_usb_exit(void)
{
	usb_deregister(&ld_usb_driver);
}
static loff_t tower_llseek (struct file *file, loff_t off, int whence)
{
	return -ESPIPE;		/* unseekable */
}
static void __exit cleanup_phidget(void)
{
	class_destroy(phidget_class);
}
static void __exit interfacekit_exit(void)
{
	usb_deregister(&interfacekit_driver);
}
static void __exit motorcontrol_exit(void)
{
	usb_deregister(&motorcontrol_driver);
}
static void __exit
phidget_servo_exit(void)
{
	usb_deregister(&servo_driver);
}
int
sisusb_setreg(struct sisusb_usb_data *sisusb, int port, u8 data)
{
	return sisusb_write_memio_byte(sisusb, SISUSB_TYPE_IO, port, data);
}
int
sisusb_getreg(struct sisusb_usb_data *sisusb, int port, u8 *data)
{
	return sisusb_read_memio_byte(sisusb, SISUSB_TYPE_IO, port, data);
}
int
sisusb_setidxregor(struct sisusb_usb_data *sisusb, int port, u8 index, u8 myor)
{
	return(sisusb_setidxregandor(sisusb, port, index, 0xff, myor));
}
int
sisusb_setidxregand(struct sisusb_usb_data *sisusb, int port, u8 idx, u8 myand)
{
	return(sisusb_setidxregandor(sisusb, port, idx, myand, 0x00));
}
int
sisusb_writeb(struct sisusb_usb_data *sisusb, u32 adr, u8 data)
{
	return(sisusb_write_memio_byte(sisusb, SISUSB_TYPE_MEM, adr, data));
}
int
sisusb_readb(struct sisusb_usb_data *sisusb, u32 adr, u8 *data)
{
	return(sisusb_read_memio_byte(sisusb, SISUSB_TYPE_MEM, adr, data));
}
int
sisusb_copy_memory(struct sisusb_usb_data *sisusb, char *src,
			u32 dest, int length, size_t *bytes_written)
{
	return(sisusb_write_mem_bulk(sisusb, dest, src, length, NULL, 0, bytes_written));
}
int
sisusb_read_memory(struct sisusb_usb_data *sisusb, char *dest,
			u32 src, int length, size_t *bytes_written)
{
	return(sisusb_read_mem_bulk(sisusb, src, dest, length, NULL, bytes_written));
}
static void __exit usb_sisusb_exit(void)
{
	usb_deregister(&sisusb_driver);
}
static inline struct sisusb_usb_data *
sisusb_get_sisusb(unsigned short console)
{
	return mysisusbs[console];
}
static const char *
sisusbcon_startup(void)
{
	return "SISUSBCON";
}
static const char *sisusbdummycon_startup(void)
{
    return "SISUSBVGADUMMY";
}
static int sisusbdummycon_dummy(void)
{
    return 0;
}
static void
SiS_SetReg(struct SiS_Private *SiS_Pr, unsigned long port,
	   unsigned short index, unsigned short data)
{
	sisusb_setidxreg(SiS_Pr->sisusb, port, index, data);
}
static void
SiS_SetRegByte(struct SiS_Private *SiS_Pr, unsigned long port,
	       unsigned short data)
{
	sisusb_setreg(SiS_Pr->sisusb, port, data);
}
static void
SiS_SetRegANDOR(struct SiS_Private *SiS_Pr, unsigned long port,
		unsigned short index, unsigned short DataAND,
		unsigned short DataOR)
{
	sisusb_setidxregandor(SiS_Pr->sisusb, port, index, DataAND, DataOR);
}
static void
SiS_SetRegAND(struct SiS_Private *SiS_Pr, unsigned long port,
	      unsigned short index, unsigned short DataAND)
{
	sisusb_setidxregand(SiS_Pr->sisusb, port, index, DataAND);
}
static void
SiS_SetRegOR(struct SiS_Private *SiS_Pr, unsigned long port,
	     unsigned short index, unsigned short DataOR)
{
	sisusb_setidxregor(SiS_Pr->sisusb, port, index, DataOR);
}
static void SiS_DisplayOn(struct SiS_Private *SiS_Pr)
{
	SiS_SetRegAND(SiS_Pr, SiS_Pr->SiS_P3c4, 0x01, 0xDF);
}
static void SiS_GetSysFlags(struct SiS_Private *SiS_Pr)
{
	SiS_Pr->SiS_MyCR63 = 0x63;
}
static void SiS_ResetSegmentReg(struct SiS_Private *SiS_Pr)
{
	SiS_SetSegmentReg(SiS_Pr, 0);
}
static void SiS_ResetSegmentRegOver(struct SiS_Private *SiS_Pr)
{
	SiS_SetSegmentRegOver(SiS_Pr, 0);
}
static void SiS_HandleCRT1(struct SiS_Private *SiS_Pr)
{
	SiS_SetRegAND(SiS_Pr, SiS_Pr->SiS_P3d4, SiS_Pr->SiS_MyCR63, 0xbf);
}
static void __exit tv_exit(void)
{
	usb_deregister(&tv_driver);
}
static int lcd_resume (struct usb_interface *intf)
{
	return 0;
}
static void __exit usb_lcd_exit(void)
{
	usb_deregister(&lcd_driver);
}
static void __exit usb_led_exit(void)
{
	usb_deregister(&led_driver);
}
inline size_t my_memlen(const char *buf, size_t count)
{
	if (count > 0 && buf[count-1] == '\n')
		return count - 1;
	else
		return count;
}
static void __exit usb_sevseg_exit(void)
{
	usb_deregister(&sevseg_driver);
}
static struct usb_device *testdev_to_usbdev (struct usbtest_dev *test)
{
	return interface_to_usbdev (test->intf);
}
static void simple_callback (struct urb *urb)
{
	complete(urb->context);
}
static int usbtest_suspend (struct usb_interface *intf, pm_message_t message)
{
	return 0;
}
static int usbtest_resume (struct usb_interface *intf)
{
	return 0;
}
static void __exit usbtest_exit (void)
{
	usb_deregister (&usbtest_driver);
}
static void parport_uss720_write_data(struct parport *pp, unsigned char d)
{
	set_1284_register(pp, 0, d, GFP_KERNEL);
}
static void __exit uss720_cleanup(void)
{
	usb_deregister(&uss720_driver);
}
static int vstusb_resume(struct usb_interface *intf)
{
	return 0;
}
static void __exit vstusb_exit(void)
{
	usb_deregister(&vstusb_driver);
}
static inline struct mon_bin_hdr *MON_OFF2HDR(const struct mon_reader_bin *rp,
    unsigned int offset)
{
	return (struct mon_bin_hdr *)
	    (rp->b_vec[offset / CHUNK_SIZE].ptr + offset % CHUNK_SIZE);
}
void mon_bin_del(struct mon_bus *mbus)
{
	device_destroy(mon_bin_class, mbus->classdev->devt);
}
char mon_dmapeek(unsigned char *dst, dma_addr_t dma_addr, int len)
{
	return 'D';
}
void mon_dmapeek_vec(const struct mon_reader_bin *rp,
    unsigned int offset, dma_addr_t dma_addr, unsigned int length)
{
	;
}
static void mon_text_read_intstat(struct mon_reader_text *rp,
	struct mon_text_ptr *p, const struct mon_event_text *ep)
{
	p->cnt += snprintf(p->pbuf + p->cnt, p->limit - p->cnt,
	    " %d:%d", ep->status, ep->interval);
}
static void mon_text_ctor(void *mem)
{
	memset(mem, 0xe5, sizeof(struct mon_event_text));
}
void mon_text_exit(void)
{
	debugfs_remove(mon_dir);
}
static int bfin_set_power(struct otg_transceiver *x, unsigned mA)
{
	return 0;
}
int musb_platform_get_vbus_status(struct musb *musb)
{
	return 0;
}
int musb_platform_suspend(struct musb *musb)
{
	return 0;
}
int musb_platform_resume(struct musb *musb)
{
	return 0;
}
static inline void core_rxirq_disable(void __iomem *tibase, unsigned epnum)
{
	musb_writel(tibase, DAVINCI_USB_INT_MASK_CLR_REG, 1 << (epnum + 8));
}
static inline void core_rxirq_enable(void __iomem *tibase, unsigned epnum)
{
	musb_writel(tibase, DAVINCI_USB_INT_MASK_SET_REG, 1 << (epnum + 8));
}
static void cppi_dump_rxbd(const char *tag, struct cppi_descriptor *bd)
{
	pr_debug("RXBD/%s %08x: "
			"nxt %08x buf %08x off.blen %08x opt.plen %08x\n",
			tag, bd->dma,
			bd->hw_next, bd->hw_bufp, bd->hw_off_len,
			bd->hw_options);
}
static inline void phy_off(void)
{
	__raw_writel(USBPHY_OSCPDWN | USBPHY_PHYPDWN, (void __force __iomem *)
			IO_ADDRESS(USBPHY_CTL_PADDR));
}
int musb_platform_set_mode(struct musb *musb, u8 mode)
{
	return -EIO;
}
static inline struct musb *dev_to_musb(struct device *dev)
{
	return hcd_to_musb(dev_get_drvdata(dev));
}
static void __exit musb_cleanup(void)
{
	platform_driver_unregister(&musb_driver);
}
static inline int max_ep_writesize(struct musb *musb, struct musb_ep *ep)
{
	if (can_bulk_split(musb, ep->type))
		return ep->hw_ep->max_packet_sz_tx;
	else
		return ep->packet_sz;
}
void musb_free_request(struct usb_ep *ep, struct usb_request *req)
{
	kfree(to_musb_request(req));
}
static void musb_gadget_release(struct device *dev)
{
	dev_dbg(dev, "%s\n", __func__);
}
void musb_g_wakeup(struct musb *musb)
{
	musb_gadget_wakeup(&musb->g);
}
static void musb_g_ep0_giveback(struct musb *musb, struct usb_request *req)
{
	musb_g_giveback(&musb->endpoints[0].ep_in, req, 0);
}
static int
musb_g_ep0_enable(struct usb_ep *ep, const struct usb_endpoint_descriptor *desc)
{
	return -EINVAL;
}
static int musb_g_ep0_disable(struct usb_ep *e)
{
	return -EINVAL;
}
static int musb_g_ep0_dequeue(struct usb_ep *ep, struct usb_request *req)
{
	return -EINVAL;
}
static int musb_bus_resume(struct usb_hcd *hcd)
{
	return 0;
}
static int dma_controller_start(struct dma_controller *c)
{
	return 0;
}
static int omap_set_power(struct otg_transceiver *x, unsigned mA)
{
	return 0;
}
static int __init gpio_vbus_init(void)
{
	return platform_driver_probe(&gpio_vbus_driver, gpio_vbus_probe);
}
static void __exit gpio_vbus_exit(void)
{
	platform_driver_unregister(&gpio_vbus_driver);
}
static inline void notresponding(struct isp1301 *isp)
{
	printk(KERN_NOTICE "OTG device not responding.\n");
}
static inline void notresponding(struct isp1301 *isp)
{
	printk(KERN_NOTICE "OTG device not responding.\n");
}
static inline u8
isp1301_get_u8(struct isp1301 *isp, u8 reg)
{
	return i2c_smbus_read_byte_data(isp->client, reg + 0);
}
static inline int
isp1301_get_u16(struct isp1301 *isp, u8 reg)
{
	return i2c_smbus_read_word_data(isp->client, reg);
}
static inline int
isp1301_set_bits(struct isp1301 *isp, u8 reg, u8 bits)
{
	return i2c_smbus_write_byte_data(isp->client, reg + 0, bits);
}
static inline int
isp1301_clear_bits(struct isp1301 *isp, u8 reg, u8 bits)
{
	return i2c_smbus_write_byte_data(isp->client, reg + 1, bits);
}
static inline const char *state_name(struct isp1301 *isp)
{
	return state_string(isp->otg.state);
}
static int host_suspend(struct isp1301 *isp)
{
	return 0;
}
static int host_resume(struct isp1301 *isp)
{
	return 0;
}
static void isp1301_timer(unsigned long _isp)
{
	isp1301_defer_work((void *)_isp, WORK_TIMER);
}
static int __init isp_init(void)
{
	return i2c_add_driver(&isp1301_driver);
}
void usb_nop_xceiv_unregister(void)
{
	platform_device_unregister(&nop_xceiv_device);
}
static inline struct nop_usb_xceiv *xceiv_to_nop(struct otg_transceiver *x)
{
	return container_of(x, struct nop_usb_xceiv, otg);
}
static int nop_set_suspend(struct otg_transceiver *x, int suspend)
{
	return 0;
}
static int __init nop_usb_xceiv_init(void)
{
	return platform_driver_register(&nop_usb_xceiv_driver);
}
static void __exit nop_usb_xceiv_exit(void)
{
	platform_driver_unregister(&nop_usb_xceiv_driver);
}
void otg_put_transceiver(struct otg_transceiver *x)
{
	put_device(x->dev);
}
static inline int twl4030_usb_read(struct twl4030_usb *twl, u8 address)
{
	return twl4030_readb(twl, TWL4030_MODULE_USB, address);
}
static inline int
twl4030_usb_set_bits(struct twl4030_usb *twl, u8 reg, u8 bits)
{
	return twl4030_usb_write(twl, reg + 1, bits);
}
static inline int
twl4030_usb_clear_bits(struct twl4030_usb *twl, u8 reg, u8 bits)
{
	return twl4030_usb_write(twl, reg + 2, bits);
}
static int __init twl4030_usb_init(void)
{
	return platform_driver_register(&twl4030_usb_driver);
}
static void __exit twl4030_usb_exit(void)
{
	platform_driver_unregister(&twl4030_usb_driver);
}
static void serial_buf_clear(struct circ_buf *cb)
{
	cb->head = cb->tail = 0;
}
static int serial_buf_data_avail(struct circ_buf *cb)
{
	return CIRC_CNT(cb->head, cb->tail, AIRCABLE_BUF_SIZE);
}
static inline void ARK3116_RCV_QUIET(struct usb_serial *serial,
				     __u8 request, __u8 requesttype,
				     __u16 value, __u16 index, char *buf)
{
	usb_control_msg(serial->dev,
			usb_rcvctrlpipe(serial->dev, 0),
			request, requesttype, value, index,
			buf, 0x0000001, 1000);
}
static inline int cp2101_set_config_single(struct usb_serial_port *port,
		u8 request, unsigned int data)
{
	return cp2101_set_config(port, request, &data, 2);
}
static int cyberjack_write_room(struct tty_struct *tty)
{
	return CYBERJACK_LOCAL_BUF_SIZE;
}
static unsigned int cypress_buf_data_avail(struct cypress_buf *cb)
{
	if (cb != NULL)
		return (cb->buf_size + cb->buf_put - cb->buf_get)
							% cb->buf_size;
	else
		return 0;
}
static unsigned int cypress_buf_space_avail(struct cypress_buf *cb)
{
	if (cb != NULL)
		return (cb->buf_size + cb->buf_get - cb->buf_put - 1)
							% cb->buf_size;
	else
		return 0;
}
static void empeg_shutdown(struct usb_serial *serial)
{
	dbg("%s", __func__);
}
static unsigned short int ftdi_232am_baud_to_divisor(int baud)
{
	 return ftdi_232am_baud_base_to_divisor(baud, 48000000);
}
static __u32 ftdi_232bm_baud_to_divisor(int baud)
{
	 return ftdi_232bm_baud_base_to_divisor(baud, 48000000);
}
static void ftdi_shutdown(struct usb_serial *serial)
{
	dbg("%s", __func__);
}
static inline int noResponseFromAppLayer(struct garmin_data *garmin_data_p)
{
	return atomic_read(&garmin_data_p->req_count) ==
				atomic_read(&garmin_data_p->resp_count);
}
static inline int getLayerId(const __u8 *usbPacket)
{
	return __le32_to_cpup((__le32 *)(usbPacket));
}
static inline int getPacketId(const __u8 *usbPacket)
{
	return __le32_to_cpup((__le32 *)(usbPacket+4));
}
static inline int getDataLength(const __u8 *usbPacket)
{
	return __le32_to_cpup((__le32 *)(usbPacket+8));
}
static inline int isAbortTrfCmnd(const unsigned char *buf)
{
	if (0 == memcmp(buf, GARMIN_STOP_TRANSFER_REQ,
					sizeof(GARMIN_STOP_TRANSFER_REQ)) ||
	    0 == memcmp(buf, GARMIN_STOP_TRANSFER_REQ_V2,
					sizeof(GARMIN_STOP_TRANSFER_REQ_V2)))
		return 1;
	else
		return 0;
}
static int send_cmd(struct usb_device *dev, __u8 command,
				__u8 moduleid, __u16 value, u8 *data,
				int size)
{
	return ti_vsend_sync(dev, command, value, moduleid, data, size);
}
static int read_ram(struct usb_device *dev, int start_address,
						int length, __u8 *buffer)
{
	return read_download_mem(dev, start_address, length,
					DTK_ADDR_SPACE_XDATA, buffer);
}
static int config_boot_dev(struct usb_device *dev)
{
	return 0;
}
static int ti_cpu_rev(struct edge_ti_manuf_descriptor *desc)
{
	return TI_GET_CPU_REVISION(desc->CpuRev_BoardRev);
}
static int edge_create_sysfs_attrs(struct usb_serial_port *port)
{
	return device_create_file(&port->dev, &dev_attr_uart_mode);
}
static void ipaq_shutdown(struct usb_serial *serial)
{
	dbg("%s", __func__);
}
static int ipw_probe(struct usb_serial_port *port)
{
	return 0;
}
static int set_control_lines(struct usb_device *dev, u8 value)
{
	return 0;
}
static void	usa26_inack_callback(struct urb *urb)
{
	dbg("%s", __func__);
}
static void	usa26_glocont_callback(struct urb *urb)
{
	dbg("%s", __func__);
}
static void	usa28_inack_callback(struct urb *urb)
{
	dbg("%s", __func__);
}
static void	usa28_glocont_callback(struct urb *urb)
{
	dbg("%s", __func__);
}
static void	usa49_inack_callback(struct urb *urb)
{
	dbg("%s", __func__);
}
static void usa49_outcont_callback(struct urb *urb)
{
	dbg("%s", __func__);
}
static int kobil_write_room(struct tty_struct *tty)
{
	return 8;
}
static inline void mos7840_set_port_private(struct usb_serial_port *port,
					    struct moschip_port *data)
{
	usb_set_serial_port_data(port, (void *)data);
}
static inline struct moschip_port *mos7840_get_port_private(struct
							    usb_serial_port
							    *port)
{
	return (struct moschip_port *)usb_get_serial_port_data(port);
}
static int mos7840_serial_probe(struct usb_serial *serial,
				const struct usb_device_id *id)
{
	return 1;
}
static void ti_buf_clear(struct circ_buf *cb)
{
	cb->head = cb->tail = 0;
}
static int ti_buf_data_avail(struct circ_buf *cb)
{
	return CIRC_CNT(cb->head, cb->tail, TI_WRITE_BUF_SIZE);
}
static int ti_buf_space_avail(struct circ_buf *cb)
{
	return CIRC_SPACE(cb->head, cb->tail, TI_WRITE_BUF_SIZE);
}
void usb_serial_port_softint(struct usb_serial_port *port)
{
	schedule_work(&port->work);
}
static int whiteheat_firmware_attach(struct usb_serial *serial)
{
	return 1;
}
static void whiteheat_set_termios(struct tty_struct *tty,
	struct usb_serial_port *port, struct ktermios *old_termios)
{
	firm_setup_port(tty);
}
static struct list_head *list_first(struct list_head *head)
{
	return head->next;
}
static int nand_compare_ecc(unsigned char *data, unsigned char *ecc) {
	return (data[0] == ecc[0] && data[1] == ecc[1] && data[2] == ecc[2]);
}
static void nand_store_ecc(unsigned char *data, unsigned char *ecc) {
	memcpy(data, ecc, 3);
}
static void isd200_srb_set_bufflen(struct scsi_cmnd *srb, unsigned bufflen)
{
	srb->sdb.length = bufflen;
}
static void usu_disconnect(struct usb_interface *intf)
{
	;	/* We should not be here. */
}
static int usu_get_bias(char *buffer, struct kernel_param *kp)
{
	return strlen(strcpy(buffer, bias_names[atomic_read(&usu_bias)]));
}
void usb_stor_transparent_scsi_command(struct scsi_cmnd *srb,
				       struct us_data *us)
{
	usb_stor_invoke_transport(srb, us);
}
static const char* host_info(struct Scsi_Host *host)
{
	return "SCSI emulation for USB Mass Storage devices";
}
static int nand_compare_ecc(unsigned char *data, unsigned char *ecc) {
	return (data[0] == ecc[0] && data[1] == ecc[1] && data[2] == ecc[2]);
}
static void nand_store_ecc(unsigned char *data, unsigned char *ecc) {
	memcpy(data, ecc, 3);
}
static int
sddr09_send_scsi_command(struct us_data *us,
			 unsigned char *command,
			 unsigned int command_len) {
	return sddr09_send_command(us, 0, USB_DIR_OUT, command, command_len);
}
int
usb_stor_sddr09_init(struct us_data *us) {
	return sddr09_common_init(us);
}
int sddr55_reset(struct us_data *us) {
	return 0;
}
static int usbat_get_device_type(struct us_data *us)
{
	return ((struct usbat_info*)us->extra)->devicetype;
}
static int usbat_read(struct us_data *us,
		      unsigned char access,
		      unsigned char reg,
		      unsigned char *content)
{
	return usb_stor_ctrl_transfer(us,
		us->recv_ctrl_pipe,
		access | USBAT_CMD_READ_REG,
		0xC0,
		(u16)reg,
		0,
		content,
		1);
}
static int usbat_write(struct us_data *us,
		       unsigned char access,
		       unsigned char reg,
		       unsigned char content)
{
	return usb_stor_ctrl_transfer(us,
		us->send_ctrl_pipe,
		access | USBAT_CMD_WRITE_REG,
		0x40,
		short_pack(reg, content),
		0,
		NULL,
		0);
}
static int usbat_execute_command(struct us_data *us,
								 unsigned char *commands,
								 unsigned int len)
{
	return usb_stor_ctrl_transfer(us, us->send_ctrl_pipe,
								  USBAT_CMD_EXEC_CMD, 0x40, 0, 0,
								  commands, len);
}
static int usbat_write_user_io(struct us_data *us,
			       unsigned char enable_flags,
			       unsigned char data_flags)
{
	return usb_stor_ctrl_transfer(us,
		us->send_ctrl_pipe,
		USBAT_CMD_UIO,
		0x40,
		short_pack(enable_flags, data_flags),
		0,
		NULL,
		USBAT_UIO_WRITE);
}
int init_usbat_cd(struct us_data *us)
{
	return init_usbat(us, USBAT_DEV_HP8200);
}
int init_usbat_flash(struct us_data *us)
{
	return init_usbat(us, USBAT_DEV_FLASH);
}
int init_usbat_probe(struct us_data *us)
{
	return init_usbat(us, 0);
}
static bool containsFullLinuxPackage(struct swoc_info *swocInfo)
{
	if ((swocInfo->LinuxSKU >= 0x2100 && swocInfo->LinuxSKU <= 0x2FFF) ||
	   (swocInfo->LinuxSKU >= 0x7100 && swocInfo->LinuxSKU <= 0x7FFF))
		return true;
	else
		return false;
}
static int skel_resume (struct usb_interface *intf)
{
	return 0;
}
static void __exit usb_skel_exit(void)
{
	usb_deregister(&skel_driver);
}
static int __init cbaf_driver_init(void)
{
	return usb_register(&cbaf_driver);
}
static void __exit cbaf_driver_exit(void)
{
	usb_deregister(&cbaf_driver);
}
static void wusb_key_dump(const void *buf, size_t len)
{
	print_hex_dump(KERN_ERR, "  ", DUMP_PREFIX_OFFSET, 16, 1,
		       buf, len, 0);
}
void wusbhc_mmcie_destroy(struct wusbhc *wusbhc)
{
	kfree(wusbhc->mmcie);
}
void wusbhc_pal_unregister(struct wusbhc *wusbhc)
{
	uwb_pal_unregister(&wusbhc->pal);
}
static void wusb_port_init(struct wusb_port *port)
{
	port->status |= USB_PORT_STAT_HIGH_SPEED;
}
void wusbhc_rh_destroy(struct wusbhc *wusbhc)
{
	kfree(wusbhc->port);
}
void wusbhc_sec_stop(struct wusbhc *wusbhc)
{
	cancel_work_sync(&wusbhc->gtk_rekey_done_work);
}
void wa_reset_all(struct wahc *wa)
{
	wusbhc_reset_all(wa->wusb);
}
static void wa_seg_init(struct wa_seg *seg)
{
	kref_init(&seg->urb.kref);
}
static void wa_xfer_get(struct wa_xfer *xfer)
{
	kref_get(&xfer->refcnt);
}
static void wa_xfer_put(struct wa_xfer *xfer)
{
	kref_put(&xfer->refcnt, wa_xfer_destroy);
}
static void wa_xfer_id_init(struct wa_xfer *xfer)
{
	xfer->id = atomic_add_return(1, &xfer->wa->xfer_id_count);
}
static u32 wa_xfer_id(struct wa_xfer *xfer)
{
	return xfer->id;
}
static inline struct kobject *wusbhc_kobj(struct wusbhc *wusbhc)
{
	return &wusbhc->usb_hcd.self.controller->kobj;
}
void wusbhc_reset_all(struct wusbhc *wusbhc)
{
	uwb_rc_reset_all(wusbhc->uwb_rc);
}
int uwb_rc_mac_addr_get(struct uwb_rc *rc,
			struct uwb_mac_addr *addr) {
	return uwb_rc_addr_get(rc, addr, UWB_ADDR_MAC);
}
int uwb_rc_dev_addr_get(struct uwb_rc *rc,
			struct uwb_dev_addr *addr) {
	return uwb_rc_addr_get(rc, addr, UWB_ADDR_DEV);
}
static
ssize_t beacon_timeout_ms_show(struct class *class, char *buf)
{
	return scnprintf(buf, PAGE_SIZE, "%lu\n", beacon_timeout_ms);
}
static bool uwb_drp_involves_us(struct uwb_rc *rc, struct uwb_ie_drp *drp_ie)
{
	return uwb_dev_addr_cmp(&rc->uwb_dev.dev_addr, &drp_ie->dev_addr) == 0;
}
static void uwb_drp_availability_process(struct uwb_rc *rc, struct uwb_dev *src,
					 struct uwb_ie_drp_avail *drp_availability_ie)
{
	bitmap_copy(src->last_availability_bm,
		    drp_availability_ie->bmp, UWB_NUM_MAS);
}
static void hwarc_init(struct hwarc *hwarc)
{
	edc_init(&hwarc->neep_edc);
}
static int __init hwarc_driver_init(void)
{
	return usb_register(&hwarc_driver);
}
static void __exit hwarc_driver_exit(void)
{
	usb_deregister(&hwarc_driver);
}
static
void i1480_usb_init(struct i1480_usb *i1480_usb)
{
	i1480_init(&i1480_usb->i1480);
}
static int __init i1480_dfu_driver_init(void)
{
	return usb_register(&i1480_dfu_driver);
}
static void __exit i1480_dfu_driver_exit(void)
{
	usb_deregister(&i1480_dfu_driver);
}
static int __init i1480u_driver_init(void)
{
	return usb_register(&i1480u_driver);
}
static void __exit i1480u_driver_exit(void)
{
	usb_deregister(&i1480u_driver);
}
ssize_t uwb_phy_rate_show(const struct wlp_options *options, char *buf)
{
	return sprintf(buf, "%u\n",
		       wlp_tx_hdr_phy_rate(&options->def_tx_hdr));
}
ssize_t uwb_rts_cts_show(const struct wlp_options *options, char *buf)
{
	return sprintf(buf, "%u\n",
		       wlp_tx_hdr_rts_cts(&options->def_tx_hdr));
}
ssize_t uwb_ack_policy_show(const struct wlp_options *options, char *buf)
{
	return sprintf(buf, "%u\n",
		       wlp_tx_hdr_ack_policy(&options->def_tx_hdr));
}
ssize_t uwb_pca_base_priority_show(const struct wlp_options *options,
				   char *buf)
{
	return sprintf(buf, "%u\n",
		       options->pca_base_priority);
}
void i1480u_sysfs_release(struct i1480u *i1480u)
{
	sysfs_remove_group(&i1480u->net_dev->dev.kobj,
			   &i1480u_attr_group);
}
void uwb_rc_ie_init(struct uwb_rc *uwb_rc)
{
	mutex_init(&uwb_rc->ies_mutex);
}
static inline void uwb_dev_addr_init(struct uwb_dev_addr *addr)
{
	memset(&addr->data, 0xff, sizeof(addr->data));
}
static inline void uwb_mac_addr_init(struct uwb_mac_addr *addr)
{
	memset(&addr->data, 0xff, sizeof(addr->data));
}
struct uwb_dev *uwb_dev_try_get(struct uwb_rc *rc, struct uwb_dev *uwb_dev)
{
	if (uwb_dev_for_each(rc, __uwb_dev_try_get, uwb_dev))
		return uwb_dev;
	else
		return NULL;
}
int uwb_dev_for_each(struct uwb_rc *rc, uwb_dev_for_each_f function, void *priv)
{
	return device_for_each_child(&rc->uwb_dev.dev, priv, function);
}
static int uwb_rc_sys_add(struct uwb_rc *rc)
{
	return sysfs_create_group(&rc->uwb_dev.dev.kobj, &rc_attr_group);
}
static void __uwb_rc_sys_rm(struct uwb_rc *rc)
{
	sysfs_remove_group(&rc->uwb_dev.dev.kobj, &rc_attr_group);
}
void uwb_rc_put(struct uwb_rc *rc)
{
	__uwb_rc_put(rc);
}
static void uwb_rc_neh_get(struct uwb_rc_neh *neh)
{
	kref_get(&neh->kref);
}
void uwb_rc_neh_put(struct uwb_rc_neh *neh)
{
	kref_put(&neh->kref, uwb_rc_neh_release);
}
static bool uwb_rc_neh_match(struct uwb_rc_neh *neh, const struct uwb_rceb *rceb)
{
	return neh->evt_type == rceb->bEventType
		&& neh->evt == rceb->wEvent
		&& neh->context == rceb->bEventContext;
}
void uwb_pal_init(struct uwb_pal *pal)
{
	INIT_LIST_HEAD(&pal->node);
}
void uwb_rc_pal_init(struct uwb_rc *rc)
{
	INIT_LIST_HEAD(&rc->pals);
}
int uwb_radio_setup(struct uwb_rc *rc)
{
	return uwb_rc_reset(rc);
}
ssize_t uwb_rc_vcmd(struct uwb_rc *rc, const char *cmd_name,
		    struct uwb_rccb *cmd, size_t cmd_size,
		    u8 expected_type, u16 expected_event,
		    struct uwb_rceb **preply)
{
	return __uwb_rc_cmd(rc, cmd_name, cmd, cmd_size, NULL, 0,
			    expected_type, expected_event, preply);
}
void uwb_rsv_get(struct uwb_rsv *rsv)
{
	kref_get(&rsv->kref);
}
void uwb_rsv_put(struct uwb_rsv *rsv)
{
	kref_put(&rsv->kref, uwb_rsv_release);
}
void uwb_rsv_destroy(struct uwb_rsv *rsv)
{
	uwb_rsv_put(rsv);
}
int uwb_rsv_modify(struct uwb_rsv *rsv, int max_mas, int min_mas, int max_interval)
{
	return -ENOSYS;
}
static int __init umc_bus_init(void)
{
	return bus_register(&umc_bus_type);
}
static void __exit umc_bus_exit(void)
{
	bus_unregister(&umc_bus_type);
}
void umc_driver_unregister(struct umc_driver *umc_drv)
{
	driver_unregister(&umc_drv->driver);
}
static int cmd_ie_add(struct uwb_rc *rc, struct uwb_dbg_cmd_ie *ie_to_add)
{
	return uwb_rc_ie_add(rc,
			     (const struct uwb_ie_hdr *) ie_to_add->data,
			     ie_to_add->len);
}
static int cmd_ie_rm(struct uwb_rc *rc, struct uwb_dbg_cmd_ie *ie_to_rm)
{
	return uwb_rc_ie_rm(rc, ie_to_rm->data[0]);
}
static int reservations_open(struct inode *inode, struct file *file)
{
	return single_open(file, reservations_print, inode->i_private);
}
static int drp_avail_open(struct inode *inode, struct file *file)
{
	return single_open(file, drp_avail_print, inode->i_private);
}
void uwb_dbg_init(void)
{
	root_dir = debugfs_create_dir("uwb", NULL);
}
void uwb_dbg_exit(void)
{
	debugfs_remove(root_dir);
}
static int __init whcrc_driver_init(void)
{
	return umc_driver_register(&whcrc_driver);
}
static void __exit whcrc_driver_exit(void)
{
	umc_driver_unregister(&whcrc_driver);
}
static int __init whci_init(void)
{
	return pci_register_driver(&whci_driver);
}
static void __exit whci_exit(void)
{
	pci_unregister_driver(&whci_driver);
}
static int __init wlp_subsys_init(void)
{
	return 0;
}
static void __exit wlp_subsys_exit(void)
{
	return;
}
static ssize_t wlp_get_wss_info_to_cache(struct wlp *wlp,
					 struct wlp_attr_wss_info *attr,
					 struct wlp_neighbor_e *neighbor,
					 ssize_t buflen)
{
	return wlp_get_all_wss_info(wlp, attr, neighbor, NULL, buflen);
}
static ssize_t wlp_get_wss_info_to_enroll(struct wlp *wlp,
					  struct wlp_attr_wss_info *attr,
					  struct wlp_wss *wss, ssize_t buflen)
{
	return wlp_get_all_wss_info(wlp, attr, NULL, wss, buflen);
}
static
int wlp_build_assoc_c1(struct wlp *wlp, struct wlp_wss *wss,
		       struct sk_buff **skb)
{
	return wlp_build_assoc_c1c2(wlp, wss, skb, WLP_ASSOC_C1);
}
static
int wlp_build_assoc_c2(struct wlp *wlp, struct wlp_wss *wss,
		       struct sk_buff **skb)
{
	return wlp_build_assoc_c1c2(wlp, wss, skb, WLP_ASSOC_C2);
}
static
int wlp_build_assoc_c3(struct wlp *wlp, struct wlp_wss *wss,
		       struct sk_buff **skb)
{
	return wlp_build_assoc_c3c4(wlp, wss, skb, WLP_ASSOC_C3);
}
static
int wlp_build_assoc_c4(struct wlp *wlp, struct wlp_wss *wss,
		       struct sk_buff **skb)
{
	return wlp_build_assoc_c3c4(wlp, wss, skb, WLP_ASSOC_C4);
}
static
void wlp_neighbor_init(struct wlp_neighbor_e *neighbor)
{
	INIT_LIST_HEAD(&neighbor->wssid);
}
static
void __wlp_fill_device_info(struct wlp *wlp)
{
	wlp->fill_device_info(wlp, wlp->dev_info);
}
static
int wlp_discover_neighbor(struct wlp *wlp,
			  struct wlp_neighbor_e *neighbor)
{
	return wlp_d1d2_exchange(wlp, neighbor, NULL, NULL);
}
void wlp_reset_all(struct wlp *wlp)
{
	uwb_rc_reset_all(wlp->rc);
}
static
u8 wlp_wss_comp_wssid_hash(struct wlp_uuid *wssid)
{
	return wssid->data[0]  ^ wssid->data[1]  ^ wssid->data[2]
	       ^ wssid->data[3]  ^ wssid->data[4]  ^ wssid->data[5]
	       ^ wssid->data[6]  ^ wssid->data[7]  ^ wssid->data[8]
	       ^ wssid->data[9]  ^ wssid->data[10] ^ wssid->data[11]
	       ^ wssid->data[12] ^ wssid->data[13] ^ wssid->data[14]
	       ^ wssid->data[15];
}
static void __exit mc68x328fb_cleanup(void)
{
	unregister_framebuffer(&fb_info);
}
static int __init
acornfb_detect_monitortype(void)
{
	return 4;
}
static int __init acornfb_init(void)
{
	return platform_driver_register(&acornfb_driver);
}
static void __exit amba_clcdfb_exit(void)
{
	amba_driver_unregister(&clcd_driver);
}
static inline unsigned long comp(unsigned long a, unsigned long b,
				 unsigned long mask)
{
	return ((a ^ b) & mask) ^ b;
}
static inline unsigned long xor(unsigned long a, unsigned long b,
				unsigned long mask)
{
	return (a & mask) ^ b;
}
static unsigned char ks108_readb_ctl2(struct arcfb_par *par)
{
	return inb(par->c2io_addr);
}
static void ks108_set_start_line(struct arcfb_par *par,
				unsigned int chipindex, unsigned char y)
{
	ks108_writeb_ctl(par, chipindex, KS_SET_DPY_START_LINE|y);
}
static void ks108_set_yaddr(struct arcfb_par *par,
				unsigned int chipindex, unsigned char y)
{
	ks108_writeb_ctl(par, chipindex, KS_SET_PAGE_NUM|y);
}
static void ks108_set_xaddr(struct arcfb_par *par,
				unsigned int chipindex, unsigned char x)
{
	ks108_writeb_ctl(par, chipindex, KS_SET_X|x);
}
static inline u32 expand_color(u32 c)
{
	return ((c & 1) | ((c & 2) << 7) | ((c & 4) << 14) | ((c & 8) << 21)) * 0xFF;
}
static inline u32 expand_pixel(u32 c)
{
	return (((c &  1) << 24) | ((c &  2) << 27) | ((c &  4) << 14) | ((c &   8) << 17) |
		((c & 16) <<  4) | ((c & 32) <<  7) | ((c & 64) >>  6) | ((c & 128) >>  3)) * 0xF;
}
static inline void dac_read_regs(struct dac_info *info, u8 *code, int count)
{
	info->dac_read_regs(info->data, code, count);
}
static inline void dac_write_regs(struct dac_info *info, u8 *code, int count)
{
	info->dac_write_regs(info->data, code, count);
}
static inline int dac_set_mode(struct dac_info *info, int mode)
{
	return info->dacops->dac_set_mode(info, mode);
}
static inline int dac_set_freq(struct dac_info *info, int channel, u32 freq)
{
	return info->dacops->dac_set_freq(info, channel, freq);
}
static inline void dac_release(struct dac_info *info)
{
	info->dacops->dac_release(info);
}
static void mm_write_xr(struct fb_info *p, u8 reg, u8 data)
{
	mm_write_ind(reg, data, 0x7ac, 0x7ad);
}
static void mm_write_fr(struct fb_info *p, u8 reg, u8 data)
{
	mm_write_ind(reg, data, 0x7a0, 0x7a1);
}
static void mm_write_cr(struct fb_info *p, u8 reg, u8 data)
{
	mm_write_ind(reg, data, 0x7a8, 0x7a9);
}
static void mm_write_gr(struct fb_info *p, u8 reg, u8 data)
{
	mm_write_ind(reg, data, 0x79c, 0x79d);
}
static void mm_write_sr(struct fb_info *p, u8 reg, u8 data)
{
	mm_write_ind(reg, data, 0x788, 0x789);
}
static void __exit asiliantfb_exit(void)
{
	pci_unregister_driver(&asiliantfb_driver);
}
static inline int hxx_prescale(struct falcon_hw *hw)
{
	return hw->ste_mode ? 16
			    : vdl_prescale[mon_type][hw->vid_mode >> 2 & 0x3];
}
static void ext_get_par(struct atafb_par *par)
{
	par->screen_base = external_addr;
}
int init_module(void)
{
	return 0;
}
int init_module(void)
{
	return 0;
}
int init_module(void)
{
	return 0;
}
int init_module(void)
{
	return 0;
}
static void init_backlight(struct atmel_lcdfb_info *sinfo)
{
	dev_warn(&sinfo->pdev->dev, "backlight control is not available\n");
}
static int __init atmel_lcdfb_init(void)
{
	return platform_driver_probe(&atmel_lcdfb_driver, atmel_lcdfb_probe);
}
static void __exit atmel_lcdfb_exit(void)
{
	platform_driver_unregister(&atmel_lcdfb_driver);
}
static inline u32 _aty_ld_le32(volatile unsigned int regindex, 
			       const struct aty128fb_par *par)
{
	return readl (par->regbase + regindex);
}
static inline void _aty_st_le32(volatile unsigned int regindex, u32 val, 
				const struct aty128fb_par *par)
{
	writel (val, par->regbase + regindex);
}
static inline u8 _aty_ld_8(unsigned int regindex,
			   const struct aty128fb_par *par)
{
	return readb (par->regbase + regindex);
}
static inline void _aty_st_8(unsigned int regindex, u8 val,
			     const struct aty128fb_par *par)
{
	writeb (val, par->regbase + regindex);
}
static int aty_pll_readupdate(const struct aty128fb_par *par)
{
	return !(aty_ld_pll(PPLL_REF_DIV) & PPLL_ATOMIC_UPDATE_R);
}
static int aty128_bl_get_brightness(struct backlight_device *bd)
{
	return bd->props.brightness;
}
static void __exit aty128fb_exit(void)
{
	pci_unregister_driver(&aty128fb_driver);
}
static int aty_bl_get_brightness(struct backlight_device *bd)
{
	return bd->props.brightness;
}
static void __exit atyfb_exit(void)
{
	pci_unregister_driver(&atyfb_driver);
}
static int dummy(void)
{
	return 0;
}
static u32 aty_pll_18818_to_var(const struct fb_info *info,
				const union aty_pll *pll)
{
	return (pll->ics2595.period_in_ps);	/* default for now */
}
static u32 aty_pll_1703_to_var(const struct fb_info *info,
			       const union aty_pll *pll)
{
	return (pll->ics2595.period_in_ps);	/* default for now */
}
static u32 aty_pll_8398_to_var(const struct fb_info *info,
			       const union aty_pll *pll)
{
	return (pll->ics2595.period_in_ps);	/* default for now */
}
static u32 aty_pll_408_to_var(const struct fb_info *info,
			      const union aty_pll *pll)
{
	return (pll->ics2595.period_in_ps);	/* default for now */
}
static int dummy(void)
{
	return 0;
}
static int radeon_bl_get_brightness(struct backlight_device *bd)
{
	return bd->props.brightness;
}
static ssize_t radeon_show_one_edid(char *buf, loff_t off, size_t count, const u8 *edid)
{
	return memory_read_from_buffer(buf, count, &off, edid, EDID_LENGTH);
}
static void __exit radeonfb_exit (void)
{
	pci_unregister_driver (&radeonfb_driver);
}
static inline int radeon_apply_workarounds(struct radeonfb_info *rinfo)
{
        return 0;
}
static int radeon_check_power_loss(struct radeonfb_info *rinfo)
{
	return rinfo->save_regs[4] != INPLL(CLK_PIN_CNTL) ||
	       rinfo->save_regs[2] != INPLL(MCLK_CNTL) ||
	       rinfo->save_regs[3] != INPLL(SCLK_CNTL);
}
int au1100fb_fb_cursor(struct fb_info *info, struct fb_cursor *cursor)
{
	if (nocursor)
		return 0;
	else
		return -EINVAL;	/* just to force soft_cursor() call */
}
static int au1200fb_drv_suspend(struct platform_device *dev, u32 state)
{
	return 0;
}
static int au1200fb_drv_resume(struct platform_device *dev)
{
	return 0;
}
static void __exit au1200fb_cleanup(void)
{
	platform_driver_unregister(&au1200fb_driver);
}
static int __init atmel_pwm_bl_init(void)
{
	return platform_driver_probe(&atmel_pwm_bl_driver, atmel_pwm_bl_probe);
}
static void __exit atmel_pwm_bl_exit(void)
{
	platform_driver_unregister(&atmel_pwm_bl_driver);
}
static void backlight_unregister_fb(struct backlight_device *bd)
{
	fb_unregister_client(&bd->fb_notif);
}
static inline int backlight_register_fb(struct backlight_device *bd)
{
	return 0;
}
static void __exit backlight_class_exit(void)
{
	class_destroy(backlight_class);
}
static void lcdtg_i2c_wait_ack(struct corgi_lcd *lcd, uint8_t base)
{
	lcdtg_i2c_send_bit(lcd, base);
}
static int __init corgi_lcd_init(void)
{
	return spi_register_driver(&corgi_lcd_driver);
}
static void __exit corgi_lcd_exit(void)
{
	spi_unregister_driver(&corgi_lcd_driver);
}
static int __init da903x_backlight_init(void)
{
	return platform_driver_register(&da903x_backlight_driver);
}
static void __exit da903x_backlight_exit(void)
{
	platform_driver_unregister(&da903x_backlight_driver);
}
static int genericbl_get_intensity(struct backlight_device *bd)
{
	return genericbl_intensity;
}
static int __init genericbl_init(void)
{
	return platform_driver_register(&genericbl_driver);
}
static void __exit genericbl_exit(void)
{
	platform_driver_unregister(&genericbl_driver);
}
static int hp680bl_get_intensity(struct backlight_device *bd)
{
	return current_intensity;
}
static inline struct ili9320 *to_our_lcd(struct lcd_device *lcd)
{
	return lcd_get_data(lcd);
}
void ili9320_shutdown(struct ili9320 *lcd)
{
	ili9320_power(lcd, FB_BLANK_POWERDOWN);
}
static int kb3886bl_get_intensity(struct backlight_device *bd)
{
	return kb3886bl_intensity;
}
static void __exit kb3886_exit(void)
{
	platform_driver_unregister(&kb3886bl_driver);
}
static void lcd_unregister_fb(struct lcd_device *ld)
{
	fb_unregister_client(&ld->fb_notif);
}
static int lcd_register_fb(struct lcd_device *ld)
{
	return 0;
}
static void __exit lcd_class_exit(void)
{
	class_destroy(lcd_class);
}
static int locomolcd_get_intensity(struct backlight_device *bd)
{
	return current_intensity;
}
static void __exit locomolcd_exit(void)
{
	locomo_driver_unregister(&poodle_lcd_driver);
}
static int __init ltv350qv_init(void)
{
	return spi_register_driver(&ltv350qv_driver);
}
static void __exit ltv350qv_exit(void)
{
	spi_unregister_driver(&ltv350qv_driver);
}
static void inline omapbl_send_intensity(int intensity)
{
	omap_writeb(intensity, OMAP_PWL_ENABLE);
}
static void inline omapbl_send_enable(int enable)
{
	omap_writeb(enable, OMAP_PWL_CLK_ENABLE);
}
static int __init omapbl_init(void)
{
	return platform_driver_register(&omapbl_driver);
}
static void __exit omapbl_exit(void)
{
	platform_driver_unregister(&omapbl_driver);
}
static inline struct platform_lcd *to_our_lcd(struct lcd_device *lcd)
{
	return lcd_get_data(lcd);
}
static int __init platform_lcd_init(void)
{
	return platform_driver_register(&platform_lcd_driver);
}
static void __exit platform_lcd_cleanup(void)
{
	platform_driver_unregister(&platform_lcd_driver);
}
static int pwm_backlight_get_brightness(struct backlight_device *bl)
{
	return bl->props.brightness;
}
static int __init pwm_backlight_init(void)
{
	return platform_driver_register(&pwm_backlight_driver);
}
static void __exit pwm_backlight_exit(void)
{
	platform_driver_unregister(&pwm_backlight_driver);
}
static int tdo24m_power_off(struct tdo24m *lcd)
{
	return tdo24m_writes(lcd, lcd_panel_off);
}
static int __init tdo24m_init(void)
{
	return spi_register_driver(&tdo24m_driver);
}
static void __exit tdo24m_exit(void)
{
	spi_unregister_driver(&tdo24m_driver);
}
static int __init tosa_bl_init(void)
{
	return i2c_add_driver(&tosa_bl_driver);
}
static void __exit tosa_bl_exit(void)
{
	i2c_del_driver(&tosa_bl_driver);
}
int tosa_bl_enable(struct spi_device *spi, int enable)
{
	return tosa_tg_send(spi, TG_GPODR2, enable? 0x01 : 0x00);
}
static int __init tosa_lcd_init(void)
{
	return spi_register_driver(&tosa_lcd_driver);
}
static void __exit tosa_lcd_exit(void)
{
	spi_unregister_driver(&tosa_lcd_driver);
}
static int vgg2432a4_suspend(struct spi_device *spi, pm_message_t state)
{
	return ili9320_suspend(dev_get_drvdata(&spi->dev), state);
}
static int vgg2432a4_resume(struct spi_device *spi)
{
	return ili9320_resume(dev_get_drvdata(&spi->dev));
}
static int __devexit vgg2432a4_remove(struct spi_device *spi)
{
	return ili9320_remove(dev_get_drvdata(&spi->dev));
}
static void vgg2432a4_shutdown(struct spi_device *spi)
{
	ili9320_shutdown(dev_get_drvdata(&spi->dev));
}
static int __init vgg2432a4_init(void)
{
	return spi_register_driver(&vgg2432a4_driver);
}
static void __exit vgg2432a4_exit(void)
{
	spi_unregister_driver(&vgg2432a4_driver);
}
int bfin_bf54x_fb_cursor(struct fb_info *info, struct fb_cursor *cursor)
{
	if (nocursor)
		return 0;
	else
		return -EINVAL;	/* just to force soft_cursor() call */
}
static int bl_get_brightness(struct backlight_device *bd)
{
	return 0;
}
static int bfin_lcd_get_power(struct lcd_device *dev)
{
	return 0;
}
static int bfin_lcd_set_power(struct lcd_device *dev, int power)
{
	return 0;
}
static int bfin_lcd_get_contrast(struct lcd_device *dev)
{
	return 0;
}
static int bfin_lcd_set_contrast(struct lcd_device *dev, int contrast)
{
	return 0;
}
static int __devinit bfin_bf54x_driver_init(void)
{
	return platform_driver_register(&bfin_bf54x_driver);
}
static void __exit bfin_bf54x_driver_cleanup(void)
{
	platform_driver_unregister(&bfin_bf54x_driver);
}
static inline void bfin_t350mcqb_disable_ppi(void)
{
	bfin_write_PPI_CONTROL(bfin_read_PPI_CONTROL() & ~PORT_EN);
}
static inline void bfin_t350mcqb_enable_ppi(void)
{
	bfin_write_PPI_CONTROL(bfin_read_PPI_CONTROL() | PORT_EN);
}
int bfin_t350mcqb_fb_cursor(struct fb_info *info, struct fb_cursor *cursor)
{
	if (nocursor)
		return 0;
	else
		return -EINVAL;	/* just to force soft_cursor() call */
}
static int bl_get_brightness(struct backlight_device *bd)
{
	return 0;
}
static int bfin_lcd_get_power(struct lcd_device *dev)
{
	return 0;
}
static int bfin_lcd_set_power(struct lcd_device *dev, int power)
{
	return 0;
}
static int bfin_lcd_get_contrast(struct lcd_device *dev)
{
	return 0;
}
static int bfin_lcd_set_contrast(struct lcd_device *dev, int contrast)
{
	return 0;
}
static int __devinit bfin_t350mcqb_driver_init(void)
{
	return platform_driver_register(&bfin_t350mcqb_driver);
}
static void __exit bfin_t350mcqb_driver_cleanup(void)
{
	platform_driver_unregister(&bfin_t350mcqb_driver);
}
static int __init broadsheetfb_init(void)
{
	return platform_driver_register(&broadsheetfb_driver);
}
static void __exit broadsheetfb_exit(void)
{
	platform_driver_unregister(&broadsheetfb_driver);
}
static void __exit bw2_exit(void)
{
	of_unregister_driver(&bw2_driver);
}
static void c_set_disp_reg(const struct carmine_fb *par,
		u32 offset, u32 val)
{
	writel(val, par->display_reg + offset);
}
static u32 c_get_disp_reg(const struct carmine_fb *par,
		u32 offset)
{
	return readl(par->display_reg + offset);
}
static void c_set_hw_reg(const struct carmine_hw *hw,
		u32 offset, u32 val)
{
	writel(val, hw->v_regs + offset);
}
static u32 c_get_hw_reg(const struct carmine_hw *hw,
		u32 offset)
{
	return readl(hw->v_regs + offset);
}
static void __exit carminefb_cleanup(void)
{
	pci_unregister_driver(&carmine_pci_driver);
}
static void __exit cg14_exit(void)
{
	of_unregister_driver(&cg14_driver);
}
static void __exit cg3_exit(void)
{
	of_unregister_driver(&cg3_driver);
}
static void __exit cg6_exit(void)
{
	of_unregister_driver(&cg6_driver);
}
static int chipsfb_blank(int blank, struct fb_info *info)
{
	return 1;	/* get fb_blank to set the colormap to all black */
}
static void __exit chipsfb_exit(void)
{
	pci_unregister_driver(&chipsfb_driver);
}
static
void cirrusfb_dbg_print_byte(const char *name, unsigned char val)
{
	DPRINTK("%8s = 0x%02X (bits 7-0: %c%c%c%c%c%c%c%c)\n",
		name, val,
		val & 0x80 ? '1' : '0',
		val & 0x40 ? '1' : '0',
		val & 0x20 ? '1' : '0',
		val & 0x10 ? '1' : '0',
		val & 0x08 ? '1' : '0',
		val & 0x04 ? '1' : '0',
		val & 0x02 ? '1' : '0',
		val & 0x01 ? '1' : '0');
}
static void cirrusfb_dump(void)
{
	cirrusfb_dbg_reg_dump(NULL);
}
static inline void lcd_write_control(struct fb_info *info, u8 control)
{
	writel((u32)control << 24, info->screen_base);
}
static inline u8 lcd_read_control(struct fb_info *info)
{
	return readl(info->screen_base) >> 24;
}
static inline void lcd_write_data(struct fb_info *info, u8 data)
{
	writel((u32)data << 24, info->screen_base + LCD_DATA_REG_OFFSET);
}
static inline u8 lcd_read_data(struct fb_info *info)
{
	return readl(info->screen_base + LCD_DATA_REG_OFFSET) >> 24;
}
static int __init cobalt_lcdfb_init(void)
{
	return platform_driver_register(&cobalt_lcdfb_driver);
}
static void __exit cobalt_lcdfb_exit(void)
{
	platform_driver_unregister(&cobalt_lcdfb_driver);
}
static const char *dummycon_startup(void)
{
    return "dummy device";
}
static int dummycon_dummy(void)
{
    return 0;
}
static u8 mdacon_build_attr(struct vc_data *c, u8 color, u8 intensity, 
			    u8 blink, u8 underline, u8 reverse, u8 italic)
{
	return (intensity & 3) |
		((underline & 1) << 2) |
		((reverse   & 1) << 3) |
		(!!italic << 4) |
		((blink     & 1) << 7);
}
static void mdacon_putc(struct vc_data *c, int ch, int y, int x)
{
	scr_writew(mda_convert_attr(ch), MDA_ADDR(x, y));
}
static int mdacon_switch(struct vc_data *c)
{
	return 1;	/* redrawing needed */
}
static int mdacon_set_palette(struct vc_data *c, unsigned char *table)
{
	return -EINVAL;
}
static int mdacon_scrolldelta(struct vc_data *c, int lines)
{
	return 0;
}
static void __exit mda_console_exit(void)
{
	give_up_console(&mda_con);
}
static int newport_font_default(struct vc_data *vc, struct console_font *op, char *name)
{
	return newport_set_def_font(vc->vc_num, op);
}
static int newport_font_set(struct vc_data *vc, struct console_font *font, unsigned flags)
{
	return newport_set_font(vc->vc_num, font);
}
static int newport_set_palette(struct vc_data *vc, unsigned char *table)
{
	return -EINVAL;
}
static int newport_scrolldelta(struct vc_data *vc, int lines)
{
	return 0;
}
static int newport_dummy(struct vc_data *c)
{
	return 0;
}
static __inline__ void
promcon_puts(char *buf, int cnt)
{
	prom_printf("%*.*s", cnt, cnt, buf);
}
static int
promcon_switch(struct vc_data *conp)
{
	return 1;
}
static u8 promcon_build_attr(struct vc_data *conp, u8 _color, u8 _intensity,
    u8 _blink, u8 _underline, u8 _reverse, u8 _italic)
{
	return (_reverse) ? 0xf : 0x7;
}
static int promcon_dummy(void)
{
        return 0;
}
static const char *sticon_startup(void)
{
    return "STI console";
}
static int sticon_set_palette(struct vc_data *c, unsigned char *table)
{
    return -EINVAL;
}
static int sticon_switch(struct vc_data *conp)
{
    return 1;	/* needs refreshing */
}
static int sticon_set_origin(struct vc_data *conp)
{
    return 0;
}
static int sticon_scrolldelta(struct vc_data *conp, int lines)
{
    return 0;
}
static void sti_flush(unsigned long start, unsigned long end)
{
	flush_icache_range(start, end);
}
static void __devinit
sti_dump_outptr(struct sti_struct *sti)
{
	DPRINTK((KERN_INFO
		"%d bits per pixel\n"
		"%d used bits\n"
		"%d planes\n"
		"attributes %08x\n",
		 sti->outptr.bits_per_pixel,
		 sti->outptr.bits_used,
		 sti->outptr.planes,
		 sti->outptr.attributes));
}
static struct sti_cooked_font __devinit
*sti_select_fbfont(struct sti_cooked_rom *cooked_rom, const char *fbfont_name)
{
	return NULL;
}
static void __devexit sticore_pci_remove(struct pci_dev *pd)
{
	BUG();
}
static void tile_clear_margins(struct vc_data *vc, struct fb_info *info,
			       int bottom_only)
{
	return;
}
bool vgacon_text_force(void)
{
	return vgacon_text_mode_force ? true : false;
}
static inline void vga_set_mem_top(struct vc_data *c)
{
	write_vga(12, (c->vc_visible_origin - vga_vram_base) / 2);
}
static int vgacon_dummy(struct vc_data *c)
{
	return 0;
}
static inline int VAR_MATCH(struct fb_var_screeninfo *x, struct fb_var_screeninfo *y)
{
	return (!DIRTY(bits_per_pixel) && !DIRTY(xres)
		&& !DIRTY(yres) && !DIRTY(xres_virtual)
		&& !DIRTY(yres_virtual)
		&& !DIRTY_CMAP(red) && !DIRTY_CMAP(green) && !DIRTY_CMAP(blue));
}
void cleanup_module(void)
{
	control_cleanup();
}
static inline void
cyber2000_crtcw(unsigned int reg, unsigned int val, struct cfb_info *cfb)
{
	cyber2000fb_writew((reg & 255) | val << 8, 0x3d4, cfb);
}
static inline void
cyber2000_grphw(unsigned int reg, unsigned int val, struct cfb_info *cfb)
{
	cyber2000fb_writew((reg & 255) | val << 8, 0x3ce, cfb);
}
static inline void
cyber2000_seqw(unsigned int reg, unsigned int val, struct cfb_info *cfb)
{
	cyber2000fb_writew((reg & 255) | val << 8, 0x3c4, cfb);
}
void cyber2000fb_get_fb_var(struct cfb_info *cfb, struct fb_var_screeninfo *var)
{
	memcpy(var, &cfb->fb.var, sizeof(struct fb_var_screeninfo));
}
static int cyberpro_pci_suspend(struct pci_dev *dev, pm_message_t state)
{
	return 0;
}
static void __exit cyberpro_exit(void)
{
	pci_unregister_driver(&cyberpro_driver);
}
static void __exit cyblafb_exit(void)
{
	pci_unregister_driver(&cyblafb_pci_driver);
}
static void __exit display_class_exit(void)
{
	class_destroy(display_class);
}
static inline u8 epson1355_read_reg(struct epson1355_par *par, int index)
{
	return __raw_readb(par->reg_addr + index);
}
static inline void epson1355_write_reg(struct epson1355_par *par, u8 data, int index)
{
	__raw_writeb(data, par->reg_addr + index);
}
void fb_deferred_io_open(struct fb_info *info,
			 struct inode *inode,
			 struct file *file)
{
	file->f_mapping->a_ops = &fb_deferred_io_aops;
}
int fb_register_client(struct notifier_block *nb)
{
	return blocking_notifier_chain_register(&fb_notifier_list, nb);
}
int fb_unregister_client(struct notifier_block *nb)
{
	return blocking_notifier_chain_unregister(&fb_notifier_list, nb);
}
int fb_notifier_call_chain(unsigned long val, void *v)
{
	return blocking_notifier_call_chain(&fb_notifier_list, val, v);
}
void fb_pad_aligned_buffer(u8 *dst, u32 d_pitch, u8 *src, u32 s_pitch, u32 height)
{
	__fb_pad_aligned_buffer(dst, d_pitch, src, s_pitch, height);
}
static inline unsigned safe_shift(unsigned d, int n)
{
	return n < 0 ? d >> -n : d << n;
}
static inline int fb_prepare_extra_logos(struct fb_info *info,
					 unsigned int height,
					 unsigned int yres)
{
	return height;
}
static inline int fb_show_extra_logos(struct fb_info *info, int y, int rotate)
{
	return y;
}
int fb_prepare_logo(struct fb_info *info, int rotate) { return 0; }
int fb_show_logo(struct fb_info *info, int rotate) { return 0; }
static void *fb_seq_start(struct seq_file *m, loff_t *pos)
{
	return (*pos < FB_MAX) ? pos : NULL;
}
static int proc_fb_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &proc_fb_seq_ops);
}
static int edid_is_serial_block(unsigned char *block)
{
	if ((block[0] == 0x00) && (block[1] == 0x00) &&
	    (block[2] == 0x00) && (block[3] == 0xff) &&
	    (block[4] == 0x00))
		return 1;
	else
		return 0;
}
static int edid_is_ascii_block(unsigned char *block)
{
	if ((block[0] == 0x00) && (block[1] == 0x00) &&
	    (block[2] == 0x00) && (block[3] == 0xfe) &&
	    (block[4] == 0x00))
		return 1;
	else
		return 0;
}
static int edid_is_limits_block(unsigned char *block)
{
	if ((block[0] == 0x00) && (block[1] == 0x00) &&
	    (block[2] == 0x00) && (block[3] == 0xfd) &&
	    (block[4] == 0x00))
		return 1;
	else
		return 0;
}
static int edid_is_monitor_block(unsigned char *block)
{
	if ((block[0] == 0x00) && (block[1] == 0x00) &&
	    (block[2] == 0x00) && (block[3] == 0xfc) &&
	    (block[4] == 0x00))
		return 1;
	else
		return 0;
}
static int edid_is_timing_block(unsigned char *block)
{
	if ((block[0] != 0x00) || (block[1] != 0x00) ||
	    (block[2] != 0x00) || (block[4] != 0x00))
		return 1;
	else
		return 0;
}
void fb_destroy_modedb(struct fb_videomode *modedb)
{
	kfree(modedb);
}
int fb_parse_edid(unsigned char *edid, struct fb_var_screeninfo *var)
{
	return 1;
}
void fb_edid_to_monspecs(unsigned char *edid, struct fb_monspecs *specs)
{
	specs = NULL;
}
int fb_get_mode(int flags, u32 val, struct fb_var_screeninfo *var,
		struct fb_info *info)
{
	return -EINVAL;
}
const unsigned char *fb_firmware_edid(struct device *device)
{
	return NULL;
}
void framebuffer_release(struct fb_info *info)
{
	kfree(info);
}
static ssize_t show_blank(struct device *device,
			  struct device_attribute *attr, char *buf)
{
	return 0;
}
static ssize_t store_console(struct device *device,
			     struct device_attribute *attr,
			     const char *buf, size_t count)
{
	return 0;
}
static ssize_t show_console(struct device *device,
			    struct device_attribute *attr, char *buf)
{
	return 0;
}
static ssize_t store_cursor(struct device *device,
			    struct device_attribute *attr,
			    const char *buf, size_t count)
{
	return 0;
}
static ssize_t show_cursor(struct device *device,
			   struct device_attribute *attr, char *buf)
{
	return 0;
}
static void __exit ffb_exit(void)
{
	of_unregister_driver(&ffb_driver);
}
static inline __u32 CNVT_TOHW(__u32 val, __u32 width)
{
	return ((val<<width) + 0x7FFF - val)>>16;
}
static void gbe_reset(void)
{
	gbe->ctrlstat = 0x300aa000;
}
static ssize_t gbefb_show_memsize(struct device *dev, struct device_attribute *attr, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%d\n", gbe_mem_size);
}
static ssize_t gbefb_show_rev(struct device *device, struct device_attribute *attr, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%d\n", gbe_revision);
}
int gx_line_delta(int xres, int bpp)
{
	return (xres * (bpp >> 3) + 7) & ~0x7;
}
unsigned gx1_gx_base(void)
{
	return (gx1_read_conf_reg(CONFIG_GCR) & 0x03) << 30;
}
static void __exit gx1fb_cleanup(void)
{
	pci_unregister_driver(&gx1fb_driver);
}
static int gxfb_blank(int blank_mode, struct fb_info *info)
{
	return gx_blank_display(info, blank_mode);
}
static void __exit gxfb_cleanup(void)
{
	pci_unregister_driver(&gxfb_driver);
}
static int lxfb_blank(int blank_mode, struct fb_info *info)
{
	return lx_blank_display(info, blank_mode);
}
static void __exit lxfb_cleanup(void)
{
	pci_unregister_driver(&lxfb_driver);
}
static int calc_pixclock(struct gxt4500_par *par)
{
	return par->refclk_ps * par->pll_m * par->pll_pd1 * par->pll_pd2
		/ par->pll_n;
}
static void __exit gxt4500_exit(void)
{
	pci_unregister_driver(&gxt4500_driver);
}
static void hecubafb_dpy_deferred_io(struct fb_info *info,
				struct list_head *pagelist)
{
	hecubafb_dpy_update(info->par);
}
static int __init hecubafb_init(void)
{
	return platform_driver_register(&hecubafb_driver);
}
static void __exit hecubafb_exit(void)
{
	platform_driver_unregister(&hecubafb_driver);
}
static inline u8 __iomem * rowaddr(struct fb_info *info, u_int row)
{
	return info->screen_base + HGA_ROWADDR(row);
}
static int __exit hitfb_remove(struct platform_device *dev)
{
	return unregister_framebuffer(&fb_info);
}
static void hpfb_copyarea(struct fb_info *info, const struct fb_copyarea *area) 
{
	topcat_blit(area->sx, area->sy, area->dx, area->dy, area->width, area->height, RR_COPY);
}
void __exit hpfb_cleanup_module(void)
{
	dio_unregister_driver(&hpfb_driver);
}
static inline void i810_report_error(u8 __iomem *mmio)
{
	printk("IIR     : 0x%04x\n"
	       "EIR     : 0x%04x\n"
	       "PGTBL_ER: 0x%04x\n"
	       "IPEIR   : 0x%04x\n"
	       "IPEHR   : 0x%04x\n",
	       i810_readw(IIR, mmio),
	       i810_readb(EIR, mmio),
	       i810_readl(PGTBL_ER, mmio),
	       i810_readl(IPEIR, mmio), 
	       i810_readl(IPEHR, mmio));
}
inline void round_off_yres(u32 *xres, u32 *yres)
{
	*yres = (*xres * 3) >> 2;
}
static void __exit i810fb_exit(void)
{
	pci_unregister_driver(&i810fb_driver);
}
static inline u32 read_reg_le32(volatile u32 __iomem *base, int regindex)
{
	return in_le32(base + regindex);
}
static struct imstt_regvals *
compute_imstt_regvals (struct imstt_par *par, u_int xres, u_int yres)
{
	if (par->ramdac == IBM)
		return compute_imstt_regvals_ibm(par, xres, yres);
	else
		return compute_imstt_regvals_tvp(par, xres, yres);
}
static void __exit imsttfb_exit(void)
{
	pci_unregister_driver(&imsttfb_pci_driver);
}
int __init imxfb_init(void)
{
	return platform_driver_probe(&imxfb_driver, imxfb_probe);
}
static void __exit imxfb_cleanup(void)
{
	platform_driver_unregister(&imxfb_driver);
}
const char * intelfbhw_dvo_to_string(int dvo)
{
	if (dvo & DVOA_PORT)
		return "DVO port A";
	else if (dvo & DVOB_PORT)
		return "DVO port B";
	else if (dvo & DVOC_PORT)
		return "DVO port C";
	else if (dvo & LVDS_PORT)
		return "LVDS port";
	else
		return NULL;
}
static inline unsigned long get_line_length(int x, int bpp)
{
	return (unsigned long)((((x*bpp)+31)&~31) >> 3);
}
static void __exit kyrofb_exit(void)
{
	pci_unregister_driver(&kyrofb_pci_driver);
}
static void __exit leo_exit(void)
{
	of_unregister_driver(&leo_driver);
}
static inline unsigned int g450_vco2f(unsigned char p, unsigned int fvco) {
	return (p & 0x40) ? fvco : fvco >> ((p & 3) + 1);
}
static inline unsigned int g450_f2vco(unsigned char p, unsigned int fin) {
	return (p & 0x40) ? fin : fin << ((p & 3) + 1);
}
unsigned int g450_mnp2f(CPMINFO unsigned int mnp) {
	return g450_vco2f(mnp, g450_mnp2vco(PMINFO mnp));
}
static int g450_testpll(CPMINFO unsigned int mnp, unsigned int pll) {
	return g450_isplllocked(PMINFO g450_setpll(PMINFO mnp, pll));
}
static inline void i2c_maven_done(struct matroxfb_dh_maven_info* minfo2) {
	i2c_bit_bus_del(&minfo2->maven);
}
static inline void i2c_ddc1_done(struct matroxfb_dh_maven_info* minfo2) {
	i2c_bit_bus_del(&minfo2->ddc1);
}
static inline void i2c_ddc2_done(struct matroxfb_dh_maven_info* minfo2) {
	i2c_bit_bus_del(&minfo2->ddc2);
}
static void __exit i2c_matroxfb_exit(void) {
	matroxfb_unregister_driver(&i2c_matroxfb);
}
static void __exit matrox_done(void) {
	pci_unregister_driver(&matroxfb_driver);
}
static void matroxfb_crtc2_exit(void) {
	matroxfb_unregister_driver(&crtc2);
}
static inline int* get_ctrl_ptr(WPMINFO unsigned int idx) {
	return (int*)((char*)MINFO + g450_controls[idx].control);
}
static int* get_ctrl_ptr(struct maven_data* md, int idx) {
	return (int*)((char*)(md->primary_head) + maven_controls[idx].control);
}
static const struct maven_gamma* maven_compute_gamma (const struct maven_data* md) {
 	return maven_gamma + md->primary_head->altout.tvo_params.gamma;
}
static int maven_out_compute(void* md, struct my_timming* mt) {
	return maven_compute_timming(md, mt, &ACCESS_FBINFO(hw).maven);
}
static int maven_out_program(void* md) {
	return maven_program_timming(md, &ACCESS_FBINFO(hw).maven);
}
static int maven_out_start(void* md) {
	return maven_resync(md);
}
static int maven_out_get_queryctrl(void* md, struct v4l2_queryctrl* p) {
        return maven_get_queryctrl(md, p);
}
static int maven_out_get_ctrl(void* md, struct v4l2_control* p) {
	return maven_get_control(md, p);
}
static int maven_out_set_ctrl(void* md, struct v4l2_control* p) {
	return maven_set_control(md, p);
}
static int __init matroxfb_maven_init(void)
{
	return i2c_add_driver(&maven_driver);
}
static void __exit matroxfb_maven_exit(void)
{
	i2c_del_driver(&maven_driver);
}
static void __exit maxinefb_exit(void)
{
	unregister_framebuffer(&fb_info);
}
static inline int h_total(struct fb_var_screeninfo *var)
{
	return var->xres + var->left_margin +
		var->right_margin + var->hsync_len;
}
static inline int v_total(struct fb_var_screeninfo *var)
{
	return var->yres + var->upper_margin +
		var->lower_margin + var->vsync_len;
}
static inline int hsp(struct fb_var_screeninfo *var)
{
	return var->xres + var->right_margin - 1;
}
static inline int vsp(struct fb_var_screeninfo *var)
{
	return var->yres + var->lower_margin - 1;
}
static inline int d_pitch(struct fb_var_screeninfo *var)
{
	return var->xres * var->bits_per_pixel / 8;
}
static ssize_t write_file_dummy(struct file *file, const char __user *buf,
				size_t count, loff_t *ppos)
{
	return count;
}
int __devinit mbxfb_init(void)
{
	return platform_driver_register(&mbxfb_driver);
}
static void __devexit mbxfb_exit(void)
{
	platform_driver_unregister(&mbxfb_driver);
}
static int __init metronomefb_init(void)
{
	return platform_driver_register(&metronomefb_driver);
}
static void __exit metronomefb_exit(void)
{
	platform_driver_unregister(&metronomefb_driver);
}
int fb_mode_is_equal(const struct fb_videomode *mode1,
		     const struct fb_videomode *mode2)
{
	return (mode1->xres         == mode2->xres &&
		mode1->yres         == mode2->yres &&
		mode1->pixclock     == mode2->pixclock &&
		mode1->hsync_len    == mode2->hsync_len &&
		mode1->vsync_len    == mode2->vsync_len &&
		mode1->left_margin  == mode2->left_margin &&
		mode1->right_margin == mode2->right_margin &&
		mode1->upper_margin == mode2->upper_margin &&
		mode1->lower_margin == mode2->lower_margin &&
		mode1->sync         == mode2->sync &&
		mode1->vmode        == mode2->vmode);
}
static u32 mx3fb_read_reg(struct mx3fb_data *mx3fb, unsigned long reg)
{
       return __raw_readl(mx3fb->reg_base + reg);
}
static void mx3fb_write_reg(struct mx3fb_data *mx3fb, u32 value, unsigned long reg)
{
       __raw_writel(value, mx3fb->reg_base + reg);
}
static void __exit mx3fb_exit(void)
{
       platform_driver_unregister(&mx3fb_driver);
}
static unsigned char n411_get_ctl(struct hecubafb_par *par)
{
	return inb(c2io_addr);
}
static void n411_set_data(struct hecubafb_par *par, unsigned char value)
{
	outb(value, dio_addr);
}
static void __exit n411_exit(void)
{
	platform_device_unregister(n411_device);
}
static inline void write_le32(int regindex, u32 val, const struct neofb_par *par)
{
	writel(val, par->neo2200 + par->cursorOff + regindex);
}
static void vgaHWLock(struct vgastate *state)
{
	vga_wcrt(state->vgabase, 0x11, vga_rcrt(state->vgabase, 0x11) | 0x80);
}
static void vgaHWUnlock(void)
{
	vga_wcrt(NULL, 0x11, vga_rcrt(NULL, 0x11) & ~0x80);
}
static inline void neo2200_wait_fifo(struct fb_info *info,
				     int requested_fifo_space)
{
	neo2200_sync(info);
}
static void __exit neofb_exit(void)
{
	pci_unregister_driver(&neofb_driver);
}
static int nvidia_bl_get_brightness(struct backlight_device *bd)
{
	return bd->props.brightness;
}
void NVSetStartAddress(struct nvidia_par *par, u32 start)
{
	NV_WR32(par->PCRTC, 0x800, start);
}
void NVWriteMiscOut(struct nvidia_par *par, u8 value)
{
	VGA_WR08(par->PVIO, VGA_MIS_W, value);
}
u8 NVReadMiscOut(struct nvidia_par *par)
{
	return (VGA_RD08(par->PVIO, VGA_MIS_R));
}
void NVWriteDacMask(struct nvidia_par *par, u8 value)
{
	VGA_WR08(par->PDIO, VGA_PEL_MSK, value);
}
void NVWriteDacReadAddr(struct nvidia_par *par, u8 value)
{
	VGA_WR08(par->PDIO, VGA_PEL_IR, value);
}
void NVWriteDacWriteAddr(struct nvidia_par *par, u8 value)
{
	VGA_WR08(par->PDIO, VGA_PEL_IW, value);
}
void NVWriteDacData(struct nvidia_par *par, u8 value)
{
	VGA_WR08(par->PDIO, VGA_PEL_D, value);
}
u8 NVReadDacData(struct nvidia_par *par)
{
	return (VGA_RD08(par->PDIO, VGA_PEL_D));
}
static void __exit nvidiafb_exit(void)
{
	pci_unregister_driver(&nvidiafb_driver);
}
static void blizzard_stop_sdram(void)
{
	blizzard_write_reg(BLIZZARD_MEM_BANK0_ACTIVATE, 0);
}
static void disable_overlay(void)
{
	blizzard_write_reg(BLIZZARD_DATA_SOURCE_SELECT,
				BLIZZARD_SRC_DISABLE_OVERLAY);
}
static int update_full_screen(void)
{
	return blizzard_update_window_async(blizzard.fbdev->fb_info[0],
				     &blizzard.auto_update_window, NULL, NULL);
}
static enum omapfb_update_mode blizzard_get_update_mode(void)
{
	return blizzard.update_mode;
}
static inline void set_extif_timings(const struct extif_timings *t)
{
	blizzard.extif->set_timings(t);
}
static void blizzard_restore_pll_regs(void)
{
	_restore_regs(blizzard_pll_regs, ARRAY_SIZE(blizzard_pll_regs));
}
static void blizzard_restore_gen_regs(void)
{
	_restore_regs(blizzard_gen_regs, ARRAY_SIZE(blizzard_gen_regs));
}
static void inline dispc_write_reg(int idx, u32 val)
{
	__raw_writel(val, dispc.base + idx);
}
static enum omapfb_update_mode omap_dispc_get_update_mode(void)
{
	return dispc.update_mode;
}
static int omap_dispc_update_window(struct fb_info *fbi,
				 struct omapfb_update_window *win,
				 void (*complete_callback)(void *arg),
				 void *complete_callback_data)
{
	return dispc.update_mode == OMAPFB_UPDATE_DISABLED ? -ENODEV : 0;
}
static void unmap_kern(struct omapfb_mem_region *region)
{
	vunmap(region->vaddr);
}
static void free_palette_ram(void)
{
	dma_free_writecombine(dispc.fbdev->dev, MAX_PALETTE_SIZE,
			dispc.palette_vaddr, dispc.palette_paddr);
}
static void free_fbmem(struct omapfb_mem_region *region)
{
	dma_free_writecombine(dispc.fbdev->dev, region->size,
			      region->vaddr, region->paddr);
}
static void cleanup_resmap(struct resmap *res_map)
{
	kfree(res_map);
}
static inline int resmap_mem_type(unsigned long start)
{
	if (start >= OMAP2_SRAM_START &&
	    start < OMAP2_SRAM_START + OMAP2_SRAM_SIZE)
		return OMAPFB_MEMTYPE_SRAM;
	else
		return OMAPFB_MEMTYPE_SDRAM;
}
static inline int resmap_page_reserved(struct resmap *res_map, unsigned page_nr)
{
	return *RESMAP_PTR(res_map, page_nr) & RESMAP_MASK(page_nr) ? 1 : 0;
}
static void send_frame_complete(void *data)
{
	hwa742.int_ctrl->enable_plane(OMAPFB_PLANE_GFX, 0);
}
static enum omapfb_update_mode hwa742_get_update_mode(void)
{
	return hwa742.update_mode;
}
static int h3_panel_init(struct lcd_panel *panel, struct omapfb_device *fbdev)
{
	return 0;
}
static unsigned long h3_panel_get_caps(struct lcd_panel *panel)
{
	return 0;
}
static int h3_panel_remove(struct platform_device *pdev)
{
	return 0;
}
static int h3_panel_suspend(struct platform_device *pdev, pm_message_t mesg)
{
	return 0;
}
static int h3_panel_resume(struct platform_device *pdev)
{
	return 0;
}
static int h3_panel_drv_init(void)
{
	return platform_driver_register(&h3_panel_driver);
}
static void h3_panel_drv_cleanup(void)
{
	platform_driver_unregister(&h3_panel_driver);
}
static int h4_panel_init(struct lcd_panel *panel, struct omapfb_device *fbdev)
{
	return 0;
}
static int h4_panel_enable(struct lcd_panel *panel)
{
	return 0;
}
static unsigned long h4_panel_get_caps(struct lcd_panel *panel)
{
	return 0;
}
static int h4_panel_remove(struct platform_device *pdev)
{
	return 0;
}
static int h4_panel_suspend(struct platform_device *pdev, pm_message_t mesg)
{
	return 0;
}
static int h4_panel_resume(struct platform_device *pdev)
{
	return 0;
}
static int h4_panel_drv_init(void)
{
	return platform_driver_register(&h4_panel_driver);
}
static void h4_panel_drv_cleanup(void)
{
	platform_driver_unregister(&h4_panel_driver);
}
static int innovator1510_panel_init(struct lcd_panel *panel,
				    struct omapfb_device *fbdev)
{
	return 0;
}
static void innovator1510_panel_disable(struct lcd_panel *panel)
{
	fpga_write(0x0, OMAP1510_FPGA_LCD_PANEL_CONTROL);
}
static unsigned long innovator1510_panel_get_caps(struct lcd_panel *panel)
{
	return 0;
}
static int innovator1510_panel_remove(struct platform_device *pdev)
{
	return 0;
}
static int innovator1510_panel_suspend(struct platform_device *pdev,
				       pm_message_t mesg)
{
	return 0;
}
static int innovator1510_panel_resume(struct platform_device *pdev)
{
	return 0;
}
static int innovator1510_panel_drv_init(void)
{
	return platform_driver_register(&innovator1510_panel_driver);
}
static void innovator1510_panel_drv_cleanup(void)
{
	platform_driver_unregister(&innovator1510_panel_driver);
}
static unsigned long innovator1610_panel_get_caps(struct lcd_panel *panel)
{
	return 0;
}
static int innovator1610_panel_remove(struct platform_device *pdev)
{
	return 0;
}
static int innovator1610_panel_suspend(struct platform_device *pdev,
				       pm_message_t mesg)
{
	return 0;
}
static int innovator1610_panel_resume(struct platform_device *pdev)
{
	return 0;
}
static int innovator1610_panel_drv_init(void)
{
	return platform_driver_register(&innovator1610_panel_driver);
}
static void innovator1610_panel_drv_cleanup(void)
{
	platform_driver_unregister(&innovator1610_panel_driver);
}
static int osk_panel_init(struct lcd_panel *panel, struct omapfb_device *fbdev)
{
	return 0;
}
static unsigned long osk_panel_get_caps(struct lcd_panel *panel)
{
	return 0;
}
static int osk_panel_remove(struct platform_device *pdev)
{
	return 0;
}
static int osk_panel_suspend(struct platform_device *pdev, pm_message_t mesg)
{
	return 0;
}
static int osk_panel_resume(struct platform_device *pdev)
{
	return 0;
}
static int osk_panel_drv_init(void)
{
	return platform_driver_register(&osk_panel_driver);
}
static void osk_panel_drv_cleanup(void)
{
	platform_driver_unregister(&osk_panel_driver);
}
static int palmte_panel_init(struct lcd_panel *panel,
				struct omapfb_device *fbdev)
{
	return 0;
}
static int palmte_panel_enable(struct lcd_panel *panel)
{
	return 0;
}
static unsigned long palmte_panel_get_caps(struct lcd_panel *panel)
{
	return 0;
}
static int palmte_panel_remove(struct platform_device *pdev)
{
	return 0;
}
static int palmte_panel_suspend(struct platform_device *pdev, pm_message_t mesg)
{
	return 0;
}
static int palmte_panel_resume(struct platform_device *pdev)
{
	return 0;
}
static int palmte_panel_drv_init(void)
{
	return platform_driver_register(&palmte_panel_driver);
}
static void palmte_panel_drv_cleanup(void)
{
	platform_driver_unregister(&palmte_panel_driver);
}
static int palmtt_panel_init(struct lcd_panel *panel,
	struct omapfb_device *fbdev)
{
	return 0;
}
static int palmtt_panel_enable(struct lcd_panel *panel)
{
	return 0;
}
static unsigned long palmtt_panel_get_caps(struct lcd_panel *panel)
{
	return OMAPFB_CAPS_SET_BACKLIGHT;
}
static int palmtt_panel_remove(struct platform_device *pdev)
{
	return 0;
}
static int palmtt_panel_suspend(struct platform_device *pdev, pm_message_t mesg)
{
	return 0;
}
static int palmtt_panel_resume(struct platform_device *pdev)
{
	return 0;
}
static int palmtt_panel_drv_init(void)
{
	return platform_driver_register(&palmtt_panel_driver);
}
static void palmtt_panel_drv_cleanup(void)
{
	platform_driver_unregister(&palmtt_panel_driver);
}
static int palmz71_panel_init(struct lcd_panel *panel,
			      struct omapfb_device *fbdev)
{
	return 0;
}
static int palmz71_panel_enable(struct lcd_panel *panel)
{
	return 0;
}
static unsigned long palmz71_panel_get_caps(struct lcd_panel *panel)
{
	return OMAPFB_CAPS_SET_BACKLIGHT;
}
static int palmz71_panel_remove(struct platform_device *pdev)
{
	return 0;
}
static int palmz71_panel_suspend(struct platform_device *pdev,
				 pm_message_t mesg)
{
	return 0;
}
static int palmz71_panel_resume(struct platform_device *pdev)
{
	return 0;
}
static int palmz71_panel_drv_init(void)
{
	return platform_driver_register(&palmz71_panel_driver);
}
static void palmz71_panel_drv_cleanup(void)
{
	platform_driver_unregister(&palmz71_panel_driver);
}
static void inline enable_irqs(int mask)
{
	lcdc.irq_mask |= mask;
}
static void inline disable_irqs(int mask)
{
	lcdc.irq_mask &= ~mask;
}
static enum omapfb_update_mode omap_lcdc_get_update_mode(void)
{
	return lcdc.update_mode;
}
static void omap_lcdc_get_caps(int plane, struct omapfb_caps *caps)
{
	return;
}
void omap_lcdc_free_dma_callback(void)
{
	lcdc.dma_callback = NULL;
}
static void unmap_kern(void)
{
	vunmap(lcdc.vram_virt);
}
static void free_palette_ram(void)
{
	dma_free_writecombine(lcdc.fbdev->dev, MAX_PALETTE_SIZE,
			lcdc.palette_virt, lcdc.palette_phys);
}
static void free_fbmem(void)
{
	dma_free_writecombine(lcdc.fbdev->dev, lcdc.vram_size,
			      lcdc.vram_virt, lcdc.vram_phys);
}
static void omapfb_rqueue_lock(struct omapfb_device *fbdev)
{
	mutex_lock(&fbdev->rqueue_mutex);
}
static void omapfb_rqueue_unlock(struct omapfb_device *fbdev)
{
	mutex_unlock(&fbdev->rqueue_mutex);
}
static void ctrl_cleanup(struct omapfb_device *fbdev)
{
	fbdev->ctrl->cleanup();
}
static int omapfb_open(struct fb_info *info, int user)
{
	return 0;
}
static int omapfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,
			    u_int transp, struct fb_info *info)
{
	return _setcolreg(info, regno, red, green, blue, transp, 1);
}
int omapfb_unregister_client(struct omapfb_notifier_block *omapfb_nb)
{
	return blocking_notifier_chain_unregister(
		&omapfb_client_list[omapfb_nb->plane_idx], &omapfb_nb->nb);
}
static void fbinfo_cleanup(struct omapfb_device *fbdev, struct fb_info *fbi)
{
	fb_dealloc_cmap(&fbi->cmap);
}
static void __exit omapfb_cleanup(void)
{
	platform_driver_unregister(&omapfb_driver);
}
static inline void rfbi_write_reg(int idx, u32 val)
{
	__raw_writel(val, rfbi.base + idx);
}
static inline u32 rfbi_read_reg(int idx)
{
	return __raw_readl(rfbi.base + idx);
}
static int rfbi_get_max_tx_rate(void)
{
	return rfbi.l4_khz * 1000;
}
static inline u32 sossi_read_reg(int reg)
{
	return readl(sossi.base + reg);
}
static inline u16 sossi_read_reg16(int reg)
{
	return readw(sossi.base + reg);
}
static inline u8 sossi_read_reg8(int reg)
{
	return readb(sossi.base + reg);
}
static inline void sossi_write_reg(int reg, u32 value)
{
	writel(value, sossi.base + reg);
}
static inline void sossi_write_reg16(int reg, u16 value)
{
	writew(value, sossi.base + reg);
}
static inline void sossi_write_reg8(int reg, u8 value)
{
	writeb(value, sossi.base + reg);
}
static void sossi_set_bits(int reg, u32 bits)
{
	sossi_write_reg(reg, sossi_read_reg(reg) | bits);
}
static void sossi_clear_bits(int reg, u32 bits)
{
	sossi_write_reg(reg, sossi_read_reg(reg) & ~bits);
}
static void __exit video_output_class_exit(void)
{
	class_unregister(&video_output_class);
}
static int __init video_output_class_init(void)
{
	return class_register(&video_output_class);
}
static void __exit p9100_exit(void)
{
	of_unregister_driver(&p9100_driver);
}
static int platinumfb_check_var (struct fb_var_screeninfo *var, struct fb_info *info)
{
	return platinum_var_to_par(var, info->par, 1);
}
static int platinumfb_blank(int blank,  struct fb_info *fb)
{
	return 0;
}
static inline int platinum_vram_reqd(int video_mode, int color_mode)
{
	return vmode_attrs[video_mode-1].vres *
	       (vmode_attrs[video_mode-1].hres * (1<<color_mode) +
		((video_mode == VMODE_832_624_75) &&
		 (color_mode > CMODE_8)) ? 0x10 : 0x20) + 0x1000;
}
static void __exit platinumfb_exit(void)
{
	of_unregister_platform_driver(&platinum_driver);
}
static inline u32 pm2_RD(struct pm2fb_par *p, s32 off)
{
	return fb_readl(p->v_regs + off);
}
static inline void pm2_WR(struct pm2fb_par *p, s32 off, u32 v)
{
	fb_writel(v, p->v_regs + off);
}
static void __exit pm2fb_exit(void)
{
	pci_unregister_driver(&pm2fb_driver);
}
static inline u32 PM3_READ_REG(struct pm3_par *par, s32 off)
{
	return fb_readl(par->v_regs + off);
}
static inline void PM3_WRITE_REG(struct pm3_par *par, s32 off, u32 v)
{
	fb_writel(v, par->v_regs + off);
}
static void __exit pm3fb_exit(void)
{
	pci_unregister_driver(&pm3fb_driver);
}
static void aafb_get_par(struct aafb_par *par)
{
	*par = current_par;
}
static int aafb_ioctl(struct fb_info *info, u32 cmd, unsigned long arg)
{
	return -ENOIOCTLCMD;
}
static inline void dac_write(struct pmagbafb_par *par, unsigned int reg, u8 v)
{
	writeb(v, par->dac + reg / 4);
}
static inline u8 dac_read(struct pmagbafb_par *par, unsigned int reg)
{
	return readb(par->dac + reg / 4);
}
static void __exit pmagbafb_exit(void)
{
	tc_unregister_driver(&pmagbafb_driver);
}
static inline void sfb_write(struct pmagbbfb_par *par, unsigned int reg, u32 v)
{
	writel(v, par->sfb + reg / 4);
}
static inline u32 sfb_read(struct pmagbbfb_par *par, unsigned int reg)
{
	return readl(par->sfb + reg / 4);
}
static inline void dac_write(struct pmagbbfb_par *par, unsigned int reg, u8 v)
{
	writeb(v, par->dac + reg / 4);
}
static inline u8 dac_read(struct pmagbbfb_par *par, unsigned int reg)
{
	return readb(par->dac + reg / 4);
}
static inline void gp0_write(struct pmagbbfb_par *par, u32 v)
{
	writel(v, par->mmio + PMAGB_B_GP0);
}
static void __exit pmagbbfb_exit(void)
{
	tc_unregister_driver(&pmagbbfb_driver);
}
static int no_cursor(struct fb_info *info, struct fb_cursor *cursor)
{
	return 0;
}
static int rgbfb_mmap(struct fb_info *info, struct vm_area_struct *vma)
{
	return pnx4008_sdum_mmap(info, vma, NULL);
}
static int __init rgbfb_init(void)
{
	return platform_driver_register(&rgbfb_driver);
}
static void __exit rgbfb_exit(void)
{
	platform_driver_unregister(&rgbfb_driver);
}
static u32 nof_pixels_dx(struct dum_ch_setup *ch_setup)
{
	return (ch_setup->xmax - ch_setup->xmin + 1);
}
static u32 nof_pixels_dy(struct dum_ch_setup *ch_setup)
{
	return (ch_setup->ymax - ch_setup->ymin + 1);
}
static u32 nof_pixels_dxy(struct dum_ch_setup *ch_setup)
{
	return (nof_pixels_dx(ch_setup) * nof_pixels_dy(ch_setup));
}
static u32 build_command(int disp_no, u32 reg, u32 val)
{
	return ((disp_no << 26) | BIT(25) | (val << 16) | (disp_no << 10) |
		(reg << 0));
}
static u32 build_double_index(int disp_no, u32 val)
{
	return ((disp_no << 26) | (val << 16) | (disp_no << 10) | (val << 0));
}
int __init sdum_init(void)
{
	return platform_driver_register(&sdum_driver);
}

static void __exit sdum_exit(void)
{
	platform_driver_unregister(&sdum_driver);
}
static const struct fb_videomode *ps3fb_native_vmode(enum ps3av_mode_num id)
{
	return &ps3fb_modedb[FIRST_NATIVE_MODE_INDEX + id - 1];
}
static inline void pvr2fb_set_pal_entry(struct pvr2fb_par *par,
					unsigned int regno,
					unsigned int val)
{
	fb_writel(val, par->mmio_base + 0x1000 + (4 * regno));
}
static inline unsigned long get_line_length(int xres_virtual, int bpp)
{
	return (unsigned long)((((xres_virtual*bpp)+31)&~31) >> 3);
}
static int __init pvr2fb_pci_init(void)
{
	return pci_register_driver(&pvr2fb_pci_driver);
}
static void __exit pvr2fb_pci_exit(void)
{
	pci_unregister_driver(&pvr2fb_pci_driver);
}
static inline unsigned long
lcd_readl(struct pxafb_info *fbi, unsigned int off)
{
	return __raw_readl(fbi->mmio_base + off);
}
static inline void
lcd_writel(struct pxafb_info *fbi, unsigned int off, unsigned long val)
{
	__raw_writel(val, fbi->mmio_base + off);
}
static inline int var_to_depth(struct fb_var_screeninfo *var)
{
	return var->red.length + var->green.length +
		var->blue.length + var->transp.length;
}
static unsigned int pxafb_display_dma_period(struct fb_var_screeninfo *var)
{
	return var->pixclock * 8 * 16 / var->bits_per_pixel;
}
int pxafb_smart_queue(struct fb_info *info, uint16_t *cmds, int n_cmds)
{
	return 0;
}
int pxafb_smart_flush(struct fb_info *info)
{
	return 0;
}
static inline int pxafb_smart_init(struct pxafb_info *fbi) { return 0; }
static void __exit pxafb_exit(void)
{
	platform_driver_unregister(&pxafb_driver);
}
static int riva_bl_get_brightness(struct backlight_device *bd)
{
	return bd->props.brightness;
}
static inline void MISCout(struct riva_par *par, unsigned char val)
{
	VGA_WR08(par->riva.PVIO, 0x3c2, val);
}
static inline unsigned char MISCin(struct riva_par *par)
{
	return (VGA_RD08(par->riva.PVIO, 0x3cc));
}
static void __exit rivafb_exit(void)
{
	pci_unregister_driver(&rivafb_driver);
}
static inline unsigned char MISCin(struct riva_par *par)
{
	return (VGA_RD08(par->riva.PVIO, 0x3cc));
}
static int nv3Busy
(
    RIVA_HW_INST *chip
)
{
    return ((NV_RD32(&chip->Rop->FifoFree, 0) < chip->FifoEmptyCount) ||
	    NV_RD32(&chip->PGRAPH[0x000006B0/4], 0) & 0x01);
}
static int nv4Busy
(
    RIVA_HW_INST *chip
)
{
    return ((NV_RD32(&chip->Rop->FifoFree, 0) < chip->FifoEmptyCount) ||
	    NV_RD32(&chip->PGRAPH[0x00000700/4], 0) & 0x01);
}
static int nv10Busy
(
    RIVA_HW_INST *chip
)
{
    return ((NV_RD32(&chip->Rop->FifoFree, 0) < chip->FifoEmptyCount) ||
	    NV_RD32(&chip->PGRAPH[0x00000700/4], 0) & 0x01);
}
static void SetStartAddress
(
    RIVA_HW_INST *chip,
    unsigned      start
)
{
    NV_WR32(chip->PCRTC, 0x800, start);
}
static void __exit
s1d13xxxfb_exit(void)
{
	platform_driver_unregister(&s1d13xxxfb_driver);
}
static int is_s3c2412(struct s3c2410fb_info *fbi)
{
	return (fbi->drv_type == DRV_S3C2412);
}
static int s3c2410fb_debug_show(struct device *dev,
				struct device_attribute *attr, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%s\n", debug ? "on" : "off");
}
static int __init s3c2410fb_probe(struct platform_device *pdev)
{
	return s3c24xxfb_probe(pdev, DRV_S3C2410);
}
static int __init s3c2412fb_probe(struct platform_device *pdev)
{
	return s3c24xxfb_probe(pdev, DRV_S3C2412);
}
static inline u32 expand_color(u32 c)
{
	return ((c & 1) | ((c & 2) << 7) | ((c & 4) << 14) | ((c & 8) << 21)) * 0xFF;
}
static inline u32 expand_pixel(u32 c)
{
	return (((c &  1) << 24) | ((c &  2) << 27) | ((c &  4) << 14) | ((c &   8) << 17) |
		((c & 16) <<  4) | ((c & 32) <<  7) | ((c & 64) >>  6) | ((c & 128) >>  3)) * 0xF;
}
static inline unsigned int sa1100fb_display_dma_period(struct fb_var_screeninfo *var)
{
	return var->pixclock * 8 * 16 / var->bits_per_pixel;
}
static unsigned int sa1100fb_min_dma_period(struct sa1100fb_info *fbi)
{
	return sa1100fb_display_dma_period(&fbi->fb.var);
}
int __init sa1100fb_setup(char *options)
{
	return 0;
}
static unsigned long get_line_length(int xres_virtual, int bpp)
{
	return (xres_virtual * bytes_per_pixel(bpp));
}
static int __init sh7760fb_init(void)
{
	return platform_driver_register(&sh7760_lcdc_driver);
}
static void __exit sh7760fb_exit(void)
{
	platform_driver_unregister(&sh7760_lcdc_driver);
}
static void lcdc_write_chan(struct sh_mobile_lcdc_chan *chan,
			    int reg_nr, unsigned long data)
{
	iowrite32(data, chan->lcdc->base + chan->reg_offs[reg_nr]);
}
static unsigned long lcdc_read_chan(struct sh_mobile_lcdc_chan *chan,
				    int reg_nr)
{
	return ioread32(chan->lcdc->base + chan->reg_offs[reg_nr]);
}
static void lcdc_write(struct sh_mobile_lcdc_priv *priv,
		       unsigned long reg_offs, unsigned long data)
{
	iowrite32(data, priv->base + reg_offs);
}
static unsigned long lcdc_read(struct sh_mobile_lcdc_priv *priv,
			       unsigned long reg_offs)
{
	return ioread32(priv->base + reg_offs);
}
static int lcdc_chan_is_sublcd(struct sh_mobile_lcdc_chan *chan)
{
	return chan->cfg.chan == LCDC_CHAN_SUBLCD;
}
static int __init sh_mobile_lcdc_init(void)
{
	return platform_driver_register(&sh_mobile_lcdc_driver);
}
static void __exit sh_mobile_lcdc_exit(void)
{
	platform_driver_unregister(&sh_mobile_lcdc_driver);
}
void
SiS_SetRegByte(SISIOADDRESS port, unsigned short data)
{
   OutPortByte(port, data);
}
void
SiS_SetRegShort(SISIOADDRESS port, unsigned short data)
{
   OutPortWord(port, data);
}
void
SiS_SetRegLong(SISIOADDRESS port, unsigned int data)
{
   OutPortLong(port, data);
}
unsigned char
SiS_GetRegByte(SISIOADDRESS port)
{
   return(InPortByte(port));
}
unsigned short
SiS_GetRegShort(SISIOADDRESS port)
{
   return(InPortWord(port));
}
unsigned int
SiS_GetRegLong(SISIOADDRESS port)
{
   return(InPortLong(port));
}
void
SiS_DisplayOn(struct SiS_Private *SiS_Pr)
{
   SiS_SetRegAND(SiS_Pr->SiS_P3c4,0x01,0xDF);
}
void
SiS_DisplayOff(struct SiS_Private *SiS_Pr)
{
   SiS_SetRegOR(SiS_Pr->SiS_P3c4,0x01,0x20);
}
void
SiS_SetEnableDstn(struct SiS_Private *SiS_Pr, int enable)
{
   SiS_Pr->SiS_IF_DEF_DSTN = enable ? 1 : 0;
}
void
SiS_SetEnableFstn(struct SiS_Private *SiS_Pr, int enable)
{
   SiS_Pr->SiS_IF_DEF_FSTN = enable ? 1 : 0;
}
static void
SiS_ResetSegmentReg(struct SiS_Private *SiS_Pr)
{
   SiS_SetSegmentReg(SiS_Pr, 0);
}
static void
SiS_ResetSegmentRegOver(struct SiS_Private *SiS_Pr)
{
   SiS_SetSegmentRegOver(SiS_Pr, 0);
}
static void
SiS_HandleCRT1(struct SiS_Private *SiS_Pr)
{
   SiS_SetRegAND(SiS_Pr->SiS_P3d4,SiS_Pr->SiS_MyCR63,0xbf);
}
static void
SiS_GenericDelay(struct SiS_Private *SiS_Pr, unsigned short delay)
{
   SiS_DDC2Delay(SiS_Pr, delay * 36);
}
unsigned short
SiS_GetResInfo(struct SiS_Private *SiS_Pr, unsigned short ModeNo, unsigned short ModeIdIndex)
{
   if(ModeNo <= 0x13)
      return ((unsigned short)SiS_Pr->SiS_SModeIDTable[ModeIdIndex].St_ResInfo);
   else
      return ((unsigned short)SiS_Pr->SiS_EModeIDTable[ModeIdIndex].Ext_RESINFO);
}
static
unsigned short
SiS_GetCH70xx(struct SiS_Private *SiS_Pr, unsigned short tempbx)
{
  if(SiS_Pr->SiS_IF_DEF_CH70xx == 1)
     return SiS_GetCH700x(SiS_Pr, tempbx);
  else
     return SiS_GetCH701x(SiS_Pr, tempbx);
}
static unsigned int
GetOEMTVPtr661_2_OLD(struct SiS_Private *SiS_Pr)
{
   return (GetOEMTVPtr661_2_GEN(SiS_Pr, 8));
}
static int
sisfb_get_cmap_len(const struct fb_var_screeninfo *var)
{
	return (var->bits_per_pixel == 8) ? 256 : 16;
}
static int
sisfb_open(struct fb_info *info, int user)
{
	return 0;
}
static int
sisfb_release(struct fb_info *info, int user)
{
	return 0;
}
static int xxxfb_open(struct fb_info *info, int user)
{
    return 0;
}
static int xxxfb_release(struct fb_info *info, int user)
{
    return 0;
}
static int xxxfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
{
    return 0;	   	
}
static int xxxfb_pan_display(struct fb_var_screeninfo *var,
			     struct fb_info *info)
{
    return 0;
}
static int xxxfb_blank(int blank_mode, struct fb_info *info)
{
    return 0;
}
int xxxfb_sync(struct fb_info *info)
{
	return 0;
}
static void __exit xxxfb_exit(void)
{
	pci_unregister_driver(&xxxfb_driver);
}
static inline int h_total(struct fb_var_screeninfo *var)
{
	return var->xres + var->left_margin +
		var->right_margin + var->hsync_len;
}
static inline int v_total(struct fb_var_screeninfo *var)
{
	return var->yres + var->upper_margin +
		var->lower_margin + var->vsync_len;
}
static inline void sm501fb_sync_regs(struct sm501fb_info *info)
{
	readl(info->regs);
}
static int sm501fb_check_var_crt(struct fb_var_screeninfo *var,
				 struct fb_info *info)
{
	return sm501fb_check_var(var, info);
}
static int sm501fb_check_var_pnl(struct fb_var_screeninfo *var,
				 struct fb_info *info)
{
	return sm501fb_check_var(var, info);
}
static int __devinit sm501fb_init(void)
{
	return platform_driver_register(&sm501fb_driver);
}
static void __exit sm501fb_cleanup(void)
{
	platform_driver_unregister(&sm501fb_driver);
}
static void sstfb_clear_screen(struct fb_info *info)
{
	fb_memset(info->screen_base, 0, info->fix.smem_len);
}
static void __devexit sstfb_exit(void)
{
	pci_unregister_driver(&sstfb_driver);
}
static void __exit s3d_exit(void)
{
	pci_unregister_driver(&s3d_driver);
}
static void __exit e3d_exit(void)
{
	pci_unregister_driver(&e3d_driver);
}
int svga_get_tilemax(struct fb_info *info)
{
	return 256;
}
static inline u32 abs_diff(u32 a, u32 b)
{
	return (a > b) ? (a - b) : (b - a);
}
static void __exit tcx_exit(void)
{
	of_unregister_driver(&tcx_driver);
}
static inline int mtrr_add(unsigned long base, unsigned long size,
				unsigned int type, char increment)
{
    return -ENODEV;
}
static inline int mtrr_del(int reg, unsigned long base,
				unsigned long size)
{
    return -ENODEV;
}
static inline u8 vga_inb(struct tdfx_par *par, u32 reg)
{
	return inb(par->iobase + reg - 0x300);
}
static inline void vga_outb(struct tdfx_par *par, u32 reg, u8 val)
{
	outb(val, par->iobase + reg - 0x300);
}
static inline u32 tdfx_inl(struct tdfx_par *par, unsigned int reg)
{
	return readl(par->regbase_virt + reg);
}
static inline void tdfx_outl(struct tdfx_par *par, unsigned int reg, u32 val)
{
	writel(val, par->regbase_virt + reg);
}
static void __exit tdfxfb_exit(void)
{
	pci_unregister_driver(&tdfxfb_driver);
}
static int __devinit
tgafb_pci_register(struct pci_dev *pdev, const struct pci_device_id *ent)
{
	return tgafb_register(&pdev->dev);
}
static void __devexit
tgafb_pci_unregister(struct pci_dev *pdev)
{
	tgafb_unregister(&pdev->dev);
}
static int tmiofb_blank(int blank, struct fb_info *info)
{
	return 0;
}
static void __exit tmiofb_cleanup(void)
{
	platform_driver_unregister(&tmiofb_driver);
}
static inline int is_oldclock(int id)
{
	return	(id == TGUI9440) ||
		(id == TGUI9660) ||
		(id == CYBER9320);
}
static inline int is_oldprotect(int id)
{
	return	is_oldclock(id) ||
		(id == PROVIDIA9685) ||
		(id == CYBER9382) ||
		(id == CYBER9385);
}
static inline int is_blade(int id)
{
	return	(id == BLADE3D) ||
		(id == CYBERBLADEE4) ||
		(id == CYBERBLADEi7) ||
		(id == CYBERBLADEi7D) ||
		(id == CYBERBLADEi1) ||
		(id == CYBERBLADEi1D) ||
		(id == CYBERBLADEAi1) ||
		(id == CYBERBLADEAi1D);
}
static inline int is_xp(int id)
{
	return	(id == CYBERBLADEXPAi1) ||
		(id == CYBERBLADEXPm8) ||
		(id == CYBERBLADEXPm16);
}
static inline int is3Dchip(int id)
{
	return	is_blade(id) || is_xp(id) ||
		(id == CYBER9397) || (id == CYBER9397DVD) ||
		(id == CYBER9520) || (id == CYBER9525DVD) ||
		(id == IMAGE975) || (id == IMAGE985);
}
static inline void t_outb(struct tridentfb_par *p, u8 val, u16 reg)
{
	fb_writeb(val, p->io_virt + reg);
}
static inline u8 t_inb(struct tridentfb_par *p, u16 reg)
{
	return fb_readb(p->io_virt + reg);
}
static inline void writemmr(struct tridentfb_par *par, u16 r, u32 v)
{
	fb_writel(v, par->io_virt + r);
}
static inline u32 readmmr(struct tridentfb_par *par, u16 r)
{
	return fb_readl(par->io_virt + r);
}
static inline unsigned char read3X4(struct tridentfb_par *par, int reg)
{
	return vga_mm_rcrt(par->io_virt, reg);
}
static inline void write3X4(struct tridentfb_par *par, int reg,
			    unsigned char val)
{
	vga_mm_wcrt(par->io_virt, reg, val);
}
static inline unsigned char read3CE(struct tridentfb_par *par,
				    unsigned char reg)
{
	return vga_mm_rgfx(par->io_virt, reg);
}
static inline void write3CE(struct tridentfb_par *par, int reg,
			    unsigned char val)
{
	vga_mm_wgfx(par->io_virt, reg, val);
}
static inline void crtc_unlock(struct tridentfb_par *par)
{
	write3X4(par, VGA_CRTC_V_SYNC_END,
		 read3X4(par, VGA_CRTC_V_SYNC_END) & 0x7F);
}
static inline void shadowmode_on(struct tridentfb_par *par)
{
	write3CE(par, CyberControl, read3CE(par, CyberControl) | 0x81);
}
static inline void shadowmode_off(struct tridentfb_par *par)
{
	write3CE(par, CyberControl, read3CE(par, CyberControl) & 0x7E);
}
static void __exit tridentfb_exit(void)
{
	pci_unregister_driver(&tridentfb_pci_driver);
}
static ssize_t show_v86d(struct device_driver *dev, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%s\n", v86d_path);
}
static int param_get_scroll(char *buffer, struct kernel_param *kp)
{
	return 0;
}
static inline int valkyrie_par_to_var(struct fb_par_valkyrie *par,
				      struct fb_var_screeninfo *var)
{
	return mac_vmode_to_var(par->vmode, par->cmode, var);
}
static int crvml_nearest_clock(const struct vml_sys *sys, int clock)
{
	return crvml_clocks[crvml_nearest_index(sys, clock)];
}
static int vmlfb_open(struct fb_info *info, int user)
{
	return 0;
}
static int vmlfb_release(struct fb_info *info, int user)
{
	return 0;
}
static void vml_wait_vblank(struct vml_info *vinfo)
{
	mdelay(20);
}
static int vmlfb_sync(struct fb_info *info)
{
	return 0;
}
static int vmlfb_cursor(struct fb_info *info, struct fb_cursor *cursor)
{
	return -EINVAL;	/* just to force soft_cursor() call */
}
static void __exit vmlfb_cleanup(void)
{
	pci_unregister_driver(&vmlfb_pci_driver);
}
static inline int selectmask(void)
{
	return vga_io_rgfx(VGA_GFX_BIT_MASK);
}
static inline void setmask(int mask)
{
	vga_io_w(VGA_GFX_D, mask);
}
static inline int getindex(void)
{
	return vga_io_r(VGA_GFX_I);
}
static inline void setindex(int index)
{
	vga_io_w(VGA_GFX_I, index);
}
static int check_tmds_chip(int device_id_subaddr, int device_id)
{
	if (tmds_register_read(device_id_subaddr) == device_id)
		return OK;
	else
		return FAIL;
}
static int check_lvds_chip(int device_id_subaddr, int device_id)
{
	if (lvds_register_read(device_id_subaddr) == device_id)
		return OK;
	else
		return FAIL;
}
void viafb_delete_i2c_buss(void *par)
{
	i2c_del_adapter(&((struct viafb_par *)par)->i2c_stuff.adapter);
}
static int get_clk_range_index(u32 Clk)
{
	if (Clk < DPA_CLK_30M)
		return DPA_CLK_RANGE_30M;
	else if (Clk < DPA_CLK_50M)
		return DPA_CLK_RANGE_30_50M;
	else if (Clk < DPA_CLK_70M)
		return DPA_CLK_RANGE_50_70M;
	else if (Clk < DPA_CLK_100M)
		return DPA_CLK_RANGE_70_100M;
	else if (Clk < DPA_CLK_150M)
		return DPA_CLK_RANGE_100_150M;
	else
		return DPA_CLK_RANGE_150M;
}
static inline u32 expand_color(u32 c)
{
	return ((c & 1) | ((c & 2) << 7) | ((c & 4) << 14) | ((c & 8) << 21)) * 0xFF;
}
static inline u32 expand_pixel(u32 c)
{
	return (((c &  1) << 24) | ((c &  2) << 27) | ((c &  4) << 14) | ((c &   8) << 17) |
		((c & 16) <<  4) | ((c & 32) <<  7) | ((c & 64) >>  6) | ((c & 128) >>  3)) * 0xF;
}
static void w100fb_clear_screen(struct w100fb_par *par)
{
	memset_io(remapped_fbuf + (W100_FB_BASE-MEM_WINDOW_BASE), 0, (par->xres * par->yres * BITS_PER_PIXEL/8));
}
int __devinit w100fb_init(void)
{
	return platform_driver_register(&w100fb_driver);
}
void __exit w100fb_cleanup(void)
{
	platform_driver_unregister(&w100fb_driver);
}
static unsigned long vmalloc_to_mfn(void *address)
{
	return pfn_to_mfn(vmalloc_to_pfn(address));
}
static void __exit xenfb_cleanup(void)
{
	xenbus_unregister_driver(&xenfb_driver);
}
static int
xilinxfb_platform_remove(struct platform_device *pdev)
{
	return xilinxfb_release(&pdev->dev);
}
static int __devexit xilinxfb_of_remove(struct of_device *op)
{
	return xilinxfb_release(&op->dev);
}
static inline void __exit xilinxfb_of_unregister(void)
{
	of_unregister_platform_driver(&xilinxfb_of_driver);
}
static inline int __init xilinxfb_of_register(void) { return 0; }
static void add_status(struct virtio_device *dev, unsigned status)
{
	dev->config->set_status(dev, dev->config->get_status(dev) | status);
}
void unregister_virtio_driver(struct virtio_driver *driver)
{
	driver_unregister(&driver->driver);
}
void unregister_virtio_device(struct virtio_device *dev)
{
	device_unregister(&dev->dev);
}
static void __exit virtio_exit(void)
{
	bus_unregister(&virtio_bus);
}
static int __init init(void)
{
	return register_virtio_driver(&virtio_balloon);
}
static void __exit fini(void)
{
	unregister_virtio_driver(&virtio_balloon);
}
static struct virtio_pci_device *to_vp_device(struct virtio_device *vdev)
{
	return container_of(vdev, struct virtio_pci_device, vdev);
}
static inline bool more_used(const struct vring_virtqueue *vq)
{
	return vq->last_used_idx != vq->vring.used->idx;
}
void vring_del_virtqueue(struct virtqueue *vq)
{
	kfree(to_vvq(vq));
}
static inline void ds1wm_write_register(struct ds1wm_data *ds1wm_data, u32 reg,
					u8 val)
{
	__raw_writeb(val, ds1wm_data->map + (reg << ds1wm_data->bus_shift));
}
static inline u8 ds1wm_read_register(struct ds1wm_data *ds1wm_data, u32 reg)
{
	return __raw_readb(ds1wm_data->map + (reg << ds1wm_data->bus_shift));
}
static void __exit ds1wm_exit(void)
{
	platform_driver_unregister(&ds1wm_driver);
}
static int __init sensors_ds2482_init(void)
{
	return i2c_add_driver(&ds2482_driver);
}
static void __exit sensors_ds2482_exit(void)
{
	i2c_del_driver(&ds2482_driver);
}
static inline void ds_print_msg(unsigned char *buf, unsigned char *str, int off)
{
	printk(KERN_INFO "%45s: %8x\n", str, buf[off]);
}
static void ds_w1_fini(struct ds_device *dev)
{
	w1_remove_master_device(&dev->master);
}
static void ds_fini(void)
{
	usb_deregister(&ds_driver);
}
static int __init matrox_w1_init(void)
{
	return pci_register_driver(&matrox_w1_pci_driver);
}
static void __exit matrox_w1_fini(void)
{
	pci_unregister_driver(&matrox_w1_pci_driver);
}
static int __init mxc_w1_init(void)
{
	return platform_driver_register(&mxc_w1_driver);
}
static void mxc_w1_exit(void)
{
	platform_driver_unregister(&mxc_w1_driver);
}
static inline u8 hdq_reg_in(struct hdq_data *hdq_data, u32 offset)
{
	return __raw_readb(hdq_data->hdq_base + offset);
}
static inline void hdq_reg_out(struct hdq_data *hdq_data, u32 offset, u8 val)
{
	__raw_writeb(val, hdq_data->hdq_base + offset);
}
static u8 omap_w1_reset_bus(void *_hdq)
{
	return 0;
}
static int __init
omap_hdq_init(void)
{
	return platform_driver_register(&omap_hdq_driver);
}
static void __exit
omap_hdq_exit(void)
{
	platform_driver_unregister(&omap_hdq_driver);
}
static int __init w1_gpio_init(void)
{
	return platform_driver_probe(&w1_gpio_driver, w1_gpio_probe);
}
static void __exit w1_gpio_exit(void)
{
	platform_driver_unregister(&w1_gpio_driver);
}
static void __exit w1_bq27000_exit(void)
{
	w1_unregister_family(&w1_bq27000_family);
}
static int w1_f2d_add_slave(struct w1_slave *sl)
{
	return sysfs_create_bin_file(&sl->dev.kobj, &w1_f2d_bin_attr);
}

static void w1_f2d_remove_slave(struct w1_slave *sl)
{
	sysfs_remove_bin_file(&sl->dev.kobj, &w1_f2d_bin_attr);
}
static int __init w1_f2d_init(void)
{
	return w1_register_family(&w1_family_2d);
}

static void __exit w1_f2d_fini(void)
{
	w1_unregister_family(&w1_family_2d);
}
static int __init w1_f23_init(void)
{
	return w1_register_family(&w1_family_23);
}
static void __exit w1_f23_fini(void)
{
	w1_unregister_family(&w1_family_23);
}
int w1_ds2760_read(struct device *dev, char *buf, int addr, size_t count)
{
	return w1_ds2760_io(dev, buf, addr, count, 0);
}
int w1_ds2760_write(struct device *dev, char *buf, int addr, size_t count)
{
	return w1_ds2760_io(dev, buf, addr, count, 1);
}
static int w1_therm_add_slave(struct w1_slave *sl)
{
	return device_create_file(&sl->dev, &w1_therm_attr);
}
static void w1_therm_remove_slave(struct w1_slave *sl)
{
	device_remove_file(&sl->dev, &w1_therm_attr);
}
static int w1_master_match(struct device *dev, struct device_driver *drv)
{
	return 1;
}
static int w1_master_probe(struct device *dev)
{
	return -ENODEV;
}
static int w1_default_add_slave(struct w1_slave *sl)
{
	return sysfs_create_bin_file(&sl->dev.kobj, &w1_default_attr);
}
static void w1_default_remove_slave(struct w1_slave *sl)
{
	sysfs_remove_bin_file(&sl->dev.kobj, &w1_default_attr);
}
int w1_create_master_attributes(struct w1_master *master)
{
	return sysfs_create_group(&master->dev.kobj, &w1_master_defattr_group);
}
void w1_destroy_master_attributes(struct w1_master *master)
{
	sysfs_remove_group(&master->dev.kobj, &w1_master_defattr_group);
}
static int w1_uevent(struct device *dev, struct kobj_uevent_env *env)
{
	return 0;
}
static void __w1_family_put(struct w1_family *f)
{
	atomic_dec(&f->refcnt);
}
static void w1_free_dev(struct w1_master *dev)
{
	device_unregister(&dev->dev);
}
static void w1_delay(unsigned long tm)
{
	udelay(tm * w1_delay_parm);
}
void w1_next_pullup(struct w1_master *dev, int delay)
{
	dev->pullup_duration = delay;
}
int w1_init_netlink(void)
{
	return 0;
}
static void acq_keepalive(void)
{
	inb_p(wdt_start);
}
static void acq_stop(void)
{
	inb_p(wdt_stop);
}
static void acq_shutdown(struct platform_device *dev)
{
	acq_stop();
}
static void advwdt_ping(void)
{
	outb_p(timeout, wdt_start);
}
static void advwdt_disable(void)
{
	inb_p(wdt_stop);
}
static void advwdt_shutdown(struct platform_device *dev)
{
	advwdt_disable();
}
static void ali_keepalive(void)
{
	ali_start();
}
static void wdt_keepalive(void)
{
	next_heartbeat = jiffies + (timeout * HZ);
}
static void at32_wdt_shutdown(struct platform_device *pdev)
{
	at32_wdt_stop();
}
static int __init at32_wdt_init(void)
{
	return platform_driver_probe(&at32_wdt_driver, at32_wdt_probe);
}
static void __exit at32_wdt_exit(void)
{
	platform_driver_unregister(&at32_wdt_driver);
}
static inline void at91_wdt_stop(void)
{
	at91_sys_write(AT91_ST_WDMR, AT91_ST_EXTEN);
}
static inline void at91_wdt_reload(void)
{
	at91_sys_write(AT91_ST_CR, AT91_ST_WDRST);
}
static void at91wdt_shutdown(struct platform_device *pdev)
{
	at91_wdt_stop();
}
static void __exit at91_wdt_exit(void)
{
	platform_driver_unregister(&at91wdt_driver);
}
static inline void at91_wdt_reset(void)
{
	at91_sys_write(AT91_WDT_CR, AT91_WDT_KEY | AT91_WDT_WDRSTT);
}
static int at91wdt_suspend(struct platform_device *pdev, pm_message_t message)
{
	return 0;
}
static int at91wdt_resume(struct platform_device *pdev)
{
	return 0;
}
static int __init at91sam_wdt_init(void)
{
	return platform_driver_probe(&at91wdt_driver, at91wdt_probe);
}
static void __exit at91sam_wdt_exit(void)
{
	platform_driver_unregister(&at91wdt_driver);
}
static void __booke_wdt_ping(void *data)
{
	mtspr(SPRN_TSR, TSR_ENW|TSR_WIS);
}
static void booke_wdt_ping(void)
{
	on_each_cpu(__booke_wdt_ping, NULL, 0);
}
static void __exit booke_wdt_exit(void)
{
	misc_deregister(&booke_wdt_miscdev);
}
static int __devinit cpu5wdt_init_module(void)
{
	return cpu5wdt_init();
}
static void __devexit cpu5wdt_exit_module(void)
{
	cpu5wdt_exit();
}
static void cpwd_writew(u16 val, void __iomem *addr)
{
	writew(cpu_to_le16(val), addr);
}
static void cpwd_writeb(u8 val, void __iomem *addr)
{
	writeb(val, addr);
}
static u8 cpwd_readb(void __iomem *addr)
{
	return readb(addr);
}
static int cpwd_release(struct inode *inode, struct file *file)
{
	return 0;
}
static ssize_t cpwd_read(struct file * file, char __user *buffer,
			 size_t count, loff_t *ppos)
{
	return -EINVAL;
}
static int __init cpwd_init(void)
{
	return of_register_driver(&cpwd_driver, &of_bus_type);
}
static void __exit cpwd_exit(void)
{
	of_unregister_driver(&cpwd_driver);
}
static int __init davinci_wdt_init(void)
{
	return platform_driver_register(&platform_wdt_driver);
}

static void __exit davinci_wdt_exit(void)
{
	platform_driver_unregister(&platform_wdt_driver);
}
static void wdt_enable(void)
{
	__raw_writew(0xaaaa, EP93XX_WDT_WATCHDOG);
}
static void wdt_disable(void)
{
	__raw_writew(0xaa55, EP93XX_WDT_WATCHDOG);
}
static inline void wdt_ping(void)
{
	__raw_writew(0x5555, EP93XX_WDT_WATCHDOG);
}
static void wdt_keepalive(void)
{
	next_heartbeat = jiffies + (timeout * HZ);
}
static inline void eurwdt_lock_chip(void)
{
	outb(0xaa, io);
}
static inline void eurwdt_set_timeout(int timeout)
{
	eurwdt_write_reg(WDT_TIMEOUT_VAL, (u8) timeout);
}
static inline void eurwdt_disable_timer(void)
{
	eurwdt_set_timeout(0);
}
static void eurwdt_ping(void)
{
	eurwdt_set_timeout(eurwdt_timeout);
}
static void gef_wdt_service(void)
{
	gef_wdt_toggle_wdc(GEF_WDC_ENABLED_TRUE,
		GEF_WDC_SERVICE_SHIFT);
}
static void __exit gef_wdt_exit(void)
{
	of_unregister_platform_driver(&gef_wdt_driver);
}
static void geodewdt_shutdown(struct platform_device *dev)
{
	geodewdt_disable();
}
static void hpwdt_ping(void)
{
	iowrite16(reload, hpwdt_timer_reg);
}
static void __exit hpwdt_cleanup(void)
{
	pci_unregister_driver(&hpwdt_driver);
}
static int __init hpwdt_init(void)
{
	return pci_register_driver(&hpwdt_driver);
}
static void supermicro_old_pre_keepalive(unsigned long acpibase)
{
	outb(0x08, TCO1_STS);
}
static void supermicro_new_lock_watchdog(void)
{
	outb(SM_ENDWATCH, SM_REGINDEX);
}
static void __exit iTCO_vendor_exit_module(void)
{
	printk(KERN_INFO PFX "Module Unloaded\n");
}
static inline unsigned int seconds_to_ticks(int seconds)
{
	return (seconds * 10) / 6;
}
static void iTCO_wdt_shutdown(struct platform_device *dev)
{
	iTCO_wdt_stop();
}
static void ibwdt_shutdown(struct platform_device *dev)
{
	ibwdt_disable();
}
static void indydog_ping(void)
{
	sgimc->watchdogt = 0;
}
static unsigned long iop_watchdog_timeout(void)
{
	return (0xffffffffUL / get_iop_tick_rate());
}
static void __exit iop_wdt_exit(void)
{
	misc_deregister(&iop_wdt_miscdev);
}
static inline void it8712f_wdt_ping(void)
{
	inb(address);
}
static int it8712f_wdt_get_status(void)
{
	if (superio_inb(WDT_CONTROL) & 0x01)
		return WDIOF_CARDRESET;
	else
		return 0;
}
static void __exit ixp2000_wdt_exit(void)
{
	misc_deregister(&ixp2000_wdt_miscdev);
}
static void __exit ixp4xx_wdt_exit(void)
{
	misc_deregister(&ixp4xx_wdt_miscdev);
}
static void ks8695wdt_shutdown(struct platform_device *pdev)
{
	ks8695_wdt_stop();
}
static void __exit ks8695_wdt_exit(void)
{
	platform_driver_unregister(&ks8695wdt_driver);
}
static inline void zf_set_status(unsigned char new)
{
	zf_writeb(STATUS, new);
}
static inline unsigned short zf_get_control(void)
{
	return zf_readw(CONTROL);
}
static inline void zf_set_control(unsigned short new)
{
	zf_writew(CONTROL, new);
}
static int mpc5200_wdt_get_timeout(struct mpc5200_wdt *wdt)
{
	return wdt->count * 0x10000 / wdt->ipb_freq;
}
static int __init mpc5200_wdt_init(void)
{
	return of_register_platform_driver(&mpc5200_wdt_driver);
}
static void __exit mpc5200_wdt_exit(void)
{
	of_unregister_platform_driver(&mpc5200_wdt_driver);
}
static void mpc8xxx_wdt_pr_warn(const char *msg)
{
	pr_crit("mpc8xxx_wdt: %s, expect the %s soon!\n", msg,
		reset ? "reset" : "machine check exception");
}
static int __init mpc8xxx_wdt_init(void)
{
	return of_register_platform_driver(&mpc8xxx_wdt_driver);
}
static void __exit mpc8xxx_wdt_exit(void)
{
	of_unregister_platform_driver(&mpc8xxx_wdt_driver);
}
static void __exit mpcore_wdt_exit(void)
{
	platform_driver_unregister(&mpcore_wdt_driver);
}
static void mtx1_wdt_reset(void)
{
	ticks = mtx1_wdt_device.default_ticks;
}
static int __init mtx1_wdt_init(void)
{
	return platform_driver_register(&mtx1_wdt);
}
static void __exit mtx1_wdt_exit(void)
{
	platform_driver_unregister(&mtx1_wdt);
}
static void mv64x60_wdt_service(void)
{
	mv64x60_wdt_toggle_wdc(MV64x60_WDC_ENABLED_TRUE,
			       MV64x60_WDC_SERVICE_SHIFT);
}
static void __exit mv64x60_wdt_exit(void)
{
	platform_driver_unregister(&mv64x60_wdt_driver);
}
static void __exit omap_wdt_exit(void)
{
	platform_driver_unregister(&omap_wdt_driver);
}
static void __exit orion5x_wdt_exit(void)
{
	misc_deregister(&orion5x_wdt_miscdev);
}
static int pc87413_status(void)
{
	  return 0; /* currently not supported */
}
static int pcwd_temp_close(struct inode *inode, struct file *file)
{
	return 0;
}
static int __init pcwd_init_module(void)
{
	return isa_register_driver(&pcwd_isa_driver, PCWD_ISA_NR_CARDS);
}
static int pcipcwd_temp_release(struct inode *inode, struct file *file)
{
	return 0;
}
static int usb_pcwd_temperature_open(struct inode *inode, struct file *file)
{
	return nonseekable_open(inode, file);
}
static int usb_pcwd_temperature_release(struct inode *inode, struct file *file)
{
	return 0;
}
static void __exit usb_pcwd_exit(void)
{
	usb_deregister(&usb_pcwd_driver);
}
static void pikawdt_keepalive(void)
{
	pikawdt_private.next_heartbeat = jiffies + heartbeat * HZ;
}
static int __init pnx4008_wdt_init(void)
{
	return platform_driver_register(&platform_wdt_driver);
}

static void __exit pnx4008_wdt_exit(void)
{
	platform_driver_unregister(&platform_wdt_driver);
}
static void rc32434_wdt_reset(void)
{
	ticks = rc32434_wdt_device.default_ticks;
}
static int __init rc32434_wdt_init(void)
{
	return platform_driver_register(&rc32434_wdt);
}
static void __exit rc32434_wdt_exit(void)
{
	platform_driver_unregister(&rc32434_wdt);
}
static void rdc321x_wdt_reset(void)
{
	ticks = rdc321x_wdt_device.default_ticks;
}
static int __init rdc321x_wdt_init(void)
{
	return platform_driver_register(&rdc321x_wdt_driver);
}
static void __exit rdc321x_wdt_exit(void)
{
	platform_driver_unregister(&rdc321x_wdt_driver);
}
static int riowd_release(struct inode *inode, struct file *filp)
{
	return 0;
}
static int __init riowd_init(void)
{
	return of_register_driver(&riowd_driver, &of_bus_type);
}
static void __exit riowd_exit(void)
{
	of_unregister_driver(&riowd_driver);
}
static void __exit wdt_gpi_cleanup_module(void)
{
	platform_driver_unregister(&wdt_gpi_driver);
}
static void s3c2410wdt_shutdown(struct platform_device *dev)
{
	s3c2410wdt_stop();
}
static void __exit watchdog_exit(void)
{
	platform_driver_unregister(&s3c2410wdt_driver);
}
static void __exit sa1100dog_exit(void)
{
	misc_deregister(&sa1100dog_miscdev);
}
static void __exit sbwdog_exit(void)
{
	misc_deregister(&sbwdog_miscdev);
}
static void wdt_keepalive(void)
{
	next_heartbeat = jiffies + (timeout * HZ);
}
static void sbc8360_ping(void)
{
	outb(wd_margin, SBC8360_BASETIME);
}
static void sbc8360_stop(void)
{
	outb(0, SBC8360_ENABLE);
}
static void epx_c3_start(void)
{
	outb(1, EPXC3_WATCHDOG_CTL_REG);
}
static void epx_c3_pet(void)
{
	outb(1, EPXC3_WATCHDOG_PET_REG);
}
static void sc1200wdt_stop(void)
{
	sc1200wdt_write_data(WDTO, 0);
}
static inline void sch311x_sio_enter(int sio_config_port)
{
	outb(0x55, sio_config_port);
}
static inline void sch311x_sio_exit(int sio_config_port)
{
	outb(0xaa, sio_config_port);
}
static void sch311x_wdt_shutdown(struct platform_device *dev)
{
	sch311x_wdt_stop();
}
static inline void close_io_config(void)
{
	outb(0xAA, IOPORT);
}
static inline void gpio_bit12(unsigned char reg)
{
	write_io_cr(0xE2, reg);
}
static inline void gpio_bit13(unsigned char reg)
{
	write_io_cr(0xE3, reg);
}
static inline void wdt_timer_units(unsigned char new_units)
{
	write_io_cr(0xF1, new_units);
}
static inline void wdt_timeout_value(unsigned char new_timeout)
{
	write_io_cr(0xF2, new_timeout);
}
static inline void wdt_timer_conf(unsigned char conf)
{
	write_io_cr(0xF3, conf);
}
static inline void wdt_timer_ctrl(unsigned char reg)
{
	write_io_cr(0xF4, reg);
}
static void wb_smsc_wdt_disable(void)
{
	wb_smsc_wdt_set_timeout(0);
}
static void wb_smsc_wdt_enable(void)
{
	wb_smsc_wdt_set_timeout(timeout);
}
static int wb_smsc_wdt_status(void)
{
	return (wb_smsc_wdt_get_timeout() == 0) ? 0 : WDIOF_KEEPALIVEPING;
}
static int __init watchdog_init(void)
{
	return platform_driver_probe(&txx9wdt_driver, txx9wdt_probe);
}
static void __exit watchdog_exit(void)
{
	platform_driver_unregister(&txx9wdt_driver);
}
static void w83627hf_unselect_wd_register(void)
{
	outb_p(0xAA, WDT_EFER); /* Leave extended function mode */
}
static inline void w83697hf_lock(void)
{
	outb_p(0xAA, W83697HF_EFER);	/* Leave extended function mode */
}
static void w83697hf_write_timeout(int timeout)
{
	w83697hf_set_reg(0xF4, timeout);
}
static inline void w83697hf_deselect_wdt(void)
{
	w83697hf_lock();
}
static void w83697ug_unselect_wd_register(void)
{
	outb_p(0xAA, WDT_EFER); /* Leave extended function mode */
}
static void wdt_keepalive(void)
{
	next_heartbeat = jiffies + (timeout * HZ);
}
static void wafwdt_stop(void)
{
	inb_p(wdt_stop);
}
static void wdrtas_timer_start(void)
{
	wdrtas_set_interval(wdrtas_interval);
}
static void wdrtas_timer_stop(void)
{
	wdrtas_set_interval(0);
}
static int wdrtas_get_status(void)
{
	return 0; /* TODO */
}
static int wdrtas_get_boot_status(void)
{
	return 0; /* TODO */
}
static int wdrtas_temp_open(struct inode *inode, struct file *file)
{
	return nonseekable_open(inode, file);
}
static int wdrtas_temp_close(struct inode *inode, struct file *file)
{
	return 0;
}
static int wdt_temp_open(struct inode *inode, struct file *file)
{
	return nonseekable_open(inode, file);
}
static int wdt_temp_release(struct inode *inode, struct file *file)
{
	return 0;
}
static void watchdog_ping(void)
{
	*CSR_TIMER4_LOAD = reload;
}
static void __exit footbridge_watchdog_exit(void)
{
	misc_deregister(&watchdog_miscdev);
}
static int wdtpci_temp_open(struct inode *inode, struct file *file)
{
	return nonseekable_open(inode, file);
}
static int wdtpci_temp_release(struct inode *inode, struct file *file)
{
	return 0;
}
static void __exit wdtpci_cleanup(void)
{
	pci_unregister_driver(&wdtpci_driver);
}
static int __init wdtpci_init(void)
{
	return pci_register_driver(&wdtpci_driver);
}
static struct wm8350 *get_wm8350(void)
{
	return dev_get_drvdata(wm8350_wdt_miscdev.parent);
}
static int __init wm8350_wdt_init(void)
{
	return platform_driver_register(&wm8350_wdt_driver);
}
static void __exit wm8350_wdt_exit(void)
{
	platform_driver_unregister(&wm8350_wdt_driver);
}
static void scrub_page(struct page *page)
{
	clear_highpage(page);
}
static void balloon_alarm(unsigned long unused)
{
	schedule_work(&balloon_worker);
}
static void balloon_exit(void)
{
    return;
}
static ssize_t show_target_kb(struct sys_device *dev, struct sysdev_attribute *attr,
			      char *buf)
{
	return sprintf(buf, "%lu\n", PAGES2KB(balloon_stats.target_pages));
}
static ssize_t show_target(struct sys_device *dev, struct sysdev_attribute *attr,
			      char *buf)
{
	return sprintf(buf, "%llu\n",
		       (u64)balloon_stats.target_pages << PAGE_SHIFT);
}
static inline unsigned long *cpu_evtchn_mask(int cpu)
{
	return cpu_evtchn_mask_p[cpu].bits;
}
static struct irq_info mk_unbound_info(void)
{
  return (struct irq_info) { .type = IRQT_UNBOUND };
}
static struct irq_info mk_evtchn_info(unsigned short evtchn)
{
	return (struct irq_info) { .type = IRQT_EVTCHN, .evtchn = evtchn,
				      .cpu = 0 };
}
static struct irq_info mk_ipi_info(unsigned short evtchn, enum ipi_vector ipi)
{
	return (struct irq_info) { .type = IRQT_IPI, .evtchn = evtchn,
				      .cpu = 0, .u.ipi = ipi };
}
static struct irq_info mk_virq_info(unsigned short evtchn, unsigned short virq)
{
	return (struct irq_info) { .type = IRQT_VIRQ, .evtchn = evtchn,
				      .cpu = 0, .u.virq = virq };
}
static struct irq_info mk_pirq_info(unsigned short evtchn,
				    unsigned short gsi, unsigned short vector)
{
	return (struct irq_info) { .type = IRQT_PIRQ, .evtchn = evtchn,
			.cpu = 0, .u.pirq = { .gsi = gsi, .vector = vector } };
}
static struct irq_info *info_for_irq(unsigned irq)
{
	return &irq_info[irq];
}
static unsigned int evtchn_from_irq(unsigned irq)
{
	return info_for_irq(irq)->evtchn;
}
static enum xen_irq_type type_from_irq(unsigned irq)
{
	return info_for_irq(irq)->type;
}
static unsigned cpu_from_irq(unsigned irq)
{
	return info_for_irq(irq)->cpu;
}
static inline unsigned long active_evtchns(unsigned int cpu,
					   struct shared_info *sh,
					   unsigned int idx)
{
	return (sh->evtchn_pending[idx] &
		cpu_evtchn_mask(cpu)[idx] &
		~sh->evtchn_mask[idx]);
}
static inline grant_ref_t *__gnttab_entry(grant_ref_t entry)
{
	return &gnttab_list[(entry) / RPP][(entry) % RPP];
}
void gnttab_grant_foreign_access_ref(grant_ref_t ref, domid_t domid,
				     unsigned long frame, int readonly)
{
	update_grant_entry(ref, domid, frame,
			   GTF_permit_access | (readonly ? GTF_readonly : 0));
}
void gnttab_grant_foreign_transfer_ref(grant_ref_t ref, domid_t domid,
				       unsigned long pfn)
{
	update_grant_entry(ref, domid, pfn, GTF_accept_transfer);
}
void gnttab_free_grant_reference(grant_ref_t ref)
{
	put_free_entry(ref);
}
int gnttab_empty_grant_references(const grant_ref_t *private_head)
{
	return (*private_head == GNTTAB_LIST_END);
}
static char *error_path(struct xenbus_device *dev)
{
	return kasprintf(GFP_KERNEL, "error/%s", dev->nodename);
}
static int check_indexes(XENSTORE_RING_IDX cons, XENSTORE_RING_IDX prod)
{
	return ((prod - cons) <= XENSTORE_RING_SIZE);
}
int xb_wait_for_data_to_read(void)
{
	return wait_event_interruptible(xb_waitq, xb_data_to_read());
}
static int read_backend_details(struct xenbus_device *xendev)
{
	return read_otherend_details(xendev, "backend-id", "backend");
}
static int watch_otherend(struct xenbus_device *dev)
{
	return xenbus_watch_pathfmt(dev, &dev->otherend_watch, otherend_changed,
				    "%s/%s", dev->otherend, "state");
}
void xenbus_unregister_driver(struct xenbus_driver *drv)
{
	driver_unregister(&drv->driver);
}
static ssize_t xendev_show_nodename(struct device *dev,
				    struct device_attribute *attr, char *buf)
{
	return sprintf(buf, "%s\n", to_xenbus_device(dev)->nodename);
}
static ssize_t xendev_show_devtype(struct device *dev,
				   struct device_attribute *attr, char *buf)
{
	return sprintf(buf, "%s\n", to_xenbus_device(dev)->devicetype);
}
static ssize_t xendev_show_modalias(struct device *dev,
				    struct device_attribute *attr, char *buf)
{
	return sprintf(buf, "xen:%s\n", to_xenbus_device(dev)->devicetype);
}
void unregister_xenstore_notifier(struct notifier_block *nb)
{
	blocking_notifier_chain_unregister(&xenstore_chain, nb);
}
static int exists_disconnected_device(struct device_driver *drv)
{
	return bus_for_each_dev(&xenbus_frontend.bus, NULL, drv,
				is_disconnected_device);
}
static int xenfs_get_sb(struct file_system_type *fs_type,
			int flags, const char *dev_name,
			void *data, struct vfsmount *mnt)
{
	return get_sb_single(fs_type, flags, data, xenfs_fill_super, mnt);
}
static void * zorro_seq_start(struct seq_file *m, loff_t *pos)
{
	return (*pos < zorro_num_autocon) ? pos : NULL;
}
static int zorro_devices_proc_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &zorro_devices_seq_ops);
}
void zorro_unregister_driver(struct zorro_driver *drv)
{
	driver_unregister(&drv->driver);
}
static int __init zorro_driver_init(void)
{
	return bus_register(&zorro_bus_type);
}
static void __exit exit_v9fs(void)
{
	unregister_filesystem(&v9fs_fs_type);
}
static int
v9fs_open_created(struct inode *inode, struct file *file)
{
	return 0;
}
static int v9fs_vfs_unlink(struct inode *i, struct dentry *d)
{
	return v9fs_remove(i, d, 0);
}
static int v9fs_vfs_rmdir(struct inode *i, struct dentry *d)
{
	return v9fs_remove(i, d, 1);
}
static void v9fs_clear_inode(struct inode *inode)
{
	filemap_fdatawrite(inode->i_mapping);
}
static int adfs_writepage(struct page *page, struct writeback_control *wbc)
{
	return block_write_full_page(page, adfs_get_block, wbc);
}
static int adfs_readpage(struct file *file, struct page *page)
{
	return block_read_full_page(page, adfs_get_block);
}
static sector_t _adfs_bmap(struct address_space *mapping, sector_t block)
{
	return generic_block_bmap(mapping, block, adfs_get_block);
}
static void adfs_destroy_inode(struct inode *inode)
{
	kmem_cache_free(adfs_inode_cachep, ADFS_I(inode));
}
static void destroy_inodecache(void)
{
	kmem_cache_destroy(adfs_inode_cachep);
}
static int adfs_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_bdev(fs_type, flags, dev_name, data, adfs_fill_super,
			   mnt);
}
static int affs_writepage(struct page *page, struct writeback_control *wbc)
{
	return block_write_full_page(page, affs_get_block, wbc);
}
static int affs_readpage(struct file *file, struct page *page)
{
	return block_read_full_page(page, affs_get_block);
}
static sector_t _affs_bmap(struct address_space *mapping, sector_t block)
{
	return generic_block_bmap(mapping,block,affs_get_block);
}
static int
affs_toupper(int ch)
{
	return ch >= 'a' && ch <= 'z' ? ch -= ('a' - 'A') : ch;
}
static int
affs_intl_toupper(int ch)
{
	return (ch >= 'a' && ch <= 'z') || (ch >= 0xE0
		&& ch <= 0xFE && ch != 0xF7) ?
		ch - ('a' - 'A') : ch;
}
static inline toupper_t
affs_get_toupper(struct super_block *sb)
{
	return AFFS_SB(sb)->s_flags & SF_INTL ? affs_intl_toupper : affs_toupper;
}
static int
affs_hash_dentry(struct dentry *dentry, struct qstr *qstr)
{
	return __affs_hash_dentry(dentry, qstr, affs_toupper);
}
static int
affs_intl_hash_dentry(struct dentry *dentry, struct qstr *qstr)
{
	return __affs_hash_dentry(dentry, qstr, affs_intl_toupper);
}
static int
affs_compare_dentry(struct dentry *dentry, struct qstr *a, struct qstr *b)
{
	return __affs_compare_dentry(dentry, a, b, affs_toupper);
}
static int
affs_intl_compare_dentry(struct dentry *dentry, struct qstr *a, struct qstr *b)
{
	return __affs_compare_dentry(dentry, a, b, affs_intl_toupper);
}
static void affs_destroy_inode(struct inode *inode)
{
	kmem_cache_free(affs_inode_cachep, AFFS_I(inode));
}
static void destroy_inodecache(void)
{
	kmem_cache_destroy(affs_inode_cachep);
}
static int affs_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_bdev(fs_type, flags, dev_name, data, affs_fill_super,
			   mnt);
}
void afs_callback_update_kill(void)
{
	destroy_workqueue(afs_callback_update_worker);
}
static void afs_d_release(struct dentry *dentry)
{
	_enter("%s", dentry->d_name.name);
}
static void afs_schedule_lock_extension(struct afs_vnode *vnode)
{
	queue_delayed_work(afs_lock_manager, &vnode->lock_work,
			   AFS_LOCKWAIT * HZ / 2);
}
static void *afs_proc_cells_next(struct seq_file *p, void *v, loff_t *pos)
{
	return seq_list_next(v, &afs_proc_cells, pos);
}
static void afs_proc_cells_stop(struct seq_file *p, void *v)
{
	up_read(&afs_proc_cells_sem);
}
static int afs_proc_rootcell_open(struct inode *inode, struct file *file)
{
	return 0;
}
static int afs_proc_rootcell_release(struct inode *inode, struct file *file)
{
	return 0;
}
static ssize_t afs_proc_rootcell_read(struct file *file, char __user *buf,
				      size_t size, loff_t *_pos)
{
	return 0;
}
static int afs_proc_cell_volumes_release(struct inode *inode, struct file *file)
{
	return seq_release(inode, file);
}
static int afs_proc_cell_vlservers_release(struct inode *inode,
					   struct file *file)
{
	return seq_release(inode, file);
}
static int afs_proc_cell_servers_release(struct inode *inode,
					 struct file *file)
{
	return seq_release(inode, file);
}
static void afs_wake_up_call_waiter(struct afs_call *call)
{
	wake_up(&call->waitq);
}
static inline void clear_timeout(struct aio_timeout *to)
{
	del_singleshot_timer_sync(&to->timer);
}
static int anon_inodefs_get_sb(struct file_system_type *fs_type, int flags,
			       const char *dev_name, void *data,
			       struct vfsmount *mnt)
{
	return get_sb_pseudo(fs_type, "anon_inode:", NULL, ANON_INODE_FS_MAGIC,
			     mnt);
}
static void autofs_delete_usage(struct autofs_dir_ent *ent)
{
	list_del(&ent->exp);
}
static int autofs_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_nodev(fs_type, flags, data, autofs_fill_super, mnt);
}
static int __init init_autofs_fs(void)
{
	return register_filesystem(&autofs_fs_type);
}
static void __exit exit_autofs_fs(void)
{
	unregister_filesystem(&autofs_fs_type);
}
static inline int autofs_get_protover(int __user *p)
{
	return put_user(AUTOFS_PROTO_VERSION, p);
}
static int autofs_dev_ioctl_closemount(struct file *fp,
				       struct autofs_sb_info *sbi,
				       struct autofs_dev_ioctl *param)
{
	return sys_close(param->ioctlfd);
}
static long autofs_dev_ioctl_compat(struct file *file, uint command, ulong u)
{
	return (long) autofs_dev_ioctl(file, command, (ulong) compat_ptr(u));
}
static int autofs_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_nodev(fs_type, flags, data, autofs4_fill_super, mnt);
}
static inline int autofs4_get_protover(struct autofs_sb_info *sbi, int __user *p)
{
	return put_user(sbi->version, p);
}
static inline int autofs4_get_protosubver(struct autofs_sb_info *sbi, int __user *p)
{
	return put_user(sbi->sub_version, p);
}
int is_autofs4_dentry(struct dentry *dentry)
{
	return dentry && dentry->d_inode &&
		(dentry->d_op == &autofs4_root_dentry_operations ||
		 dentry->d_op == &autofs4_dentry_operations) &&
		dentry->d_fsdata != NULL;
}
static loff_t bad_file_llseek(struct file *file, loff_t offset, int origin)
{
	return -EIO;
}
static ssize_t bad_file_read(struct file *filp, char __user *buf,
			size_t size, loff_t *ppos)
{
        return -EIO;
}
static ssize_t bad_file_write(struct file *filp, const char __user *buf,
			size_t siz, loff_t *ppos)
{
        return -EIO;
}
static ssize_t bad_file_aio_read(struct kiocb *iocb, const struct iovec *iov,
			unsigned long nr_segs, loff_t pos)
{
	return -EIO;
}
static ssize_t bad_file_aio_write(struct kiocb *iocb, const struct iovec *iov,
			unsigned long nr_segs, loff_t pos)
{
	return -EIO;
}
static int bad_file_readdir(struct file *filp, void *dirent, filldir_t filldir)
{
	return -EIO;
}
static unsigned int bad_file_poll(struct file *filp, poll_table *wait)
{
	return POLLERR;
}
static int bad_file_ioctl (struct inode *inode, struct file *filp,
			unsigned int cmd, unsigned long arg)
{
	return -EIO;
}
static long bad_file_unlocked_ioctl(struct file *file, unsigned cmd,
			unsigned long arg)
{
	return -EIO;
}
static long bad_file_compat_ioctl(struct file *file, unsigned int cmd,
			unsigned long arg)
{
	return -EIO;
}
static int bad_file_mmap(struct file *file, struct vm_area_struct *vma)
{
	return -EIO;
}
static int bad_file_open(struct inode *inode, struct file *filp)
{
	return -EIO;
}
static int bad_file_flush(struct file *file, fl_owner_t id)
{
	return -EIO;
}
static int bad_file_release(struct inode *inode, struct file *filp)
{
	return -EIO;
}
static int bad_file_fsync(struct file *file, struct dentry *dentry,
			int datasync)
{
	return -EIO;
}
static int bad_file_aio_fsync(struct kiocb *iocb, int datasync)
{
	return -EIO;
}
static int bad_file_fasync(int fd, struct file *filp, int on)
{
	return -EIO;
}
static int bad_file_lock(struct file *file, int cmd, struct file_lock *fl)
{
	return -EIO;
}
static ssize_t bad_file_sendpage(struct file *file, struct page *page,
			int off, size_t len, loff_t *pos, int more)
{
	return -EIO;
}
static unsigned long bad_file_get_unmapped_area(struct file *file,
				unsigned long addr, unsigned long len,
				unsigned long pgoff, unsigned long flags)
{
	return -EIO;
}
static int bad_file_check_flags(int flags)
{
	return -EIO;
}
static int bad_file_flock(struct file *filp, int cmd, struct file_lock *fl)
{
	return -EIO;
}
static ssize_t bad_file_splice_write(struct pipe_inode_info *pipe,
			struct file *out, loff_t *ppos, size_t len,
			unsigned int flags)
{
	return -EIO;
}
static ssize_t bad_file_splice_read(struct file *in, loff_t *ppos,
			struct pipe_inode_info *pipe, size_t len,
			unsigned int flags)
{
	return -EIO;
}
static int bad_inode_create (struct inode *dir, struct dentry *dentry,
		int mode, struct nameidata *nd)
{
	return -EIO;
}
static struct dentry *bad_inode_lookup(struct inode *dir,
			struct dentry *dentry, struct nameidata *nd)
{
	return ERR_PTR(-EIO);
}
static int bad_inode_link (struct dentry *old_dentry, struct inode *dir,
		struct dentry *dentry)
{
	return -EIO;
}
static int bad_inode_unlink(struct inode *dir, struct dentry *dentry)
{
	return -EIO;
}
static int bad_inode_symlink (struct inode *dir, struct dentry *dentry,
		const char *symname)
{
	return -EIO;
}
static int bad_inode_mkdir(struct inode *dir, struct dentry *dentry,
			int mode)
{
	return -EIO;
}
static int bad_inode_rmdir (struct inode *dir, struct dentry *dentry)
{
	return -EIO;
}
static int bad_inode_mknod (struct inode *dir, struct dentry *dentry,
			int mode, dev_t rdev)
{
	return -EIO;
}
static int bad_inode_rename (struct inode *old_dir, struct dentry *old_dentry,
		struct inode *new_dir, struct dentry *new_dentry)
{
	return -EIO;
}
static int bad_inode_readlink(struct dentry *dentry, char __user *buffer,
		int buflen)
{
	return -EIO;
}
static int bad_inode_permission(struct inode *inode, int mask)
{
	return -EIO;
}
static int bad_inode_getattr(struct vfsmount *mnt, struct dentry *dentry,
			struct kstat *stat)
{
	return -EIO;
}
static int bad_inode_setattr(struct dentry *direntry, struct iattr *attrs)
{
	return -EIO;
}
static int bad_inode_setxattr(struct dentry *dentry, const char *name,
		const void *value, size_t size, int flags)
{
	return -EIO;
}
static ssize_t bad_inode_getxattr(struct dentry *dentry, const char *name,
			void *buffer, size_t size)
{
	return -EIO;
}
static ssize_t bad_inode_listxattr(struct dentry *dentry, char *buffer,
			size_t buffer_size)
{
	return -EIO;
}
static int bad_inode_removexattr(struct dentry *dentry, const char *name)
{
	return -EIO;
}
int is_bad_inode(struct inode *inode)
{
	return (inode->i_op == &bad_inode_ops);	
}
static int
befs_leafnode(befs_btree_node * node)
{
	if (node->head.overflow == befs_bt_inval)
		return 1;
	else
		return 0;
}
static char *
befs_bt_keydata(befs_btree_node * node)
{
	return (char *) ((void *) node->od_node + sizeof (befs_btree_nodehead));
}
static int
befs_readpage(struct file *file, struct page *page)
{
	return block_read_full_page(page, befs_get_block);
}
static sector_t
befs_bmap(struct address_space *mapping, sector_t block)
{
	return generic_block_bmap(mapping, block, befs_get_block);
}
static void
befs_destroy_inode(struct inode *inode)
{
        kmem_cache_free(befs_inode_cachep, BEFS_I(inode));
}
static void
befs_destroy_inodecache(void)
{
	kmem_cache_destroy(befs_inode_cachep);
}
static int
befs_get_sb(struct file_system_type *fs_type, int flags, const char *dev_name,
	    void *data, struct vfsmount *mnt)
{
	return get_sb_bdev(fs_type, flags, dev_name, data, befs_fill_super,
			   mnt);
}
static int bfs_writepage(struct page *page, struct writeback_control *wbc)
{
	return block_write_full_page(page, bfs_get_block, wbc);
}
static int bfs_readpage(struct file *file, struct page *page)
{
	return block_read_full_page(page, bfs_get_block);
}
static sector_t bfs_bmap(struct address_space *mapping, sector_t block)
{
	return generic_block_bmap(mapping, block, bfs_get_block);
}
static void bfs_destroy_inode(struct inode *inode)
{
	kmem_cache_free(bfs_inode_cachep, BFS_I(inode));
}
static void destroy_inodecache(void)
{
	kmem_cache_destroy(bfs_inode_cachep);
}
static int bfs_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_bdev(fs_type, flags, dev_name, data, bfs_fill_super, mnt);
}
static int dump_write(struct file *file, const void *addr, int nr)
{
	return file->f_op->write(file, addr, nr, &file->f_pos) == nr;
}
static int __init init_aout_binfmt(void)
{
	return register_binfmt(&aout_format);
}
static void __exit exit_aout_binfmt(void)
{
	unregister_binfmt(&aout_format);
}
static int dump_write(struct file *file, const void *addr, int nr)
{
	return file->f_op->write(file, addr, nr, &file->f_pos) == nr;
}
static size_t get_note_info_size(struct elf_note_info *info)
{
	return info->size;
}
static int __init init_elf_binfmt(void)
{
	return register_binfmt(&elf_format);
}
static void __exit exit_elf_binfmt(void)
{
	unregister_binfmt(&elf_format);
}
static int __init init_elf_fdpic_binfmt(void)
{
	return register_binfmt(&elf_fdpic_format);
}
static void __exit exit_elf_fdpic_binfmt(void)
{
	unregister_binfmt(&elf_fdpic_format);
}
static int dump_write(struct file *file, const void *addr, int nr)
{
	return file->f_op->write(file, addr, nr, &file->f_pos) == nr;
}
static int __init init_em86_binfmt(void)
{
	return register_binfmt(&em86_format);
}
static void __exit exit_em86_binfmt(void)
{
	unregister_binfmt(&em86_format);
}
static int __init init_flat_binfmt(void)
{
	return register_binfmt(&flat_format);
}
static void bm_clear_inode(struct inode *inode)
{
	kfree(inode->i_private);
}
static int bm_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_single(fs_type, flags, data, bm_fill_super, mnt);
}
static int __init init_script_binfmt(void)
{
	return register_binfmt(&script_format);
}
static void __exit exit_script_binfmt(void)
{
	unregister_binfmt(&script_format);
}
static int load_som_library(struct file *f)
{
	return -ENOEXEC;
}
static int __init init_som_binfmt(void)
{
	return register_binfmt(&som_format);
}
static void __exit exit_som_binfmt(void)
{
	unregister_binfmt(&som_format);
}
struct bio_integrity_payload *bio_integrity_alloc(struct bio *bio,
						  gfp_t gfp_mask,
						  unsigned int nr_vecs)
{
	return bio_integrity_alloc_bioset(bio, gfp_mask, nr_vecs, fs_bio_set);
}
void __init bio_integrity_init_slab(void)
{
	bio_integrity_slab = KMEM_CACHE(bio_integrity_payload,
					SLAB_HWCACHE_ALIGN|SLAB_PANIC);
}
unsigned int bvec_nr_vecs(unsigned short idx)
{
	return bvec_slabs[idx].nr_vecs;
}
static void bio_fs_destructor(struct bio *bio)
{
	bio_free(bio, fs_bio_set);
}
int bio_add_pc_page(struct request_queue *q, struct bio *bio, struct page *page,
		    unsigned int len, unsigned int offset)
{
	return __bio_add_page(q, bio, page, len, offset, q->max_hw_sectors);
}
static void bio_map_kern_endio(struct bio *bio, int err)
{
	bio_put(bio);
}
static void biovec_free_pools(struct bio_set *bs)
{
	mempool_destroy(bs->bvec_pool);
}
static inline struct bdev_inode *BDEV_I(struct inode *inode)
{
	return container_of(inode, struct bdev_inode, vfs_inode);
}
inline struct block_device *I_BDEV(struct inode *inode)
{
	return &BDEV_I(inode)->bdev;
}
static int blkdev_writepage(struct page *page, struct writeback_control *wbc)
{
	return block_write_full_page(page, blkdev_get_block, wbc);
}
static int blkdev_readpage(struct file * file, struct page * page)
{
	return block_read_full_page(page, blkdev_get_block);
}
static int block_fsync(struct file *filp, struct dentry *dentry, int datasync)
{
	return sync_blockdev(I_BDEV(filp->f_mapping->host));
}
static int bd_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_pseudo(fs_type, "bdev:", &bdev_sops, 0x62646576, mnt);
}
static inline unsigned long hash(dev_t dev)
{
	return MAJOR(dev)+MINOR(dev);
}
static int bdev_test(struct inode *inode, void *data)
{
	return BDEV_I(inode)->bdev.bd_dev == *(dev_t *)data;
}
void bdput(struct block_device *bdev)
{
	iput(bdev->bd_inode);
}
static void free_bd_holder(struct bd_holder *bo)
{
	kfree(bo);
}
int bd_claim_by_disk(struct block_device *bdev, void *holder,
			struct gendisk *disk)
{
	return bd_claim_by_kobject(bdev, holder, kobject_get(disk->slave_dir));
}
int blkdev_get(struct block_device *bdev, fmode_t mode)
{
	return __blkdev_get(bdev, mode, 0);
}
int blkdev_put(struct block_device *bdev, fmode_t mode)
{
	return __blkdev_put(bdev, mode, 0);
}
static int btrfs_xattr_acl_access_get(struct inode *inode, const char *name,
				      void *value, size_t size)
{
	return btrfs_xattr_get_acl(inode, ACL_TYPE_ACCESS, value, size);
}
static int btrfs_xattr_acl_access_set(struct inode *inode, const char *name,
				      const void *value, size_t size, int flags)
{
	return btrfs_xattr_set_acl(inode, ACL_TYPE_ACCESS, value, size);
}
static int btrfs_xattr_acl_default_get(struct inode *inode, const char *name,
				       void *value, size_t size)
{
	return btrfs_xattr_get_acl(inode, ACL_TYPE_DEFAULT, value, size);
}
static int btrfs_xattr_acl_default_set(struct inode *inode, const char *name,
			       const void *value, size_t size, int flags)
{
	return btrfs_xattr_set_acl(inode, ACL_TYPE_DEFAULT, value, size);
}
int btrfs_acl_chmod(struct inode *inode)
{
	return 0;
}
int btrfs_init_acl(struct inode *inode, struct inode *dir)
{
	return 0;
}
int btrfs_check_acl(struct inode *inode, int mask)
{
	return 0;
}
inline void btrfs_init_path(struct btrfs_path *p)
{
	memset(p, 0, sizeof(*p));
}
static noinline int check_block(struct btrfs_root *root,
				struct btrfs_path *path, int level)
{
	return 0;
}
u32 btrfs_csum_data(struct btrfs_root *root, char *data, u32 seed, size_t len)
{
	return btrfs_crc32c(seed, data, len);
}
void btrfs_csum_final(u32 crc, char *result)
{
	*(__le32 *)result = ~cpu_to_le32(crc);
}
int btrfs_congested_async(struct btrfs_fs_info *info, int iodone)
{
	return atomic_read(&info->nr_async_bios) >
		btrfs_async_submit_limit(info);
}
static int __btree_submit_bio_done(struct inode *inode, int rw, struct bio *bio,
				 int mirror_num, unsigned long bio_flags)
{
	return btrfs_map_bio(BTRFS_I(inode)->root, rw, bio, mirror_num, 1);
}
int btrfs_write_tree_block(struct extent_buffer *buf)
{
	return btrfs_fdatawrite_range(buf->first_page->mapping, buf->start,
				      buf->start + buf->len - 1, WB_SYNC_ALL);
}
int btrfs_wait_tree_block_writeback(struct extent_buffer *buf)
{
	return btrfs_wait_on_page_writeback_range(buf->first_page->mapping,
				  buf->start, buf->start + buf->len - 1);
}
static int block_group_bits(struct btrfs_block_group_cache *cache, u64 bits)
{
	return (cache->flags & bits) == bits;
}
static void btrfs_issue_discard(struct block_device *bdev,
				u64 start, u64 len)
{
	blkdev_issue_discard(bdev, start >> 9, len >> 9, GFP_KERNEL);
}
static unsigned long calc_ra(unsigned long start, unsigned long last,
			     unsigned long nr)
{
	return min(last, start + nr - 1);
}
static int btrfs_next_ref_path(struct btrfs_trans_handle *trans,
			       struct btrfs_root *extent_root,
			       struct btrfs_ref_path *ref_path)
{
	return __next_ref_path(trans, extent_root, ref_path, 0);
}
int set_extent_dirty(struct extent_io_tree *tree, u64 start, u64 end,
		     gfp_t mask)
{
	return set_extent_bit(tree, start, end, EXTENT_DIRTY, 0, NULL,
			      mask);
}
int set_extent_ordered(struct extent_io_tree *tree, u64 start, u64 end,
		       gfp_t mask)
{
	return set_extent_bit(tree, start, end, EXTENT_ORDERED, 0, NULL, mask);
}
int set_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,
		    int bits, gfp_t mask)
{
	return set_extent_bit(tree, start, end, bits, 0, NULL,
			      mask);
}
int clear_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,
		      int bits, gfp_t mask)
{
	return clear_extent_bit(tree, start, end, bits, 0, 0, mask);
}
int set_extent_delalloc(struct extent_io_tree *tree, u64 start, u64 end,
		     gfp_t mask)
{
	return set_extent_bit(tree, start, end,
			      EXTENT_DELALLOC | EXTENT_DIRTY,
			      0, NULL, mask);
}
int clear_extent_dirty(struct extent_io_tree *tree, u64 start, u64 end,
		       gfp_t mask)
{
	return clear_extent_bit(tree, start, end,
				EXTENT_DIRTY | EXTENT_DELALLOC, 0, 0, mask);
}
int clear_extent_ordered(struct extent_io_tree *tree, u64 start, u64 end,
			 gfp_t mask)
{
	return clear_extent_bit(tree, start, end, EXTENT_ORDERED, 1, 0, mask);
}
int set_extent_new(struct extent_io_tree *tree, u64 start, u64 end,
		     gfp_t mask)
{
	return set_extent_bit(tree, start, end, EXTENT_NEW, 0, NULL,
			      mask);
}
static int clear_extent_new(struct extent_io_tree *tree, u64 start, u64 end,
		       gfp_t mask)
{
	return clear_extent_bit(tree, start, end, EXTENT_NEW, 0, 0, mask);
}
int set_extent_uptodate(struct extent_io_tree *tree, u64 start, u64 end,
			gfp_t mask)
{
	return set_extent_bit(tree, start, end, EXTENT_UPTODATE, 0, NULL,
			      mask);
}
static int clear_extent_uptodate(struct extent_io_tree *tree, u64 start,
				 u64 end, gfp_t mask)
{
	return clear_extent_bit(tree, start, end, EXTENT_UPTODATE, 0, 0, mask);
}
static int set_extent_writeback(struct extent_io_tree *tree, u64 start, u64 end,
			 gfp_t mask)
{
	return set_extent_bit(tree, start, end, EXTENT_WRITEBACK,
			      0, NULL, mask);
}
static int clear_extent_writeback(struct extent_io_tree *tree, u64 start,
				  u64 end, gfp_t mask)
{
	return clear_extent_bit(tree, start, end, EXTENT_WRITEBACK, 1, 0, mask);
}
int wait_on_extent_writeback(struct extent_io_tree *tree, u64 start, u64 end)
{
	return wait_extent_bit(tree, start, end, EXTENT_WRITEBACK);
}
int unlock_extent(struct extent_io_tree *tree, u64 start, u64 end,
		  gfp_t mask)
{
	return clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, mask);
}
static void set_page_extent_head(struct page *page, unsigned long len)
{
	set_page_private(page, EXTENT_PAGE_PRIVATE_FIRST_PAGE | len << 2);
}
static inline unsigned long num_extent_pages(u64 start, u64 len)
{
	return ((start + len + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT) -
		(start >> PAGE_CACHE_SHIFT);
}
int wait_on_extent_buffer_writeback(struct extent_io_tree *tree,
				    struct extent_buffer *eb)
{
	return wait_on_extent_writeback(tree, eb->start,
					eb->start + eb->len - 1);
}
void unmap_extent_buffer(struct extent_buffer *eb, char *token, int km)
{
	kunmap_atomic(token, km);
}
int btrfs_check_file(struct btrfs_root *root, struct inode *inode)
{
	return 0;
}
static int btrfs_writepage_end_io_hook(struct page *page, u64 start, u64 end,
				struct extent_state *state, int uptodate)
{
	return btrfs_finish_ordered_io(page->mapping->host, start, end);
}
static inline u8 btrfs_inode_type(struct inode *inode)
{
	return btrfs_type_by_mode[(inode->i_mode & S_IFMT) >> S_SHIFT];
}
static ssize_t btrfs_direct_IO(int rw, struct kiocb *iocb,
			const struct iovec *iov, loff_t offset,
			unsigned long nr_segs)
{
	return -EINVAL;
}
static int btrfs_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,
		__u64 start, __u64 len)
{
	return extent_fiemap(inode, fieinfo, start, len, btrfs_get_extent);
}
struct kmem_cache *btrfs_cache_create(const char *name, size_t size,
				       unsigned long extra_flags,
				       void (*ctor)(void *))
{
	return kmem_cache_create(name, size, 0, (SLAB_RECLAIM_ACCOUNT |
				 SLAB_MEM_SPREAD | extra_flags), ctor);
}
static int btrfs_set_page_dirty(struct page *page)
{
	return __set_page_dirty_nobuffers(page);
}
static inline void spin_nested(struct extent_buffer *eb)
{
	spin_lock_nested(&eb->lock, BTRFS_MAX_LEVEL - btrfs_header_level(eb));
}
static inline void spin_nested(struct extent_buffer *eb)
{
	spin_lock(&eb->lock);
}
int btrfs_tree_locked(struct extent_buffer *eb)
{
	return test_bit(EXTENT_BUFFER_BLOCKING, &eb->bflags) ||
			spin_is_locked(&eb->lock);
}
static void print_dev_item(struct extent_buffer *eb,
			   struct btrfs_dev_item *dev_item)
{
	printk(KERN_INFO "\t\tdev item devid %llu "
	       "total_bytes %llu bytes used %llu\n",
	       (unsigned long long)btrfs_device_id(eb, dev_item),
	       (unsigned long long)btrfs_device_total_bytes(eb, dev_item),
	       (unsigned long long)btrfs_device_bytes_used(eb, dev_item));
}
static void btrfs_write_super(struct super_block *sb)
{
	sb->s_dirt = 0;
}
static int btrfs_interface_init(void)
{
	return misc_register(&btrfs_misc);
}
static ssize_t root_blocks_used_show(struct btrfs_root *root, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%llu\n",
		(unsigned long long)btrfs_root_used(&root->root_item));
}
static ssize_t root_block_limit_show(struct btrfs_root *root, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%llu\n",
		(unsigned long long)btrfs_root_limit(&root->root_item));
}
static ssize_t super_blocks_used_show(struct btrfs_fs_info *fs, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%llu\n",
		(unsigned long long)btrfs_super_bytes_used(&fs->super_copy));
}
static ssize_t super_total_blocks_show(struct btrfs_fs_info *fs, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%llu\n",
		(unsigned long long)btrfs_super_total_bytes(&fs->super_copy));
}
static ssize_t super_blocksize_show(struct btrfs_fs_info *fs, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%llu\n",
		(unsigned long long)btrfs_super_sectorsize(&fs->super_copy));
}
void btrfs_exit_sysfs(void)
{
	kset_unregister(btrfs_kset);
}
struct btrfs_trans_handle *btrfs_start_transaction(struct btrfs_root *root,
						   int num_blocks)
{
	return start_transaction(root, num_blocks, 1);
}
struct btrfs_trans_handle *btrfs_join_transaction(struct btrfs_root *root,
						   int num_blocks)
{
	return start_transaction(root, num_blocks, 0);
}
struct btrfs_trans_handle *btrfs_start_ioctl_transaction(struct btrfs_root *r,
							 int num_blocks)
{
	return start_transaction(r, num_blocks, 2);
}
int btrfs_end_transaction(struct btrfs_trans_handle *trans,
			  struct btrfs_root *root)
{
	return __btrfs_end_transaction(trans, root, 0);
}
int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,
				   struct btrfs_root *root)
{
	return __btrfs_end_transaction(trans, root, 1);
}
void btrfs_lock_volumes(void)
{
	mutex_lock(&uuid_mutex);
}
void btrfs_unlock_volumes(void)
{
	mutex_unlock(&uuid_mutex);
}
static void lock_chunks(struct btrfs_root *root)
{
	mutex_lock(&root->fs_info->chunk_mutex);
}
static void unlock_chunks(struct btrfs_root *root)
{
	mutex_unlock(&root->fs_info->chunk_mutex);
}
static noinline u64 chunk_bytes_by_type(u64 type, u64 calc_size,
					int num_stripes, int sub_stripes)
{
	if (type & (BTRFS_BLOCK_GROUP_RAID1 | BTRFS_BLOCK_GROUP_DUP))
		return calc_size;
	else if (type & BTRFS_BLOCK_GROUP_RAID10)
		return calc_size * (num_stripes / sub_stripes);
	else
		return calc_size * num_stripes;
}
void btrfs_mapping_init(struct btrfs_mapping_tree *tree)
{
	extent_map_tree_init(&tree->map_tree, GFP_NOFS);
}
int btrfs_map_block(struct btrfs_mapping_tree *map_tree, int rw,
		      u64 logical, u64 *length,
		      struct btrfs_multi_bio **multi_ret, int mirror_num)
{
	return __btrfs_map_block(map_tree, rw, logical, length, multi_ret,
				 mirror_num, NULL);
}
static bool btrfs_is_valid_xattr(const char *name)
{
	return !strncmp(name, XATTR_SECURITY_PREFIX,
			XATTR_SECURITY_PREFIX_LEN) ||
	       !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) ||
	       !strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN) ||
	       !strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN);
}
void btrfs_zlib_exit(void)
{
    free_workspaces();
}
void __lock_buffer(struct buffer_head *bh)
{
	wait_on_bit_lock(&bh->b_state, BH_Lock, sync_buffer,
							TASK_UNINTERRUPTIBLE);
}
void __wait_on_buffer(struct buffer_head * bh)
{
	wait_on_bit(&bh->b_state, BH_Lock, sync_buffer, TASK_UNINTERRUPTIBLE);
}
int inode_has_buffers(struct inode *inode)
{
	return !list_empty(&inode->i_data.private_list);
}
static inline void check_irqs_on(void)
{
	BUG_ON(irqs_disabled());
}
void invalidate_bh_lrus(void)
{
	on_each_cpu(invalidate_bh_lru, NULL, 1);
}
static void end_buffer_read_nobh(struct buffer_head *bh, int uptodate)
{
	__end_buffer_read_notouch(bh, uptodate);
}
static inline int buffer_busy(struct buffer_head *bh)
{
	return atomic_read(&bh->b_count) |
		(bh->b_state & ((1 << BH_Dirty) | (1 << BH_Lock)));
}
static void cachefiles_dissociate_pages(struct fscache_cache *cache)
{
	_enter("");
}
static int cachefiles_histogram_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &cachefiles_histogram_ops);
}
static inline int major_to_index(int major)
{
	return major % CHRDEV_MAJOR_HASH_SIZE;
}
static void cdev_unmap(dev_t dev, unsigned count)
{
	kobj_unmap(cdev_map, dev, count);
}
static int cifs_debug_data_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, cifs_debug_data_proc_show, NULL);
}
static int cifs_stats_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, cifs_stats_proc_show, NULL);
}
static int cifsFYI_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, cifsFYI_proc_show, NULL);
}
static int cifs_oplock_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, cifs_oplock_proc_show, NULL);
}
static int cifs_experimental_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, cifs_experimental_proc_show, NULL);
}
static int cifs_linux_ext_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, cifs_linux_ext_proc_show, NULL);
}
static int cifs_lookup_cache_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, cifs_lookup_cache_proc_show, NULL);
}
static int traceSMB_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, traceSMB_proc_show, NULL);
}
static int cifs_multiuser_mount_proc_open(struct inode *inode, struct file *fh)
{
	return single_open(fh, cifs_multiuser_mount_proc_show, NULL);
}
static int cifs_security_flags_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, cifs_security_flags_proc_show, NULL);
}
static void
cifs_spnego_key_destroy(struct key *key)
{
	kfree(key->payload.data);
}
static void
cifs_destroy_inode(struct inode *inode)
{
	kmem_cache_free(cifs_inode_cachep, CIFS_I(inode));
}
static int cifs_show_stats(struct seq_file *s, struct vfsmount *mnt)
{
	return 0;
}
static void
cifs_destroy_inodecache(void)
{
	kmem_cache_destroy(cifs_inode_cachep);
}
static void
dns_resolver_destroy(struct key *key)
{
	kfree(key->payload.data);
}
static inline int cifs_get_disposition(unsigned int flags)
{
	if ((flags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))
		return FILE_CREATE;
	else if ((flags & (O_CREAT | O_TRUNC)) == (O_CREAT | O_TRUNC))
		return FILE_OVERWRITE_IF;
	else if ((flags & O_CREAT) == O_CREAT)
		return FILE_OPEN_IF;
	else if ((flags & O_TRUNC) == O_TRUNC)
		return FILE_OVERWRITE;
	else
		return FILE_OPEN;
}
static __u32
F(__u32 X, __u32 Y, __u32 Z)
{
	return (X & Y) | ((~X) & Z);
}
static __u32
G(__u32 X, __u32 Y, __u32 Z)
{
	return (X & Y) | (X & Z) | (Y & Z);
}
static __u32
H(__u32 X, __u32 Y, __u32 Z)
{
	return X ^ Y ^ Z;
}
void
hmac_md5_update(const unsigned char *text, int text_len,
		struct HMACMD5Context *ctx)
{
	cifs_MD5_update(&ctx->ctx, text, text_len);	/* then text of datagram */
}
unsigned int
smbCalcSize(struct smb_hdr *ptr)
{
	return (sizeof(struct smb_hdr) + (2 * ptr->WordCount) +
		2 /* size of the bcc field */ + BCC(ptr));
}
unsigned int
smbCalcSize_LE(struct smb_hdr *ptr)
{
	return (sizeof(struct smb_hdr) + (2 * ptr->WordCount) +
		2 /* size of the bcc field */ + le16_to_cpu(BCC_LE(ptr)));
}
u64
cifs_UnixTimeToNT(struct timespec t)
{
	return (u64) t.tv_sec * 10000000 + t.tv_nsec/100 + NTFS_TIME_OFFSET;
}
__le64 cnvrtDosCifsTm(__u16 date, __u16 time)
{
	return cpu_to_le64(cifs_UnixTimeToNT(cnvrtDosUnixTm(date, time)));
}
void coda_cache_clear_all(struct super_block *sb)
{
	atomic_inc(&permission_epoch);
}
static inline int coda_fideq(struct CodaFid *fid1, struct CodaFid *fid2)
{
	return memcmp(fid1, fid2, sizeof(*fid1)) == 0;
}
int coda_iscontrol(const char *name, size_t length)
{
	return ((CODA_CONTROLLEN == length) && 
                (strncmp(name, CODA_CONTROL, CODA_CONTROLLEN) == 0));
}
int coda_isroot(struct inode *i)
{
    return ( i->i_sb->s_root->d_inode == i );
}
static int coda_return_EIO(void)
{
	return -EIO;
}
static void coda_destroy_inode(struct inode *inode)
{
	kmem_cache_free(coda_inode_cachep, ITOC(inode));
}
void coda_destroy_inodecache(void)
{
	kmem_cache_destroy(coda_inode_cachep);
}
static void coda_clear_inode(struct inode *inode)
{
	coda_cache_clear_inode(inode);
}
static int coda_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_nodev(fs_type, flags, data, coda_fill_super, mnt);
}
static int coda_ioctl_permission(struct inode *inode, int mask)
{
	return (mask & MAY_EXEC) ? -EACCES : 0;
}
asmlinkage long compat_sys_utimes(char __user *filename, struct compat_timeval __user *t)
{
	return compat_sys_futimesat(AT_FDCWD, filename, t);
}
asmlinkage long
compat_sys_open(const char __user *filename, int flags, int mode)
{
	return do_sys_open(AT_FDCWD, filename, flags, mode);
}
asmlinkage long
compat_sys_openat(unsigned int dfd, const char __user *filename, int flags, int mode)
{
	return do_sys_open(dfd, filename, flags, mode);
}
long asmlinkage compat_sys_nfsservctl(int cmd, void *notused, void *notused2)
{
	return sys_ni_syscall();
}
asmlinkage long compat_sys_signalfd(int ufd,
				    const compat_sigset_t __user *sigmask,
				    compat_size_t sigsetsize)
{
	return compat_sys_signalfd4(ufd, sigmask, sigsetsize, 0);
}
static int do_ioctl32_pointer(unsigned int fd, unsigned int cmd,
			      unsigned long arg, struct file *f)
{
	return sys_ioctl(fd, cmd, (unsigned long)compat_ptr(arg));
}
static __used int
ret_einval(unsigned int fd, unsigned int cmd, unsigned long arg)
{
	return -EINVAL;
}
static int ioc_settimeout(unsigned int fd, unsigned int cmd, unsigned long arg)
{
	return rw_long(fd, AUTOFS_IOC_SETTIMEOUT, arg);
}
static inline unsigned long ioctl32_hash(unsigned long cmd)
{
	return (((cmd >> 6) ^ (cmd >> 4) ^ cmd)) % IOCTL_HASHSIZE;
}
static int configfs_d_delete(struct dentry *dentry)
{
	return 1;
}
static inline unsigned char dt_type(struct configfs_dirent *sd)
{
	return (sd->s_mode >> 12) & 15;
}
static int configfs_open_file(struct inode * inode, struct file * filp)
{
	return check_perm(inode,filp);
}
int __init configfs_inode_init(void)
{
	return bdi_init(&configfs_backing_dev_info);
}
void __exit configfs_inode_exit(void)
{
	bdi_destroy(&configfs_backing_dev_info);
}
static inline struct config_item * to_item(struct list_head * entry)
{
	return container_of(entry,struct config_item,ci_entry);
}
static void config_item_release(struct kref *kref)
{
	config_item_cleanup(container_of(kref, struct config_item, ci_kref));
}
int configfs_is_root(struct config_item *item)
{
	return item == &configfs_root_group.cg_item;
}
static int configfs_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_single(fs_type, flags, data, configfs_fill_super, mnt);
}
int configfs_pin_fs(void)
{
	return simple_pin_fs(&configfs_fs_type, &configfs_mount,
			     &configfs_mnt_count);
}
void configfs_release_fs(void)
{
	simple_release_fs(&configfs_mount, &configfs_mnt_count);
}
static int cramfs_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_bdev(fs_type, flags, dev_name, data, cramfs_fill_super,
			   mnt);
}
struct dentry * dget_locked(struct dentry *dentry)
{
	return __dget_locked(dentry);
}
void shrink_dcache_sb(struct super_block * sb)
{
	__shrink_dcache_sb(sb, NULL, 0);
}
static void _d_rehash(struct dentry * entry)
{
	__d_rehash(entry, d_hash(entry->d_parent, entry->d_name.hash));
}
static int prepend_name(char **buffer, int *buflen, struct qstr *name)
{
	return prepend(buffer, buflen, name->name, name->len);
}
static inline int is_live(void)
{
	return !(list_empty(&dcookie_users));
}
static inline unsigned long dcookie_value(struct dcookie_struct * dcs)
{
	return (unsigned long)dcs->path.dentry;
}
static size_t dcookie_hash(unsigned long dcookie)
{
	return (dcookie >> L1_CACHE_SHIFT) & (hash_size - 1);
}
asmlinkage long SyS_lookup_dcookie(u64 cookie64, long buf, long len)
{
	return SYSC_lookup_dcookie(cookie64, (char __user *) buf, (size_t) len);
}
static ssize_t default_read_file(struct file *file, char __user *buf,
				 size_t count, loff_t *ppos)
{
	return 0;
}
static ssize_t default_write_file(struct file *file, const char __user *buf,
				   size_t count, loff_t *ppos)
{
	return count;
}
struct dentry *debugfs_create_u8(const char *name, mode_t mode,
				 struct dentry *parent, u8 *value)
{
	return debugfs_create_file(name, mode, parent, value, &fops_u8);
}
struct dentry *debugfs_create_u16(const char *name, mode_t mode,
				  struct dentry *parent, u16 *value)
{
	return debugfs_create_file(name, mode, parent, value, &fops_u16);
}
struct dentry *debugfs_create_u32(const char *name, mode_t mode,
				 struct dentry *parent, u32 *value)
{
	return debugfs_create_file(name, mode, parent, value, &fops_u32);
}
struct dentry *debugfs_create_u64(const char *name, mode_t mode,
				 struct dentry *parent, u64 *value)
{
	return debugfs_create_file(name, mode, parent, value, &fops_u64);
}
struct dentry *debugfs_create_x8(const char *name, mode_t mode,
				 struct dentry *parent, u8 *value)
{
	return debugfs_create_file(name, mode, parent, value, &fops_x8);
}
struct dentry *debugfs_create_x16(const char *name, mode_t mode,
				 struct dentry *parent, u16 *value)
{
	return debugfs_create_file(name, mode, parent, value, &fops_x16);
}
struct dentry *debugfs_create_x32(const char *name, mode_t mode,
				 struct dentry *parent, u32 *value)
{
	return debugfs_create_file(name, mode, parent, value, &fops_x32);
}
struct dentry *debugfs_create_size_t(const char *name, mode_t mode,
				     struct dentry *parent, size_t *value)
{
	return debugfs_create_file(name, mode, parent, value, &fops_size_t);
}
struct dentry *debugfs_create_bool(const char *name, mode_t mode,
				   struct dentry *parent, u32 *value)
{
	return debugfs_create_file(name, mode, parent, value, &fops_bool);
}
struct dentry *debugfs_create_blob(const char *name, mode_t mode,
				   struct dentry *parent,
				   struct debugfs_blob_wrapper *blob)
{
	return debugfs_create_file(name, mode, parent, blob, &fops_blob);
}
static inline int debugfs_positive(struct dentry *dentry)
{
	return dentry->d_inode && !d_unhashed(dentry);
}
static int debug_get_sb(struct file_system_type *fs_type,
			int flags, const char *dev_name,
			void *data, struct vfsmount *mnt)
{
	return get_sb_single(fs_type, flags, data, debug_fill_super, mnt);
}
struct dentry *debugfs_create_dir(const char *name, struct dentry *parent)
{
	return debugfs_create_file(name, 
				   S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO,
				   parent, NULL, NULL);
}
static inline struct pts_fs_info *DEVPTS_SB(struct super_block *sb)
{
	return sb->s_fs_info;
}
static inline void update_ptmx_mode(struct pts_fs_info *fsi)
{
       return;
}
static int devpts_get_sb(struct file_system_type *fs_type, int flags,
		const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_single(fs_type, flags, data, devpts_fill_super, mnt);
}
static inline unsigned dio_pages_present(struct dio *dio)
{
	return dio->tail - dio->head;
}
void dlm_astd_stop(void)
{
	kthread_stop(astd_task);
}
void dlm_astd_suspend(void)
{
	mutex_lock(&astd_running);
}
void dlm_astd_resume(void)
{
	mutex_unlock(&astd_running);
}
static struct dlm_cluster *config_item_to_cluster(struct config_item *i)
{
	return i ? container_of(to_config_group(i), struct dlm_cluster, group) :
		   NULL;
}
static struct dlm_space *config_item_to_space(struct config_item *i)
{
	return i ? container_of(to_config_group(i), struct dlm_space, group) :
		   NULL;
}
static struct dlm_comm *config_item_to_comm(struct config_item *i)
{
	return i ? container_of(i, struct dlm_comm, item) : NULL;
}
static struct dlm_node *config_item_to_node(struct config_item *i)
{
	return i ? container_of(i, struct dlm_node, item) : NULL;
}
void dlm_config_exit(void)
{
	configfs_unregister_subsystem(&clusters_root.subsys);
}
static ssize_t comm_nodeid_read(struct dlm_comm *cm, char *buf)
{
	return sprintf(buf, "%d\n", cm->nodeid);
}
static ssize_t comm_local_read(struct dlm_comm *cm, char *buf)
{
	return sprintf(buf, "%d\n", cm->local);
}
static ssize_t node_nodeid_read(struct dlm_node *nd, char *buf)
{
	return sprintf(buf, "%d\n", nd->nodeid);
}
static ssize_t node_weight_read(struct dlm_node *nd, char *buf)
{
	return sprintf(buf, "%d\n", nd->weight);
}
static void put_space(struct dlm_space *sp)
{
	config_item_put(&sp->group.cg_item);
}
static void put_comm(struct dlm_comm *cm)
{
	config_item_put(&cm->item);
}
int dlm_our_nodeid(void)
{
	return local_comm ? local_comm->nodeid : 0;
}
void dlm_unregister_debugfs(void)
{
	debugfs_remove(dlm_root);
}
int dlm_dir_nodeid(struct dlm_rsb *r)
{
	return dlm_hash2nodeid(r->res_ls, r->res_hash);
}
int dlm_dir_lookup(struct dlm_ls *ls, int nodeid, char *name, int namelen,
		   int *r_nodeid)
{
	return get_entry(ls, nodeid, name, namelen, r_nodeid);
}
int dlm_modes_compat(int mode1, int mode2)
{
	return __dlm_compat_matrix[mode1 + 1][mode2 + 1];
}
void dlm_print_lkb(struct dlm_lkb *lkb)
{
	printk(KERN_ERR "lkb: nodeid %d id %x remid %x exflags %x flags %x\n"
	       "     status %d rqmode %d grmode %d wait_type %d ast_type %d\n",
	       lkb->lkb_nodeid, lkb->lkb_id, lkb->lkb_remid, lkb->lkb_exflags,
	       lkb->lkb_flags, lkb->lkb_status, lkb->lkb_rqmode,
	       lkb->lkb_grmode, lkb->lkb_wait_type, lkb->lkb_ast_type);
}
static void dlm_print_rsb(struct dlm_rsb *r)
{
	printk(KERN_ERR "rsb: nodeid %d flags %lx first %x rlc %d name %s\n",
	       r->res_nodeid, r->res_flags, r->res_first_lkid,
	       r->res_recover_locks_count, r->res_name);
}
static inline void dlm_lock_recovery(struct dlm_ls *ls)
{
	down_read(&ls->ls_in_recovery);
}
void dlm_unlock_recovery(struct dlm_ls *ls)
{
	up_read(&ls->ls_in_recovery);
}
int dlm_lock_recovery_try(struct dlm_ls *ls)
{
	return down_read_trylock(&ls->ls_in_recovery);
}
static inline int can_be_queued(struct dlm_lkb *lkb)
{
	return !(lkb->lkb_exflags & DLM_LKF_NOQUEUE);
}
static inline int force_blocking_asts(struct dlm_lkb *lkb)
{
	return (lkb->lkb_exflags & DLM_LKF_NOQUEUEBAST);
}
static inline int is_demoted(struct dlm_lkb *lkb)
{
	return (lkb->lkb_sbflags & DLM_SBF_DEMOTED);
}
static inline int is_altmode(struct dlm_lkb *lkb)
{
	return (lkb->lkb_sbflags & DLM_SBF_ALTMODE);
}
static inline int is_granted(struct dlm_lkb *lkb)
{
	return (lkb->lkb_status == DLM_LKSTS_GRANTED);
}
static inline int is_process_copy(struct dlm_lkb *lkb)
{
	return (lkb->lkb_nodeid && !(lkb->lkb_flags & DLM_IFL_MSTCPY));
}
static inline int down_conversion(struct dlm_lkb *lkb)
{
	return (!middle_conversion(lkb) && lkb->lkb_rqmode < lkb->lkb_grmode);
}
static inline int is_overlap_unlock(struct dlm_lkb *lkb)
{
	return lkb->lkb_flags & DLM_IFL_OVERLAP_UNLOCK;
}
static inline int is_overlap_cancel(struct dlm_lkb *lkb)
{
	return lkb->lkb_flags & DLM_IFL_OVERLAP_CANCEL;
}
static inline int is_overlap(struct dlm_lkb *lkb)
{
	return (lkb->lkb_flags & (DLM_IFL_OVERLAP_UNLOCK |
				  DLM_IFL_OVERLAP_CANCEL));
}
static inline void queue_cast_overlap(struct dlm_rsb *r, struct dlm_lkb *lkb)
{
	queue_cast(r, lkb,
		   is_overlap_unlock(lkb) ? -DLM_EUNLOCK : -DLM_ECANCEL);
}
static inline void hold_rsb(struct dlm_rsb *r)
{
	kref_get(&r->res_ref);
}
void dlm_hold_rsb(struct dlm_rsb *r)
{
	hold_rsb(r);
}
void dlm_put_rsb(struct dlm_rsb *r)
{
	put_rsb(r);
}
static inline void hold_lkb(struct dlm_lkb *lkb)
{
	kref_get(&lkb->lkb_ref);
}
static void remove_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb)
{
	_remove_lock(r, lkb);
}
static int revert_lock_pc(struct dlm_rsb *r, struct dlm_lkb *lkb)
{
	return revert_lock(r, lkb);
}
static void send_blocking_asts(struct dlm_rsb *r, struct dlm_lkb *lkb)
{
	send_bast_queue(r, &r->res_grantqueue, lkb);
}
static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb)
{
	return send_common(r, lkb, DLM_MSG_REQUEST);
}
static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb)
{
	return send_common(r, lkb, DLM_MSG_UNLOCK);
}
static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb)
{
	return send_common(r, lkb, DLM_MSG_CANCEL);
}
static int send_request_reply(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)
{
	return send_common_reply(r, lkb, DLM_MSG_REQUEST_REPLY, rv);
}
static int send_convert_reply(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)
{
	return send_common_reply(r, lkb, DLM_MSG_CONVERT_REPLY, rv);
}
static int send_unlock_reply(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)
{
	return send_common_reply(r, lkb, DLM_MSG_UNLOCK_REPLY, rv);
}
static int send_cancel_reply(struct dlm_rsb *r, struct dlm_lkb *lkb, int rv)
{
	return send_common_reply(r, lkb, DLM_MSG_CANCEL_REPLY, rv);
}
static int receive_extralen(struct dlm_message *ms)
{
	return (ms->m_header.h_length - sizeof(struct dlm_message));
}
static void fake_bastfn(void *astparam, int mode)
{
	log_print("fake_bastfn should not be called");
}
static void fake_astfn(void *astparam)
{
	log_print("fake_astfn should not be called");
}
static void receive_purge(struct dlm_ls *ls, struct dlm_message *ms)
{
	do_purge(ls, ms->m_nodeid, ms->m_pid);
}
void dlm_receive_message_saved(struct dlm_ls *ls, struct dlm_message *ms)
{
	_receive_message(ls, ms);
}
static int purge_dead_test(struct dlm_ls *ls, struct dlm_lkb *lkb)
{
	return (is_master_copy(lkb) && dlm_is_removed(ls, lkb->lkb_nodeid));
}
static int purge_mstcpy_test(struct dlm_ls *ls, struct dlm_lkb *lkb)
{
	return is_master_copy(lkb);
}
static ssize_t dlm_id_show(struct dlm_ls *ls, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%u\n", ls->ls_global_id);
}
static ssize_t dlm_recover_nodeid_show(struct dlm_ls *ls, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%d\n", ls->ls_recover_nodeid);
}
void dlm_lockspace_exit(void)
{
	kset_unregister(dlm_kset);
}
static void dlm_scand_stop(void)
{
	kthread_stop(scand_task);
}
static void cbuf_add(struct cbuf *cb, int n)
{
	cb->len += n;
}
static int cbuf_data(struct cbuf *cb)
{
	return ((cb->base + cb->len) & cb->mask);
}
static bool cbuf_empty(struct cbuf *cb)
{
	return cb->len == 0;
}
static inline int nodeid_hash(int nodeid)
{
	return nodeid & (CONN_HASH_SIZE-1);
}
static void clean_writequeues(void)
{
	foreach_conn(clean_one_writequeue);
}
void dlm_clear_members_gone(struct dlm_ls *ls)
{
	clear_memb_list(&ls->ls_nodes_gone);
}
void dlm_free_lvb(char *p)
{
	kfree(p);
}
static int rcom_response(struct dlm_ls *ls)
{
	return test_bit(LSFL_RCOM_READY, &ls->ls_flags);
}
static void receive_rcom_lookup_reply(struct dlm_ls *ls, struct dlm_rcom *rc_in)
{
	dlm_recover_master_reply(ls, rc_in);
}
int dlm_recover_members_wait(struct dlm_ls *ls)
{
	return wait_status(ls, DLM_RS_NODES);
}
int dlm_recover_directory_wait(struct dlm_ls *ls)
{
	return wait_status(ls, DLM_RS_DIR);
}
int dlm_recover_locks_wait(struct dlm_ls *ls)
{
	return wait_status(ls, DLM_RS_LOCKS);
}
int dlm_recover_done_wait(struct dlm_ls *ls)
{
	return wait_status(ls, DLM_RS_DONE);
}
void dlm_recoverd_stop(struct dlm_ls *ls)
{
	kthread_stop(ls->ls_recoverd_task);
}
void dlm_recoverd_resume(struct dlm_ls *ls)
{
	mutex_unlock(&ls->ls_recoverd_active);
}
static int ctl_device_close(struct inode *inode, struct file *file)
{
	return 0;
}
static void ecryptfs_lower_offset_for_extent(loff_t *offset, loff_t extent_num,
					     struct ecryptfs_crypt_stat *crypt_stat)
{
	(*offset) = (crypt_stat->num_header_bytes_at_front
		     + (crypt_stat->extent_size * extent_num));
}
static void set_default_header_data(struct ecryptfs_crypt_stat *crypt_stat)
{
	crypt_stat->num_header_bytes_at_front =
		ECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE;
}
static int
ecryptfs_fsync(struct file *file, struct dentry *dentry, int datasync)
{
	return vfs_fsync(ecryptfs_file_to_lower(file),
			 ecryptfs_dentry_to_lower(dentry),
			 datasync);
}
static void
ecryptfs_put_link(struct dentry *dentry, struct nameidata *nd, void *ptr)
{
	kfree(nd_get_link(nd));
}
static int
ecryptfs_permission(struct inode *inode, int mask)
{
	return inode_permission(ecryptfs_inode_to_lower(inode), mask);
}
static ssize_t
ecryptfs_getxattr(struct dentry *dentry, const char *name, void *value,
		  size_t size)
{
	return ecryptfs_getxattr_lower(ecryptfs_dentry_to_lower(dentry), name,
				       value, size);
}
int ecryptfs_inode_test(struct inode *inode, void *candidate_lower_inode)
{
	if ((ecryptfs_inode_to_lower(inode)
	     == (struct inode *)candidate_lower_inode))
		return 1;
	else
		return 0;
}
static void ecryptfs_kill_block_super(struct super_block *sb)
{
	generic_shutdown_super(sb);
}
static ssize_t version_show(struct kobject *kobj,
			    struct kobj_attribute *attr, char *buff)
{
	return snprintf(buff, PAGE_SIZE, "%d\n", ECRYPTFS_VERSIONING_MASK);
}
static int ecryptfs_statfs(struct dentry *dentry, struct kstatfs *buf)
{
	return vfs_statfs(ecryptfs_dentry_to_lower(dentry), buf);
}
static void ecryptfs_clear_inode(struct inode *inode)
{
	iput(ecryptfs_inode_to_lower(inode));
}
static int efs_readpage(struct file *file, struct page *page)
{
	return block_read_full_page(page,efs_get_block);
}
static sector_t _efs_bmap(struct address_space *mapping, sector_t block)
{
	return generic_block_bmap(mapping,block,efs_get_block);
}
struct dentry *efs_fh_to_dentry(struct super_block *sb, struct fid *fid,
		int fh_len, int fh_type)
{
	return generic_fh_to_dentry(sb, fid, fh_len, fh_type,
				    efs_nfs_get_inode);
}
struct dentry *efs_fh_to_parent(struct super_block *sb, struct fid *fid,
		int fh_len, int fh_type)
{
	return generic_fh_to_parent(sb, fid, fh_len, fh_type,
				    efs_nfs_get_inode);
}
static int efs_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_bdev(fs_type, flags, dev_name, data, efs_fill_super, mnt);
}
static void efs_destroy_inode(struct inode *inode)
{
	kmem_cache_free(efs_inode_cachep, INODE_INFO(inode));
}
static void destroy_inodecache(void)
{
	kmem_cache_destroy(efs_inode_cachep);
}
static inline int ep_cmp_ffd(struct epoll_filefd *p1,
			     struct epoll_filefd *p2)
{
	return (p1->file > p2->file ? +1:
	        (p1->file < p2->file ? -1 : p1->fd - p2->fd));
}
static inline int ep_is_linked(struct list_head *p)
{
	return !list_empty(p);
}
static inline struct epitem *ep_item_from_wait(wait_queue_t *p)
{
	return container_of(p, struct eppoll_entry, wait)->base;
}
static inline struct epitem *ep_item_from_epqueue(poll_table *p)
{
	return container_of(p, struct ep_pqueue, pt)->epi;
}
static inline int ep_op_has_event(int op)
{
	return op != EPOLL_CTL_DEL;
}
static inline int is_file_epoll(struct file *f)
{
	return f->f_op == &eventpoll_fops;
}
static inline void put_binfmt(struct linux_binfmt * fmt)
{
	module_put(fmt->module);
}
static void put_arg_page(struct page *page)
{
	put_page(page);
}
static void flush_arg_page(struct linux_binprm *bprm, unsigned long pos,
		struct page *page)
{
	flush_cache_page(bprm->vma, pos, page_to_pfn(page));
}
static bool valid_arg_len(struct linux_binprm *bprm, long len)
{
	return len <= MAX_ARG_STRLEN;
}
static bool valid_arg_len(struct linux_binprm *bprm, long len)
{
	return len <= bprm->p;
}
static inline unsigned exofs_chunk_size(struct inode *inode)
{
	return inode->i_sb->s_blocksize;
}
static inline unsigned long dir_pages(struct inode *inode)
{
	return (inode->i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;
}
static inline
struct exofs_dir_entry *exofs_next_entry(struct exofs_dir_entry *p)
{
	return (struct exofs_dir_entry *)((char *)p + le16_to_cpu(p->rec_len));
}
static int exofs_release_file(struct inode *inode, struct file *filp)
{
	return 0;
}
static void readpage_done(struct osd_request *or, void *p)
{
	__readpage_done(or, p, true);
}
static int exofs_readpage(struct file *file, struct page *page)
{
	return readpage_filler(page);
}
static int readpage_strip(void *data, struct page *page)
{
	return readpage_filler(page);
}
static int exofs_readpages(struct file *file, struct address_space *mapping,
			   struct list_head *pages, unsigned nr_pages)
{
	return read_cache_pages(mapping, pages, readpage_strip, NULL);
}
int exofs_write_inode(struct inode *inode, int wait)
{
	return exofs_update_inode(inode, wait);
}
void exofs_make_credential(u8 cred_a[OSD_CAP_LEN], const struct osd_obj_id *obj)
{
	osd_sec_init_nosec_doall_caps(cred_a, obj, false, true);
}
static void exofs_destroy_inode(struct inode *inode)
{
	kmem_cache_free(exofs_inode_cachep, exofs_i(inode));
}
static void destroy_inodecache(void)
{
	kmem_cache_destroy(exofs_inode_cachep);
}
int
ext2_permission(struct inode *inode, int mask)
{
	return generic_permission(inode, mask, ext2_check_acl);
}
static inline int rsv_is_empty(struct ext2_reserve_window *rsv)
{
	return (rsv->_rsv_end == EXT2_RESERVE_WINDOW_NOT_ALLOCATED);
}
unsigned long ext2_bg_num_gdb(struct super_block *sb, int group)
{
	return ext2_bg_has_super(sb, group) ? EXT2_SB(sb)->s_gdb_count : 0;
}
static inline unsigned ext2_chunk_size(struct inode *inode)
{
	return inode->i_sb->s_blocksize;
}
static inline unsigned long dir_pages(struct inode *inode)
{
	return (inode->i_size+PAGE_CACHE_SIZE-1)>>PAGE_CACHE_SHIFT;
}
static inline ext2_dirent *ext2_next_entry(ext2_dirent *p)
{
	return (ext2_dirent *)((char *)p +
			ext2_rec_len_from_disk(p->rec_len));
}
int ext2_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,
		u64 start, u64 len)
{
	return generic_block_fiemap(inode, fieinfo, start, len,
				    ext2_get_block);
}
static int ext2_writepage(struct page *page, struct writeback_control *wbc)
{
	return block_write_full_page(page, ext2_get_block, wbc);
}
static int ext2_readpage(struct file *file, struct page *page)
{
	return mpage_readpage(page, ext2_get_block);
}
static int
ext2_readpages(struct file *file, struct address_space *mapping,
		struct list_head *pages, unsigned nr_pages)
{
	return mpage_readpages(mapping, pages, nr_pages, ext2_get_block);
}
int __ext2_write_begin(struct file *file, struct address_space *mapping,
		loff_t pos, unsigned len, unsigned flags,
		struct page **pagep, void **fsdata)
{
	return block_write_begin(file, mapping, pos, len, flags, pagep, fsdata,
							ext2_get_block);
}
static int
ext2_nobh_write_begin(struct file *file, struct address_space *mapping,
		loff_t pos, unsigned len, unsigned flags,
		struct page **pagep, void **fsdata)
{
	return nobh_write_begin(file, mapping, pos, len, flags, pagep, fsdata,
							ext2_get_block);
}
static int ext2_nobh_writepage(struct page *page,
			struct writeback_control *wbc)
{
	return nobh_writepage(page, ext2_get_block, wbc);
}
static sector_t ext2_bmap(struct address_space *mapping, sector_t block)
{
	return generic_block_bmap(mapping,block,ext2_get_block);
}
static int
ext2_writepages(struct address_space *mapping, struct writeback_control *wbc)
{
	return mpage_writepages(mapping, wbc, ext2_get_block);
}
int ext2_write_inode(struct inode *inode, int wait)
{
	return ext2_update_inode(inode, wait);
}
static void ext2_destroy_inode(struct inode *inode)
{
	kmem_cache_free(ext2_inode_cachep, EXT2_I(inode));
}
static void destroy_inodecache(void)
{
	kmem_cache_destroy(ext2_inode_cachep);
}
static struct dentry *ext2_fh_to_dentry(struct super_block *sb, struct fid *fid,
		int fh_len, int fh_type)
{
	return generic_fh_to_dentry(sb, fid, fh_len, fh_type,
				    ext2_nfs_get_inode);
}
static struct dentry *ext2_fh_to_parent(struct super_block *sb, struct fid *fid,
		int fh_len, int fh_type)
{
	return generic_fh_to_parent(sb, fid, fh_len, fh_type,
				    ext2_nfs_get_inode);
}
static int ext2_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_bdev(fs_type, flags, dev_name, data, ext2_fill_super, mnt);
}
ssize_t
ext2_listxattr(struct dentry *dentry, char *buffer, size_t size)
{
	return ext2_xattr_list(dentry->d_inode, buffer, size);
}
void
ext2_xattr_put_super(struct super_block *sb)
{
	mb_cache_shrink(sb->s_bdev);
}
void
exit_ext2_xattr(void)
{
	mb_cache_destroy(ext2_xattr_cache);
}
int
ext3_permission(struct inode *inode, int mask)
{
	return generic_permission(inode, mask, ext3_check_acl);
}
static inline int rsv_is_empty(struct ext3_reserve_window *rsv)
{
	return rsv->_rsv_end == EXT3_RESERVE_WINDOW_NOT_ALLOCATED;
}
static unsigned long ext3_bg_num_gdb_nometa(struct super_block *sb, int group)
{
	return ext3_bg_has_super(sb, group) ? EXT3_SB(sb)->s_gdb_count : 0;
}
int ext3_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,
		u64 start, u64 len)
{
	return generic_block_fiemap(inode, fieinfo, start, len,
				    ext3_get_block);
}
static int ext3_readpage(struct file *file, struct page *page)
{
	return mpage_readpage(page, ext3_get_block);
}
static int
ext3_readpages(struct file *file, struct address_space *mapping,
		struct list_head *pages, unsigned nr_pages)
{
	return mpage_readpages(mapping, pages, nr_pages, ext3_get_block);
}
int ext3_get_inode_loc(struct inode *inode, struct ext3_iloc *iloc)
{
	return __ext3_get_inode_loc(inode, iloc,
		!(EXT3_I(inode)->i_state & EXT3_STATE_XATTR));
}
static inline struct ext3_dir_entry_2 *
ext3_next_entry(struct ext3_dir_entry_2 *p)
{
	return (struct ext3_dir_entry_2 *)((char *)p +
		ext3_rec_len_from_disk(p->rec_len));
}
static inline unsigned dx_get_block (struct dx_entry *entry)
{
	return le32_to_cpu(entry->block) & 0x00ffffff;
}
static inline void dx_set_block (struct dx_entry *entry, unsigned value)
{
	entry->block = cpu_to_le32(value);
}
static inline unsigned dx_get_hash (struct dx_entry *entry)
{
	return le32_to_cpu(entry->hash);
}
static inline void dx_set_hash (struct dx_entry *entry, unsigned value)
{
	entry->hash = cpu_to_le32(value);
}
static inline unsigned dx_get_count (struct dx_entry *entries)
{
	return le16_to_cpu(((struct dx_countlimit *) entries)->count);
}
static inline unsigned dx_get_limit (struct dx_entry *entries)
{
	return le16_to_cpu(((struct dx_countlimit *) entries)->limit);
}
static inline void dx_set_count (struct dx_entry *entries, unsigned value)
{
	((struct dx_countlimit *) entries)->count = cpu_to_le16(value);
}
static inline void dx_set_limit (struct dx_entry *entries, unsigned value)
{
	((struct dx_countlimit *) entries)->limit = cpu_to_le16(value);
}
static inline struct inode *orphan_list_entry(struct list_head *l)
{
	return &list_entry(l, struct ext3_inode_info, i_orphan)->vfs_inode;
}
static void destroy_inodecache(void)
{
	kmem_cache_destroy(ext3_inode_cachep);
}
static struct dentry *ext3_fh_to_dentry(struct super_block *sb, struct fid *fid,
		int fh_len, int fh_type)
{
	return generic_fh_to_dentry(sb, fid, fh_len, fh_type,
				    ext3_nfs_get_inode);
}
static struct dentry *ext3_fh_to_parent(struct super_block *sb, struct fid *fid,
		int fh_len, int fh_type)
{
	return generic_fh_to_parent(sb, fid, fh_len, fh_type,
				    ext3_nfs_get_inode);
}
static inline struct inode *dquot_to_inode(struct dquot *dquot)
{
	return sb_dqopt(dquot->dq_sb)->files[dquot->dq_type];
}
static int ext3_quota_on_mount(struct super_block *sb, int type)
{
	return vfs_quota_on_mount(sb, EXT3_SB(sb)->s_qf_names[type],
			EXT3_SB(sb)->s_jquota_fmt, type);
}
static int ext3_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_bdev(fs_type, flags, dev_name, data, ext3_fill_super, mnt);
}
ssize_t
ext3_listxattr(struct dentry *dentry, char *buffer, size_t size)
{
	return ext3_xattr_list(dentry->d_inode, buffer, size);
}
void
ext3_xattr_put_super(struct super_block *sb)
{
	mb_cache_shrink(sb->s_bdev);
}
int
ext4_permission(struct inode *inode, int mask)
{
	return generic_permission(inode, mask, ext4_check_acl);
}
static unsigned long ext4_bg_num_gdb_nometa(struct super_block *sb,
					ext4_group_t group)
{
	return ext4_bg_has_super(sb, group) ? EXT4_SB(sb)->s_gdb_count : 0;
}
static void bi_complete(struct bio *bio, int error)
{
	complete((struct completion *)bio->bi_private);
}
static inline int ext4_begin_ordered_truncate(struct inode *inode,
					      loff_t new_size)
{
	return jbd2_journal_begin_ordered_truncate(
					EXT4_SB(inode->i_sb)->s_journal,
					&EXT4_I(inode)->jinode,
					new_size);
}
static ext4_fsblk_t ext4_find_goal(struct inode *inode, ext4_lblk_t block,
		Indirect *partial)
{
	return ext4_find_near(inode, partial);
}
static int ext4_bh_unmapped_or_delay(handle_t *handle, struct buffer_head *bh)
{
	return ((!buffer_mapped(bh) || buffer_delay(bh)) && buffer_dirty(bh));
}
static int ext4_readpage(struct file *file, struct page *page)
{
	return mpage_readpage(page, ext4_get_block);
}
static int
ext4_readpages(struct file *file, struct address_space *mapping,
		struct list_head *pages, unsigned nr_pages)
{
	return mpage_readpages(mapping, pages, nr_pages, ext4_get_block);
}
int ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)
{
	return __ext4_get_inode_loc(inode, iloc,
		!(EXT4_I(inode)->i_state & EXT4_STATE_XATTR));
}
int ext4_chunk_trans_blocks(struct inode *inode, int nrblocks)
{
	return ext4_meta_trans_blocks(inode, nrblocks, 1);
}
static int ext4_bh_unmapped(handle_t *handle, struct buffer_head *bh)
{
	return !buffer_mapped(bh);
}
static inline void mb_free_blocks_double(struct inode *inode,
				struct ext4_buddy *e4b, int first, int count)
{
	return;
}
static inline void mb_mark_used_double(struct ext4_buddy *e4b,
						int first, int count)
{
	return;
}
static inline void mb_cmp_bitmaps(struct ext4_buddy *e4b, void *bitmap)
{
	return;
}
void ext4_mb_update_group_info(struct ext4_group_info *grp, ext4_grpblk_t add)
{
	grp->bb_free += add;
}
static void ext4_mb_return_to_preallocation(struct inode *inode,
					struct ext4_buddy *e4b,
					sector_t block, int count)
{
	BUG_ON(!list_empty(&EXT4_I(inode)->i_prealloc_list));
}
static inline void ext4_mb_show_ac(struct ext4_allocation_context *ac)
{
	return;
}
static inline struct ext4_dir_entry_2 *
ext4_next_entry(struct ext4_dir_entry_2 *p)
{
	return (struct ext4_dir_entry_2 *)((char *)p +
		ext4_rec_len_from_disk(p->rec_len));
}
static inline ext4_lblk_t dx_get_block(struct dx_entry *entry)
{
	return le32_to_cpu(entry->block) & 0x00ffffff;
}
static inline void dx_set_block(struct dx_entry *entry, ext4_lblk_t value)
{
	entry->block = cpu_to_le32(value);
}
static inline unsigned dx_get_hash(struct dx_entry *entry)
{
	return le32_to_cpu(entry->hash);
}
static inline void dx_set_hash(struct dx_entry *entry, unsigned value)
{
	entry->hash = cpu_to_le32(value);
}
static inline unsigned dx_get_count(struct dx_entry *entries)
{
	return le16_to_cpu(((struct dx_countlimit *) entries)->count);
}
static inline unsigned dx_get_limit(struct dx_entry *entries)
{
	return le16_to_cpu(((struct dx_countlimit *) entries)->limit);
}
static inline void dx_set_count(struct dx_entry *entries, unsigned value)
{
	((struct dx_countlimit *) entries)->count = cpu_to_le16(value);
}
static inline void dx_set_limit(struct dx_entry *entries, unsigned value)
{
	((struct dx_countlimit *) entries)->limit = cpu_to_le16(value);
}
ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,
			       struct ext4_group_desc *bg)
{
	return le32_to_cpu(bg->bg_block_bitmap_lo) |
		(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?
		(ext4_fsblk_t)le32_to_cpu(bg->bg_block_bitmap_hi) << 32 : 0);
}
ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,
			       struct ext4_group_desc *bg)
{
	return le32_to_cpu(bg->bg_inode_bitmap_lo) |
		(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?
		(ext4_fsblk_t)le32_to_cpu(bg->bg_inode_bitmap_hi) << 32 : 0);
}
ext4_fsblk_t ext4_inode_table(struct super_block *sb,
			      struct ext4_group_desc *bg)
{
	return le32_to_cpu(bg->bg_inode_table_lo) |
		(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?
		(ext4_fsblk_t)le32_to_cpu(bg->bg_inode_table_hi) << 32 : 0);
}
__u32 ext4_free_blks_count(struct super_block *sb,
			      struct ext4_group_desc *bg)
{
	return le16_to_cpu(bg->bg_free_blocks_count_lo) |
		(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?
		(__u32)le16_to_cpu(bg->bg_free_blocks_count_hi) << 16 : 0);
}
__u32 ext4_free_inodes_count(struct super_block *sb,
			      struct ext4_group_desc *bg)
{
	return le16_to_cpu(bg->bg_free_inodes_count_lo) |
		(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?
		(__u32)le16_to_cpu(bg->bg_free_inodes_count_hi) << 16 : 0);
}
__u32 ext4_used_dirs_count(struct super_block *sb,
			      struct ext4_group_desc *bg)
{
	return le16_to_cpu(bg->bg_used_dirs_count_lo) |
		(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?
		(__u32)le16_to_cpu(bg->bg_used_dirs_count_hi) << 16 : 0);
}
__u32 ext4_itable_unused_count(struct super_block *sb,
			      struct ext4_group_desc *bg)
{
	return le16_to_cpu(bg->bg_itable_unused_lo) |
		(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?
		(__u32)le16_to_cpu(bg->bg_itable_unused_hi) << 16 : 0);
}
static inline struct inode *orphan_list_entry(struct list_head *l)
{
	return &list_entry(l, struct ext4_inode_info, i_orphan)->vfs_inode;
}
static void destroy_inodecache(void)
{
	kmem_cache_destroy(ext4_inode_cachep);
}
static struct dentry *ext4_fh_to_dentry(struct super_block *sb, struct fid *fid,
		int fh_len, int fh_type)
{
	return generic_fh_to_dentry(sb, fid, fh_len, fh_type,
				    ext4_nfs_get_inode);
}
static struct dentry *ext4_fh_to_parent(struct super_block *sb, struct fid *fid,
		int fh_len, int fh_type)
{
	return generic_fh_to_parent(sb, fid, fh_len, fh_type,
				    ext4_nfs_get_inode);
}
static inline struct inode *dquot_to_inode(struct dquot *dquot)
{
	return sb_dqopt(dquot->dq_sb)->files[dquot->dq_type];
}
static int ext4_quota_on_mount(struct super_block *sb, int type)
{
	return vfs_quota_on_mount(sb, EXT4_SB(sb)->s_qf_names[type],
			EXT4_SB(sb)->s_jquota_fmt, type);
}
static int ext4_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_bdev(fs_type, flags, dev_name, data, ext4_fill_super, mnt);
}
static int ext4_ui_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, ext4_ui_proc_show, PDE(inode)->data);
}
ssize_t
ext4_listxattr(struct dentry *dentry, char *buffer, size_t size)
{
	return ext4_xattr_list(dentry->d_inode, buffer, size);
}
void
ext4_xattr_put_super(struct super_block *sb)
{
	mb_cache_shrink(sb->s_bdev);
}
static inline int fat_max_cache(struct inode *inode)
{
	return FAT_MAX_CACHE;
}
void fat_cache_destroy(void)
{
	kmem_cache_destroy(fat_cache_cachep);
}
static inline struct fat_cache *fat_cache_alloc(struct inode *inode)
{
	return kmem_cache_alloc(fat_cache_cachep, GFP_NOFS);
}
static inline loff_t fat_make_i_pos(struct super_block *sb,
				    struct buffer_head *bh,
				    struct msdos_dir_entry *de)
{
	return ((loff_t)bh->b_blocknr << MSDOS_SB(sb)->dir_per_block_bits)
		| (de - (struct msdos_dir_entry *)bh->b_data);
}
static inline int fat_uni_to_x8(struct msdos_sb_info *sbi, const wchar_t *uni,
				unsigned char *buf, int size)
{
	if (sbi->options.utf8)
		return utf8_wcstombs(buf, uni, size);
	else
		return uni16_to_x8(buf, uni, size, sbi->options.unicode_xlate,
				   sbi->nls_io);
}
static inline void lock_fat(struct msdos_sb_info *sbi)
{
	mutex_lock(&sbi->fat_lock);
}
static inline void unlock_fat(struct msdos_sb_info *sbi)
{
	mutex_unlock(&sbi->fat_lock);
}
static int fat_writepage(struct page *page, struct writeback_control *wbc)
{
	return block_write_full_page(page, fat_get_block, wbc);
}
static int fat_writepages(struct address_space *mapping,
			  struct writeback_control *wbc)
{
	return mpage_writepages(mapping, wbc, fat_get_block);
}
static int fat_readpage(struct file *file, struct page *page)
{
	return mpage_readpage(page, fat_get_block);
}
static int fat_readpages(struct file *file, struct address_space *mapping,
			 struct list_head *pages, unsigned nr_pages)
{
	return mpage_readpages(mapping, pages, nr_pages, fat_get_block);
}
static inline unsigned long fat_hash(loff_t i_pos)
{
	return hash_32(i_pos, FAT_HASH_BITS);
}
static void fat_destroy_inode(struct inode *inode)
{
	kmem_cache_free(fat_inode_cachep, MSDOS_I(inode));
}
static void __exit fat_destroy_inodecache(void)
{
	kmem_cache_destroy(fat_inode_cachep);
}
int fat_sync_inode(struct inode *inode)
{
	return fat_write_inode(inode, 1);
}
static int msdos_get_sb(struct file_system_type *fs_type,
			int flags, const char *dev_name,
			void *data, struct vfsmount *mnt)
{
	return get_sb_bdev(fs_type, flags, dev_name, data, msdos_fill_super,
			   mnt);
}
static int __init init_msdos_fs(void)
{
	return register_filesystem(&msdos_fs_type);
}
static void __exit exit_msdos_fs(void)
{
	unregister_filesystem(&msdos_fs_type);
}
static inline wchar_t vfat_bad_char(wchar_t w)
{
	return (w < 0x0020)
	    || (w == '*') || (w == '?') || (w == '<') || (w == '>')
	    || (w == '|') || (w == '"') || (w == ':') || (w == '/')
	    || (w == '\\');
}
static inline wchar_t vfat_replace_char(wchar_t w)
{
	return (w == '[') || (w == ']') || (w == ';') || (w == ',')
	    || (w == '+') || (w == '=');
}
static wchar_t vfat_skip_char(wchar_t w)
{
	return (w == '.') || (w == ' ');
}
static int vfat_get_sb(struct file_system_type *fs_type,
		       int flags, const char *dev_name,
		       void *data, struct vfsmount *mnt)
{
	return get_sb_bdev(fs_type, flags, dev_name, data, vfat_fill_super,
			   mnt);
}
static int __init init_vfat_fs(void)
{
	return register_filesystem(&vfat_fs_type);
}
static void __exit exit_vfat_fs(void)
{
	unregister_filesystem(&vfat_fs_type);
}
void f_delown(struct file *filp)
{
	f_modown(filp, NULL, PIDTYPE_PID, 0, 0, 1);
}
static void wake_up_partner(struct inode* inode)
{
	wake_up_interruptible(&inode->i_pipe->wait);
}
static inline void * alloc_fdmem(unsigned int size)
{
	if (size <= PAGE_SIZE)
		return kmalloc(size, GFP_KERNEL);
	else
		return vmalloc(size);
}
int get_unused_fd(void)
{
	return alloc_fd(0, 0);
}
static int get_nr_files(void)
{
	return percpu_counter_read_positive(&nr_files);
}
int get_max_files(void)
{
	return files_stat.max_files;
}
int proc_nr_files(ctl_table *table, int write, struct file *filp,
                     void __user *buffer, size_t *lenp, loff_t *ppos)
{
	return -ENOSYS;
}
void get_filesystem(struct file_system_type *fs)
{
	__module_get(fs->owner);
}
void put_filesystem(struct file_system_type *fs)
{
	module_put(fs->owner);
}
static int filesystems_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, filesystems_proc_show, NULL);
}
void
vxfs_put_fake_inode(struct inode *ip)
{
	iput(ip);
}
void
vxfs_clear_inode(struct inode *ip)
{
	kmem_cache_free(vxfs_inode_cachep, ip->i_private);
}
static inline u_long
dir_pages(struct inode *inode)
{
	return (inode->i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;
}
static inline struct vxfs_direct *
vxfs_next_entry(struct vxfs_direct *de)
{
	return ((struct vxfs_direct *)((char*)de + de->d_reclen));
}
static int
vxfs_readpage(struct file *file, struct page *page)
{
	return block_read_full_page(page, vxfs_getblk);
}
static sector_t
vxfs_bmap(struct address_space *mapping, sector_t block)
{
	return generic_block_bmap(mapping, block, vxfs_getblk);
}
static int vxfs_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_bdev(fs_type, flags, dev_name, data, vxfs_fill_super,
			   mnt);
}
static int writeback_acquire(struct backing_dev_info *bdi)
{
	return !test_and_set_bit(BDI_pdflush, &bdi->state);
}
int writeback_in_progress(struct backing_dev_info *bdi)
{
	return test_bit(BDI_pdflush, &bdi->state);
}
static void requeue_io(struct inode *inode)
{
	list_move(&inode->i_list, &inode->i_sb->s_more_io);
}
int sb_has_dirty_inodes(struct super_block *sb)
{
	return !list_empty(&sb->s_dirty) ||
	       !list_empty(&sb->s_io) ||
	       !list_empty(&sb->s_more_io);
}
static void sync_sb_inodes(struct super_block *sb,
				struct writeback_control *wbc)
{
	generic_sync_sb_inodes(sb, wbc);
}
static int fscache_histogram_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &fscache_histogram_ops);
}
static void fscache_release_write_op(struct fscache_operation *_op)
{
	_enter("{OP%x}", _op->debug_id);
}
static int fscache_stats_open(struct inode *inode, struct file *file)
{
	return single_open(file, fscache_stats_show, NULL);
}
static int fuse_ctl_get_sb(struct file_system_type *fs_type, int flags,
			const char *dev_name, void *raw_data,
			struct vfsmount *mnt)
{
	return get_sb_single(fs_type, flags, raw_data,
				fuse_ctl_fill_super, mnt);
}
int __init fuse_ctl_init(void)
{
	return register_filesystem(&fuse_ctl_fs_type);
}
void fuse_ctl_cleanup(void)
{
	unregister_filesystem(&fuse_ctl_fs_type);
}
static struct fuse_conn *fuse_get_conn(struct file *file)
{
	return file->private_data;
}
void fuse_request_free(struct fuse_req *req)
{
	kmem_cache_free(fuse_req_cachep, req);
}
static void restore_sigs(sigset_t *oldset)
{
	sigprocmask(SIG_SETMASK, oldset, NULL);
}
static void __fuse_get_request(struct fuse_req *req)
{
	atomic_inc(&req->count);
}
static int request_pending(struct fuse_conn *fc)
{
	return !list_empty(&fc->pending) || !list_empty(&fc->interrupts);
}
static inline void fuse_dentry_settime(struct dentry *entry, u64 time)
{
	entry->d_time = time;
}
static inline u64 fuse_dentry_time(struct dentry *entry)
{
	return entry->d_time;
}
static u64 fuse_dentry_time(struct dentry *entry)
{
	return (u64) entry->d_time +
		((u64) (unsigned long) entry->d_fsdata << 32);
}
static u64 time_to_jiffies(unsigned long sec, unsigned long nsec)
{
	if (sec || nsec) {
	} else
		return 0;
}
static void fuse_change_entry_timeout(struct dentry *entry,
				      struct fuse_entry_out *o)
{
	fuse_dentry_settime(entry,
		time_to_jiffies(o->entry_valid, o->entry_valid_nsec));
}
static u64 attr_timeout(struct fuse_attr_out *o)
{
	return time_to_jiffies(o->attr_valid, o->attr_valid_nsec);
}
static u64 entry_attr_timeout(struct fuse_entry_out *o)
{
	return time_to_jiffies(o->attr_valid, o->attr_valid_nsec);
}
void fuse_invalidate_attr(struct inode *inode)
{
	get_fuse_inode(inode)->i_time = 0;
}
void fuse_invalidate_entry_cache(struct dentry *entry)
{
	fuse_dentry_settime(entry, 0);
}
static int invalid_nodeid(u64 nodeid)
{
	return !nodeid || nodeid == FUSE_ROOT_ID;
}
int fuse_valid_type(int m)
{
	return S_ISREG(m) || S_ISDIR(m) || S_ISLNK(m) || S_ISCHR(m) ||
		S_ISBLK(m) || S_ISFIFO(m) || S_ISSOCK(m);
}
static void fuse_put_link(struct dentry *dentry, struct nameidata *nd, void *c)
{
	free_link(nd_get_link(nd));
}
static int fuse_dir_open(struct inode *inode, struct file *file)
{
	return fuse_open_common(inode, file, 1);
}
static int fuse_dir_release(struct inode *inode, struct file *file)
{
	return fuse_release_common(inode, file, 1);
}
static int fuse_dir_fsync(struct file *file, struct dentry *de, int datasync)
{
	return file ? fuse_fsync_common(file, de, datasync, 1) : 0;
}
static int fuse_setattr(struct dentry *entry, struct iattr *attr)
{
	if (attr->ia_valid & ATTR_FILE)
		return fuse_do_setattr(entry, attr, attr->ia_file);
	else
		return fuse_do_setattr(entry, attr, NULL);
}
void fuse_init_common(struct inode *inode)
{
	inode->i_op = &fuse_common_inode_operations;
}
void fuse_init_symlink(struct inode *inode)
{
	inode->i_op = &fuse_symlink_inode_operations;
}
static int fuse_open(struct inode *inode, struct file *file)
{
	return fuse_open_common(inode, file, 0);
}
static int fuse_release(struct inode *inode, struct file *file)
{
	return fuse_release_common(inode, file, 0);
}
static int fuse_fsync(struct file *file, struct dentry *de, int datasync)
{
	return fuse_fsync_common(file, de, datasync, 0);
}
static ssize_t fuse_direct_read(struct file *file, char __user *buf,
				     size_t count, loff_t *ppos)
{
	return fuse_direct_io(file, buf, count, ppos, 0);
}
static void fuse_vma_close(struct vm_area_struct *vma)
{
	filemap_write_and_wait(vma->vm_file->f_mapping);
}
static long fuse_file_ioctl(struct file *file, unsigned int cmd,
			    unsigned long arg)
{
	return fuse_file_do_ioctl(file, cmd, arg, 0);
}
static long fuse_file_compat_ioctl(struct file *file, unsigned int cmd,
				   unsigned long arg)
{
	return fuse_file_do_ioctl(file, cmd, arg, FUSE_IOCTL_COMPAT);
}
static void fuse_umount_begin(struct super_block *sb)
{
	fuse_abort_conn(get_fuse_conn_super(sb));
}
static void fuse_free_conn(struct fuse_conn *fc)
{
	kfree(fc);
}
static int fuse_get_sb(struct file_system_type *fs_type,
		       int flags, const char *dev_name,
		       void *raw_data, struct vfsmount *mnt)
{
	return get_sb_nodev(fs_type, flags, raw_data, fuse_fill_super, mnt);
}
static int fuse_get_sb_blk(struct file_system_type *fs_type,
			   int flags, const char *dev_name,
			   void *raw_data, struct vfsmount *mnt)
{
	return get_sb_bdev(fs_type, flags, dev_name, raw_data, fuse_fill_super,
			   mnt);
}
static inline int register_fuseblk(void)
{
	return register_filesystem(&fuseblk_fs_type);
}
static inline void unregister_fuseblk(void)
{
	unregister_filesystem(&fuseblk_fs_type);
}
static inline int register_fuseblk(void)
{
	return 0;
}
int gfs2_file_dealloc(struct gfs2_inode *ip)
{
	return trunc_dealloc(ip, 0);
}
static inline int gfs2_dirent_sentinel(const struct gfs2_dirent *dent)
{
	return dent->de_inum.no_addr == 0 || dent->de_inum.no_formal_ino == 0;
}
static int gfs2_dirent_find(const struct gfs2_dirent *dent,
			    const struct qstr *name,
			    void *opaque)
{
	return __gfs2_dirent_find(dent, name, 1);
}
static int gfs2_dirent_prev(const struct gfs2_dirent *dent,
			    const struct qstr *name,
			    void *opaque)
{
	return __gfs2_dirent_find(dent, name, 2);
}
static inline rwlock_t *gl_lock_addr(unsigned int x)
{
	return &gl_hash_locks[x & (GL_HASH_LOCK_SZ-1)];
}
static inline rwlock_t *gl_lock_addr(unsigned int x)
{
	return NULL;
}
int gfs2_glock_poll(struct gfs2_holder *gh)
{
	return test_bit(HIF_WAIT, &gh->gh_iflags) ? 0 : 1;
}
static int gfs2_glock_seq_show(struct seq_file *seq, void *iter_ptr)
{
	return dump_glock(seq, iter_ptr);
}
static int rgrp_go_demote_ok(const struct gfs2_glock *gl)
{
	return !gl->gl_aspace->i_mapping->nrpages;
}
static int rgrp_go_lock(struct gfs2_holder *gh)
{
	return gfs2_rgrp_bh_get(gh->gh_gl->gl_object);
}
static void rgrp_go_unlock(struct gfs2_holder *gh)
{
	gfs2_rgrp_bh_put(gh->gh_gl->gl_object);
}
static int trans_go_demote_ok(const struct gfs2_glock *gl)
{
	return 0;
}
static inline struct gfs2_log_descriptor *bh_log_desc(struct buffer_head *bh)
{
	return (struct gfs2_log_descriptor *)bh->b_data;
}
static inline __be64 *bh_ptr_end(struct buffer_head *bh)
{
	return (__force __be64 *)(bh->b_data + bh->b_size);
}
static int gfs2_aspace_writepage(struct page *page,
				 struct writeback_control *wbc)
{
	return block_write_full_page(page, aspace_get_block, wbc);
}
static int gfs2_get_block_direct(struct inode *inode, sector_t lblock,
				 struct buffer_head *bh_result, int create)
{
	return gfs2_block_map(inode, lblock, bh_result, 0);
}
static int gfs2_writeback_writepages(struct address_space *mapping,
				     struct writeback_control *wbc)
{
	return mpage_writepages(mapping, wbc, gfs2_get_block_noalloc);
}
static int gfs2_setlease(struct file *file, long arg, struct file_lock **fl)
{
	return -EINVAL;
}
static int gfs2_get_sb(struct file_system_type *fs_type, int flags,
		       const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_bdev(fs_type, flags, dev_name, data, fill_super, mnt);
}
static void gfs2_write_super(struct super_block *sb)
{
	sb->s_dirt = 0;
}
static void gfs2_destroy_inode(struct inode *inode)
{
	kmem_cache_free(gfs2_inode_cachep, inode);
}
static ssize_t id_show(struct gfs2_sbd *sdp, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%u:%u\n",
			MAJOR(sdp->sd_vfs->s_dev), MINOR(sdp->sd_vfs->s_dev));
}
static ssize_t fsname_show(struct gfs2_sbd *sdp, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%s\n", sdp->sd_fsname);
}
static ssize_t quota_scale_show(struct gfs2_sbd *sdp, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%u %u\n",
			sdp->sd_tune.gt_quota_scale_num,
			sdp->sd_tune.gt_quota_scale_den);
}
void gfs2_sys_uninit(void)
{
	kset_unregister(gfs2_kset);
}
void gfs2_trans_add_rg(struct gfs2_rgrpd *rgd)
{
	lops_add(rgd->rd_sbd, &rgd->rd_le);
}
void gfs2_assert_i(struct gfs2_sbd *sdp)
{
	printk(KERN_EMERG "GFS2: fsid=%s: fatal assertion failed\n",
	       sdp->sd_fsname);
}
void hfs_bnode_write_u8(struct hfs_bnode *node, int off, u8 data)
{
	hfs_bnode_write(node, &data, off, 1);
}
void hfs_bnode_free(struct hfs_bnode *node)
{
	kfree(node);
}
static int hfs_writepage(struct page *page, struct writeback_control *wbc)
{
	return block_write_full_page(page, hfs_get_block, wbc);
}
static int hfs_readpage(struct file *file, struct page *page)
{
	return block_read_full_page(page, hfs_get_block);
}
static sector_t hfs_bmap(struct address_space *mapping, sector_t block)
{
	return generic_block_bmap(mapping, block, hfs_get_block);
}
static int hfs_writepages(struct address_space *mapping,
			  struct writeback_control *wbc)
{
	return mpage_writepages(mapping, wbc, hfs_get_block);
}
static void hfs_destroy_inode(struct inode *inode)
{
	kmem_cache_free(hfs_inode_cachep, HFS_I(inode));
}
static int hfs_get_sb(struct file_system_type *fs_type,
		      int flags, const char *dev_name, void *data,
		      struct vfsmount *mnt)
{
	return get_sb_bdev(fs_type, flags, dev_name, data, hfs_fill_super, mnt);
}
void hfs_bnode_free(struct hfs_bnode *node)
{
	kfree(node);
}
static int hfsplus_readpage(struct file *file, struct page *page)
{
	return block_read_full_page(page, hfsplus_get_block);
}
static int hfsplus_writepage(struct page *page, struct writeback_control *wbc)
{
	return block_write_full_page(page, hfsplus_get_block, wbc);
}
static sector_t hfsplus_bmap(struct address_space *mapping, sector_t block)
{
	return generic_block_bmap(mapping, block, hfsplus_get_block);
}
static int hfsplus_writepages(struct address_space *mapping,
			      struct writeback_control *wbc)
{
	return mpage_writepages(mapping, wbc, hfsplus_get_block);
}
static void hfsplus_destroy_inode(struct inode *inode)
{
	kmem_cache_free(hfsplus_inode_cachep, &HFSPLUS_I(inode));
}
static int hfsplus_get_sb(struct file_system_type *fs_type,
			  int flags, const char *dev_name, void *data,
			  struct vfsmount *mnt)
{
	return get_sb_bdev(fs_type, flags, dev_name, data, hfsplus_fill_super,
			   mnt);
}
static inline struct hostfs_inode_info *HOSTFS_I(struct inode *inode)
{
	return list_entry(inode, struct hostfs_inode_info, vfs_inode);
}
int hostfs_d_delete(struct dentry *dentry)
{
	return 1;
}
int hostfs_fsync(struct file *file, struct dentry *dentry, int datasync)
{
	return fsync_file(HOSTFS_I(dentry->d_inode)->fd, datasync);
}
static int hostfs_read_sb(struct file_system_type *type,
			  int flags, const char *dev_name,
			  void *data, struct vfsmount *mnt)
{
	return get_sb_nodev(type, flags, data, hostfs_fill_sb_common, mnt);
}
static int __init init_hostfs(void)
{
	return register_filesystem(&hostfs_type);
}
static void __exit exit_hostfs(void)
{
	unregister_filesystem(&hostfs_type);
}
void close_file(void *stream)
{
	close(*((int *) stream));
}
void close_dir(void *stream)
{
	closedir(stream);
}
void hpfs_set_dentry_operations(struct dentry *dentry)
{
	dentry->d_op = &hpfs_dentry_operations;
}
static void set_indirect_ea(struct super_block *s, int ano, secno a, char *data,
			    int size)
{
	hpfs_ea_write(s, a, ano, 0, size, data);
}
int hpfs_file_fsync(struct file *file, struct dentry *dentry, int datasync)
{
	return 0; /* Don't fsync :-) */
}
static int hpfs_writepage(struct page *page, struct writeback_control *wbc)
{
	return block_write_full_page(page,hpfs_get_block, wbc);
}
static int hpfs_readpage(struct file *file, struct page *page)
{
	return block_read_full_page(page,hpfs_get_block);
}
static sector_t _hpfs_bmap(struct address_space *mapping, sector_t block)
{
	return generic_block_bmap(mapping,block,hpfs_get_block);
}
unsigned *hpfs_map_dnode_bitmap(struct super_block *s, struct quad_buffer_head *qbh)
{
	return hpfs_map_4sectors(s, hpfs_sb(s)->sb_dmap, qbh, 0);
}
static inline int not_allowed_char(unsigned char c)
{
	return c<' ' || c=='"' || c=='*' || c=='/' || c==':' || c=='<' ||
	      c=='>' || c=='?' || c=='\\' || c=='|';
}
static inline int no_dos_char(unsigned char c)
{	/* Characters that are allowed in HPFS but not in DOS */
	return c=='+' || c==',' || c==';' || c=='=' || c=='[' || c==']';
}
unsigned char hpfs_upcase(unsigned char *dir, unsigned char a)
{
	return upcase(dir, a);
}
static void hpfs_destroy_inode(struct inode *inode)
{
	kmem_cache_free(hpfs_inode_cachep, hpfs_i(inode));
}
static void destroy_inodecache(void)
{
	kmem_cache_destroy(hpfs_inode_cachep);
}
static inline void hpfs_help(void)
{
	printk("\n\
HPFS filesystem options:\n\
      help              do not mount and display this text\n\
      uid=xxx           set uid of files that don't have uid specified in eas\n\
      gid=xxx           set gid of files that don't have gid specified in eas\n\
      umask=xxx         set mode of files that don't have mode specified in eas\n\
      case=lower        lowercase all files\n\
      case=asis         do not lowercase files (default)\n\
      conv=binary       do not convert CR/LF -> LF (default)\n\
      conv=auto         convert only files with known text extensions\n\
      conv=text         convert all files\n\
      check=none        no fs checks - kernel may crash on corrupted filesystem\n\
      check=normal      do some checks - it should not crash (default)\n\
      check=strict      do extra time-consuming checks, used for debugging\n\
      errors=continue   continue on errors\n\
      errors=remount-ro remount read-only if errors found (default)\n\
      errors=panic      panic on errors\n\
      chkdsk=no         do not mark fs for chkdsking even if there were errors\n\
      chkdsk=errors     mark fs dirty if errors found (default)\n\
      chkdsk=always     always mark fs dirty - used for debugging\n\
      eas=no            ignore extended attributes\n\
      eas=ro            read but do not write extended attributes\n\
      eas=rw            r/w eas => enables chmod, chown, mknod, ln -s (default)\n\
      timeshift=nnn	add nnn seconds to file times\n\
\n");
}
static int hpfs_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_bdev(fs_type, flags, dev_name, data, hpfs_fill_super,
			   mnt);
}
static inline struct hppfs_inode_info *HPPFS_I(struct inode *inode)
{
	return container_of(inode, struct hppfs_inode_info, vfs_inode);
}
static int hppfs_fsync(struct file *file, struct dentry *dentry, int datasync)
{
	return 0;
}
static void hppfs_destroy_inode(struct inode *inode)
{
	kfree(HPPFS_I(inode));
}
static int hppfs_read_super(struct file_system_type *type,
			    int flags, const char *dev_name,
			    void *data, struct vfsmount *mnt)
{
	return get_sb_nodev(type, flags, data, hppfs_fill_super, mnt);
}
static int __init init_hppfs(void)
{
	return register_filesystem(&hppfs_type);
}
static void __exit exit_hppfs(void)
{
	unregister_filesystem(&hppfs_type);
}
void zisofs_cleanup(void)
{
	vfree(zisofs_zlib_workspace);
}
static void isofs_destroy_inode(struct inode *inode)
{
	kmem_cache_free(isofs_inode_cachep, ISOFS_I(inode));
}
static void destroy_inodecache(void)
{
	kmem_cache_destroy(isofs_inode_cachep);
}
static int
isofs_hash(struct dentry *dentry, struct qstr *qstr)
{
	return isofs_hash_common(dentry, qstr, 0);
}
static int
isofs_hashi(struct dentry *dentry, struct qstr *qstr)
{
	return isofs_hashi_common(dentry, qstr, 0);
}
static int
isofs_dentry_cmp(struct dentry *dentry,struct qstr *a,struct qstr *b)
{
	return isofs_dentry_cmp_common(dentry, a, b, 0);
}
static int
isofs_dentry_cmpi(struct dentry *dentry,struct qstr *a,struct qstr *b)
{
	return isofs_dentry_cmpi_common(dentry, a, b, 0);
}
static int
isofs_hash_ms(struct dentry *dentry, struct qstr *qstr)
{
	return isofs_hash_common(dentry, qstr, 1);
}
static int
isofs_hashi_ms(struct dentry *dentry, struct qstr *qstr)
{
	return isofs_hashi_common(dentry, qstr, 1);
}
static int
isofs_dentry_cmp_ms(struct dentry *dentry,struct qstr *a,struct qstr *b)
{
	return isofs_dentry_cmp_common(dentry, a, b, 1);
}
static int
isofs_dentry_cmpi_ms(struct dentry *dentry,struct qstr *a,struct qstr *b)
{
	return isofs_dentry_cmpi_common(dentry, a, b, 1);
}
static int isofs_readpage(struct file *file, struct page *page)
{
	return block_read_full_page(page,isofs_get_block);
}
static sector_t _isofs_bmap(struct address_space *mapping, sector_t block)
{
	return generic_block_bmap(mapping,block,isofs_get_block);
}
static int isofs_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_bdev(fs_type, flags, dev_name, data, isofs_fill_super,
				mnt);
}
void journal_abort(journal_t *journal, int errno)
{
	__journal_abort_soft(journal, errno);
}
int journal_blocks_per_page(struct inode *inode)
{
	return 1 << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);
}
void
journal_release_buffer(handle_t *handle, struct buffer_head *bh)
{
	BUFFER_TRACE(bh, "entry");
}
static void *jbd2_seq_info_start(struct seq_file *seq, loff_t *pos)
{
	return *pos ? NULL : SEQ_START_TOKEN;
}
static void *jbd2_seq_info_next(struct seq_file *seq, void *v, loff_t *pos)
{
	return NULL;
}
void jbd2_journal_abort(journal_t *journal, int errno)
{
	__journal_abort_soft(journal, errno);
}
int jbd2_journal_blocks_per_page(struct inode *inode)
{
	return 1 << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);
}
size_t journal_tag_bytes(journal_t *journal)
{
	if (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_64BIT))
		return JBD2_TAG_SIZE64;
	else
		return JBD2_TAG_SIZE32;
}
static void __init jbd2_create_jbd_stats_proc_entry(void)
{
	proc_jbd2_stats = proc_mkdir(JBD2_STATS_PROC_NAME, NULL);
}
void
jbd2_journal_release_buffer(handle_t *handle, struct buffer_head *bh)
{
	BUFFER_TRACE(bh, "entry");
}
int jffs2_permission(struct inode *inode, int mask)
{
	return generic_permission(inode, mask, jffs2_check_acl);
}
int jffs2_rtime_init(void)
{
    return jffs2_register_compressor(&jffs2_rtime_comp);
}
void jffs2_rtime_exit(void)
{
    jffs2_unregister_compressor(&jffs2_rtime_comp);
}
static inline int pushedbits(struct pushpull *pp)
{
	return pp->ofs;
}
static inline int pulledbits(struct pushpull *pp)
{
	return pp->ofs;
}
int jffs2_rubinmips_init(void)
{
	return jffs2_register_compressor(&jffs2_rubinmips_comp);
}
void jffs2_rubinmips_exit(void)
{
	jffs2_unregister_compressor(&jffs2_rubinmips_comp);
}
int jffs2_dynrubin_init(void)
{
	return jffs2_register_compressor(&jffs2_dynrubin_comp);
}
void jffs2_dynrubin_exit(void)
{
	jffs2_unregister_compressor(&jffs2_dynrubin_comp);
}
void jffs2_gc_release_inode(struct jffs2_sb_info *c,
				   struct jffs2_inode_info *f)
{
	iput(OFNI_EDONI_2SFFJ(f));
}
long jffs2_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
	return -ENOTTY;
}
static inline uint32_t EMPTY_SCAN_SIZE(uint32_t sector_size) {
	if (sector_size < DEFAULT_EMPTY_SCAN_SIZE)
		return sector_size;
	else
		return DEFAULT_EMPTY_SCAN_SIZE;
}
int jffs2_sum_is_disabled(struct jffs2_summary *s)
{
	return (s->sum_size == JFFS2_SUMMARY_NOSUM_SIZE);
}
static void jffs2_destroy_inode(struct inode *inode)
{
	kmem_cache_free(jffs2_inode_cachep, JFFS2_INODE_INFO(inode));
}
static struct inode *jffs2_nfs_get_inode(struct super_block *sb, uint64_t ino,
					 uint32_t generation)
{
	return jffs2_iget(sb, ino);
}
static struct dentry *jffs2_fh_to_dentry(struct super_block *sb, struct fid *fid,
					 int fh_len, int fh_type)
{
        return generic_fh_to_dentry(sb, fid, fh_len, fh_type,
                                    jffs2_nfs_get_inode);
}
static struct dentry *jffs2_fh_to_parent(struct super_block *sb, struct fid *fid,
					 int fh_len, int fh_type)
{
        return generic_fh_to_parent(sb, fid, fh_len, fh_type,
                                    jffs2_nfs_get_inode);
}
static int jffs2_get_sb(struct file_system_type *fs_type,
			int flags, const char *dev_name,
			void *data, struct vfsmount *mnt)
{
	return get_sb_mtd(fs_type, flags, dev_name, data, jffs2_fill_super,
			  mnt);
}
void jffs2_nor_wbuf_flash_cleanup(struct jffs2_sb_info *c) {
	kfree(c->wbuf);
}
void jffs2_ubivol_cleanup(struct jffs2_sb_info *c) {
	kfree(c->wbuf);
}
int jfs_permission(struct inode *inode, int mask)
{
	return generic_permission(inode, mask, jfs_check_acl);
}
static int jfs_writepage(struct page *page, struct writeback_control *wbc)
{
	return block_write_full_page(page, jfs_get_block, wbc);
}
static int jfs_writepages(struct address_space *mapping,
			struct writeback_control *wbc)
{
	return mpage_writepages(mapping, wbc, jfs_get_block);
}
static int jfs_readpage(struct file *file, struct page *page)
{
	return mpage_readpage(page, jfs_get_block);
}
static int jfs_readpages(struct file *file, struct address_space *mapping,
		struct list_head *pages, unsigned nr_pages)
{
	return mpage_readpages(mapping, pages, nr_pages, jfs_get_block);
}
static int jfs_write_begin(struct file *file, struct address_space *mapping,
				loff_t pos, unsigned len, unsigned flags,
				struct page **pagep, void **fsdata)
{
	return nobh_write_begin(file, mapping, pos, len, flags, pagep, fsdata,
				jfs_get_block);
}
static sector_t jfs_bmap(struct address_space *mapping, sector_t block)
{
	return generic_block_bmap(mapping, block, jfs_get_block);
}
static int jfs_loglevel_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, jfs_loglevel_proc_show, NULL);
}
static inline struct jfs_dirent *next_jfs_dirent(struct jfs_dirent *dirent)
{
	return (struct jfs_dirent *)
		((char *)dirent +
		 ((sizeof (struct jfs_dirent) + dirent->name_len + 1 +
		   sizeof (loff_t) - 1) &
		  ~(sizeof (loff_t) - 1)));
}
static int jfs_lmstats_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, jfs_lmstats_proc_show, NULL);
}
static inline void inc_io(struct page *page)
{
	atomic_inc(&mp_anchor(page)->io_count);
}
static inline struct metapage *page_to_mp(struct page *page, int offset)
{
	return PagePrivate(page) ? (struct metapage *)page_private(page) : NULL;
}
static inline struct metapage *alloc_metapage(gfp_t gfp_mask)
{
	return mempool_alloc(metapage_mempool, gfp_mask);
}
void hold_metapage(struct metapage *mp)
{
	lock_page(mp->page);
}
static int jfs_mpstat_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, jfs_mpstat_proc_show, NULL);
}
static int jfs_txanchor_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, jfs_txanchor_proc_show, NULL);
}
static int jfs_txstats_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, jfs_txstats_proc_show, NULL);
}
static int jfs_xtstat_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, jfs_xtstat_proc_show, NULL);
}
struct dentry *jfs_fh_to_dentry(struct super_block *sb, struct fid *fid,
		int fh_len, int fh_type)
{
	return generic_fh_to_dentry(sb, fid, fh_len, fh_type,
				    jfs_nfs_get_inode);
}
struct dentry *jfs_fh_to_parent(struct super_block *sb, struct fid *fid,
		int fh_len, int fh_type)
{
	return generic_fh_to_parent(sb, fid, fh_len, fh_type,
				    jfs_nfs_get_inode);
}
static int jfs_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_bdev(fs_type, flags, dev_name, data, jfs_fill_super,
			   mnt);
}
static inline int name_size(struct jfs_ea *ea)
{
	if (is_os2_xattr(ea))
		return ea->namelen + XATTR_OS2_PREFIX_LEN;
	else
		return ea->namelen;
}
static inline int can_list(struct jfs_ea *ea)
{
	return (strncmp(ea->name, XATTR_TRUSTED_PREFIX,
			    XATTR_TRUSTED_PREFIX_LEN) ||
		capable(CAP_SYS_ADMIN));
}
static int simple_delete_dentry(struct dentry *dentry)
{
	return 1;
}
int simple_sync_file(struct file * file, struct dentry *dentry, int datasync)
{
	return 0;
}
static inline unsigned char dt_type(struct inode *inode)
{
	return (inode->i_mode >> 12) & 15;
}
ssize_t generic_read_dir(struct file *filp, char __user *buf, size_t siz, loff_t *ppos)
{
	return -EISDIR;
}
static inline int simple_positive(struct dentry *dentry)
{
	return dentry->d_inode && !d_unhashed(dentry);
}
static void nlmclnt_release_lockargs(struct nlm_rqst *req)
{
	BUG_ON(req->a_args.lock.fl.fl_ops != NULL);
}
int locks_in_grace(void)
{
	return !list_empty(&grace_list);
}
static inline struct sockaddr *nsm_addr(const struct nsm_handle *nsm)
{
	return (struct sockaddr *)&nsm->sm_addr;
}
static int encode_mon_name(struct xdr_stream *xdr, const struct nsm_args *argp)
{
	return encode_nsm_string(xdr, argp->mon_name);
}
static unsigned long get_lockd_grace_period(void)
{
	if (nlm_grace_period)
		return roundup(nlm_grace_period, nlm_timeout) * HZ;
	else
		return nlm_timeout * 5 * HZ;
}
static void grace_ender(struct work_struct *not_used)
{
	locks_end_grace(&lockd_manager);
}
static inline int is_callback(u32 proc)
{
	return proc == NLMPROC_GRANTED
		|| proc == NLMPROC_GRANTED_MSG
		|| proc == NLMPROC_TEST_RES
		|| proc == NLMPROC_LOCK_RES
		|| proc == NLMPROC_CANCEL_RES
		|| proc == NLMPROC_UNLOCK_RES
		|| proc == NLMPROC_NSM_NOTIFY;
}
static void nlm4svc_callback_exit(struct rpc_task *task, void *data)
{
	dprintk("lockd: %5u callback returned %d\n", task->tk_pid,
			-task->tk_status);
}
static int nlmsvc_same_owner(struct file_lock *fl1, struct file_lock *fl2)
{
	return fl1->fl_owner == fl2->fl_owner && fl1->fl_pid == fl2->fl_pid;
}
static void nlmsvc_callback_exit(struct rpc_task *task, void *data)
{
	dprintk("lockd: %5u callback returned %d\n", task->tk_pid,
			-task->tk_status);
}
static inline int
nlm_cmp_owner(struct nlm_share *share, struct xdr_netobj *oh)
{
	return share->s_owner.len == oh->len
	    && !memcmp(share->s_owner.data, oh->data, oh->len);
}
static inline void nlm_debug_print_fh(char *msg, struct nfs_fh *f)
{
	return;
}
static inline void nlm_debug_print_file(char *msg, struct nlm_file *file)
{
	return;
}
static int
nlmsvc_always_match(void *dummy1, struct nlm_host *dummy2)
{
	return 1;
}
void
nlmsvc_invalidate_all(void)
{
	nlm_traverse_files(NULL, nlmsvc_is_client, NULL);
}
static int
nlmsvc_match_ip(void *datap, struct nlm_host *host)
{
	return nlm_cmp_addr(nlm_srcaddr(host), datap);
}
static inline loff_t
s32_to_loff_t(__s32 offset)
{
	return (loff_t)offset;
}
static inline __be32 *
nlm_decode_oh(__be32 *p, struct xdr_netobj *oh)
{
	return xdr_decode_netobj(p, oh);
}
static inline __be32 *
nlm_encode_oh(__be32 *p, struct xdr_netobj *oh)
{
	return xdr_encode_netobj(p, oh);
}
int
nlmsvc_decode_void(struct svc_rqst *rqstp, __be32 *p, void *dummy)
{
	return xdr_argsize_check(rqstp, p);
}
int
nlmsvc_encode_void(struct svc_rqst *rqstp, __be32 *p, void *dummy)
{
	return xdr_ressize_check(rqstp, p);
}
static int
nlmclt_decode_void(struct rpc_rqst *req, u32 *p, void *ptr)
{
	return 0;
}
static inline loff_t
s64_to_loff_t(__s64 offset)
{
	return (loff_t)offset;
}
static __be32 *
nlm4_decode_oh(__be32 *p, struct xdr_netobj *oh)
{
	return xdr_decode_netobj(p, oh);
}
static __be32 *
nlm4_encode_oh(__be32 *p, struct xdr_netobj *oh)
{
	return xdr_encode_netobj(p, oh);
}
int
nlm4svc_decode_void(struct svc_rqst *rqstp, __be32 *p, void *dummy)
{
	return xdr_argsize_check(rqstp, p);
}
int
nlm4svc_encode_void(struct svc_rqst *rqstp, __be32 *p, void *dummy)
{
	return xdr_ressize_check(rqstp, p);
}
static int
nlm4clt_decode_void(struct rpc_rqst *req, __be32 *p, void *ptr)
{
	return 0;
}
static struct file_lock *locks_alloc_lock(void)
{
	return kmem_cache_alloc(filelock_cache, GFP_KERNEL);
}
static void lease_break_callback(struct file_lock *fl)
{
	kill_fasync(&fl->fl_fasync, SIGIO, POLL_MSG);
}
static int lease_mylease_callback(struct file_lock *fl, struct file_lock *try)
{
	return fl->fl_file == try->fl_file;
}
static inline int locks_overlap(struct file_lock *fl1, struct file_lock *fl2)
{
	return ((fl1->fl_end >= fl2->fl_start) &&
		(fl2->fl_end >= fl1->fl_start));
}
int posix_lock_file(struct file *filp, struct file_lock *fl,
			struct file_lock *conflock)
{
	return __posix_lock_file(filp->f_path.dentry->d_inode, fl, conflock);
}
int vfs_lock_file(struct file *filp, unsigned int cmd, struct file_lock *fl, struct file_lock *conf)
{
	if (filp->f_op && filp->f_op->lock)
		return filp->f_op->lock(filp, cmd, fl);
	else
		return posix_lock_file(filp, fl, conf);
}
static void *locks_next(struct seq_file *f, void *v, loff_t *pos)
{
	return seq_list_next(v, &file_lock_list, pos);
}
static void locks_stop(struct seq_file *f, void *v)
{
	unlock_kernel();
}
static int locks_open(struct inode *inode, struct file *filp)
{
	return seq_open(filp, &locks_seq_operations);
}
static inline int
mb_cache_indexes(struct mb_cache *cache)
{
	return MB_CACHE_INDEXES_COUNT;
}
static inline int
__mb_cache_entry_is_hashed(struct mb_cache_entry *ce)
{
	return !list_empty(&ce->e_block_list);
}
static void __exit exit_mbcache(void)
{
	unregister_shrinker(&mb_cache_shrinker);
}
unsigned long minix_count_free_blocks(struct minix_sb_info *sbi)
{
	return (count_free(sbi->s_zmap, sbi->s_zmap_blocks,
		sbi->s_nzones - sbi->s_firstdatazone + 1)
		<< sbi->s_log_zone_size);
}
unsigned long minix_count_free_inodes(struct minix_sb_info *sbi)
{
	return count_free(sbi->s_imap, sbi->s_imap_blocks, sbi->s_ninodes + 1);
}
static inline unsigned long dir_pages(struct inode *inode)
{
	return (inode->i_size+PAGE_CACHE_SIZE-1)>>PAGE_CACHE_SHIFT;
}
static inline void *minix_next_entry(void *de, struct minix_sb_info *sbi)
{
	return (void*)((char*)de + sbi->s_dirsize);
}
static void minix_destroy_inode(struct inode *inode)
{
	kmem_cache_free(minix_inode_cachep, minix_i(inode));
}
static void destroy_inodecache(void)
{
	kmem_cache_destroy(minix_inode_cachep);
}
static int minix_get_block(struct inode *inode, sector_t block,
		    struct buffer_head *bh_result, int create)
{
	if (INODE_VERSION(inode) == MINIX_V1)
		return V1_minix_get_block(inode, block, bh_result, create);
	else
		return V2_minix_get_block(inode, block, bh_result, create);
}
static int minix_writepage(struct page *page, struct writeback_control *wbc)
{
	return block_write_full_page(page, minix_get_block, wbc);
}
static int minix_readpage(struct file *file, struct page *page)
{
	return block_read_full_page(page,minix_get_block);
}
int __minix_write_begin(struct file *file, struct address_space *mapping,
			loff_t pos, unsigned len, unsigned flags,
			struct page **pagep, void **fsdata)
{
	return block_write_begin(file, mapping, pos, len, flags, pagep, fsdata,
				minix_get_block);
}
static sector_t minix_bmap(struct address_space *mapping, sector_t block)
{
	return generic_block_bmap(mapping,block,minix_get_block);
}
static struct buffer_head *minix_update_inode(struct inode *inode)
{
	if (INODE_VERSION(inode) == MINIX_V1)
		return V1_minix_update_inode(inode);
	else
		return V2_minix_update_inode(inode);
}
static int minix_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_bdev(fs_type, flags, dev_name, data, minix_fill_super,
			   mnt);
}
static inline block_t *block_end(struct buffer_head *bh)
{
	return (block_t *)((char*)bh->b_data + bh->b_size);
}
static inline unsigned long block_to_cpu(block_t n)
{
	return n;
}
static inline block_t cpu_to_block(unsigned long n)
{
	return n;
}
static inline block_t *i_data(struct inode *inode)
{
	return (block_t *)minix_i(inode)->u.i1_data;
}
int V1_minix_get_block(struct inode * inode, long block,
			struct buffer_head *bh_result, int create)
{
	return get_block(inode, block, bh_result, create);
}
void V1_minix_truncate(struct inode * inode)
{
	truncate(inode);
}
unsigned V1_minix_blocks(loff_t size, struct super_block *sb)
{
	return nblocks(size, sb);
}
static inline unsigned long block_to_cpu(block_t n)
{
	return n;
}
static inline block_t cpu_to_block(unsigned long n)
{
	return n;
}
static inline block_t *i_data(struct inode *inode)
{
	return (block_t *)minix_i(inode)->u.i2_data;
}
int V2_minix_get_block(struct inode * inode, long block,
			struct buffer_head *bh_result, int create)
{
	return get_block(inode, block, bh_result, create);
}
void V2_minix_truncate(struct inode * inode)
{
	truncate(inode);
}
unsigned V2_minix_blocks(loff_t size, struct super_block *sb)
{
	return nblocks(size, sb);
}
static int minix_create(struct inode * dir, struct dentry *dentry, int mode,
		struct nameidata *nd)
{
	return minix_mknod(dir, dentry, mode, 0);
}
int file_permission(struct file *file, int mask)
{
	return inode_permission(file->f_path.dentry->d_inode, mask);
}
int path_lookup(const char *name, unsigned int flags,
			struct nameidata *nd)
{
	return do_path_lookup(AT_FDCWD, name, flags, nd);
}
struct file *filp_open(const char *filename, int flags, int mode)
{
	return do_filp_open(AT_FDCWD, filename, flags, mode);
}
int vfs_follow_link(struct nameidata *nd, const char *link)
{
	return __vfs_follow_link(nd, link);
}
int page_symlink(struct inode *inode, const char *symname, int len)
{
	return __page_symlink(inode, symname, len,
			!(mapping_gfp_mask(inode->i_mapping) & __GFP_FS));
}
static inline int check_mnt(struct vfsmount *mnt)
{
	return mnt->mnt_ns == current->nsproxy->mnt_ns;
}
static inline void mangle(struct seq_file *m, const char *s)
{
	seq_escape(m, s, " \t\n\\");
}
static void m_stop(struct seq_file *m, void *v)
{
	up_read(&namespace_sem);
}
static inline int
ncp_single_volume(struct ncp_server *server)
{
	return (server->m.mounted_vol[0] != '\0');
}
static inline int ncp_is_server_root(struct inode *inode)
{
	return (!ncp_single_volume(NCP_SERVER(inode)) &&
		inode == inode->i_sb->s_root->d_inode);
}
static int ncp_create(struct inode *dir, struct dentry *dentry, int mode,
		struct nameidata *nd)
{
	return ncp_create_new(dir, dentry, mode, 0, 0);
}
static int utc2local(int time)
{
	return time - sys_tz.tz_minuteswest * 60;
}
static int local2utc(int time)
{
	return time + sys_tz.tz_minuteswest * 60;
}
static int ncp_fsync(struct file *file, struct dentry *dentry, int datasync)
{
	return 0;
}
static void ncp_destroy_inode(struct inode *inode)
{
	kmem_cache_free(ncp_inode_cachep, NCP_FINFO(inode));
}
static void destroy_inodecache(void)
{
	kmem_cache_destroy(ncp_inode_cachep);
}
static int ncp_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_nodev(fs_type, flags, data, ncp_fill_super, mnt);
}
static inline void ncp_add_dword_lh(struct ncp_server *server, __u32 x) {
	ncp_add_dword(server, cpu_to_le32(x));
}
static inline char *
ncp_reply_data(struct ncp_server *server, int offset)
{
	return &(server->packet[sizeof(struct ncp_reply_header) + offset]);
}
static inline u8 BVAL(void *data)
{
	return *(u8 *)data;
}
static u8 ncp_reply_byte(struct ncp_server *server, int offset)
{
	return *(u8 *)ncp_reply_data(server, offset);
}
static inline u16 WVAL_LH(void *data)
{
	return get_unaligned_le16(data);
}
static u16
ncp_reply_le16(struct ncp_server *server, int offset)
{
	return get_unaligned_le16(ncp_reply_data(server, offset));
}
static u16
ncp_reply_be16(struct ncp_server *server, int offset)
{
	return get_unaligned_be16(ncp_reply_data(server, offset));
}
static inline u32 DVAL_LH(void *data)
{
	return get_unaligned_le32(data);
}
static __le32
ncp_reply_dword(struct ncp_server *server, int offset)
{
	return get_unaligned((__le32 *)ncp_reply_data(server, offset));
}
static inline __u32 ncp_reply_dword_lh(struct ncp_server* server, int offset) {
	return le32_to_cpu(ncp_reply_dword(server, offset));
}
int ncp_modify_file_or_subdir_dos_info(struct ncp_server *server,
				       struct inode *dir,
				       __le32 info_mask,
				       const struct nw_modify_dos_info *info)
{
	return ncp_modify_file_or_subdir_dos_info_path(server, dir, NULL,
		info_mask, info);
}
static inline __u16
WVAL_LH(__u8 * buf, int pos)
{
	return PVAL(buf, pos) | PVAL(buf, pos + 1) << 8;
}
static inline __u32
DVAL_LH(__u8 * buf, int pos)
{
	return WVAL_LH(buf, pos) | WVAL_LH(buf, pos + 2) << 16;
}
static __be32 nfs4_callback_null(struct svc_rqst *rqstp, void *argp, void *resp)
{
	return htonl(NFS4_OK);
}
static int nfs4_decode_void(struct svc_rqst *rqstp, __be32 *p, void *dummy)
{
	return xdr_argsize_check(rqstp, p);
}
static int nfs4_encode_void(struct svc_rqst *rqstp, __be32 *p, void *dummy)
{
	return xdr_ressize_check(rqstp, p);
}
static int nfs_sockaddr_match_ipaddr4(const struct sockaddr_in *sa1,
				 const struct sockaddr_in *sa2)
{
	return sa1->sin_addr.s_addr == sa2->sin_addr.s_addr;
}
static void *nfs_server_list_next(struct seq_file *p, void *v, loff_t *pos)
{
	return seq_list_next(v, &nfs_client_list, pos);
}
static void nfs_server_list_stop(struct seq_file *p, void *v)
{
	spin_unlock(&nfs_client_lock);
}
static void *nfs_volume_list_next(struct seq_file *p, void *v, loff_t *pos)
{
	return seq_list_next(v, &nfs_volume_list, pos);
}
static void nfs_volume_list_stop(struct seq_file *p, void *v)
{
	spin_unlock(&nfs_client_lock);
}
static void nfs_do_free_delegation(struct nfs_delegation *delegation)
{
	kfree(delegation);
}
void nfs_mark_delegation_referenced(struct nfs_delegation *delegation)
{
	set_bit(NFS_DELEGATION_REFERENCED, &delegation->flags);
}
static inline unsigned int dt_type(struct inode *inode)
{
	return (inode->i_mode >> 12) & 15;
}
void nfs_force_lookup_revalidate(struct inode *dir)
{
	NFS_I(dir)->cache_change_attribute++;
}
int nfs_may_open(struct inode *inode, struct rpc_cred *cred, int openflags)
{
	return nfs_do_access(inode, cred, nfs_open_permission_mask(openflags));
}
static inline void get_dreq(struct nfs_direct_req *dreq)
{
	atomic_inc(&dreq->io_count);
}
static inline int put_dreq(struct nfs_direct_req *dreq)
{
	return atomic_dec_and_test(&dreq->io_count);
}
static void nfs_direct_req_release(struct nfs_direct_req *dreq)
{
	kref_put(&dreq->kref, nfs_direct_req_free);
}
static inline void nfs_alloc_commit_data(struct nfs_direct_req *dreq)
{
	dreq->commit_data = NULL;
}
void nfs_destroy_directcache(void)
{
	kmem_cache_destroy(nfs_direct_cachep);
}
int nfs_fscache_register(void)
{
	return fscache_register_netfs(&nfs_fscache_netfs);
}
void nfs_fscache_unregister(void)
{
	fscache_unregister_netfs(&nfs_fscache_netfs);
}
static void nfs_fh_get_context(void *cookie_netfs_data, void *context)
{
	get_nfs_open_context(context);
}
static inline struct idmap_hashent *
idmap_name_hash(struct idmap_hashtable* h, const char *name, size_t len)
{
	return &h->h_entries[fnvhash32(name, len) % IDMAP_HASH_SZ];
}
static inline struct idmap_hashent *
idmap_id_hash(struct idmap_hashtable* h, __u32 id)
{
	return &h->h_entries[fnvhash32(&id, sizeof(id)) % IDMAP_HASH_SZ];
}
static inline struct idmap_hashent *
idmap_alloc_name(struct idmap_hashtable *h, char *name, size_t len)
{
	return idmap_name_hash(h, name, len);
}
static inline struct idmap_hashent *
idmap_alloc_id(struct idmap_hashtable *h, __u32 id)
{
	return idmap_id_hash(h, id);
}
static inline unsigned long
nfs_fattr_to_ino_t(struct nfs_fattr *fattr)
{
	return nfs_fileid_to_ino_t(fattr->fileid);
}
void put_nfs_open_context(struct nfs_open_context *ctx)
{
	__put_nfs_open_context(ctx, 0);
}
static void put_nfs_open_context_sync(struct nfs_open_context *ctx)
{
	__put_nfs_open_context(ctx, 1);
}
static int nfs_ctime_need_update(const struct inode *inode, const struct nfs_fattr *fattr)
{
	return timespec_compare(&fattr->ctime, &inode->i_ctime) > 0;
}
static int nfs_size_need_update(const struct inode *inode, const struct nfs_fattr *fattr)
{
	return nfs_size_to_loff_t(fattr->size) > i_size_read(inode);
}
static unsigned long nfs_read_attr_generation_counter(void)
{
	return atomic_long_read(&nfs_attr_generation_counter);
}
unsigned long nfs_inc_attr_generation_counter(void)
{
	return atomic_long_inc_return(&nfs_attr_generation_counter);
}
void nfs_destroy_inode(struct inode *inode)
{
	kmem_cache_free(nfs_inode_cachep, NFS_I(inode));
}
static void nfs_destroy_inodecache(void)
{
	kmem_cache_destroy(nfs_inode_cachep);
}
static void nfs3_free_createdata(struct nfs3_createdata *data)
{
	kfree(data);
}
static void
nfs3_proc_unlink_setup(struct rpc_message *msg, struct inode *dir)
{
	msg->rpc_proc = &nfs3_procedures[NFS3PROC_REMOVE];
}
static void nfs3_proc_read_setup(struct nfs_read_data *data, struct rpc_message *msg)
{
	msg->rpc_proc = &nfs3_procedures[NFS3PROC_READ];
}
static void nfs3_proc_write_setup(struct nfs_write_data *data, struct rpc_message *msg)
{
	msg->rpc_proc = &nfs3_procedures[NFS3PROC_WRITE];
}
static void nfs3_proc_commit_setup(struct nfs_write_data *data, struct rpc_message *msg)
{
	msg->rpc_proc = &nfs3_procedures[NFS3PROC_COMMIT];
}
static inline __be32 *
xdr_encode_fhandle(__be32 *p, const struct nfs_fh *fh)
{
	return xdr_encode_array(p, fh->data, fh->size);
}
static int
nfs3_xdr_removeres(struct rpc_rqst *req, __be32 *p, struct nfs_removeres *res)
{
	return nfs3_xdr_wccstat(req, p, &res->dir_attr);
}
static void nfs4_free_createdata(struct nfs4_createdata *data)
{
	kfree(data);
}
static inline int nfs4_server_supports_acls(struct nfs_server *server)
{
	return (server->caps & NFS_CAP_ACLS)
		&& (server->acl_bitmask & ACL4_SUPPORT_ALLOW_ACL)
		&& (server->acl_bitmask & ACL4_SUPPORT_DENY_ACL);
}
static void nfs4_zap_acl_attr(struct inode *inode)
{
	nfs4_set_cached_acl(inode, NULL);
}
static void nfs4_delegreturn_release(void *calldata)
{
	kfree(calldata);
}
void
nfs4_renewd_prepare_shutdown(struct nfs_server *server)
{
	cancel_delayed_work(&server->nfs_client->cl_renewd);
}
void
nfs4_kill_renewd(struct nfs_client *clp)
{
	cancel_delayed_work_sync(&clp->cl_renewd);
}
static void nfs_free_unique_id(struct rb_root *root, struct nfs_unique_id *id)
{
	rb_erase(&id->rb_node, root);
}
static void
nfs4_free_open_state(struct nfs4_state *state)
{
	kfree(state);
}
void nfs4_close_state(struct path *path, struct nfs4_state *state, fmode_t fmode)
{
	__nfs4_close(path, state, fmode, 0);
}
void nfs4_close_sync(struct path *path, struct nfs4_state *state, fmode_t fmode)
{
	__nfs4_close(path, state, fmode, 1);
}
static void nfs4_fl_release_lock(struct file_lock *fl)
{
	nfs4_put_lock_state(fl->fl_u.nfs4_fl.owner);
}
void nfs_increment_lock_seqid(int status, struct nfs_seqid *seqid)
{
	nfs_increment_seqid(status, seqid);
}
static void nfs4_state_end_reclaim_nograce(struct nfs_client *clp)
{
	clear_bit(NFS4CLNT_RECLAIM_NOGRACE, &clp->cl_state);
}
static void encode_nops(struct compound_hdr *hdr)
{
	*hdr->nops_p = htonl(hdr->nops);
}
static void encode_getfattr(struct xdr_stream *xdr, const u32* bitmask, struct compound_hdr *hdr)
{
	encode_getattr_two(xdr, bitmask[0] & nfs4_fattr_bitmap[0],
			   bitmask[1] & nfs4_fattr_bitmap[1], hdr);
}
static void encode_fsinfo(struct xdr_stream *xdr, const u32* bitmask, struct compound_hdr *hdr)
{
	encode_getattr_two(xdr, bitmask[0] & nfs4_fsinfo_bitmap[0],
			   bitmask[1] & nfs4_fsinfo_bitmap[1], hdr);
}
static void encode_fs_locations(struct xdr_stream *xdr, const u32* bitmask, struct compound_hdr *hdr)
{
	encode_getattr_two(xdr, bitmask[0] & nfs4_fs_locations_bitmap[0],
			   bitmask[1] & nfs4_fs_locations_bitmap[1], hdr);
}
static int nfs4_xdr_enc_symlink(struct rpc_rqst *req, __be32 *p, const struct nfs4_create_arg *args)
{
	return nfs4_xdr_enc_create(req, p, args);
}
static int decode_lookup(struct xdr_stream *xdr)
{
	return decode_op_hdr(xdr, OP_LOOKUP);
}
static int decode_putfh(struct xdr_stream *xdr)
{
	return decode_op_hdr(xdr, OP_PUTFH);
}
static int decode_putrootfh(struct xdr_stream *xdr)
{
	return decode_op_hdr(xdr, OP_PUTROOTFH);
}
static int decode_renew(struct xdr_stream *xdr)
{
	return decode_op_hdr(xdr, OP_RENEW);
}
static int
decode_restorefh(struct xdr_stream *xdr)
{
	return decode_op_hdr(xdr, OP_RESTOREFH);
}
static int
decode_savefh(struct xdr_stream *xdr)
{
	return decode_op_hdr(xdr, OP_SAVEFH);
}
static int decode_setclientid_confirm(struct xdr_stream *xdr)
{
	return decode_op_hdr(xdr, OP_SETCLIENTID_CONFIRM);
}
static int decode_delegreturn(struct xdr_stream *xdr)
{
	return decode_op_hdr(xdr, OP_DELEGRETURN);
}
static int nfs4_xdr_dec_symlink(struct rpc_rqst *rqstp, __be32 *p, struct nfs4_create_res *res)
{
	return nfs4_xdr_dec_create(rqstp, p, res);
}
static inline void
nfs_page_free(struct nfs_page *p)
{
	kmem_cache_free(nfs_page_cachep, p);
}
void nfs_release_request(struct nfs_page *req)
{
	kref_put(&req->wb_kref, nfs_free_request);
}
void nfs_pageio_complete(struct nfs_pageio_descriptor *desc)
{
	nfs_pageio_doio(desc);
}
void nfs_destroy_nfspagecache(void)
{
	kmem_cache_destroy(nfs_page_cachep);
}
static void
nfs_proc_unlink_setup(struct rpc_message *msg, struct inode *dir)
{
	msg->rpc_proc = &nfs_procedures[NFSPROC_REMOVE];
}
static void nfs_proc_read_setup(struct nfs_read_data *data, struct rpc_message *msg)
{
	msg->rpc_proc = &nfs_procedures[NFSPROC_READ];
}
static void
nfs_proc_commit_setup(struct nfs_write_data *data, struct rpc_message *msg)
{
	BUG();
}
static void nfs_parse_invalid_value(const char *option)
{
	dfprintk(MOUNT, "NFS:   bad value specified for %s option\n", option);
}
static int nfs_bdi_register(struct nfs_server *server)
{
	return bdi_register_dev(&server->backing_dev_info, server->s_dev);
}
static void
nfs_mark_request_dirty(struct nfs_page *req)
{
	__set_page_dirty_nobuffers(req->wb_page);
}
static inline
int nfs_write_need_commit(struct nfs_write_data *data)
{
	return data->verf.committed != NFS_FILE_SYNC;
}
static inline int
nfs_clear_request_commit(struct nfs_page *req)
{
	return 0;
}
static inline
int nfs_write_need_commit(struct nfs_write_data *data)
{
	return 0;
}
static inline
int nfs_reschedule_unstable_write(struct nfs_page *req)
{
	return 0;
}
static inline int nfs_scan_commit(struct inode *inode, struct list_head *dst, pgoff_t idx_start, unsigned int npages)
{
	return 0;
}
static int nfs_write_pageuptodate(struct page *page, struct inode *inode)
{
	return PageUptodate(page) &&
		!(NFS_I(inode)->cache_validity & (NFS_INO_REVAL_PAGECACHE|NFS_INO_INVALID_DATA));
}
static inline int nfs_commit_list(struct inode *inode, struct list_head *head, int how)
{
	return 0;
}
int nfs_wb_all(struct inode *inode)
{
	return nfs_write_mapping(inode->i_mapping, 0);
}
int nfs_wb_nocommit(struct inode *inode)
{
	return nfs_write_mapping(inode->i_mapping, FLUSH_NOCOMMIT);
}
int nfs_wb_page(struct inode *inode, struct page* page)
{
	return nfs_wb_page_priority(inode, page, FLUSH_STABLE);
}
static inline int
fsloc_parse(char **mesg, char *buf, struct nfsd4_fs_locations *fsloc){return 0;}
static inline int
secinfo_parse(char **mesg, char *buf, struct svc_export *exp) { return 0; }
void
exp_readlock(void)
{
	down_read(&hash_sem);
}
static inline void
exp_writelock(void)
{
	down_write(&hash_sem);
}
void
exp_readunlock(void)
{
	up_read(&hash_sem);
}
static inline void
exp_writeunlock(void)
{
	up_write(&hash_sem);
}
static void
nlm_fclose(struct file *filp)
{
	fput(filp);
}
void
nfsd_lockd_shutdown(void)
{
	nlmsvc_ops = NULL;
}
static __be32
nfsacld_proc_null(struct svc_rqst *rqstp, void *argp, void *resp)
{
	return nfs_ok;
}
static __be32
nfsd3_proc_null(struct svc_rqst *rqstp, void *argp, void *resp)
{
	return nfs_ok;
}
static __be32
nfsd3_proc_null(struct svc_rqst *rqstp, void *argp, void *resp)
{
	return nfs_ok;
}
__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)
{
	return decode_fh(p, fhp);
}
__be32 *
nfs3svc_encode_post_op_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)
{
	return encode_post_op_attr(rqstp, p, fhp);
}
int
nfs3svc_encode_voidres(struct svc_rqst *rqstp, __be32 *p, void *dummy)
{
	return xdr_ressize_check(rqstp, p);
}
int
nfs3svc_encode_entry(void *cd, const char *name,
		     int namlen, loff_t offset, u64 ino, unsigned int d_type)
{
	return encode_entry(cd, name, namlen, offset, ino, d_type, 0);
}
int
nfs3svc_encode_entry_plus(void *cd, const char *name,
			  int namlen, loff_t offset, u64 ino,
			  unsigned int d_type)
{
	return encode_entry(cd, name, namlen, offset, ino, d_type, 1);
}
static inline void add_to_mask(struct posix_acl_state *state, struct posix_ace_state *astate)
{
	state->mask.allow |= astate->allow;
}
static inline void allow_bits(struct posix_ace_state *astate, u32 mask)
{
	astate->allow |= mask & ~astate->deny;
}
static inline void deny_bits(struct posix_ace_state *astate, u32 mask)
{
	astate->deny |= mask & ~astate->allow;
}
static int
nfs4_xdr_dec_cb_null(struct rpc_rqst *req, __be32 *p)
{
	return 0;
}
static void
warn_no_idmapd(struct cache_detail *detail)
{
	printk("nfsd: nfsv4 idmapping failing: has idmapd %s?\n",
			detail->last_close? "died" : "not been started");
}
static inline int
nametoid_hash(struct ent *ent)
{
	return hash_str(ent->name, ENT_HASHBITS);
}
static inline void
get_mdr(struct idmap_defer_req *mdr)
{
	atomic_inc(&mdr->count);
}
int
nfsd_map_name_to_uid(struct svc_rqst *rqstp, const char *name, size_t namelen,
		__u32 *id)
{
	return idmap_name_to_id(rqstp, IDMAP_TYPE_USER, name, namelen, id);
}
int
nfsd_map_name_to_gid(struct svc_rqst *rqstp, const char *name, size_t namelen,
		__u32 *id)
{
	return idmap_name_to_id(rqstp, IDMAP_TYPE_GROUP, name, namelen, id);
}
int
nfsd_map_uid_to_name(struct svc_rqst *rqstp, __u32 id, char *name)
{
	return idmap_id_to_name(rqstp, IDMAP_TYPE_USER, id, name);
}
int
nfsd_map_gid_to_name(struct svc_rqst *rqstp, __u32 id, char *name)
{
	return idmap_id_to_name(rqstp, IDMAP_TYPE_GROUP, id, name);
}
static __be32
nfsd4_lookup(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
	     struct nfsd4_lookup *lookup)
{
	return nfsd_lookup(rqstp, &cstate->current_fh,
			   lookup->lo_name, lookup->lo_len,
			   &cstate->current_fh);
}
static __be32
nfsd4_proc_null(struct svc_rqst *rqstp, void *argp, void *resp)
{
	return nfs_ok;
}
static void
nfs4_reset_creds(const struct cred *original)
{
	revert_creds(original);
}
void
nfs4_lock_state(void)
{
	mutex_lock(&client_mutex);
}
void
nfs4_unlock_state(void)
{
	mutex_unlock(&client_mutex);
}
static inline void
put_nfs4_file(struct nfs4_file *fi)
{
	kref_put(&fi->fi_ref, free_nfs4_file);
}
static inline void
get_nfs4_file(struct nfs4_file *fi)
{
	kref_get(&fi->fi_ref);
}
static void copy_verf(struct nfs4_client *target, nfs4_verifier *source)
{
	memcpy(target->cl_verifier.data, source->data,
			sizeof(target->cl_verifier.data));
}
static int same_name(const char *n1, const char *n2)
{
	return 0 == memcmp(n1, n2, HEXDIR_LEN);
}
static int
same_verf(nfs4_verifier *v1, nfs4_verifier *v2)
{
	return 0 == memcmp(v1->data, v2->data, sizeof(v1->data));
}
static int
same_clid(clientid_t *cl1, clientid_t *cl2)
{
	return (cl1->cl_boot == cl2->cl_boot) && (cl1->cl_id == cl2->cl_id);
}
static int
same_creds(struct svc_cred *cr1, struct svc_cred *cr2)
{
	return cr1->cr_uid == cr2->cr_uid;
}
static int
same_owner_str(struct nfs4_stateowner *sop, struct xdr_netobj *owner,
							clientid_t *clid)
{
	return (sop->so_owner.len == owner->len) &&
		0 == memcmp(sop->so_owner.data, owner->data, owner->len) &&
		(sop->so_client->cl_clientid.cl_id == clid->cl_id);
}
static inline int deny_valid(u32 x)
{
	return x <= NFS4_SHARE_DENY_BOTH;
}
static
int nfsd_change_deleg_cb(struct file_lock **onlist, int arg)
{
	if (arg & F_UNLCK)
		return lease_modify(onlist, arg);
	else
		return -EAGAIN;
}
static inline __be32
nfs4_check_delegmode(struct nfs4_delegation *dp, int flags)
{
	if ((flags & WR_STATE) && (dp->dl_type == NFS4_OPEN_DELEGATE_READ))
		return nfserr_openmode;
	else
		return nfs_ok;
}
static inline struct nfs4_stateid *
nfs4_alloc_stateid(void)
{
	return kmem_cache_alloc(stateid_slab, GFP_KERNEL);
}
static inline int
nfs4_check_fh(struct svc_fh *fhp, struct nfs4_stateid *stp)
{
	return fhp->fh_dentry->d_inode != stp->st_vfs_file->f_path.dentry->d_inode;
}
static inline int
access_permit_read(unsigned long access_bmap)
{
	return test_bit(NFS4_SHARE_ACCESS_READ, &access_bmap) ||
		test_bit(NFS4_SHARE_ACCESS_BOTH, &access_bmap) ||
		test_bit(NFS4_SHARE_ACCESS_WRITE, &access_bmap);
}
static inline int
access_permit_write(unsigned long access_bmap)
{
	return test_bit(NFS4_SHARE_ACCESS_WRITE, &access_bmap) ||
		test_bit(NFS4_SHARE_ACCESS_BOTH, &access_bmap);
}
static inline __be32
check_special_stateids(svc_fh *current_fh, stateid_t *stateid, int flags)
{
	if (!(flags & (RD_STATE | WR_STATE)))
		return nfserr_bad_stateid;
	else if (ONE_STATEID(stateid) && (flags & RD_STATE))
		return nfs_ok;
	else if (locks_in_grace()) {
	} else if (flags & WR_STATE)
		return nfs4_share_conflict(current_fh,
				NFS4_SHARE_DENY_WRITE);
	else /* (flags & RD_STATE) && ZERO_STATEID(stateid) */
		return nfs4_share_conflict(current_fh,
				NFS4_SHARE_DENY_READ);
}
static inline int
io_during_grace_disallowed(struct inode *inode, int flags)
{
	return locks_in_grace() && (flags & (RD_STATE | WR_STATE))
		&& mandatory_lock(inode);
}
static inline int
setlkflg (int type)
{
	return (type == NFS4_READW_LT || type == NFS4_READ_LT) ?
		RD_STATE : WR_STATE;
}
static inline unsigned int
lock_ownerstr_hashval(struct inode *inode, u32 cl_id,
		struct xdr_netobj *ownername)
{
	return (file_hashval(inode) + cl_id
			+ opaque_hashval(ownername->data, ownername->len))
		& LOCK_HASH_MASK;
}
static int
check_lock_length(u64 offset, u64 length)
{
	return ((length == 0)  || ((length != NFS4_MAX_UINT64) &&
	     LOFF_OVERFLOW(offset, length)));
}
static inline struct nfs4_client_reclaim *
alloc_reclaim(void)
{
	return kmalloc(sizeof(struct nfs4_client_reclaim), GFP_KERNEL);
}
__be32
nfs4_check_open_reclaim(clientid_t *clid)
{
	return nfs4_find_reclaim_client(clid) ? nfs_ok : nfserr_reclaim_bad;
}
unsigned long
get_nfs4_grace_period(void)
{
	return max(user_lease_time, lease_time) * HZ;
}
static void
set_max_delegations(void)
{
	max_delegations = nr_free_buffer_pages() >> (20 - 2 - PAGE_SHIFT);
}
time_t
nfs4_lease_time(void)
{
	return lease_time;
}
static void
nfs4_set_recdir(char *recdir)
{
	strcpy(user_recovery_dirname, recdir);
}
char *
nfs4_recoverydir(void)
{
	return user_recovery_dirname;
}
void
nfs4_reset_lease(time_t leasetime)
{
	user_lease_time = leasetime;
}
static inline __be32
nfsd4_decode_delegreturn(struct nfsd4_compoundargs *argp, struct nfsd4_delegreturn *dr)
{
	return nfsd4_decode_stateid(argp, &dr->dr_stateid);
}
static inline __be32
nfsd4_decode_getattr(struct nfsd4_compoundargs *argp, struct nfsd4_getattr *getattr)
{
	return nfsd4_decode_bitmap(argp, getattr->ga_bmval);
}
static __be32
nfsd4_decode_noop(struct nfsd4_compoundargs *argp, void *p)
{
	return nfs_ok;
}
static __be32
nfsd4_decode_notsupp(struct nfsd4_compoundargs *argp, void *p)
{
	return nfserr_opnotsupp;
}
static inline __be32
nfsd4_encode_user(struct svc_rqst *rqstp, uid_t uid, __be32 **p, int *buflen)
{
	return nfsd4_encode_name(rqstp, NFS4_ACL_WHO_NAMED, uid, 0, p, buflen);
}
static inline __be32
nfsd4_encode_group(struct svc_rqst *rqstp, uid_t gid, __be32 **p, int *buflen)
{
	return nfsd4_encode_name(rqstp, NFS4_ACL_WHO_NAMED, gid, 1, p, buflen);
}
static inline __be32
nfsd4_encode_aclname(struct svc_rqst *rqstp, int whotype, uid_t id, int group,
		__be32 **p, int *buflen)
{
	return nfsd4_encode_name(rqstp, whotype, id, group, p, buflen);
}
static __be32
nfsd4_encode_noop(struct nfsd4_compoundres *resp, __be32 nfserr, void *p)
{
	return nfserr;
}
int
nfs4svc_encode_voidres(struct svc_rqst *rqstp, __be32 *p, void *dummy)
{
        return xdr_ressize_check(rqstp, p);
}
static void
lru_put_end(struct svc_cacherep *rp)
{
	list_move_tail(&rp->c_lru, &lru_head);
}
static int exports_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &nfs_exports_op);
}
static int nfsd_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_single(fs_type, flags, data, nfsd_fill_super, mnt);
}
static int create_proc_exports_entry(void)
{
	return 0;
}
static __be32
nfsd_proc_null(struct svc_rqst *rqstp, void *argp, void *resp)
{
	return nfs_ok;
}
int nfsd_nrpools(void)
{
	if (nfsd_serv == NULL)
		return 0;
	else
		return nfsd_serv->sv_nrpools;
}
__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)
{
	return decode_fh(p, fhp);
}
int
nfssvc_decode_void(struct svc_rqst *rqstp, __be32 *p, void *dummy)
{
	return xdr_argsize_check(rqstp, p);
}
int
nfssvc_encode_void(struct svc_rqst *rqstp, __be32 *p, void *dummy)
{
	return xdr_ressize_check(rqstp, p);
}
static int nfsd_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, nfsd_proc_show, NULL);
}
void
nfsd_stat_init(void)
{
	svc_proc_register(&nfsd_svcstats, &nfsd_proc_fops);
}
void
nfsd_stat_shutdown(void)
{
	svc_proc_unregister("nfsd");
}
void
nfsd_close(struct file *filp)
{
	fput(filp);
}
int
nfsd_sync_dir(struct dentry *dp)
{
	return nfsd_dosync(NULL, dp, dp->d_inode->i_fop);
}
static int nfsd_direct_splice_actor(struct pipe_inode_info *pipe,
				    struct splice_desc *sd)
{
	return __splice_from_pipe(pipe, sd, nfsd_splice_actor);
}
static inline int svc_msnfs(struct svc_fh *ffhp)
{
	return (ffhp->fh_export->ex_flags & NFSEXP_MSNFS);
}
static int exp_rdonly(struct svc_rqst *rqstp, struct svc_export *exp)
{
	return nfsexp_flags(rqstp, exp) & NFSEXP_READONLY;
}
static int __init init_nls_ascii(void)
{
	return register_nls(&table);
}
static void __exit exit_nls_ascii(void)
{
	unregister_nls(&table);
}
struct nls_table *load_nls(char *charset)
{
	return try_then_request_module(find_nls(charset), "nls_%s", charset);
}
void unload_nls(struct nls_table *nls)
{
	module_put(nls->owner);
}
static int __init init_nls_cp1250(void)
{
        return register_nls(&table);
}
static void __exit exit_nls_cp1250(void)
{
        unregister_nls(&table);
}
static int __init init_nls_cp1251(void)
{
	return register_nls(&table);
}
static void __exit exit_nls_cp1251(void)
{
	unregister_nls(&table);
}
static int __init init_nls_cp1255(void)
{
	return register_nls(&table);
}
static void __exit exit_nls_cp1255(void)
{
	unregister_nls(&table);
}
static int __init init_nls_cp437(void)
{
	return register_nls(&table);
}
static void __exit exit_nls_cp437(void)
{
	unregister_nls(&table);
}
static int __init init_nls_cp737(void)
{
	return register_nls(&table);
}
static void __exit exit_nls_cp737(void)
{
	unregister_nls(&table);
}
static int __init init_nls_cp775(void)
{
	return register_nls(&table);
}
static void __exit exit_nls_cp775(void)
{
	unregister_nls(&table);
}
static int __init init_nls_cp850(void)
{
	return register_nls(&table);
}
static void __exit exit_nls_cp850(void)
{
	unregister_nls(&table);
}
static int __init init_nls_cp852(void)
{
	return register_nls(&table);
}
static void __exit exit_nls_cp852(void)
{
	unregister_nls(&table);
}
static int __init init_nls_cp855(void)
{
	return register_nls(&table);
}
static void __exit exit_nls_cp855(void)
{
	unregister_nls(&table);
}
static int __init init_nls_cp857(void)
{
	return register_nls(&table);
}
static void __exit exit_nls_cp857(void)
{
	unregister_nls(&table);
}
static int __init init_nls_cp860(void)
{
	return register_nls(&table);
}
static void __exit exit_nls_cp860(void)
{
	unregister_nls(&table);
}
static int __init init_nls_cp861(void)
{
	return register_nls(&table);
}
static void __exit exit_nls_cp861(void)
{
	unregister_nls(&table);
}
static int __init init_nls_cp862(void)
{
	return register_nls(&table);
}
static void __exit exit_nls_cp862(void)
{
	unregister_nls(&table);
}
static int __init init_nls_cp863(void)
{
	return register_nls(&table);
}
static void __exit exit_nls_cp863(void)
{
	unregister_nls(&table);
}
static int __init init_nls_cp864(void)
{
	return register_nls(&table);
}
static void __exit exit_nls_cp864(void)
{
	unregister_nls(&table);
}
static int __init init_nls_cp865(void)
{
	return register_nls(&table);
}
static void __exit exit_nls_cp865(void)
{
	unregister_nls(&table);
}
static int __init init_nls_cp866(void)
{
	return register_nls(&table);
}
static void __exit exit_nls_cp866(void)
{
	unregister_nls(&table);
}
static int __init init_nls_cp869(void)
{
	return register_nls(&table);
}
static void __exit exit_nls_cp869(void)
{
	unregister_nls(&table);
}
static int __init init_nls_cp874(void)
{
	return register_nls(&table);
}
static void __exit exit_nls_cp874(void)
{
	unregister_nls(&table);
}
static int __init init_nls_iso8859_1(void)
{
	return register_nls(&table);
}
static void __exit exit_nls_iso8859_1(void)
{
	unregister_nls(&table);
}
static int __init init_nls_iso8859_13(void)
{
	return register_nls(&table);
}
static void __exit exit_nls_iso8859_13(void)
{
	unregister_nls(&table);
}
static int __init init_nls_iso8859_14(void)
{
	return register_nls(&table);
}
static void __exit exit_nls_iso8859_14(void)
{
	unregister_nls(&table);
}
static int __init init_nls_iso8859_15(void)
{
	return register_nls(&table);
}
static void __exit exit_nls_iso8859_15(void)
{
	unregister_nls(&table);
}
static int __init init_nls_iso8859_2(void)
{
	return register_nls(&table);
}
static void __exit exit_nls_iso8859_2(void)
{
	unregister_nls(&table);
}
static int __init init_nls_iso8859_3(void)
{
	return register_nls(&table);
}
static void __exit exit_nls_iso8859_3(void)
{
	unregister_nls(&table);
}
static int __init init_nls_iso8859_4(void)
{
	return register_nls(&table);
}
static void __exit exit_nls_iso8859_4(void)
{
	unregister_nls(&table);
}
static int __init init_nls_iso8859_5(void)
{
	return register_nls(&table);
}
static void __exit exit_nls_iso8859_5(void)
{
	unregister_nls(&table);
}
static int __init init_nls_iso8859_6(void)
{
	return register_nls(&table);
}
static void __exit exit_nls_iso8859_6(void)
{
	unregister_nls(&table);
}
static int __init init_nls_iso8859_7(void)
{
	return register_nls(&table);
}
static void __exit exit_nls_iso8859_7(void)
{
	unregister_nls(&table);
}
static int __init init_nls_iso8859_9(void)
{
	return register_nls(&table);
}
static void __exit exit_nls_iso8859_9(void)
{
	unregister_nls(&table);
}
static int __init init_nls_koi8_r(void)
{
	return register_nls(&table);
}
static void __exit exit_nls_koi8_r(void)
{
	unregister_nls(&table);
}
static int __init init_nls_koi8_u(void)
{
	return register_nls(&table);
}
static void __exit exit_nls_koi8_u(void)
{
	unregister_nls(&table);
}
static void __exit exit_nls_utf8(void)
{
        unregister_nls(&table);
}
static int no_blkdev_open(struct inode * inode, struct file * filp)
{
	return -ENODEV;
}
static inline void get_inotify_handle(struct inotify_handle *ih)
{
	atomic_inc(&ih->count);
}
void get_inotify_watch(struct inotify_watch *watch)
{
	atomic_inc(&watch->count);
}
static inline int inotify_inode_watched(struct inode *inode)
{
	return !list_empty(&inode->inotify_watches);
}
u32 inotify_get_cookie(void)
{
	return atomic_inc_return(&inotify_cookie);
}
int inotify_rm_watch(struct inotify_handle *ih,
		     struct inotify_watch *watch)
{
	return inotify_rm_wd(ih, watch->wd);
}
static inline void get_inotify_dev(struct inotify_device *dev)
{
	atomic_inc(&dev->count);
}
static inline struct inotify_kernel_event *
inotify_dev_get_event(struct inotify_device *dev)
{
	return list_entry(dev->events.next, struct inotify_kernel_event, list);
}
static int
inotify_get_sb(struct file_system_type *fs_type, int flags,
	       const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_pseudo(fs_type, "inotify", NULL,
			INOTIFYFS_SUPER_MAGIC, mnt);
}
static inline void ntfs_attr_init_search_ctx(ntfs_attr_search_ctx *ctx,
		ntfs_inode *ni, MFT_RECORD *mrec)
{
	*ctx = (ntfs_attr_search_ctx) {
		.mrec = mrec,
		.attr = (ATTR_RECORD*)((u8*)mrec +
				le16_to_cpu(mrec->attrs_offset)),
		.is_first = true,
		.ntfs_ino = ni,
	};
}
void ntfs_truncate_vfs(struct inode *vi) {
	ntfs_truncate(vi);
}
static struct dentry *ntfs_fh_to_dentry(struct super_block *sb, struct fid *fid,
		int fh_len, int fh_type)
{
	return generic_fh_to_dentry(sb, fid, fh_len, fh_type,
				    ntfs_nfs_get_inode);
}
static struct dentry *ntfs_fh_to_parent(struct super_block *sb, struct fid *fid,
		int fh_len, int fh_type)
{
	return generic_fh_to_parent(sb, fid, fh_len, fh_type,
				    ntfs_nfs_get_inode);
}
static inline void __ntfs_rl_merge(runlist_element *dst, runlist_element *src)
{
	dst->length += src->length;
}
static int ntfs_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_bdev(fs_type, flags, dev_name, data, ntfs_fill_super,
			   mnt);
}
void ntfs_file_upcase_value(FILE_NAME_ATTR *file_name_attr,
		const ntfschar *upcase, const u32 upcase_len)
{
	ntfs_upcase_name((ntfschar*)&file_name_attr->file_name,
			file_name_attr->file_name_length, upcase, upcase_len);
}
int ntfs_file_compare_values(FILE_NAME_ATTR *file_name_attr1,
		FILE_NAME_ATTR *file_name_attr2,
		const int err_val, const IGNORE_CASE_BOOL ic,
		const ntfschar *upcase, const u32 upcase_len)
{
	return ntfs_collate_names((ntfschar*)&file_name_attr1->file_name,
			file_name_attr1->file_name_length,
			(ntfschar*)&file_name_attr2->file_name,
			file_name_attr2->file_name_length,
			err_val, ic, upcase, upcase_len);
}
static void ocfs2_xattr_tree_fill_max_leaf_clusters(struct inode *inode,
						    struct ocfs2_extent_tree *et)
{
	et->et_max_leaf_clusters =
		ocfs2_clusters_for_bytes(inode->i_sb,
					 OCFS2_MAX_XATTR_TREE_LEAF_SIZE);
}
void ocfs2_init_dinode_extent_tree(struct ocfs2_extent_tree *et,
				   struct inode *inode,
				   struct buffer_head *bh)
{
	__ocfs2_init_extent_tree(et, inode, bh, ocfs2_journal_access_di,
				 NULL, &ocfs2_dinode_et_ops);
}
void ocfs2_init_xattr_tree_extent_tree(struct ocfs2_extent_tree *et,
				       struct inode *inode,
				       struct buffer_head *bh)
{
	__ocfs2_init_extent_tree(et, inode, bh, ocfs2_journal_access_xb,
				 NULL, &ocfs2_xattr_tree_et_ops);
}
void ocfs2_init_xattr_value_extent_tree(struct ocfs2_extent_tree *et,
					struct inode *inode,
					struct ocfs2_xattr_value_buf *vb)
{
	__ocfs2_init_extent_tree(et, inode, vb->vb_bh, vb->vb_access, vb,
				 &ocfs2_xattr_value_et_ops);
}
static inline void ocfs2_et_set_last_eb_blk(struct ocfs2_extent_tree *et,
					    u64 new_last_eb_blk)
{
	et->et_ops->eo_set_last_eb_blk(et, new_last_eb_blk);
}
static inline u64 ocfs2_et_get_last_eb_blk(struct ocfs2_extent_tree *et)
{
	return et->et_ops->eo_get_last_eb_blk(et);
}
static inline void ocfs2_et_update_clusters(struct inode *inode,
					    struct ocfs2_extent_tree *et,
					    u32 clusters)
{
	et->et_ops->eo_update_clusters(inode, et, clusters);
}
static inline int ocfs2_et_root_journal_access(handle_t *handle,
					       struct inode *inode,
					       struct ocfs2_extent_tree *et,
					       int type)
{
	return et->et_root_journal_access(handle, inode, et->et_root_bh,
					  type);
}
static struct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)
{
	return ocfs2_new_path(path_root_bh(path), path_root_el(path),
			      path_root_access(path));
}
static struct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)
{
	return ocfs2_new_path(et->et_root_bh, et->et_root_el,
			      et->et_root_journal_access);
}
static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,
					 struct ocfs2_extent_block *eb)
{
	return ocfs2_cache_block_dealloc(ctxt, EXTENT_ALLOC_SYSTEM_INODE,
					 le16_to_cpu(eb->h_suballoc_slot),
					 le64_to_cpu(eb->h_blkno),
					 le16_to_cpu(eb->h_suballoc_bit));
}
static inline int ocfs2_should_zero_cluster(struct ocfs2_write_cluster_desc *d)
{
	return d->c_new || d->c_unwritten;
}
u32 ocfs2_hamming_encode_block(void *data, unsigned int blocksize)
{
	return ocfs2_hamming_encode(0, data, blocksize * 8, 0);
}
void ocfs2_hamming_fix_block(void *data, unsigned int blocksize,
			     unsigned int fix)
{
	ocfs2_hamming_fix(data, blocksize * 8, 0, fix);
}
static void o2hb_dump_slot(struct o2hb_disk_heartbeat_block *hb_block)
{
	mlog(ML_ERROR, "Dump slot information: seq = 0x%llx, node = %u, "
	     "cksum = 0x%x, generation 0x%llx\n",
	     (long long)le64_to_cpu(hb_block->hb_seq),
	     hb_block->hb_node, le32_to_cpu(hb_block->hb_cksum),
	     (long long)le64_to_cpu(hb_block->hb_generation));
}
static ssize_t o2hb_debug_read(struct file *file, char __user *buf,
				 size_t nbytes, loff_t *ppos)
{
	return simple_read_from_buffer(buf, nbytes, ppos, file->private_data,
				       i_size_read(file->f_mapping->host));
}
static int o2hb_debug_open(struct inode *inode, struct file *file)
{
	return 0;
}
static int o2hb_debug_release(struct inode *inode, struct file *file)
{
	return 0;
}
static ssize_t o2hb_debug_read(struct file *file, char __user *buf,
			       size_t nbytes, loff_t *ppos)
{
	return 0;
}
static struct o2hb_region *to_o2hb_region(struct config_item *item)
{
	return item ? container_of(item, struct o2hb_region, hr_item) : NULL;
}
static ssize_t o2hb_region_block_bytes_read(struct o2hb_region *reg,
					    char *page)
{
	return sprintf(page, "%u\n", reg->hr_block_bytes);
}
static ssize_t o2hb_region_start_block_read(struct o2hb_region *reg,
					    char *page)
{
	return sprintf(page, "%llu\n", reg->hr_start_block);
}
static ssize_t o2hb_region_blocks_read(struct o2hb_region *reg,
				       char *page)
{
	return sprintf(page, "%d\n", reg->hr_blocks);
}
static struct o2hb_heartbeat_group *to_o2hb_heartbeat_group(struct config_group *group)
{
	return group ?
		container_of(group, struct o2hb_heartbeat_group, hs_group)
		: NULL;
}
static ssize_t o2hb_heartbeat_group_threshold_show(struct o2hb_heartbeat_group *group,
						     char *page)
{
	return sprintf(page, "%u\n", o2hb_dead_threshold);
}
void mlog_sys_shutdown(void)
{
	kset_unregister(&mlog_kset);
}
void o2nm_node_put(struct o2nm_node *node)
{
	config_item_put(&node->nd_item);
}
void o2nm_node_get(struct o2nm_node *node)
{
	config_item_get(&node->nd_item);
}
static struct o2nm_cluster *to_o2nm_cluster(struct config_item *item)
{
	return item ?
		container_of(to_config_group(item), struct o2nm_cluster,
			     cl_group)
		: NULL;
}
static struct o2nm_node *to_o2nm_node(struct config_item *item)
{
	return item ? container_of(item, struct o2nm_node, nd_item) : NULL;
}
static ssize_t o2nm_node_num_read(struct o2nm_node *node, char *page)
{
	return sprintf(page, "%d\n", node->nd_num);
}
static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)
{
	return to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);
}
static ssize_t o2nm_node_ipv4_port_read(struct o2nm_node *node, char *page)
{
	return sprintf(page, "%u\n", ntohs(node->nd_ipv4_port));
}
static ssize_t o2nm_node_ipv4_address_read(struct o2nm_node *node, char *page)
{
	return sprintf(page, "%pI4\n", &node->nd_ipv4_address);
}
static ssize_t o2nm_node_local_read(struct o2nm_node *node, char *page)
{
	return sprintf(page, "%d\n", node->nd_local);
}
static ssize_t o2nm_cluster_attr_idle_timeout_ms_read(
	struct o2nm_cluster *cluster, char *page)
{
	return sprintf(page, "%u\n", cluster->cl_idle_timeout_ms);
}
static ssize_t o2nm_cluster_attr_keepalive_delay_ms_read(
	struct o2nm_cluster *cluster, char *page)
{
	return sprintf(page, "%u\n", cluster->cl_keepalive_delay_ms);
}
static ssize_t o2nm_cluster_attr_reconnect_delay_ms_read(
	struct o2nm_cluster *cluster, char *page)
{
	return sprintf(page, "%u\n", cluster->cl_reconnect_delay_ms);
}
static ssize_t o2nm_cluster_attr_reconnect_delay_ms_write(
	struct o2nm_cluster *cluster, const char *page, size_t count)
{
	return o2nm_cluster_attr_write(page, count,
	                               &cluster->cl_reconnect_delay_ms);
}
int o2nm_depend_item(struct config_item *item)
{
	return configfs_depend_item(&o2nm_cluster_group.cs_subsys, item);
}
void o2nm_undepend_item(struct config_item *item)
{
	configfs_undepend_item(&o2nm_cluster_group.cs_subsys, item);
}
void o2quo_disk_timeout(void)
{
	o2quo_fence_self();
}
void o2quo_exit(void)
{
	flush_scheduled_work();
}
static ssize_t version_show(struct kobject *kobj, struct kobj_attribute *attr,
			    char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%u\n", O2NM_API_VERSION);
}
static void o2net_set_nst_sock_time(struct o2net_send_tracking *nst)
{
	do_gettimeofday(&nst->st_sock_time);
}
static void o2net_set_nst_send_time(struct o2net_send_tracking *nst)
{
	do_gettimeofday(&nst->st_send_time);
}
static void o2net_set_nst_status_time(struct o2net_send_tracking *nst)
{
	do_gettimeofday(&nst->st_status_time);
}
static void o2net_set_nst_sock_container(struct o2net_send_tracking *nst,
					 struct o2net_sock_container *sc)
{
	nst->st_sc = sc;
}
static void o2net_set_nst_msg_id(struct o2net_send_tracking *nst, u32 msg_id)
{
	nst->st_id = msg_id;
}
static inline int o2net_reconnect_delay(void)
{
	return o2nm_single_cluster->cl_reconnect_delay_ms;
}
static inline int o2net_keepalive_delay(void)
{
	return o2nm_single_cluster->cl_keepalive_delay_ms;
}
static inline int o2net_idle_timeout(void)
{
	return o2nm_single_cluster->cl_idle_timeout_ms;
}
int o2net_num_connected_peers(void)
{
	return atomic_read(&o2net_connected_peers);
}
static void o2net_handler_put(struct o2net_msg_handler *nmh)
{
	kref_put(&nmh->nh_kref, o2net_handler_kref_release);
}
void cluster_print_version(void)
{
	printk(KERN_INFO "%s\n", VERSION_STR);
}
static int ocfs2_supports_dir_trailer(struct ocfs2_super *osb)
{
	return ocfs2_meta_ecc(osb);
}
static inline unsigned int ocfs2_dir_trailer_blk_off(struct super_block *sb)
{
	return sb->s_blocksize - sizeof(struct ocfs2_dir_block_trailer);
}
static inline int ocfs2_delete_entry_el(handle_t *handle,
					struct inode *dir,
					struct ocfs2_dir_entry *de_del,
					struct buffer_head *bh)
{
	return __ocfs2_delete_entry(handle, dir, de_del, bh, bh->b_data,
				    bh->b_size);
}
void dlm_print_one_lock(struct dlm_lock *lockid)
{
	dlm_print_one_lock_resource(lockid->lockres);
}
static void dlm_debug_get(struct dlm_debug_ctxt *dc)
{
	kref_get(&dc->debug_refcnt);
}
static void *lockres_seq_next(struct seq_file *m, void *v, loff_t *pos)
{
	return NULL;
}
static inline void byte_set_bit(u8 nr, u8 map[])
{
	map[nr >> 3] |= (1UL << (nr & 7));
}
static inline int byte_test_bit(u8 nr, u8 map[])
{
	return ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;
}
static void __dlm_get(struct dlm_ctxt *dlm)
{
	kref_get(&dlm->dlm_refs);
}
static void dlm_unregister_net_handlers(void)
{
	o2net_unregister_handler_list(&dlm_join_handlers);
}
static void dlmfs_destroy_inode(struct inode *inode)
{
	kmem_cache_free(dlmfs_inode_cache, DLMFS_I(inode));
}
static int dlmfs_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_nodev(fs_type, flags, data, dlmfs_fill_super, mnt);
}
void dlmfs_print_version(void)
{
	printk(KERN_INFO "%s\n", VERSION_STR);
}
void dlm_lock_get(struct dlm_lock *lock)
{
	kref_get(&lock->lock_refs);
}
void dlm_lock_put(struct dlm_lock *lock)
{
	kref_put(&lock->lock_refs, dlm_lock_release);
}
static inline void dlm_get_mle(struct dlm_master_list_entry *mle)
{
	kref_get(&mle->mle_refs);
}
void dlm_lockres_put(struct dlm_lock_resource *res)
{
	kref_put(&res->refs, dlm_lockres_release);
}
void dlm_kick_recovery_thread(struct dlm_ctxt *dlm)
{
	wake_up(&dlm->dlm_reco_thread_wq);
}
static void dlm_reco_unlock_ast(void *astdata, enum dlm_status st)
{
	mlog(0, "unlockast for recovery lock fired!\n");
}
void dlm_commit_pending_unlock(struct dlm_lock_resource *res,
			       struct dlm_lock *lock)
{
	list_del_init(&lock->list);
}
static inline enum dlm_status dlmunlock_master(struct dlm_ctxt *dlm,
					  struct dlm_lock_resource *res,
					  struct dlm_lock *lock,
					  struct dlm_lockstatus *lksb,
					  int flags,
					  int *call_ast)
{
	return dlmunlock_common(dlm, res, lock, lksb, flags, call_ast, 1);
}
static inline enum dlm_status dlmunlock_remote(struct dlm_ctxt *dlm,
					  struct dlm_lock_resource *res,
					  struct dlm_lock *lock,
					  struct dlm_lockstatus *lksb,
					  int flags, int *call_ast)
{
	return dlmunlock_common(dlm, res, lock, lksb, flags, call_ast, 0);
}
void dlm_print_version(void)
{
	printk(KERN_INFO "%s\n", VERSION_STR);
}
static inline void user_wait_on_busy_lock(struct user_lock_res *lockres)
{
	wait_event(lockres->l_event,
		   !user_check_wait_flag(lockres, USER_LOCK_BUSY));
}
static inline void user_wait_on_blocked_lock(struct user_lock_res *lockres)
{
	wait_event(lockres->l_event,
		   !user_check_wait_flag(lockres, USER_LOCK_BLOCKED));
}
void user_dlm_unregister_context(struct dlm_ctxt *dlm)
{
	dlm_unregister_domain(dlm);
}
static inline int ocfs2_is_inode_lock(struct ocfs2_lock_res *lockres)
{
	return lockres->l_type == OCFS2_LOCK_TYPE_META ||
		lockres->l_type == OCFS2_LOCK_TYPE_RW ||
		lockres->l_type == OCFS2_LOCK_TYPE_OPEN;
}
static inline void ocfs2_track_lock_refresh(struct ocfs2_lock_res *lockres)
{
	lockres->l_lock_refresh++;
}
static void lockres_or_flags(struct ocfs2_lock_res *lockres, unsigned long or)
{
	lockres_set_flags(lockres, lockres->l_flags | or);
}
static void lockres_clear_flags(struct ocfs2_lock_res *lockres,
				unsigned long clear)
{
	lockres_set_flags(lockres, lockres->l_flags & ~clear);
}
static inline void ocfs2_wait_on_busy_lock(struct ocfs2_lock_res *lockres)
{
	wait_event(lockres->l_event,
		   !ocfs2_check_wait_flag(lockres, OCFS2_LOCK_BUSY));
}
static inline void ocfs2_wait_on_refreshing_lock(struct ocfs2_lock_res *lockres)
{
	wait_event(lockres->l_event,
		   !ocfs2_check_wait_flag(lockres, OCFS2_LOCK_REFRESHING));
}
static void ocfs2_get_dlm_debug(struct ocfs2_dlm_debug *debug)
{
	kref_get(&debug->d_refcnt);
}
void ocfs2_set_locking_protocol(void)
{
	ocfs2_stack_glue_set_locking_protocol(&lproto);
}
static int ocfs2_dir_open(struct inode *inode, struct file *file)
{
	return ocfs2_init_file_private(inode, file);
}
static inline void __ocfs2_node_map_set_bit(struct ocfs2_node_map *map,
					    int bit)
{
	set_bit(bit, map->map);
}
static inline void __ocfs2_node_map_clear_bit(struct ocfs2_node_map *map,
					      int bit)
{
	clear_bit(bit, map->map);
}
void ocfs2_sync_blockdev(struct super_block *sb)
{
	sync_blockdev(sb->s_bdev);
}
int ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)
{
	return ocfs2_read_inode_block_full(inode, bh, 0);
}
static inline int ocfs2_wait_on_mount(struct ocfs2_super *osb)
{
	return __ocfs2_wait_on_mount(osb, 0);
}
static inline int ocfs2_wait_on_quotas(struct ocfs2_super *osb)
{
	return __ocfs2_wait_on_mount(osb, 1);
}
static inline struct ocfs2_triggers *to_ocfs2_trigger(struct jbd2_buffer_trigger_type *triggers)
{
	return container_of(triggers, struct ocfs2_triggers, ot_triggers);
}
int ocfs2_journal_access_di(handle_t *handle, struct inode *inode,
			       struct buffer_head *bh, int type)
{
	return __ocfs2_journal_access(handle, inode, bh, &di_triggers,
				      type);
}
int ocfs2_journal_access_eb(handle_t *handle, struct inode *inode,
			    struct buffer_head *bh, int type)
{
	return __ocfs2_journal_access(handle, inode, bh, &eb_triggers,
				      type);
}
int ocfs2_journal_access_gd(handle_t *handle, struct inode *inode,
			    struct buffer_head *bh, int type)
{
	return __ocfs2_journal_access(handle, inode, bh, &gd_triggers,
				      type);
}
int ocfs2_journal_access_db(handle_t *handle, struct inode *inode,
			    struct buffer_head *bh, int type)
{
	return __ocfs2_journal_access(handle, inode, bh, &db_triggers,
				      type);
}
int ocfs2_journal_access_xb(handle_t *handle, struct inode *inode,
			    struct buffer_head *bh, int type)
{
	return __ocfs2_journal_access(handle, inode, bh, &xb_triggers,
				      type);
}
int ocfs2_journal_access_dq(handle_t *handle, struct inode *inode,
			    struct buffer_head *bh, int type)
{
	return __ocfs2_journal_access(handle, inode, bh, &dq_triggers,
				      type);
}
int ocfs2_journal_access(handle_t *handle, struct inode *inode,
			 struct buffer_head *bh, int type)
{
	return __ocfs2_journal_access(handle, inode, bh, NULL, type);
}
static void ocfs2_bump_recovery_generation(struct ocfs2_dinode *di)
{
	le32_add_cpu(&(di->id1.journal1.ij_recovery_generation), 1);
}
static u32 ocfs2_get_recovery_generation(struct ocfs2_dinode *di)
{
	return le32_to_cpu(di->id1.journal1.ij_recovery_generation);
}
void ocfs2_wait_for_recovery(struct ocfs2_super *osb)
{
	wait_event(osb->recovery_event, ocfs2_recovery_completed(osb));
}
static void ocfs2_clear_recovering_orphan_dir(struct ocfs2_super *osb,
					      int slot)
{
	ocfs2_node_map_clear_bit(osb, &osb->osb_recovering_orphan_dirs, slot);
}
static inline int ocfs2_la_state_enabled(struct ocfs2_super *osb)
{
	return (osb->local_alloc_state == OCFS2_LA_THROTTLED ||
		osb->local_alloc_state == OCFS2_LA_ENABLED);
}
static inline int ocfs2_vm_op_unblock_sigs(sigset_t *oldset)
{
	return sigprocmask(SIG_SETMASK, oldset, NULL);
}
static void ocfs2_destroy_dquot(struct dquot *dquot)
{
	kmem_cache_free(ocfs2_dquot_cachep, dquot);
}
static inline unsigned int ol_quota_entries_per_block(struct super_block *sb)
{
	return ((sb->s_blocksize - OCFS2_QBLK_RESERVED_SPACE) /
		sizeof(struct ocfs2_local_disk_dqblk));
}
static inline unsigned int ol_chunk_blocks(struct super_block *sb)
{
	return ((sb->s_blocksize - sizeof(struct ocfs2_local_disk_chunk) -
		 OCFS2_QBLK_RESERVED_SPACE) << 3) /
	       ol_quota_entries_per_block(sb);
}
static unsigned int ol_chunk_entries(struct super_block *sb)
{
	return ol_chunk_blocks(sb) * ol_quota_entries_per_block(sb);
}
static unsigned int ol_quota_chunk_block(struct super_block *sb, int c)
{
	return 1 + (ol_chunk_blocks(sb) + 1) * c;
}
static loff_t ol_dqblk_off(struct super_block *sb, int c, int off)
{
	return (ol_dqblk_block(sb, c, off) << sb->s_blocksize_bits) +
	       ol_dqblk_block_off(sb, c, off);
}
static inline unsigned int ol_dqblk_file_block(struct super_block *sb, loff_t off)
{
	return off >> sb->s_blocksize_bits;
}
static inline unsigned int ol_dqblk_block_offset(struct super_block *sb, loff_t off)
{
	return off & ((1 << sb->s_blocksize_bits) - 1);
}
static int o2cb_dlm_lock_status(union ocfs2_dlm_lksb *lksb)
{
	return dlm_status_to_errno(lksb->lksb_o2dlm.status);
}
static void *o2cb_dlm_lvb(union ocfs2_dlm_lksb *lksb)
{
	return (void *)(lksb->lksb_o2dlm.lvb);
}
static void o2cb_dump_lksb(union ocfs2_dlm_lksb *lksb)
{
	dlm_print_one_lock(lksb->lksb_o2dlm.lockid);
}
static int __init o2cb_stack_init(void)
{
	return ocfs2_stack_glue_register(&o2cb_stack);
}
static void __exit o2cb_stack_exit(void)
{
	ocfs2_stack_glue_unregister(&o2cb_stack);
}
static int user_dlm_lock_status(union ocfs2_dlm_lksb *lksb)
{
	return lksb->lksb_fsdlm.sb_status;
}
int ocfs2_dlm_lock_status(union ocfs2_dlm_lksb *lksb)
{
	return active_stack->sp_ops->lock_status(lksb);
}
void *ocfs2_dlm_lvb(union ocfs2_dlm_lksb *lksb)
{
	return active_stack->sp_ops->lock_lvb(lksb);
}
void ocfs2_dlm_dump_lksb(union ocfs2_dlm_lksb *lksb)
{
	active_stack->sp_ops->dump_lksb(lksb);
}
int ocfs2_stack_supports_plocks(void)
{
	return active_stack && active_stack->sp_ops->plock;
}
int ocfs2_cluster_this_node(unsigned int *node)
{
	return active_stack->sp_ops->this_node(node);
}
static void ocfs2_sysfs_exit(void)
{
	kset_unregister(ocfs2_kset);
}
static u32 ocfs2_bits_per_group(struct ocfs2_chain_list *cl)
{
	return (u32)le16_to_cpu(cl->cl_cpg) * (u32)le16_to_cpu(cl->cl_bpc);
}
int ocfs2_reserve_new_metadata(struct ocfs2_super *osb,
			       struct ocfs2_extent_list *root_el,
			       struct ocfs2_alloc_context **ac)
{
	return ocfs2_reserve_new_metadata_blocks(osb,
					ocfs2_extend_meta_needed(root_el),
					ac);
}
int ocfs2_reserve_clusters(struct ocfs2_super *osb,
			   u32 bits_wanted,
			   struct ocfs2_alloc_context **ac)
{
	return ocfs2_reserve_clusters_with_limit(osb, bits_wanted, 0, ac);
}
static inline int ocfs2_block_group_reasonably_empty(struct ocfs2_group_desc *bg,
						     u32 wanted)
{
	return le16_to_cpu(bg->bg_free_bits_count) > wanted;
}
static ssize_t ocfs2_debug_read(struct file *file, char __user *buf,
				size_t nbytes, loff_t *ppos)
{
	return simple_read_from_buffer(buf, nbytes, ppos, file->private_data,
				       i_size_read(file->f_mapping->host));
}
static int ocfs2_osb_debug_open(struct inode *inode, struct file *file)
{
	return 0;
}
static int ocfs2_debug_release(struct inode *inode, struct file *file)
{
	return 0;
}
static ssize_t ocfs2_debug_read(struct file *file, char __user *buf,
				size_t nbytes, loff_t *ppos)
{
	return 0;
}
static void ocfs2_destroy_inode(struct inode *inode)
{
	kmem_cache_free(ocfs2_inode_cachep, OCFS2_I(inode));
}
static int ocfs2_get_sb(struct file_system_type *fs_type,
			int flags,
			const char *dev_name,
			void *data,
			struct vfsmount *mnt)
{
	return get_sb_bdev(fs_type, flags, dev_name, data, ocfs2_fill_super,
			   mnt);
}
static inline int is_global_system_inode(int type)
{
	return type >= OCFS2_FIRST_ONLINE_SYSTEM_INODE &&
		type <= OCFS2_LAST_GLOBAL_SYSTEM_INODE;
}
static inline int is_in_system_inode_array(struct ocfs2_super *osb,
					   int type,
					   u32 slot)
{
	return slot == osb->slot_num || is_global_system_inode(type);
}
int ocfs2_buffer_read_ahead(struct inode *inode,
			    struct buffer_head *bh)
{
	return buffer_locked(bh) && ocfs2_buffer_cached(OCFS2_I(inode), bh);
}
void ocfs2_print_version(void)
{
	printk(KERN_INFO "%s\n", VERSION_STR);
}
static inline u16 ocfs2_xattr_buckets_per_cluster(struct ocfs2_super *osb)
{
	return (1 << osb->s_clustersize_bits) / OCFS2_XATTR_BUCKET_SIZE;
}
static inline u16 ocfs2_blocks_per_xattr_bucket(struct super_block *sb)
{
	return OCFS2_XATTR_BUCKET_SIZE / (1 << sb->s_blocksize_bits);
}
int ocfs2_init_security_set(handle_t *handle,
			    struct inode *inode,
			    struct buffer_head *di_bh,
			    struct ocfs2_security_xattr_info *si,
			    struct ocfs2_alloc_context *xattr_ac,
			    struct ocfs2_alloc_context *data_ac)
{
	return ocfs2_xattr_set_handle(handle, inode, di_bh,
				     OCFS2_XATTR_INDEX_SECURITY,
				     si->name, si->value, si->value_len, 0,
				     xattr_ac, data_ac);
}
static int omfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
{
	return omfs_add_node(dir, dentry, mode | S_IFDIR);
}
static int omfs_create(struct inode *dir, struct dentry *dentry, int mode,
		struct nameidata *nd)
{
	return omfs_add_node(dir, dentry, mode | S_IFREG);
}
static u32 omfs_max_extents(struct omfs_sb_info *sbi, int offset)
{
	return (sbi->s_sys_blocksize - offset -
		sizeof(struct omfs_extent)) /
		sizeof(struct omfs_extent_entry) + 1;
}
static int omfs_readpage(struct file *file, struct page *page)
{
	return block_read_full_page(page, omfs_get_block);
}
static int omfs_readpages(struct file *file, struct address_space *mapping,
		struct list_head *pages, unsigned nr_pages)
{
	return mpage_readpages(mapping, pages, nr_pages, omfs_get_block);
}
static int omfs_writepage(struct page *page, struct writeback_control *wbc)
{
	return block_write_full_page(page, omfs_get_block, wbc);
}
static int
omfs_writepages(struct address_space *mapping, struct writeback_control *wbc)
{
	return mpage_writepages(mapping, wbc, omfs_get_block);
}
static sector_t omfs_bmap(struct address_space *mapping, sector_t block)
{
	return generic_block_bmap(mapping, block, omfs_get_block);
}
int omfs_sync_inode(struct inode *inode)
{
	return omfs_write_inode(inode, 1);
}
static int omfs_get_sb(struct file_system_type *fs_type,
			int flags, const char *dev_name,
			void *data, struct vfsmount *m)
{
	return get_sb_bdev(fs_type, flags, dev_name, data, omfs_fill_super, m);
}
static int __init init_omfs_fs(void)
{
	return register_filesystem(&omfs_fs_type);
}
static void __exit exit_omfs_fs(void)
{
	unregister_filesystem(&omfs_fs_type);
}
asmlinkage long SyS_truncate64(long path, loff_t length)
{
	return SYSC_truncate64((const char __user *) path, length);
}
asmlinkage long SyS_ftruncate64(long fd, loff_t length)
{
	return SYSC_ftruncate64((unsigned int) fd, length);
}
asmlinkage long SyS_fallocate(long fd, long mode, loff_t offset, loff_t len)
{
	return SYSC_fallocate((int)fd, (int)mode, offset, len);
}
static inline struct op_inode_info *OP_I(struct inode *inode)
{
	return container_of(inode, struct op_inode_info, vfs_inode);
}
static void openprom_destroy_inode(struct inode *inode)
{
	kmem_cache_free(op_inode_cachep, OP_I(inode));
}
static int openprom_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_single(fs_type, flags, data, openprom_fill_super, mnt);
}
static inline int OK_id(char *s)
{
	return  memcmp (s, "GEM", 3) == 0 || memcmp (s, "BGM", 3) == 0 ||
		memcmp (s, "LNX", 3) == 0 || memcmp (s, "SWP", 3) == 0 ||
		memcmp (s, "RAW", 3) == 0 ;
}
const char *bdevname(struct block_device *bdev, char *buf)
{
	return disk_name(bdev->bd_disk, bdev->bd_part->partno, buf);
}
static ssize_t whole_disk_show(struct device *dev,
			       struct device_attribute *attr, char *buf)
{
	return 0;
}
static inline u32
efi_crc32(const void *buf, unsigned long len)
{
	return (crc32(~0L, buf, len) ^ ~0L);
}
static inline int
cchh2blk (struct vtoc_cchh *ptr, struct hd_geometry *geo) {
        return ptr->cc * geo->heads * geo->sectors +
	       ptr->hh * geo->sectors;
}
static inline int
cchhb2blk (struct vtoc_cchhb *ptr, struct hd_geometry *geo) {
        return ptr->cc * geo->heads * geo->sectors +
		ptr->hh * geo->sectors +
		ptr->b;
}
static inline int is_extended_partition(struct partition *p)
{
	return (SYS_IND(p) == DOS_EXTENDED_PARTITION ||
		SYS_IND(p) == WIN98_EXTENDED_PARTITION ||
		SYS_IND(p) == LINUX_EXTENDED_PARTITION);
}
static inline int
msdos_magic_present(unsigned char *p)
{
	return (p[0] == MSDOS_LABEL_MAGIC1 && p[1] == MSDOS_LABEL_MAGIC2);
}
static void
parse_freebsd(struct parsed_partitions *state, struct block_device *bdev,
		u32 offset, u32 size, int origin)
{
	parse_bsd(state, bdev, offset, size, origin,
			"bsd", BSD_MAXPARTITIONS);
}
static void
parse_netbsd(struct parsed_partitions *state, struct block_device *bdev,
		u32 offset, u32 size, int origin)
{
	parse_bsd(state, bdev, offset, size, origin,
			"netbsd", BSD_MAXPARTITIONS);
}
static void
parse_openbsd(struct parsed_partitions *state, struct block_device *bdev,
		u32 offset, u32 size, int origin)
{
	parse_bsd(state, bdev, offset, size, origin,
			"openbsd", OPENBSD_MAXPARTITIONS);
}
void generic_pipe_buf_get(struct pipe_inode_info *pipe, struct pipe_buffer *buf)
{
	page_cache_get(buf->page);
}
int generic_pipe_buf_confirm(struct pipe_inode_info *info,
			     struct pipe_buffer *buf)
{
	return 0;
}
static ssize_t
bad_pipe_r(struct file *filp, char __user *buf, size_t count, loff_t *ppos)
{
	return -EBADF;
}
static ssize_t
bad_pipe_w(struct file *filp, const char __user *buf, size_t count,
	   loff_t *ppos)
{
	return -EBADF;
}
static int
pipe_read_release(struct inode *inode, struct file *filp)
{
	return pipe_release(inode, 1, 0);
}
static int
pipe_write_release(struct inode *inode, struct file *filp)
{
	return pipe_release(inode, 0, 1);
}
static char *pipefs_dname(struct dentry *dentry, char *buffer, int buflen)
{
	return dynamic_dname(dentry, buffer, buflen, "pipe:[%lu]",
				dentry->d_inode->i_ino);
}
int do_pipe(int *fd)
{
	return do_pipe_flags(fd, 0);
}
static int pipefs_get_sb(struct file_system_type *fs_type,
			 int flags, const char *dev_name, void *data,
			 struct vfsmount *mnt)
{
	return get_sb_pseudo(fs_type, "pipe:", NULL, PIPEFS_MAGIC, mnt);
}
static inline struct vfsmount *next_peer(struct vfsmount *p)
{
	return list_entry(p->mnt_share.next, struct vfsmount, mnt_share);
}
static inline struct vfsmount *first_slave(struct vfsmount *p)
{
	return list_entry(p->mnt_slave_list.next, struct vfsmount, mnt_slave);
}
static inline struct vfsmount *next_slave(struct vfsmount *p)
{
	return list_entry(p->mnt_slave.next, struct vfsmount, mnt_slave);
}
static inline void task_context_switch_counts(struct seq_file *m,
						struct task_struct *p)
{
	seq_printf(m,	"voluntary_ctxt_switches:\t%lu\n"
			"nonvoluntary_ctxt_switches:\t%lu\n",
			p->nvcsw,
			p->nivcsw);
}
int proc_tid_stat(struct seq_file *m, struct pid_namespace *ns,
			struct pid *pid, struct task_struct *task)
{
	return do_task_stat(m, ns, pid, task, 0);
}
int proc_tgid_stat(struct seq_file *m, struct pid_namespace *ns,
			struct pid *pid, struct task_struct *task)
{
	return do_task_stat(m, ns, pid, task, 1);
}
static void proc_expire_automounts(struct work_struct *work)
{
	proc_shrink_automounts();
}
static int proc_pid_schedstat(struct task_struct *task, char *buffer)
{
	return sprintf(buffer, "%llu %llu %lu\n",
			(unsigned long long)task->se.sum_exec_runtime,
			(unsigned long long)task->sched_info.run_delay,
			task->sched_info.pcount);
}
static int lstats_open(struct inode *inode, struct file *file)
{
	return single_open(file, lstats_show_proc, inode);
}
static int mounts_open(struct inode *inode, struct file *file)
{
	return mounts_open_common(inode, file, &mounts_op);
}
static int mountinfo_open(struct inode *inode, struct file *file)
{
	return mounts_open_common(inode, file, &mountinfo_op);
}
static int mountstats_open(struct inode *inode, struct file *file)
{
	return mounts_open_common(inode, file, &mountstats_op);
}
void added_exe_file_vma(struct mm_struct *mm)
{
	mm->num_exe_file_vmas++;
}
void dup_mm_exe_file(struct mm_struct *oldmm, struct mm_struct *newmm)
{
	newmm->exe_file = get_mm_exe_file(oldmm);
}
static int pid_delete_dentry(struct dentry * dentry)
{
	return !proc_pid(dentry->d_inode)->tasks[PIDTYPE_PID].first;
}
static int proc_fd_link(struct inode *inode, struct path *path)
{
	return proc_fd_info(inode, path, NULL);
}
static struct dentry *proc_lookupfd(struct inode *dir, struct dentry *dentry,
				    struct nameidata *nd)
{
	return proc_lookupfd_common(dir, dentry, proc_fd_instantiate);
}
static int proc_readfd(struct file *filp, void *dirent, filldir_t filldir)
{
	return proc_readfd_common(filp, dirent, filldir, proc_fd_instantiate);
}
static struct dentry *proc_lookupfdinfo(struct inode *dir,
					struct dentry *dentry,
					struct nameidata *nd)
{
	return proc_lookupfd_common(dir, dentry, proc_fdinfo_instantiate);
}
static int proc_readfdinfo(struct file *filp, void *dirent, filldir_t filldir)
{
	return proc_readfd_common(filp, dirent, filldir,
				  proc_fdinfo_instantiate);
}
static int proc_pident_fill_cache(struct file *filp, void *dirent,
	filldir_t filldir, struct task_struct *task, const struct pid_entry *p)
{
	return proc_fill_cache(filp, dirent, filldir, p->name, p->len,
				proc_pident_instantiate, task, p);
}
static int proc_attr_dir_readdir(struct file * filp,
			     void * dirent, filldir_t filldir)
{
	return proc_pident_readdir(filp,dirent,filldir,
				   attr_dir_stuff,ARRAY_SIZE(attr_dir_stuff));
}
static struct dentry *proc_attr_dir_lookup(struct inode *dir,
				struct dentry *dentry, struct nameidata *nd)
{
	return proc_pident_lookup(dir, dentry,
				  attr_dir_stuff, ARRAY_SIZE(attr_dir_stuff));
}
static int proc_base_fill_cache(struct file *filp, void *dirent,
	filldir_t filldir, struct task_struct *task, const struct pid_entry *p)
{
	return proc_fill_cache(filp, dirent, filldir, p->name, p->len,
				proc_base_instantiate, task, p);
}
static int proc_tid_io_accounting(struct task_struct *task, char *buffer)
{
	return do_io_accounting(task, buffer, 0);
}
static int proc_tgid_io_accounting(struct task_struct *task, char *buffer)
{
	return do_io_accounting(task, buffer, 1);
}
static int proc_tgid_base_readdir(struct file * filp,
			     void * dirent, filldir_t filldir)
{
	return proc_pident_readdir(filp,dirent,filldir,
				   tgid_base_stuff,ARRAY_SIZE(tgid_base_stuff));
}
static struct dentry *proc_tgid_base_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *nd){
	return proc_pident_lookup(dir, dentry,
				  tgid_base_stuff, ARRAY_SIZE(tgid_base_stuff));
}
static int proc_tid_base_readdir(struct file * filp,
			     void * dirent, filldir_t filldir)
{
	return proc_pident_readdir(filp,dirent,filldir,
				   tid_base_stuff,ARRAY_SIZE(tid_base_stuff));
}
static struct dentry *proc_tid_base_lookup(struct inode *dir, struct dentry *dentry, struct nameidata *nd){
	return proc_pident_lookup(dir, dentry,
				  tid_base_stuff, ARRAY_SIZE(tid_base_stuff));
}
static int cmdline_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, cmdline_proc_show, NULL);
}
static int cpuinfo_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &cpuinfo_op);
}
static int devinfo_open(struct inode *inode, struct file *filp)
{
	return seq_open(filp, &devinfo_ops);
}
static int proc_delete_dentry(struct dentry * dentry)
{
	return 1;
}
struct dentry *proc_lookup(struct inode *dir, struct dentry *dentry,
		struct nameidata *nd)
{
	return proc_lookup_de(PDE(dir), dir, dentry);
}
struct proc_dir_entry *proc_mkdir(const char *name,
		struct proc_dir_entry *parent)
{
	return proc_mkdir_mode(name, S_IRUGO | S_IXUGO, parent);
}
static void proc_destroy_inode(struct inode *inode)
{
	kmem_cache_free(proc_inode_cachep, PROC_I(inode));
}
void __init proc_init_inodecache(void)
{
	proc_inode_cachep = kmem_cache_create("proc_inode_cache",
					     sizeof(struct proc_inode),
					     0, (SLAB_RECLAIM_ACCOUNT|
						SLAB_MEM_SPREAD|SLAB_PANIC),
					     init_once);
}
static void *int_seq_start(struct seq_file *f, loff_t *pos)
{
	return (*pos <= nr_irqs) ? pos : NULL;
}
static int interrupts_open(struct inode *inode, struct file *filp)
{
	return seq_open(filp, &int_seq_ops);
}
static int open_kcore(struct inode * inode, struct file * filp)
{
	return capable(CAP_SYS_RAWIO) ? 0 : -EPERM;
}
static int kmsg_open(struct inode * inode, struct file * file)
{
	return do_syslog(1,NULL,0);
}
static int loadavg_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, loadavg_proc_show, NULL);
}
static int meminfo_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, meminfo_proc_show, NULL);
}
static void nommu_region_list_stop(struct seq_file *m, void *v)
{
	up_read(&nommu_region_sem);
}
static int proc_nommu_region_list_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &proc_nommu_region_list_seqop);
}
void proc_device_tree_add_prop(struct proc_dir_entry *pde, struct property *prop)
{
	__proc_device_tree_add_prop(pde, prop, prop->name);
}
void proc_device_tree_remove_prop(struct proc_dir_entry *pde,
				  struct property *prop)
{
	remove_proc_entry(prop->name, pde);
}
static struct net *get_proc_net(const struct inode *inode)
{
	return maybe_get_net(inode->i_sb->s_fs_info);
}
struct proc_dir_entry *proc_net_fops_create(struct net *net,
	const char *name, mode_t mode, const struct file_operations *fops)
{
	return proc_create(name, mode, net->proc_net, fops);
}
void proc_net_remove(struct net *net, const char *name)
{
	remove_proc_entry(name, net->proc_net);
}
static int proc_net_test_super(struct super_block *sb, void *data)
{
	return sb->s_fs_info == data;
}
static struct ctl_table_header *grab_header(struct inode *inode)
{
	if (PROC_I(inode)->sysctl)
		return sysctl_head_grab(PROC_I(inode)->sysctl);
	else
		return sysctl_head_next(NULL);
}
static ssize_t proc_sys_read(struct file *filp, char __user *buf,
				size_t count, loff_t *ppos)
{
	return proc_sys_call_handler(filp, (void __user *)buf, count, ppos, 0);
}
static ssize_t proc_sys_write(struct file *filp, const char __user *buf,
				size_t count, loff_t *ppos)
{
	return proc_sys_call_handler(filp, (void __user *)buf, count, ppos, 1);
}
static int proc_sys_revalidate(struct dentry *dentry, struct nameidata *nd)
{
	return !PROC_I(dentry->d_inode)->sysctl->unregistering;
}
static int proc_sys_delete(struct dentry *dentry)
{
	return !!PROC_I(dentry->d_inode)->sysctl->unregistering;
}
static void *t_next(struct seq_file *m, void *v, loff_t *pos)
{
	return seq_list_next(v, &tty_drivers, pos);
}
static void t_stop(struct seq_file *m, void *v)
{
	mutex_unlock(&tty_mutex);
}
static int tty_drivers_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &tty_drivers_op);
}
static int proc_test_super(struct super_block *sb, void *data)
{
	return sb->s_fs_info == data;
}
void pid_ns_release_proc(struct pid_namespace *ns)
{
	mntput(ns->proc_mnt);
}
unsigned long task_vsize(struct mm_struct *mm)
{
	return PAGE_SIZE * mm->total_vm;
}
static int maps_open(struct inode *inode, struct file *file)
{
	return do_maps_open(inode, file, &proc_pid_maps_op);
}
static int smaps_open(struct inode *inode, struct file *file)
{
	return do_maps_open(inode, file, &proc_pid_smaps_op);
}
static int numa_maps_open(struct inode *inode, struct file *file)
{
	return do_maps_open(inode, file, &proc_pid_numa_maps_op);
}
static int version_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, version_proc_show, NULL);
}
static int qnx4_writepage(struct page *page, struct writeback_control *wbc)
{
	return block_write_full_page(page,qnx4_get_block, wbc);
}
static int qnx4_readpage(struct file *file, struct page *page)
{
	return block_read_full_page(page,qnx4_get_block);
}
static sector_t qnx4_bmap(struct address_space *mapping, sector_t block)
{
	return generic_block_bmap(mapping,block,qnx4_get_block);
}
static void qnx4_destroy_inode(struct inode *inode)
{
	kmem_cache_free(qnx4_inode_cachep, qnx4_i(inode));
}
static void destroy_inodecache(void)
{
	kmem_cache_destroy(qnx4_inode_cachep);
}
static int qnx4_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_bdev(fs_type, flags, dev_name, data, qnx4_fill_super,
			   mnt);
}
static void put_quota_format(struct quota_format_type *fmt)
{
	module_put(fmt->qf_owner);
}
static inline void remove_dquot_hash(struct dquot *dquot)
{
	hlist_del_init(&dquot->dq_hash);
}
static inline int dquot_dirty(struct dquot *dquot)
{
	return test_bit(DQ_MOD_B, &dquot->dq_flags);
}
static inline int mark_dquot_dirty(struct dquot *dquot)
{
	return dquot->dq_sb->dq_op->mark_dirty(dquot);
}
void mark_info_dirty(struct super_block *sb, int type)
{
	set_bit(DQF_INFO_DIRTY_B, &sb_dqopt(sb)->info[type].dqi_flags);
}
void dquot_destroy(struct dquot *dquot)
{
	kmem_cache_free(dquot_cachep, dquot);
}
static inline void do_destroy_dquot(struct dquot *dquot)
{
	dquot->dq_sb->dq_op->destroy_dquot(dquot);
}
struct dquot *dquot_alloc(struct super_block *sb, int type)
{
	return kmem_cache_zalloc(dquot_cachep, GFP_NOFS);
}
static inline void dquot_incr_inodes(struct dquot *dquot, qsize_t number)
{
	dquot->dq_dqb.dqb_curinodes += number;
}
static inline void dquot_incr_space(struct dquot *dquot, qsize_t number)
{
	dquot->dq_dqb.dqb_curspace += number;
}
static inline void dquot_resv_space(struct dquot *dquot, qsize_t number)
{
	dquot->dq_dqb.dqb_rsvspace += number;
}
static inline
void dquot_free_reserved_space(struct dquot *dquot, qsize_t number)
{
	dquot->dq_dqb.dqb_rsvspace -= number;
}
int vfs_quota_off(struct super_block *sb, int type, int remount)
{
	return vfs_quota_disable(sb, type, remount ? DQUOT_SUSPENDED :
				 (DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED));
}
static inline qsize_t qbtos(qsize_t blocks)
{
	return blocks << QIF_DQBLKSIZE_BITS;
}
static inline qsize_t stoqb(qsize_t space)
{
	return (space + QIF_DQBLKSIZE - 1) >> QIF_DQBLKSIZE_BITS;
}
static int qtree_dqstr_in_blk(struct qtree_mem_dqinfo *info)
{
	return (info->dqi_usable_bs - sizeof(struct qt_disk_dqdbheader))
	       / info->dqi_entry_size;
}
static inline loff_t find_dqentry(struct qtree_mem_dqinfo *info,
				  struct dquot *dquot)
{
	return find_tree_dqentry(info, dquot, QT_TREEOFF, 0);
}
static inline qsize_t v1_stoqb(qsize_t space)
{
	return (space + QUOTABLOCK_SIZE - 1) >> QUOTABLOCK_BITS;
}
static inline qsize_t v1_qbtos(qsize_t blocks)
{
	return blocks << QUOTABLOCK_BITS;
}
static int __init init_v1_quota_format(void)
{
        return register_quota_format(&v1_quota_format);
}
static void __exit exit_v1_quota_format(void)
{
        unregister_quota_format(&v1_quota_format);
}
static inline qsize_t v2_stoqb(qsize_t space)
{
	return (space + QUOTABLOCK_SIZE - 1) >> QUOTABLOCK_BITS;
}
static inline qsize_t v2_qbtos(qsize_t blocks)
{
	return blocks << QUOTABLOCK_BITS;
}
static int v2_read_dquot(struct dquot *dquot)
{
	return qtree_read_dquot(sb_dqinfo(dquot->dq_sb, dquot->dq_type)->dqi_priv, dquot);
}
static int v2_write_dquot(struct dquot *dquot)
{
	return qtree_write_dquot(sb_dqinfo(dquot->dq_sb, dquot->dq_type)->dqi_priv, dquot);
}
static int v2_release_dquot(struct dquot *dquot)
{
	return qtree_release_dquot(sb_dqinfo(dquot->dq_sb, dquot->dq_type)->dqi_priv, dquot);
}
static int __init init_v2_quota_format(void)
{
	return register_quota_format(&v2_quota_format);
}
static void __exit exit_v2_quota_format(void)
{
	unregister_quota_format(&v2_quota_format);
}
static int ramfs_create(struct inode *dir, struct dentry *dentry, int mode, struct nameidata *nd)
{
	return ramfs_mknod(dir, dentry, mode | S_IFREG, 0);
}
int ramfs_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_nodev(fs_type, flags, data, ramfs_fill_super, mnt);
}
static int rootfs_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_nodev(fs_type, flags|MS_NOUSER, data, ramfs_fill_super,
			    mnt);
}
static int __init init_ramfs_fs(void)
{
	return register_filesystem(&ramfs_fs_type);
}
static void __exit exit_ramfs_fs(void)
{
	unregister_filesystem(&ramfs_fs_type);
}
loff_t no_llseek(struct file *file, loff_t offset, int origin)
{
	return -ESPIPE;
}
static inline loff_t file_pos_read(struct file *file)
{
	return file->f_pos;
}
static inline void file_pos_write(struct file *file, loff_t pos)
{
	file->f_pos = pos;
}
asmlinkage long SyS_pread64(long fd, long buf, long count, loff_t pos)
{
	return SYSC_pread64((unsigned int) fd, (char __user *) buf,
			    (size_t) count, pos);
}
asmlinkage long SyS_pwrite64(long fd, long buf, long count, loff_t pos)
{
	return SYSC_pwrite64((unsigned int) fd, (const char __user *) buf,
			     (size_t) count, pos);
}
static inline int
this_blocknr_allocation_would_make_it_a_large_file(reiserfs_blocknr_hint_t *
						   hint)
{
	return hint->block ==
	    REISERFS_SB(hint->th->t_super)->s_alloc_options.large_file_size;
}
inline void do_balance_mark_leaf_dirty(struct tree_balance *tb,
				       struct buffer_head *bh, int flag)
{
	journal_mark_dirty(tb->transaction_handle,
			   tb->transaction_handle->t_super, bh);
}
static void reiserfs_vfs_truncate_file(struct inode *inode)
{
	reiserfs_truncate_file(inode, 1);
}
static void decrement_key(struct cpu_key *p_s_key)
{
	item_ops[cpu_key_k_type(p_s_key)]->decrement_key(p_s_key);
}
static void tb_buffer_sanity_check(struct super_block *p_s_sb,
				   struct buffer_head *p_s_bh,
				   const char *descr, int level)
{;
}
static int clear_all_dirty_bits(struct super_block *s, struct buffer_head *bh)
{
	return reiserfs_prepare_for_journal(s, bh, 0);
}
void make_cpu_key(struct cpu_key *key, struct inode *inode, loff_t offset,
		  int type, int length)
{
	_make_cpu_key(key, get_inode_item_key_version(inode),
		      le32_to_cpu(INODE_PKEY(inode)->k_dir_id),
		      le32_to_cpu(INODE_PKEY(inode)->k_objectid), offset, type,
		      length);
}
static inline int indirect_item_found(int retval, struct item_head *ih)
{
	return (retval == POSITION_FOUND) && is_indirect_le_ih(ih);
}
static inline void set_block_dev_mapped(struct buffer_head *bh,
					b_blocknr_t block, struct inode *inode)
{
	map_bh(bh, inode->i_sb, block);
}
static int reiserfs_get_block_create_0(struct inode *inode, sector_t block,
				       struct buffer_head *bh_result,
				       int create)
{
	return reiserfs_get_block(inode, block, bh_result, GET_BLOCK_NO_HOLE);
}
static int
reiserfs_readpages(struct file *file, struct address_space *mapping,
		   struct list_head *pages, unsigned nr_pages)
{
	return mpage_readpages(mapping, pages, nr_pages, reiserfs_get_block);
}
static int reiserfs_readpage(struct file *f, struct page *page)
{
	return block_read_full_page(page, reiserfs_get_block);
}
static sector_t reiserfs_aop_bmap(struct address_space *as, sector_t block)
{
	return generic_block_bmap(as, block, reiserfs_bmap);
}
static int sd_bytes_number(struct item_head *ih, int block_size)
{
	return 0;
}
static int sd_is_left_mergeable(struct reiserfs_key *key, unsigned long bsize)
{
	return 0;
}
static int sd_check_right(struct virtual_item *vi, int free)
{
	return -1;
}
static int sd_unit_num(struct virtual_item *vi)
{
	return vi->vi_item_len - IH_SIZE;
}
static void sd_print_vi(struct virtual_item *vi)
{
	reiserfs_warning(NULL, "STATDATA, index %d, type 0x%x, %h",
			 vi->vi_index, vi->vi_type, vi->vi_ih);
}
static int direct_bytes_number(struct item_head *ih, int block_size)
{
	return ih_item_len(ih);
}
static int direct_check_right(struct virtual_item *vi, int free)
{
	return direct_check_left(vi, free, 0, 0);
}
static int direct_part_size(struct virtual_item *vi, int first, int count)
{
	return count;
}
static int direct_unit_num(struct virtual_item *vi)
{
	return vi->vi_item_len - IH_SIZE;
}
static void direct_print_vi(struct virtual_item *vi)
{
	reiserfs_warning(NULL, "DIRECT, index %d, type 0x%x, %h",
			 vi->vi_index, vi->vi_type, vi->vi_ih);
}
static int indirect_bytes_number(struct item_head *ih, int block_size)
{
	return ih_item_len(ih) / UNFM_P_SIZE * block_size;	//- get_ih_free_space (ih);
}
static int indirect_check_right(struct virtual_item *vi, int free)
{
	return indirect_check_left(vi, free, 0, 0);
}
static int indirect_part_size(struct virtual_item *vi, int first, int units)
{
	return units;
}
static int indirect_unit_num(struct virtual_item *vi)
{
	return vi->vi_item_len - IH_SIZE;
}
static void indirect_print_vi(struct virtual_item *vi)
{
	reiserfs_warning(NULL, "INDIRECT, index %d, type 0x%x, %h",
			 vi->vi_index, vi->vi_type, vi->vi_ih);
}
static void errcatch_decrement_key(struct cpu_key *key)
{
	reiserfs_warning(NULL,
			 "green-16002: Invalid item type observed, run fsck ASAP");
}
static void errcatch_print_item(struct item_head *ih, char *item)
{
	reiserfs_warning(NULL,
			 "green-16004: Invalid item type observed, run fsck ASAP");
}
static void errcatch_check_item(struct item_head *ih, char *item)
{
	reiserfs_warning(NULL,
			 "green-16005: Invalid item type observed, run fsck ASAP");
}
static void errcatch_print_vi(struct virtual_item *vi)
{
	reiserfs_warning(NULL,
			 "green-16011: Invalid item type observed, run fsck ASAP");
}
static inline void unlock_journal(struct super_block *p_s_sb)
{
	mutex_unlock(&SB_JOURNAL(p_s_sb)->j_mutex);
}
static inline void get_journal_list(struct reiserfs_journal_list *jl)
{
	jl->j_refcount++;
}
int reiserfs_add_tail_list(struct inode *inode, struct buffer_head *bh)
{
	return __add_jh(SB_JOURNAL(inode->i_sb), bh, 1);
}
int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh)
{
	return __add_jh(SB_JOURNAL(inode->i_sb), bh, 0);
}
static int update_journal_header_block(struct super_block *p_s_sb,
				       unsigned long offset,
				       unsigned long trans_id)
{
	return _update_journal_header_block(p_s_sb, offset, trans_id);
}
int journal_release(struct reiserfs_transaction_handle *th,
		    struct super_block *p_s_sb)
{
	return do_journal_release(th, p_s_sb, 0);
}
int journal_release_error(struct reiserfs_transaction_handle *th,
			  struct super_block *p_s_sb)
{
	return do_journal_release(th, p_s_sb, 1);
}
static void journal_list_init(struct super_block *p_s_sb)
{
	SB_JOURNAL(p_s_sb)->j_current_jl = alloc_journal_list(p_s_sb);
}
void reiserfs_journal_abort(struct super_block *sb, int errno)
{
	__reiserfs_journal_abort_soft(sb, errno);
}
static void check_objectid_map(struct super_block *s, __le32 * map)
{;
}
static void sprintf_block_head(char *buf, struct buffer_head *bh)
{
	sprintf(buf, "level=%d, nr_items=%d, free_space=%d rdkey ",
		B_LEVEL(bh), B_NR_ITEMS(bh), B_FREE_SPACE(bh));
}
static void sprintf_disk_child(char *buf, struct disk_child *dc)
{
	sprintf(buf, "[dc_number=%d, dc_size=%u]", dc_block_number(dc),
		dc_size(dc));
}
void print_cur_tb(char *mes)
{
	printk("%s\n%s", mes, print_tb_buf);
}
static int test_sb(struct super_block *sb, void *data)
{
	return data == sb;
}
static int set_sb(struct super_block *sb, void *data)
{
	return -ENOENT;
}
static void add_file(struct super_block *sb, char *name,
		     int (*func) (struct seq_file *, struct super_block *))
{
	proc_create_data(name, 0, REISERFS_SB(sb)->procdir,
			 &r_file_operations, func);
}
struct proc_dir_entry *reiserfs_proc_register_global(char *name,
						     read_proc_t * func)
{
	return (proc_info_root) ? create_proc_read_entry(name, 0,
							 proc_info_root,
							 func, NULL) : NULL;
}
void reiserfs_proc_unregister_global(const char *name)
{
	remove_proc_entry(name, proc_info_root);
}
int reiserfs_proc_info_init(struct super_block *sb)
{
	return 0;
}
int reiserfs_proc_info_done(struct super_block *sb)
{
	return 0;
}
struct proc_dir_entry *reiserfs_proc_register_global(char *name,
						     read_proc_t * func)
{
	return NULL;
}
void reiserfs_proc_unregister_global(const char *name)
{;
}
int reiserfs_proc_info_global_init(void)
{
	return 0;
}
int reiserfs_proc_info_global_done(void)
{
	return 0;
}
int reiserfs_global_version_in_proc(char *buffer, char **start,
				    off_t offset,
				    int count, int *eof, void *data)
{
	return 0;
}
inline void copy_item_head(struct item_head *p_v_to,
			   const struct item_head *p_v_from)
{
	memcpy(p_v_to, p_v_from, IH_SIZE);
}
inline int comp_le_keys(const struct reiserfs_key *k1,
			const struct reiserfs_key *k2)
{
	return memcmp(k1, k2, sizeof(struct reiserfs_key));
}
int is_reiserfs_3_5(struct reiserfs_super_block *rs)
{
	return !strncmp(rs->s_v1.s_magic, reiserfs_3_5_magic_string,
			strlen(reiserfs_3_5_magic_string));
}
int is_reiserfs_3_6(struct reiserfs_super_block *rs)
{
	return !strncmp(rs->s_v1.s_magic, reiserfs_3_6_magic_string,
			strlen(reiserfs_3_6_magic_string));
}
int is_reiserfs_jr(struct reiserfs_super_block *rs)
{
	return !strncmp(rs->s_v1.s_magic, reiserfs_jr_magic_string,
			strlen(reiserfs_jr_magic_string));
}
static int is_any_reiserfs_magic_string(struct reiserfs_super_block *rs)
{
	return (is_reiserfs_3_5(rs) || is_reiserfs_3_6(rs) ||
		is_reiserfs_jr(rs));
}
static void reiserfs_write_super(struct super_block *s)
{
	reiserfs_sync_fs(s, 1);
}
static void reiserfs_destroy_inode(struct inode *inode)
{
	kmem_cache_free(reiserfs_inode_cachep, REISERFS_I(inode));
}
static void destroy_inodecache(void)
{
	kmem_cache_destroy(reiserfs_inode_cachep);
}
static int reiserfs_quota_on_mount(struct super_block *sb, int type)
{
	return vfs_quota_on_mount(sb, REISERFS_SB(sb)->s_qf_names[type],
				  REISERFS_SB(sb)->s_jquota_fmt, type);
}
static int get_super_block(struct file_system_type *fs_type,
			   int flags, const char *dev_name,
			   void *data, struct vfsmount *mnt)
{
	return get_sb_bdev(fs_type, flags, dev_name, data, reiserfs_fill_super,
			   mnt);
}
static inline __u32 xattr_hash(const char *msg, int len)
{
	return csum_partial(msg, len, 0);
}
static inline unsigned long romfs_maxsize(struct super_block *sb)
{
	return (unsigned long)sb->s_fs_info;
}
static inline struct romfs_inode_info *ROMFS_I(struct inode *inode)
{
	return container_of(inode, struct romfs_inode_info, vfs_inode);
}
static void romfs_destroy_inode(struct inode *inode)
{
	kmem_cache_free(romfs_inode_cachep, ROMFS_I(inode));
}
static void destroy_inodecache(void)
{
	kmem_cache_destroy(romfs_inode_cachep);
}
static int romfs_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_bdev(fs_type, flags, dev_name, data, romfs_fill_super,
			   mnt);
}
static void *single_start(struct seq_file *p, loff_t *pos)
{
	return NULL + (*pos == 0);
}
int seq_open_private(struct file *filp, const struct seq_operations *ops,
		int psize)
{
	return __seq_open_private(filp, ops, psize) ? 0 : -ENOMEM;
}
static void smb_destroy_inode(struct inode *inode)
{
	kmem_cache_free(smb_inode_cachep, SMB_I(inode));
}
static void destroy_inodecache(void)
{
	kmem_cache_destroy(smb_inode_cachep);
}
static int smb_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_nodev(fs_type, flags, data, smb_fill_super, mnt);
}
static time_t
utc2local(struct smb_sb_info *server, time_t time)
{
	return time - server->opt.serverzone*60;
}
static time_t
local2utc(struct smb_sb_info *server, time_t time)
{
	return time + server->opt.serverzone*60;
}
static u64
smb_unixutc2ntutc(struct timespec ts)
{
	return ((u64)ts.tv_sec) * 10000000 + ts.tv_nsec/100 + NTFS_TIME_OFFSET;
}
__u32
smb_len(__u8 * p)
{
	return ((*(p+1) & 0x1) << 16L) | (*(p+2) << 8L) | *(p+3);
}
static int
smb_valid_packet(__u8 * packet)
{
	return (packet[4] == 0xff
		&& packet[5] == 'S'
		&& packet[6] == 'M'
		&& packet[7] == 'B'
		&& (smb_len(packet) + 4 == SMB_HEADER_LEN
		    + SMB_WCT(packet) * 2 + smb_bcc(packet)));
}
static inline int
smb_get_xmitsize(struct smb_sb_info *server, int overhead)
{
	return server->opt.max_xmit - overhead;
}
int
smb_proc_mkdir(struct dentry *dentry)
{
	return smb_proc_generic_command(dentry, SMBmkdir);
}
int
smb_proc_rmdir(struct dentry *dentry)
{
	return smb_proc_generic_command(dentry, SMBrmdir);
}
static int
smb_proc_trunc32(struct inode *inode, loff_t length)
{
	return smb_proc_write(inode, length, 0, NULL);
}
static void
install_ops(struct smb_ops *dst, struct smb_ops *src)
{
	memcpy(dst, src, sizeof(void *) * SMB_OPS_NUM_STATIC);
}
void smb_install_null_ops(struct smb_ops *ops)
{
	install_ops(ops, &smb_ops_null);
}
void smb_destroy_request_cache(void)
{
	kmem_cache_destroy(req_cachep);
}
static void smb_rget(struct smb_request *req)
{
	atomic_inc(&req->rq_count);
}
static struct smb_sb_info *
server_from_socket(struct socket *socket)
{
	return socket->sk->sk_user_data;
}
int
smb_valid_socket(struct inode * inode)
{
	return (inode && S_ISSOCK(inode->i_mode) && 
		SOCKET_I(inode)->type == SOCK_STREAM);
}
static void spd_release_page(struct splice_pipe_desc *spd, unsigned int i)
{
	page_cache_release(spd->pages[i]);
}
ssize_t generic_splice_sendpage(struct pipe_inode_info *pipe, struct file *out,
				loff_t *ppos, size_t len, unsigned int flags)
{
	return splice_from_pipe(pipe, out, ppos, len, flags, pipe_to_sendpage);
}
static int squashfs_get_sb(struct file_system_type *fs_type, int flags,
				const char *dev_name, void *data,
				struct vfsmount *mnt)
{
	return get_sb_bdev(fs_type, flags, dev_name, data, squashfs_fill_super,
				mnt);
}
static void destroy_inodecache(void)
{
	kmem_cache_destroy(squashfs_inode_cachep);
}
static void squashfs_destroy_inode(struct inode *inode)
{
	kmem_cache_free(squashfs_inode_cachep, squashfs_i(inode));
}
int vfs_stat(char __user *name, struct kstat *stat)
{
	return vfs_stat_fd(AT_FDCWD, name, stat);
}
int vfs_lstat(char __user *name, struct kstat *stat)
{
	return vfs_lstat_fd(AT_FDCWD, name, stat);
}
void emergency_remount(void)
{
	pdflush_operation(do_emergency_remount, 0);
}
static int test_bdev_super(struct super_block *s, void *data)
{
	return (void *)s->s_bdev == data;
}
static int compare_single(struct super_block *s, void *p)
{
	return 1;
}
struct vfsmount *kern_mount_data(struct file_system_type *type, void *data)
{
	return vfs_kern_mount(type, MS_KERNMOUNT, type->name, data);
}
void emergency_sync(void)
{
	pdflush_operation(do_sync, 0);
}
asmlinkage long SyS_sync_file_range(long fd, loff_t offset, loff_t nbytes,
				    long flags)
{
	return SYSC_sync_file_range((int) fd, offset, nbytes,
				    (unsigned int) flags);
}
asmlinkage long SyS_sync_file_range2(long fd, long flags,
				     loff_t offset, loff_t nbytes)
{
	return SYSC_sync_file_range2((int) fd, (unsigned int) flags,
				     offset, nbytes);
}
void sysfs_remove_bin_file(struct kobject * kobj, struct bin_attribute * attr)
{
	sysfs_hash_and_remove(kobj->sd, attr->attr.name);
}
int sysfs_create_subdir(struct kobject *kobj, const char *name,
			struct sysfs_dirent **p_sd)
{
	return create_dir(kobj, kobj->sd, name, p_sd);
}
void sysfs_remove_subdir(struct sysfs_dirent *sd)
{
	remove_dir(sd);
}
static inline unsigned char dt_type(struct sysfs_dirent *sd)
{
	return (sd->s_mode >> 12) & 15;
}
void sysfs_printk_last_file(void)
{
	printk(KERN_EMERG "last sysfs file: %s\n", last_sysfs_file);
}
int sysfs_add_file(struct sysfs_dirent *dir_sd, const struct attribute *attr,
		   int type)
{
	return sysfs_add_file_mode(dir_sd, attr, type, attr->mode);
}
void sysfs_remove_file(struct kobject * kobj, const struct attribute * attr)
{
	sysfs_hash_and_remove(kobj->sd, attr->name);
}
int sysfs_create_group(struct kobject *kobj,
		       const struct attribute_group *grp)
{
	return internal_create_group(kobj, 0, grp);
}
int sysfs_update_group(struct kobject *kobj,
		       const struct attribute_group *grp)
{
	return internal_create_group(kobj, 1, grp);
}
int __init sysfs_inode_init(void)
{
	return bdi_init(&sysfs_backing_dev_info);
}
static int sysfs_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_single(fs_type, flags, data, sysfs_fill_super, mnt);
}
struct sysfs_dirent *sysfs_get(struct sysfs_dirent *sd)
{
	return __sysfs_get(sd);
}
void sysfs_put(struct sysfs_dirent *sd)
{
	__sysfs_put(sd);
}
int sysfs_create_link(struct kobject *kobj, struct kobject *target,
		      const char *name)
{
	return sysfs_do_create_link(kobj, target, name, 1);
}
int sysfs_create_link_nowarn(struct kobject *kobj, struct kobject *target,
			     const char *name)
{
	return sysfs_do_create_link(kobj, target, name, 0);
}
static inline unsigned long dir_pages(struct inode *inode)
{
	return (inode->i_size+PAGE_CACHE_SIZE-1)>>PAGE_CACHE_SHIFT;
}
static void sysv_destroy_inode(struct inode *inode)
{
	kmem_cache_free(sysv_inode_cachep, SYSV_I(inode));
}
void sysv_destroy_icache(void)
{
	kmem_cache_destroy(sysv_inode_cachep);
}
static inline int block_to_cpu(struct sysv_sb_info *sbi, sysv_zone_t nr)
{
	return sbi->s_block_base + fs32_to_cpu(sbi, nr);
}
static inline sysv_zone_t *block_end(struct buffer_head *bh)
{
	return (sysv_zone_t*)((char*)bh->b_data + bh->b_size);
}
static int sysv_writepage(struct page *page, struct writeback_control *wbc)
{
	return block_write_full_page(page,get_block,wbc);
}
static int sysv_readpage(struct file *file, struct page *page)
{
	return block_read_full_page(page,get_block);
}
int __sysv_write_begin(struct file *file, struct address_space *mapping,
			loff_t pos, unsigned len, unsigned flags,
			struct page **pagep, void **fsdata)
{
	return block_write_begin(file, mapping, pos, len, flags, pagep, fsdata,
				get_block);
}
static sector_t sysv_bmap(struct address_space *mapping, sector_t block)
{
	return generic_block_bmap(mapping,block,get_block);
}
static int sysv_create(struct inode * dir, struct dentry * dentry, int mode, struct nameidata *nd)
{
	return sysv_mknod(dir, dentry, mode, 0);
}
static int sysv_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_bdev(fs_type, flags, dev_name, data, sysv_fill_super,
			   mnt);
}
static int v7_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_bdev(fs_type, flags, dev_name, data, v7_fill_super, mnt);
}
void dbg_dump_lprop(const struct ubifs_info *c, const struct ubifs_lprops *lp)
{
	printk(KERN_DEBUG "LEB %d lprops: free %d, dirty %d (used %d), "
	       "flags %#x\n", lp->lnum, lp->free, lp->dirty,
	       c->leb_size - lp->free - lp->dirty, lp->flags);
}
void dbg_dump_index(struct ubifs_info *c)
{
	dbg_walk_index(c, NULL, dump_znode, NULL);
}
void dbg_debugfs_exit(void)
{
	debugfs_remove(dfs_rootdir);
}
void dbg_debugfs_exit_fs(struct ubifs_info *c)
{
	debugfs_remove_recursive(c->dbg->dfs_dir);
}
static inline void zero_data_node_unused(struct ubifs_data_node *data)
{
	memset(data->padding, 0, 2);
}
static inline void zero_trun_node_unused(struct ubifs_trun_node *trun)
{
	memset(trun->padding, 0, 12);
}
static inline void release_head(struct ubifs_info *c, int jhead)
{
	mutex_unlock(&c->jheads[jhead].wbuf.io_mutex);
}
static void finish_reservation(struct ubifs_info *c)
{
	up_read(&c->commit_sem);
}
static void add_pnode_dirt(struct ubifs_info *c, struct ubifs_pnode *pnode)
{
	ubifs_add_lpt_dirt(c, pnode->parent->nbranch[pnode->iip].lnum,
			   c->pnode_sz);
}
static void add_pnode_dirt(struct ubifs_info *c, struct ubifs_pnode *pnode)
{
	ubifs_add_lpt_dirt(c, pnode->parent->nbranch[pnode->iip].lnum,
			   c->pnode_sz);
}
static int bud_wbuf_callback(struct ubifs_info *c, int lnum, int free, int pad)
{
	return ubifs_update_one_lp(c, lnum, free, pad, 0, 0);
}
static void ubifs_kill_sb(struct super_block *sb)
{
	generic_shutdown_super(sb);
}
static int matches_position(struct ubifs_zbranch *zbr, int lnum, int offs)
{
	if (zbr->lnum == lnum && zbr->offs == offs)
		return 1;
	else
		return 0;
}
static int udf_writepage(struct page *page, struct writeback_control *wbc)
{
	return block_write_full_page(page, udf_get_block, wbc);
}
static int udf_readpage(struct file *file, struct page *page)
{
	return block_read_full_page(page, udf_get_block);
}
static sector_t udf_bmap(struct address_space *mapping, sector_t block)
{
	return generic_block_bmap(mapping, block, udf_get_block);
}
int udf_sync_inode(struct inode *inode)
{
	return udf_update_inode(inode, 1);
}
struct buffer_head *udf_tgetblk(struct super_block *sb, int block)
{
	if (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))
		return sb_getblk(sb, udf_fixed_to_variable(block));
	else
		return sb_getblk(sb, block);
}
struct buffer_head *udf_tread(struct super_block *sb, int block)
{
	if (UDF_QUERY_FLAG(sb, UDF_FLAG_VARCONV))
		return sb_bread(sb, udf_fixed_to_variable(block));
	else
		return sb_bread(sb, block);
}
struct buffer_head *udf_read_ptagged(struct super_block *sb,
				     struct kernel_lb_addr *loc,
				     uint32_t offset, uint16_t *ident)
{
	return udf_read_tagged(sb, udf_get_lb_pblock(sb, loc, offset),
			       loc->logicalBlockNum + offset, ident);
}
inline uint32_t udf_get_pblock_virt20(struct super_block *sb, uint32_t block,
				      uint16_t partition, uint32_t offset)
{
	return udf_get_pblock_virt15(sb, block, partition, offset);
}
static int udf_get_sb(struct file_system_type *fs_type,
		      int flags, const char *dev_name, void *data,
		      struct vfsmount *mnt)
{
	return get_sb_bdev(fs_type, flags, dev_name, data, udf_fill_super, mnt);
}
static void udf_destroy_inode(struct inode *inode)
{
	kmem_cache_free(udf_inode_cachep, UDF_I(inode));
}
static void destroy_inodecache(void)
{
	kmem_cache_destroy(udf_inode_cachep);
}
static inline unsigned long ufs_dir_pages(struct inode *inode)
{
	return (inode->i_size+PAGE_CACHE_SIZE-1)>>PAGE_CACHE_SHIFT;
}
static inline struct ufs_dir_entry *
ufs_next_entry(struct super_block *sb, struct ufs_dir_entry *p)
{
	return (struct ufs_dir_entry *)((char *)p +
					fs16_to_cpu(sb, p->d_reclen));
}
static int ufs_writepage(struct page *page, struct writeback_control *wbc)
{
	return block_write_full_page(page,ufs_getfrag_block,wbc);
}
static int ufs_readpage(struct file *file, struct page *page)
{
	return block_read_full_page(page,ufs_getfrag_block);
}
int __ufs_write_begin(struct file *file, struct address_space *mapping,
			loff_t pos, unsigned len, unsigned flags,
			struct page **pagep, void **fsdata)
{
	return block_write_begin(file, mapping, pos, len, flags, pagep, fsdata,
				ufs_getfrag_block);
}
static sector_t ufs_bmap(struct address_space *mapping, sector_t block)
{
	return generic_block_bmap(mapping,block,ufs_getfrag_block);
}
int ufs_sync_inode (struct inode *inode)
{
	return ufs_update_inode (inode, 1);
}
static void ufs_destroy_inode(struct inode *inode)
{
	kmem_cache_free(ufs_inode_cachep, UFS_I(inode));
}
static void destroy_inodecache(void)
{
	kmem_cache_destroy(ufs_inode_cachep);
}
static int ufs_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_bdev(fs_type, flags, dev_name, data, ufs_fill_super, mnt);
}
void
xfs_buf_trace(
	xfs_buf_t	*bp,
	char		*id,
	void		*data,
	void		*ra)
{
	ktrace_enter(xfs_buf_trace_buf,
		bp, id,
		(void *)(unsigned long)bp->b_flags,
		(void *)(unsigned long)bp->b_hold.counter,
		(void *)(unsigned long)bp->b_sema.count,
		(void *)current,
		data, ra,
		(void *)(unsigned long)((bp->b_file_offset>>32) & 0xffffffff),
		(void *)(unsigned long)(bp->b_file_offset & 0xffffffff),
		(void *)(unsigned long)bp->b_buffer_length,
		NULL, NULL, NULL, NULL, NULL);
}
int
xfs_buf_lock_value(
	xfs_buf_t		*bp)
{
	return bp->b_sema.count;
}
int
xfs_buf_ispin(
	xfs_buf_t		*bp)
{
	return atomic_read(&bp->b_pin_count);
}
STATIC int
xfs_setsize_buftarg_early(
	xfs_buftarg_t		*btp,
	struct block_device	*bdev)
{
	return xfs_setsize_buftarg_flags(btp,
			PAGE_CACHE_SIZE, bdev_hardsect_size(bdev), 0);
}
int
xfs_setsize_buftarg(
	xfs_buftarg_t		*btp,
	unsigned int		blocksize,
	unsigned int		sectorsize)
{
	return xfs_setsize_buftarg_flags(btp, blocksize, sectorsize, 1);
}
STATIC void
xfs_buf_runall_queues(
	struct workqueue_struct	*queue)
{
	flush_workqueue(queue);
}
struct list_head *
xfs_get_buftarg_list(void)
{
	return &xfs_buftarg_list;
}
STATIC int
xfs_file_release(
	struct inode	*inode,
	struct file	*filp)
{
	return -xfs_release(XFS_I(inode));
}
STATIC int
xfs_vm_page_mkwrite(
	struct vm_area_struct	*vma,
	struct page		*page)
{
	return block_page_mkwrite(vma, page, xfs_get_blocks);
}
int  fs_noerr(void) { return 0; }
int  fs_nosys(void) { return ENOSYS; }
void fs_noval(void) { return; }
STATIC int
xfs_handle_acceptable(
	void			*context,
	struct dentry		*dentry)
{
	return 1;
}
STATIC struct dentry *
xfs_handlereq_to_dentry(
	struct file		*parfilp,
	xfs_fsop_handlereq_t	*hreq)
{
	return xfs_handle_to_dentry(parfilp, hreq->ihandle, hreq->ihandlen);
}
STATIC int
xfs_bulkstat_one_compat(
	xfs_mount_t	*mp,		/* mount point for filesystem */
	xfs_ino_t	ino,		/* inode number to get data for */
	void		__user *buffer,	/* buffer to place output in */
	int		ubsize,		/* size of buffer */
	void		*private_data,	/* my private data */
	xfs_daddr_t	bno,		/* starting bno of inode cluster */
	int		*ubused,	/* bytes used by me */
	void		*dibuff,	/* on-disk inode buffer */
	int		*stat)		/* BULKSTAT_RV_... */
{
	return xfs_bulkstat_one_int(mp, ino, buffer, ubsize,
				    xfs_bulkstat_one_fmt_compat, bno,
				    ubused, dibuff, stat);
}
STATIC struct dentry *
xfs_compat_handlereq_to_dentry(
	struct file		*parfilp,
	compat_xfs_fsop_handlereq_t *hreq)
{
	return xfs_handle_to_dentry(parfilp,
			compat_ptr(hreq->ihandle), hreq->ihandlen);
}
STATIC int
xfs_vn_create(
	struct inode	*dir,
	struct dentry	*dentry,
	int		mode,
	struct nameidata *nd)
{
	return xfs_vn_mknod(dir, dentry, mode, 0);
}
STATIC int
xfs_vn_mkdir(
	struct inode	*dir,
	struct dentry	*dentry,
	int		mode)
{
	return xfs_vn_mknod(dir, dentry, mode|S_IFDIR, 0);
}
STATIC int
xfs_vn_permission(
	struct inode		*inode,
	int			mask)
{
	return generic_permission(inode, mask, xfs_check_acl);
}
STATIC int
xfs_vn_setattr(
	struct dentry	*dentry,
	struct iattr	*iattr)
{
	return -xfs_setattr(XFS_I(dentry->d_inode), iattr, 0);
}
void
xfs_blkdev_issue_flush(
	xfs_buftarg_t		*buftarg)
{
	blkdev_issue_flush(buftarg->bt_bdev, NULL);
}
void
xfsaild_stop(
	struct xfs_ail	*ailp)
{
	kthread_stop(ailp->xa_task);
}
STATIC int
xfs_fs_show_options(
	struct seq_file		*m,
	struct vfsmount		*mnt)
{
	return -xfs_showargs(XFS_M(mnt->mnt_sb), m);
}
STATIC int
xfs_fs_get_sb(
	struct file_system_type	*fs_type,
	int			flags,
	const char		*dev_name,
	void			*data,
	struct vfsmount		*mnt)
{
	return get_sb_bdev(fs_type, flags, dev_name, data, xfs_fs_fill_super,
			   mnt);
}
void
xfs_syncd_stop(
	struct xfs_mount	*mp)
{
	kthread_stop(mp->m_sync_task);
}
void
__xfs_inode_clear_reclaim_tag(
	xfs_mount_t	*mp,
	xfs_perag_t	*pag,
	xfs_inode_t	*ip)
{
	radix_tree_tag_clear(&pag->pag_ici_root,
			XFS_INO_TO_AGINO(mp, ip->i_ino), XFS_ICI_RECLAIM_TAG);
}
void
xfs_sysctl_unregister(void)
{
	unregister_sysctl_table(xfs_table_header);
}
static int
xfs_xattr_user_get(struct inode *inode, const char *name,
		void *value, size_t size)
{
	return __xfs_xattr_get(inode, name, value, size, 0);
}
static int
xfs_xattr_user_set(struct inode *inode, const char *name,
		const void *value, size_t size, int flags)
{
	return __xfs_xattr_set(inode, name, value, size, flags, 0);
}
static int
xfs_xattr_trusted_get(struct inode *inode, const char *name,
		void *value, size_t size)
{
	return __xfs_xattr_get(inode, name, value, size, ATTR_ROOT);
}
static int
xfs_xattr_trusted_set(struct inode *inode, const char *name,
		const void *value, size_t size, int flags)
{
	return __xfs_xattr_set(inode, name, value, size, flags, ATTR_ROOT);
}
static int
xfs_xattr_secure_get(struct inode *inode, const char *name,
		void *value, size_t size)
{
	return __xfs_xattr_get(inode, name, value, size, ATTR_SECURE);
}
static int
xfs_xattr_secure_set(struct inode *inode, const char *name,
		const void *value, size_t size, int flags)
{
	return __xfs_xattr_set(inode, name, value, size, flags, ATTR_SECURE);
}
static unsigned int xfs_xattr_prefix_len(int flags)
{
	if (flags & XFS_ATTR_SECURE)
		return sizeof("security");
	else if (flags & XFS_ATTR_ROOT)
		return sizeof("trusted");
	else
		return sizeof("user");
}
static const char *xfs_xattr_prefix(int flags)
{
	if (flags & XFS_ATTR_SECURE)
		return xfs_xattr_security_handler.prefix;
	else if (flags & XFS_ATTR_ROOT)
		return xfs_xattr_trusted_handler.prefix;
	else
		return xfs_xattr_user_handler.prefix;
}
int
xfs_qm_dqlock_nowait(
	xfs_dquot_t *dqp)
{
	return mutex_trylock(&dqp->q_qlock);
}
void
xfs_dqlock(
	xfs_dquot_t *dqp)
{
	mutex_lock(&dqp->q_qlock);
}
void
xfs_dqunlock_nonotify(
	xfs_dquot_t *dqp)
{
	mutex_unlock(&(dqp->q_qlock));
}
STATIC uint
xfs_qm_dquot_logitem_size(
	xfs_dq_logitem_t	*logitem)
{
	return (2);
}
STATIC void
xfs_qm_dquot_logitem_unpin_remove(
	xfs_dq_logitem_t *logitem,
	xfs_trans_t	 *tp)
{
	xfs_qm_dquot_logitem_unpin(logitem, 0);
}
STATIC xfs_lsn_t
xfs_qm_dquot_logitem_committed(
	xfs_dq_logitem_t	*l,
	xfs_lsn_t		lsn)
{
	return (lsn);
}
STATIC void
xfs_qm_dquot_logitem_committing(
	xfs_dq_logitem_t	*l,
	xfs_lsn_t		lsn)
{
	return;
}
STATIC uint
xfs_qm_qoff_logitem_size(xfs_qoff_logitem_t *qf)
{
	return (1);
}
STATIC void
xfs_qm_qoff_logitem_pin(xfs_qoff_logitem_t *qf)
{
	return;
}
STATIC void
xfs_qm_qoff_logitem_unpin(xfs_qoff_logitem_t *qf, int stale)
{
	return;
}
STATIC void
xfs_qm_qoff_logitem_unpin_remove(xfs_qoff_logitem_t *qf, xfs_trans_t *tp)
{
	return;
}
STATIC uint
xfs_qm_qoff_logitem_trylock(xfs_qoff_logitem_t *qf)
{
	return XFS_ITEM_LOCKED;
}
STATIC void
xfs_qm_qoff_logitem_unlock(xfs_qoff_logitem_t *qf)
{
	return;
}
STATIC xfs_lsn_t
xfs_qm_qoff_logitem_committed(xfs_qoff_logitem_t *qf, xfs_lsn_t lsn)
{
	return (lsn);
}
STATIC void
xfs_qm_qoff_logitem_push(xfs_qoff_logitem_t *qf)
{
	return;
}
STATIC void
xfs_qm_qoff_logitem_committing(xfs_qoff_logitem_t *qip, xfs_lsn_t commit_lsn)
{
	return;
}
STATIC void
xfs_qm_qoffend_logitem_committing(xfs_qoff_logitem_t *qip, xfs_lsn_t commit_lsn)
{
	return;
}
STATIC void
xfs_qm_list_destroy(
	xfs_dqlist_t	*list)
{
	mutex_destroy(&(list->qh_lock));
}
void
xfs_qm_freelist_append(xfs_frlist_t *ql, xfs_dquot_t *dq)
{
	xfs_qm_freelist_insert((xfs_frlist_t *)ql->qh_prev, dq);
}
STATIC void
xfs_trans_alloc_dqinfo(
	xfs_trans_t	*tp)
{
	(tp)->t_dqinfo = kmem_zone_zalloc(xfs_Gqm->qm_dqtrxzone, KM_SLEEP);
}
void
xfs_hex_dump(void *p, int length)
{
	print_hex_dump(KERN_ALERT, "", DUMP_PREFIX_ADDRESS, 16, 1, p, length, 1);
}
void
uuid_create_nil(uuid_t *uuid)
{
	memset(uuid, 0, sizeof(*uuid));
}
int
uuid_equal(uuid_t *uuid1, uuid_t *uuid2)
{
	return memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;
}
STATIC void
xfs_alloc_trace_alloc(
	const char	*name,		/* function tag string */
	char		*str,		/* additional string */
	xfs_alloc_arg_t	*args,		/* allocation argument structure */
	int		line)		/* source line number */
{
	ktrace_enter(xfs_alloc_trace_buf,
		(void *)(__psint_t)(XFS_ALLOC_KTRACE_ALLOC | (line << 16)),
		(void *)name,
		(void *)str,
		(void *)args->mp,
		(void *)(__psunsigned_t)args->agno,
		(void *)(__psunsigned_t)args->agbno,
		(void *)(__psunsigned_t)args->minlen,
		(void *)(__psunsigned_t)args->maxlen,
		(void *)(__psunsigned_t)args->mod,
		(void *)(__psunsigned_t)args->prod,
		(void *)(__psunsigned_t)args->minleft,
		(void *)(__psunsigned_t)args->total,
		(void *)(__psunsigned_t)args->alignment,
		(void *)(__psunsigned_t)args->len,
		(void *)((((__psint_t)args->type) << 16) |
			 (__psint_t)args->otype),
		(void *)(__psint_t)((args->wasdel << 3) |
				    (args->wasfromfl << 2) |
				    (args->isfl << 1) |
				    (args->userdata << 0)));
}
STATIC void
xfs_alloc_trace_free(
	const char	*name,		/* function tag string */
	char		*str,		/* additional string */
	xfs_mount_t	*mp,		/* file system mount point */
	xfs_agnumber_t	agno,		/* allocation group number */
	xfs_agblock_t	agbno,		/* a.g. relative block number */
	xfs_extlen_t	len,		/* length of extent */
	int		isfl,		/* set if is freelist allocation/free */
	int		line)		/* source line number */
{
	ktrace_enter(xfs_alloc_trace_buf,
		(void *)(__psint_t)(XFS_ALLOC_KTRACE_FREE | (line << 16)),
		(void *)name,
		(void *)str,
		(void *)mp,
		(void *)(__psunsigned_t)agno,
		(void *)(__psunsigned_t)agbno,
		(void *)(__psunsigned_t)len,
		(void *)(__psint_t)isfl,
		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
}
STATIC void
xfs_alloc_trace_modagf(
	const char	*name,		/* function tag string */
	char		*str,		/* additional string */
	xfs_mount_t	*mp,		/* file system mount point */
	xfs_agf_t	*agf,		/* new agf value */
	int		flags,		/* logging flags for agf */
	int		line)		/* source line number */
{
	ktrace_enter(xfs_alloc_trace_buf,
		(void *)(__psint_t)(XFS_ALLOC_KTRACE_MODAGF | (line << 16)),
		(void *)name,
		(void *)str,
		(void *)mp,
		(void *)(__psint_t)flags,
		(void *)(__psunsigned_t)be32_to_cpu(agf->agf_seqno),
		(void *)(__psunsigned_t)be32_to_cpu(agf->agf_length),
		(void *)(__psunsigned_t)be32_to_cpu(agf->agf_roots[XFS_BTNUM_BNO]),
		(void *)(__psunsigned_t)be32_to_cpu(agf->agf_roots[XFS_BTNUM_CNT]),
		(void *)(__psunsigned_t)be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]),
		(void *)(__psunsigned_t)be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]),
		(void *)(__psunsigned_t)be32_to_cpu(agf->agf_flfirst),
		(void *)(__psunsigned_t)be32_to_cpu(agf->agf_fllast),
		(void *)(__psunsigned_t)be32_to_cpu(agf->agf_flcount),
		(void *)(__psunsigned_t)be32_to_cpu(agf->agf_freeblks),
		(void *)(__psunsigned_t)be32_to_cpu(agf->agf_longest));
}
STATIC void
xfs_alloc_trace_busy(
	const char	*name,		/* function tag string */
	char		*str,		/* additional string */
	xfs_mount_t	*mp,		/* file system mount point */
	xfs_agnumber_t	agno,		/* allocation group number */
	xfs_agblock_t	agbno,		/* a.g. relative block number */
	xfs_extlen_t	len,		/* length of extent */
	int		slot,		/* perag Busy slot */
	xfs_trans_t	*tp,
	int		trtype,		/* type: add, delete, search */
	int		line)		/* source line number */
{
	ktrace_enter(xfs_alloc_trace_buf,
		(void *)(__psint_t)(trtype | (line << 16)),
		(void *)name,
		(void *)str,
		(void *)mp,
		(void *)(__psunsigned_t)agno,
		(void *)(__psunsigned_t)agbno,
		(void *)(__psunsigned_t)len,
		(void *)(__psint_t)slot,
		(void *)tp,
		NULL, NULL, NULL, NULL, NULL, NULL, NULL);
}
STATIC struct xfs_btree_cur *
xfs_allocbt_dup_cursor(
	struct xfs_btree_cur	*cur)
{
	return xfs_allocbt_init_cursor(cur->bc_mp, cur->bc_tp,
			cur->bc_private.a.agbp, cur->bc_private.a.agno,
			cur->bc_btnum);
}
STATIC int
xfs_allocbt_get_minrecs(
	struct xfs_btree_cur	*cur,
	int			level)
{
	return cur->bc_mp->m_alloc_mnr[level != 0];
}
STATIC int
xfs_allocbt_get_maxrecs(
	struct xfs_btree_cur	*cur,
	int			level)
{
	return cur->bc_mp->m_alloc_mxr[level != 0];
}
STATIC void
xfs_allocbt_trace_enter(
	struct xfs_btree_cur	*cur,
	const char		*func,
	char			*s,
	int			type,
	int			line,
	__psunsigned_t		a0,
	__psunsigned_t		a1,
	__psunsigned_t		a2,
	__psunsigned_t		a3,
	__psunsigned_t		a4,
	__psunsigned_t		a5,
	__psunsigned_t		a6,
	__psunsigned_t		a7,
	__psunsigned_t		a8,
	__psunsigned_t		a9,
	__psunsigned_t		a10)
{
	ktrace_enter(xfs_allocbt_trace_buf, (void *)(__psint_t)type,
		(void *)func, (void *)s, NULL, (void *)cur,
		(void *)a0, (void *)a1, (void *)a2, (void *)a3,
		(void *)a4, (void *)a5, (void *)a6, (void *)a7,
		(void *)a8, (void *)a9, (void *)a10);
}
void
xfs_attr_trace_l_c(char *where, struct xfs_attr_list_context *context)
{
	xfs_attr_trace_enter(XFS_ATTR_KTRACE_L_C, where, context,
		(__psunsigned_t)NULL,
		(__psunsigned_t)NULL,
		(__psunsigned_t)NULL);
}
void
xfs_attr_trace_l_cn(char *where, struct xfs_attr_list_context *context,
			 struct xfs_da_intnode *node)
{
	xfs_attr_trace_enter(XFS_ATTR_KTRACE_L_CN, where, context,
		(__psunsigned_t)be16_to_cpu(node->hdr.count),
		(__psunsigned_t)be32_to_cpu(node->btree[0].hashval),
		(__psunsigned_t)be32_to_cpu(node->btree[
				    be16_to_cpu(node->hdr.count)-1].hashval));
}
void
xfs_attr_trace_l_cb(char *where, struct xfs_attr_list_context *context,
			  struct xfs_da_node_entry *btree)
{
	xfs_attr_trace_enter(XFS_ATTR_KTRACE_L_CB, where, context,
		(__psunsigned_t)be32_to_cpu(btree->hashval),
		(__psunsigned_t)be32_to_cpu(btree->before),
		(__psunsigned_t)NULL);
}
void
xfs_attr_trace_l_cl(char *where, struct xfs_attr_list_context *context,
			      struct xfs_attr_leafblock *leaf)
{
	xfs_attr_trace_enter(XFS_ATTR_KTRACE_L_CL, where, context,
		(__psunsigned_t)be16_to_cpu(leaf->hdr.count),
		(__psunsigned_t)be32_to_cpu(leaf->entries[0].hashval),
		(__psunsigned_t)be32_to_cpu(leaf->entries[
				be16_to_cpu(leaf->hdr.count)-1].hashval));
}
void
xfs_bmbt_get_all(
	xfs_bmbt_rec_host_t *r,
	xfs_bmbt_irec_t *s)
{
	__xfs_bmbt_get_all(r->l0, r->l1, s);
}
xfs_filblks_t
xfs_bmbt_get_blockcount(
	xfs_bmbt_rec_host_t	*r)
{
	return (xfs_filblks_t)(r->l1 & xfs_mask64lo(21));
}
xfs_fsblock_t
xfs_bmbt_get_startblock(
	xfs_bmbt_rec_host_t	*r)
{
	return (((xfs_fsblock_t)r->l0 & xfs_mask64lo(9)) << 43) |
	       (((xfs_fsblock_t)r->l1) >> 21);
}
xfs_fileoff_t
xfs_bmbt_get_startoff(
	xfs_bmbt_rec_host_t	*r)
{
	return ((xfs_fileoff_t)r->l0 &
		 xfs_mask64lo(64 - BMBT_EXNTFLAG_BITLEN)) >> 9;
}
void
xfs_bmbt_disk_get_all(
	xfs_bmbt_rec_t	*r,
	xfs_bmbt_irec_t *s)
{
	__xfs_bmbt_get_all(get_unaligned_be64(&r->l0),
				get_unaligned_be64(&r->l1), s);
}
xfs_filblks_t
xfs_bmbt_disk_get_blockcount(
	xfs_bmbt_rec_t	*r)
{
	return (xfs_filblks_t)(be64_to_cpu(r->l1) & xfs_mask64lo(21));
}
xfs_fileoff_t
xfs_bmbt_disk_get_startoff(
	xfs_bmbt_rec_t	*r)
{
	return ((xfs_fileoff_t)be64_to_cpu(r->l0) &
		 xfs_mask64lo(64 - BMBT_EXNTFLAG_BITLEN)) >> 9;
}
void
xfs_bmbt_set_all(
	xfs_bmbt_rec_host_t *r,
	xfs_bmbt_irec_t	*s)
{
	xfs_bmbt_set_allf(r, s->br_startoff, s->br_startblock,
			     s->br_blockcount, s->br_state);
}
void
xfs_bmbt_disk_set_all(
	xfs_bmbt_rec_t	*r,
	xfs_bmbt_irec_t *s)
{
	xfs_bmbt_disk_set_allf(r, s->br_startoff, s->br_startblock,
				  s->br_blockcount, s->br_state);
}
STATIC void
xfs_bmbt_init_key_from_rec(
	union xfs_btree_key	*key,
	union xfs_btree_rec	*rec)
{
	key->bmbt.br_startoff =
		cpu_to_be64(xfs_bmbt_disk_get_startoff(&rec->bmbt));
}
STATIC void
xfs_bmbt_init_rec_from_cur(
	struct xfs_btree_cur	*cur,
	union xfs_btree_rec	*rec)
{
	xfs_bmbt_disk_set_all(&rec->bmbt, &cur->bc_rec.b);
}
STATIC void
xfs_bmbt_init_ptr_from_cur(
	struct xfs_btree_cur	*cur,
	union xfs_btree_ptr	*ptr)
{
	ptr->l = 0;
}
STATIC __int64_t
xfs_bmbt_key_diff(
	struct xfs_btree_cur	*cur,
	union xfs_btree_key	*key)
{
	return (__int64_t)be64_to_cpu(key->bmbt.br_startoff) -
				      cur->bc_rec.b.br_startoff;
}
STATIC int
xfs_bmbt_keys_inorder(
	struct xfs_btree_cur	*cur,
	union xfs_btree_key	*k1,
	union xfs_btree_key	*k2)
{
	return be64_to_cpu(k1->bmbt.br_startoff) <
		be64_to_cpu(k2->bmbt.br_startoff);
}
STATIC int
xfs_bmbt_recs_inorder(
	struct xfs_btree_cur	*cur,
	union xfs_btree_rec	*r1,
	union xfs_btree_rec	*r2)
{
	return xfs_bmbt_disk_get_startoff(&r1->bmbt) +
		xfs_bmbt_disk_get_blockcount(&r1->bmbt) <=
		xfs_bmbt_disk_get_startoff(&r2->bmbt);
}
int
xfs_btree_check_block(
	struct xfs_btree_cur	*cur,	/* btree cursor */
	struct xfs_btree_block	*block,	/* generic btree block pointer */
	int			level,	/* level of the btree block */
	struct xfs_buf		*bp)	/* buffer containing block, if any */
{
	if (cur->bc_flags & XFS_BTREE_LONG_PTRS)
		return xfs_btree_check_lblock(cur, block, level, bp);
	else
		return xfs_btree_check_sblock(cur, block, level, bp);
}
static inline size_t xfs_btree_block_len(struct xfs_btree_cur *cur)
{
	return (cur->bc_flags & XFS_BTREE_LONG_PTRS) ?
		XFS_BTREE_LBLOCK_LEN :
		XFS_BTREE_SBLOCK_LEN;
}
static inline size_t xfs_btree_ptr_len(struct xfs_btree_cur *cur)
{
	return (cur->bc_flags & XFS_BTREE_LONG_PTRS) ?
		sizeof(__be64) : sizeof(__be32);
}
STATIC size_t
xfs_btree_rec_offset(
	struct xfs_btree_cur	*cur,
	int			n)
{
	return xfs_btree_block_len(cur) +
		(n - 1) * cur->bc_ops->rec_len;
}
STATIC size_t
xfs_btree_key_offset(
	struct xfs_btree_cur	*cur,
	int			n)
{
	return xfs_btree_block_len(cur) +
		(n - 1) * cur->bc_ops->key_len;
}
STATIC size_t
xfs_btree_ptr_offset(
	struct xfs_btree_cur	*cur,
	int			n,
	int			level)
{
	return xfs_btree_block_len(cur) +
		cur->bc_ops->get_maxrecs(cur, level) * cur->bc_ops->key_len +
		(n - 1) * xfs_btree_ptr_len(cur);
}
STATIC union xfs_btree_rec *
xfs_btree_rec_addr(
	struct xfs_btree_cur	*cur,
	int			n,
	struct xfs_btree_block	*block)
{
	return (union xfs_btree_rec *)
		((char *)block + xfs_btree_rec_offset(cur, n));
}
STATIC union xfs_btree_key *
xfs_btree_key_addr(
	struct xfs_btree_cur	*cur,
	int			n,
	struct xfs_btree_block	*block)
{
	return (union xfs_btree_key *)
		((char *)block + xfs_btree_key_offset(cur, n));
}
STATIC int
xfs_btree_ptr_is_null(
	struct xfs_btree_cur	*cur,
	union xfs_btree_ptr	*ptr)
{
	if (cur->bc_flags & XFS_BTREE_LONG_PTRS)
		return be64_to_cpu(ptr->l) == NULLDFSBNO;
	else
		return be32_to_cpu(ptr->s) == NULLAGBLOCK;
}
void
xfs_btree_trace_argbi(
	const char		*func,
	struct xfs_btree_cur	*cur,
	struct xfs_buf		*b,
	int			i,
	int			line)
{
	cur->bc_ops->trace_enter(cur, func, XBT_ARGS, XFS_BTREE_KTRACE_ARGBI,
				 line, (__psunsigned_t)b, i, 0, 0, 0, 0, 0,
				 0, 0, 0, 0);
}
void
xfs_btree_trace_argbii(
	const char		*func,
	struct xfs_btree_cur	*cur,
	struct xfs_buf		*b,
	int			i0,
	int			i1,
	int			line)
{
	cur->bc_ops->trace_enter(cur, func, XBT_ARGS, XFS_BTREE_KTRACE_ARGBII,
				 line, (__psunsigned_t)b, i0, i1, 0, 0, 0, 0,
				 0, 0, 0, 0);
}
void
xfs_btree_trace_argfffi(
	const char		*func,
	struct xfs_btree_cur	*cur,
	xfs_dfiloff_t		o,
	xfs_dfsbno_t		b,
	xfs_dfilblks_t		i,
	int			j,
	int			line)
{
	cur->bc_ops->trace_enter(cur, func, XBT_ARGS, XFS_BTREE_KTRACE_ARGFFFI,
				 line,
				 o >> 32, (int)o,
				 b >> 32, (int)b,
				 i >> 32, (int)i,
				 (int)j, 0, 0, 0, 0);
}
void
xfs_btree_trace_argi(
	const char		*func,
	struct xfs_btree_cur	*cur,
	int			i,
	int			line)
{
	cur->bc_ops->trace_enter(cur, func, XBT_ARGS, XFS_BTREE_KTRACE_ARGI,
				 line, i, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
}
uint
xfs_buf_item_dirty(
	xfs_buf_log_item_t	*bip)
{
	return (bip->bli_flags & XFS_BLI_DIRTY);
}
enum xfs_dacmp
xfs_da_compname(
	struct xfs_da_args *args,
	const char 	*name,
	int 		len)
{
	return (args->namelen == len && memcmp(args->name, name, len) == 0) ?
					XFS_CMP_EXACT : XFS_CMP_DIFFERENT;
}
static xfs_dahash_t
xfs_default_hashname(
	struct xfs_name	*name)
{
	return xfs_da_hashname(name->name, name->len);
}
int
xfs_da_get_buf(
	xfs_trans_t	*trans,
	xfs_inode_t	*dp,
	xfs_dablk_t	bno,
	xfs_daddr_t		mappedbno,
	xfs_dabuf_t	**bpp,
	int		whichfork)
{
	return xfs_da_do_buf(trans, dp, bno, &mappedbno, bpp, whichfork, 0,
						 (inst_t *)__return_address);
}
int
xfs_da_read_buf(
	xfs_trans_t	*trans,
	xfs_inode_t	*dp,
	xfs_dablk_t	bno,
	xfs_daddr_t		mappedbno,
	xfs_dabuf_t	**bpp,
	int		whichfork)
{
	return xfs_da_do_buf(trans, dp, bno, &mappedbno, bpp, whichfork, 1,
		(inst_t *)__return_address);
}
xfs_da_state_t *
xfs_da_state_alloc(void)
{
	return kmem_zone_zalloc(xfs_da_state_zone, KM_SLEEP);
}
void
xfs_dir2_trace_args(
	char		*where,
	xfs_da_args_t	*args)
{
	xfs_dir2_trace_enter(args->dp, XFS_DIR2_KTRACE_ARGS, where,
		(char *)args->name, (int)args->namelen,
		(void *)(unsigned long)args->hashval,
		(void *)((unsigned long)(args->inumber >> 32)),
		(void *)((unsigned long)(args->inumber & 0xFFFFFFFF)),
		(void *)args->dp, (void *)args->trans,
		(void *)(unsigned long)(args->op_flags & XFS_DA_OP_JUSTCHECK),
		NULL, NULL);
}
void
xfs_dir2_trace_args_b(
	char		*where,
	xfs_da_args_t	*args,
	xfs_dabuf_t	*bp)
{
	xfs_dir2_trace_enter(args->dp, XFS_DIR2_KTRACE_ARGS_B, where,
		(char *)args->name, (int)args->namelen,
		(void *)(unsigned long)args->hashval,
		(void *)((unsigned long)(args->inumber >> 32)),
		(void *)((unsigned long)(args->inumber & 0xFFFFFFFF)),
		(void *)args->dp, (void *)args->trans,
		(void *)(unsigned long)(args->op_flags & XFS_DA_OP_JUSTCHECK),
		(void *)(bp ? bp->bps[0] : NULL), NULL);
}
void
xfs_dir2_trace_args_bb(
	char		*where,
	xfs_da_args_t	*args,
	xfs_dabuf_t	*lbp,
	xfs_dabuf_t	*dbp)
{
	xfs_dir2_trace_enter(args->dp, XFS_DIR2_KTRACE_ARGS_BB, where,
		(char *)args->name, (int)args->namelen,
		(void *)(unsigned long)args->hashval,
		(void *)((unsigned long)(args->inumber >> 32)),
		(void *)((unsigned long)(args->inumber & 0xFFFFFFFF)),
		(void *)args->dp, (void *)args->trans,
		(void *)(unsigned long)(args->op_flags & XFS_DA_OP_JUSTCHECK),
		(void *)(lbp ? lbp->bps[0] : NULL),
		(void *)(dbp ? dbp->bps[0] : NULL));
}
void
xfs_dir2_trace_args_i(
	char		*where,
	xfs_da_args_t	*args,
	xfs_ino_t	i)
{
	xfs_dir2_trace_enter(args->dp, XFS_DIR2_KTRACE_ARGS_I, where,
		(char *)args->name, (int)args->namelen,
		(void *)(unsigned long)args->hashval,
		(void *)((unsigned long)(args->inumber >> 32)),
		(void *)((unsigned long)(args->inumber & 0xFFFFFFFF)),
		(void *)args->dp, (void *)args->trans,
		(void *)(unsigned long)(args->op_flags & XFS_DA_OP_JUSTCHECK),
		(void *)((unsigned long)(i >> 32)),
		(void *)((unsigned long)(i & 0xFFFFFFFF)));
}
void
xfs_dir2_trace_args_s(
	char		*where,
	xfs_da_args_t	*args,
	int		s)
{
	xfs_dir2_trace_enter(args->dp, XFS_DIR2_KTRACE_ARGS_S, where,
		(char *)args->name, (int)args->namelen,
		(void *)(unsigned long)args->hashval,
		(void *)((unsigned long)(args->inumber >> 32)),
		(void *)((unsigned long)(args->inumber & 0xFFFFFFFF)),
		(void *)args->dp, (void *)args->trans,
		(void *)(unsigned long)(args->op_flags & XFS_DA_OP_JUSTCHECK),
		(void *)(long)s, NULL);
}
STATIC uint
xfs_efi_item_size(xfs_efi_log_item_t *efip)
{
	return 1;
}
STATIC void
xfs_efi_item_pin(xfs_efi_log_item_t *efip)
{
	return;
}
STATIC uint
xfs_efi_item_trylock(xfs_efi_log_item_t *efip)
{
	return XFS_ITEM_PINNED;
}
STATIC xfs_lsn_t
xfs_efi_item_committed(xfs_efi_log_item_t *efip, xfs_lsn_t lsn)
{
	return lsn;
}
STATIC void
xfs_efi_item_push(xfs_efi_log_item_t *efip)
{
	return;
}
STATIC void
xfs_efi_item_committing(xfs_efi_log_item_t *efip, xfs_lsn_t lsn)
{
	return;
}
STATIC uint
xfs_efd_item_size(xfs_efd_log_item_t *efdp)
{
	return 1;
}
STATIC void
xfs_efd_item_pin(xfs_efd_log_item_t *efdp)
{
	return;
}
STATIC void
xfs_efd_item_unpin(xfs_efd_log_item_t *efdp, int stale)
{
	return;
}
STATIC void
xfs_efd_item_unpin_remove(xfs_efd_log_item_t *efdp, xfs_trans_t *tp)
{
	return;
}
STATIC uint
xfs_efd_item_trylock(xfs_efd_log_item_t *efdp)
{
	return XFS_ITEM_LOCKED;
}
STATIC void
xfs_efd_item_push(xfs_efd_log_item_t *efdp)
{
	return;
}
STATIC void
xfs_efd_item_committing(xfs_efd_log_item_t *efip, xfs_lsn_t lsn)
{
	return;
}
STATIC void
xfs_filestreams_trace(
	xfs_mount_t	*mp,	/* mount point */
	int		type,	/* type of trace */
	const char	*func,	/* source function */
	int		line,	/* source line number */
	__psunsigned_t	arg0,
	__psunsigned_t	arg1,
	__psunsigned_t	arg2,
	__psunsigned_t	arg3,
	__psunsigned_t	arg4,
	__psunsigned_t	arg5)
{
	ktrace_enter(xfs_filestreams_trace_buf,
		(void *)(__psint_t)(type | (line << 16)),
		(void *)func,
		(void *)(__psunsigned_t)current_pid(),
		(void *)mp,
		(void *)(__psunsigned_t)arg0,
		(void *)(__psunsigned_t)arg1,
		(void *)(__psunsigned_t)arg2,
		(void *)(__psunsigned_t)arg3,
		(void *)(__psunsigned_t)arg4,
		(void *)(__psunsigned_t)arg5,
		NULL, NULL, NULL, NULL, NULL, NULL);
}
void
xfs_filestream_unmount(
	xfs_mount_t	*mp)
{
	xfs_mru_cache_destroy(mp->m_filestream);
}
void
xfs_filestream_flush(
	xfs_mount_t	*mp)
{
	xfs_mru_cache_flush(mp->m_filestream);
}
STATIC int
xfs_inobt_get_minrecs(
	struct xfs_btree_cur	*cur,
	int			level)
{
	return cur->bc_mp->m_inobt_mnr[level != 0];
}
STATIC struct xfs_btree_cur *
xfs_inobt_dup_cursor(
	struct xfs_btree_cur	*cur)
{
	return xfs_inobt_init_cursor(cur->bc_mp, cur->bc_tp,
			cur->bc_private.a.agbp, cur->bc_private.a.agno);
}
STATIC int
xfs_inobt_get_maxrecs(
	struct xfs_btree_cur	*cur,
	int			level)
{
	return cur->bc_mp->m_inobt_mxr[level != 0];
}
STATIC void
xfs_inobt_init_key_from_rec(
	union xfs_btree_key	*key,
	union xfs_btree_rec	*rec)
{
	key->inobt.ir_startino = rec->inobt.ir_startino;
}
STATIC void
xfs_inobt_init_rec_from_key(
	union xfs_btree_key	*key,
	union xfs_btree_rec	*rec)
{
	rec->inobt.ir_startino = key->inobt.ir_startino;
}
STATIC __int64_t
xfs_inobt_key_diff(
	struct xfs_btree_cur	*cur,
	union xfs_btree_key	*key)
{
	return (__int64_t)be32_to_cpu(key->inobt.ir_startino) -
			  cur->bc_rec.i.ir_startino;
}
STATIC int
xfs_inobt_keys_inorder(
	struct xfs_btree_cur	*cur,
	union xfs_btree_key	*k1,
	union xfs_btree_key	*k2)
{
	return be32_to_cpu(k1->inobt.ir_startino) <
		be32_to_cpu(k2->inobt.ir_startino);
}
STATIC int
xfs_inobt_recs_inorder(
	struct xfs_btree_cur	*cur,
	union xfs_btree_rec	*r1,
	union xfs_btree_rec	*r2)
{
	return be32_to_cpu(r1->inobt.ir_startino) + XFS_INODES_PER_CHUNK <=
		be32_to_cpu(r2->inobt.ir_startino);
}
STATIC void
xfs_inobt_trace_enter(
	struct xfs_btree_cur	*cur,
	const char		*func,
	char			*s,
	int			type,
	int			line,
	__psunsigned_t		a0,
	__psunsigned_t		a1,
	__psunsigned_t		a2,
	__psunsigned_t		a3,
	__psunsigned_t		a4,
	__psunsigned_t		a5,
	__psunsigned_t		a6,
	__psunsigned_t		a7,
	__psunsigned_t		a8,
	__psunsigned_t		a9,
	__psunsigned_t		a10)
{
	ktrace_enter(xfs_inobt_trace_buf, (void *)(__psint_t)type,
		(void *)func, (void *)s, NULL, (void *)cur,
		(void *)a0, (void *)a1, (void *)a2, (void *)a3,
		(void *)a4, (void *)a5, (void *)a6, (void *)a7,
		(void *)a8, (void *)a9, (void *)a10);
}
void
xfs_iunlock_map_shared(
	xfs_inode_t	*ip,
	unsigned int	lock_mode)
{
	xfs_iunlock(ip, lock_mode);
}
void
_xfs_itrace_entry(xfs_inode_t *ip, const char *func, inst_t *ra)
{
	KTRACE_ENTER(ip, INODE_KTRACE_ENTRY, func, 0, ra);
}
void
_xfs_itrace_exit(xfs_inode_t *ip, const char *func, inst_t *ra)
{
	KTRACE_ENTER(ip, INODE_KTRACE_EXIT, func, 0, ra);
}
void
xfs_itrace_hold(xfs_inode_t *ip, char *file, int line, inst_t *ra)
{
	KTRACE_ENTER(ip, INODE_KTRACE_HOLD, file, line, ra);
}
void
_xfs_itrace_ref(xfs_inode_t *ip, char *file, int line, inst_t *ra)
{
	KTRACE_ENTER(ip, INODE_KTRACE_REF, file, line, ra);
}
void
xfs_itrace_rele(xfs_inode_t *ip, char *file, int line, inst_t *ra)
{
	KTRACE_ENTER(ip, INODE_KTRACE_RELE, file, line, ra);
}
uint
xfs_dic2xflags(
	xfs_dinode_t		*dip)
{
	return _xfs_dic2xflags(be16_to_cpu(dip->di_flags)) |
				(XFS_DFORK_Q(dip) ? XFS_XFLAG_HASATTR : 0);
}
static inline void
xfs_iunpin_wait(
	xfs_inode_t	*ip)
{
	__xfs_iunpin_wait(ip, 1);
}
static inline void
xfs_iunpin_nowait(
	xfs_inode_t	*ip)
{
	__xfs_iunpin_wait(ip, 0);
}
void
xfs_ilock_trace(xfs_inode_t *ip, int lock, unsigned int lockflags, inst_t *ra)
{
	ktrace_enter(ip->i_lock_trace,
		     (void *)ip,
		     (void *)(unsigned long)lock, /* 1 = LOCK, 3=UNLOCK, etc */
		     (void *)(unsigned long)lockflags, /* XFS_ILOCK_EXCL etc */
		     (void *)ra,		/* caller of ilock */
		     (void *)(unsigned long)current_cpu(),
		     (void *)(unsigned long)current_pid(),
		     NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
}
STATIC void
xfs_inode_item_unpin(
	xfs_inode_log_item_t	*iip,
	int			stale)
{
	xfs_iunpin(iip->ili_inode);
}
STATIC void
xfs_inode_item_unpin_remove(
	xfs_inode_log_item_t	*iip,
	xfs_trans_t		*tp)
{
	xfs_iunpin(iip->ili_inode);
}
STATIC xfs_lsn_t
xfs_inode_item_committed(
	xfs_inode_log_item_t	*iip,
	xfs_lsn_t		lsn)
{
	return (lsn);
}
void
xfs_istale_done(
	xfs_buf_t		*bp,
	xfs_inode_log_item_t	*iip)
{
	xfs_iflush_abort(iip->ili_inode);
}
int
xfs_internal_inum(
	xfs_mount_t	*mp,
	xfs_ino_t	ino)
{
	return (ino == mp->m_sb.sb_rbmino || ino == mp->m_sb.sb_rsumino ||
		(xfs_sb_version_hasquota(&mp->m_sb) &&
		 (ino == mp->m_sb.sb_uquotino || ino == mp->m_sb.sb_gquotino)));
}
int
xfs_bulkstat_one(
	xfs_mount_t	*mp,		/* mount point for filesystem */
	xfs_ino_t	ino,		/* inode number to get data for */
	void		__user *buffer,	/* buffer to place output in */
	int		ubsize,		/* size of buffer */
	void		*private_data,	/* my private data */
	xfs_daddr_t	bno,		/* starting bno of inode cluster */
	int		*ubused,	/* bytes used by me */
	void		*dibuff,	/* on-disk inode buffer */
	int		*stat)		/* BULKSTAT_RV_... */
{
	return xfs_bulkstat_one_int(mp, ino, buffer, ubsize,
				    xfs_bulkstat_one_fmt, bno,
				    ubused, dibuff, stat);
}
void
xlog_trace_loggrant_alloc(xlog_t *log)
{
	log->l_grant_trace = ktrace_alloc(XLOG_TRACE_LOGGRANT_SIZE, KM_NOFS);
}
void
xlog_trace_loggrant_dealloc(xlog_t *log)
{
	ktrace_free(log->l_grant_trace);
}
void
xlog_trace_iclog_alloc(xlog_in_core_t *iclog)
{
	iclog->ic_trace = ktrace_alloc(XLOG_TRACE_ICLOG_SIZE, KM_NOFS);
}
void
xlog_trace_iclog_dealloc(xlog_in_core_t *iclog)
{
	ktrace_free(iclog->ic_trace);
}
void
xlog_trace_iclog(xlog_in_core_t *iclog, uint state)
{
	ktrace_enter(iclog->ic_trace,
		     (void *)((unsigned long)state),
		     (void *)((unsigned long)current_pid()),
		     (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL,
		     (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL,
		     (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL,
		     (void *)NULL, (void *)NULL);
}
void
xlog_put_bp(
	xfs_buf_t	*bp)
{
	xfs_buf_free(bp);
}
void
xfs_mru_cache_done(
	xfs_mru_cache_t	*mru) __releases(mru->lock)
{
	spin_unlock(&mru->lock);
}
STATIC struct xfs_dquot *
xfs_dqvopchown_default(
	struct xfs_trans	*tp,
	struct xfs_inode	*ip,
	struct xfs_dquot	**dqp,
	struct xfs_dquot	*dq)
{
	return NULL;
}
void
xfs_ioerror_alert(
	char			*func,
	struct xfs_mount	*mp,
	xfs_buf_t		*bp,
	xfs_daddr_t		blkno)
{
	cmn_err(CE_ALERT,
 "I/O error in filesystem (\"%s\") meta-data dev %s block 0x%llx"
 "       (\"%s\") error %d buf count %zd",
		(!mp || !mp->m_fsname) ? "(fs name not set)" : mp->m_fsname,
		XFS_BUFTARG_NAME(XFS_BUF_TARGET(bp)),
		(__uint64_t)blkno, func,
		XFS_BUF_GETERROR(bp), XFS_BUF_COUNT(bp));
}
STATIC uint
xfs_calc_write_reservation(xfs_mount_t *mp)
{
	return XFS_CALC_WRITE_LOG_RES(mp) + XFS_DQUOT_LOGRES(mp);
}
STATIC uint
xfs_calc_itruncate_reservation(xfs_mount_t *mp)
{
	return XFS_CALC_ITRUNCATE_LOG_RES(mp) + XFS_DQUOT_LOGRES(mp);
}
STATIC uint
xfs_calc_rename_reservation(xfs_mount_t *mp)
{
	return XFS_CALC_RENAME_LOG_RES(mp) + XFS_DQUOT_LOGRES(mp);
}
STATIC uint
xfs_calc_link_reservation(xfs_mount_t *mp)
{
	return XFS_CALC_LINK_LOG_RES(mp) + XFS_DQUOT_LOGRES(mp);
}
STATIC uint
xfs_calc_remove_reservation(xfs_mount_t *mp)
{
	return XFS_CALC_REMOVE_LOG_RES(mp) + XFS_DQUOT_LOGRES(mp);
}
STATIC uint
xfs_calc_symlink_reservation(xfs_mount_t *mp)
{
	return XFS_CALC_SYMLINK_LOG_RES(mp) + XFS_DQUOT_LOGRES(mp);
}
STATIC uint
xfs_calc_create_reservation(xfs_mount_t *mp)
{
	return XFS_CALC_CREATE_LOG_RES(mp) + XFS_DQUOT_LOGRES(mp);
}
STATIC uint
xfs_calc_mkdir_reservation(xfs_mount_t *mp)
{
	return XFS_CALC_MKDIR_LOG_RES(mp) + XFS_DQUOT_LOGRES(mp);
}
STATIC uint
xfs_calc_ifree_reservation(xfs_mount_t *mp)
{
	return XFS_CALC_IFREE_LOG_RES(mp) + XFS_DQUOT_LOGRES(mp);
}
STATIC uint
xfs_calc_ichange_reservation(xfs_mount_t *mp)
{
	return XFS_CALC_ICHANGE_LOG_RES(mp) + XFS_DQUOT_LOGRES(mp);
}
STATIC uint
xfs_calc_growdata_reservation(xfs_mount_t *mp)
{
	return XFS_CALC_GROWDATA_LOG_RES(mp);
}
STATIC uint
xfs_calc_growrtalloc_reservation(xfs_mount_t *mp)
{
	return XFS_CALC_GROWRTALLOC_LOG_RES(mp);
}
STATIC uint
xfs_calc_growrtzero_reservation(xfs_mount_t *mp)
{
	return XFS_CALC_GROWRTZERO_LOG_RES(mp);
}
STATIC uint
xfs_calc_growrtfree_reservation(xfs_mount_t *mp)
{
	return XFS_CALC_GROWRTFREE_LOG_RES(mp);
}
STATIC uint
xfs_calc_swrite_reservation(xfs_mount_t *mp)
{
	return XFS_CALC_SWRITE_LOG_RES(mp);
}
STATIC uint
xfs_calc_writeid_reservation(xfs_mount_t *mp)
{
	return XFS_CALC_WRITEID_LOG_RES(mp);
}
STATIC uint
xfs_calc_addafork_reservation(xfs_mount_t *mp)
{
	return XFS_CALC_ADDAFORK_LOG_RES(mp) + XFS_DQUOT_LOGRES(mp);
}
STATIC uint
xfs_calc_attrinval_reservation(xfs_mount_t *mp)
{
	return XFS_CALC_ATTRINVAL_LOG_RES(mp);
}
STATIC uint
xfs_calc_attrset_reservation(xfs_mount_t *mp)
{
	return XFS_CALC_ATTRSET_LOG_RES(mp) + XFS_DQUOT_LOGRES(mp);
}
STATIC uint
xfs_calc_attrrm_reservation(xfs_mount_t *mp)
{
	return XFS_CALC_ATTRRM_LOG_RES(mp) + XFS_DQUOT_LOGRES(mp);
}
STATIC uint
xfs_calc_clear_agi_bucket_reservation(xfs_mount_t *mp)
{
	return XFS_CALC_CLEAR_AGI_BUCKET_LOG_RES(mp);
}
static unsigned long __cpuinit calibrate_delay_direct(void) {return 0;}
static void __init smp_init(void)
{
	APIC_init_uniprocessor();
}
static void __init setup_nr_cpu_ids(void)
{
	nr_cpu_ids = find_last_bit(cpumask_bits(cpu_possible_mask),NR_CPUS) + 1;
}
int ipcns_notify(unsigned long val)
{
	return blocking_notifier_call_chain(&ipcns_chain, val, NULL);
}
static inline struct mqueue_inode_info *MQUEUE_I(struct inode *inode)
{
	return container_of(inode, struct mqueue_inode_info, vfs_inode);
}
static int mqueue_get_sb(struct file_system_type *fs_type,
			 int flags, const char *dev_name,
			 void *data, struct vfsmount *mnt)
{
	return get_sb_single(fs_type, flags, data, mqueue_fill_super, mnt);
}
static void mqueue_destroy_inode(struct inode *inode)
{
	kmem_cache_free(mqueue_inode_cachep, MQUEUE_I(inode));
}
static inline void set_cookie(struct sk_buff *skb, char code)
{
	((char*)skb->data)[NOTIFY_COOKIE_LEN-1] = code;
}
void msg_exit_ns(struct ipc_namespace *ns)
{
	free_ipcs(ns, &msg_ids(ns), freeque);
}
static inline void msg_rmid(struct ipc_namespace *ns, struct msg_queue *s)
{
	ipc_rmid(&msg_ids(ns), &s->q_perm);
}
void sem_exit_ns(struct ipc_namespace *ns)
{
	free_ipcs(ns, &sem_ids(ns), freeary);
}
static inline void sem_rmid(struct ipc_namespace *ns, struct sem_array *s)
{
	ipc_rmid(&sem_ids(ns), &s->sem_perm);
}
asmlinkage long SyS_semctl(int semid, int semnum, int cmd, union semun arg)
{
	return SYSC_semctl((int) semid, (int) semnum, (int) cmd, arg);
}
void shm_exit_ns(struct ipc_namespace *ns)
{
	free_ipcs(ns, &shm_ids(ns), do_shm_rmid);
}
static inline void shm_rmid(struct ipc_namespace *ns, struct shmid_kernel *s)
{
	ipc_rmid(&shm_ids(ns), &s->shm_perm);
}
static void ipc_memory_notifier(struct work_struct *work)
{
	ipcns_notify(IPCNS_MEMCHANGED);
}
void ipc_rcu_getref(void *ptr)
{
	container_of(ptr, struct ipc_rcu_hdr, data)->refcount++;
}
static void ipc_do_vfree(struct work_struct *work)
{
	vfree(container_of(work, struct ipc_rcu_sched, work));
}
int ipcget(struct ipc_namespace *ns, struct ipc_ids *ids,
			struct ipc_ops *ops, struct ipc_params *params)
{
	if (params->key == IPC_PRIVATE)
		return ipcget_new(ns, ids, ops, params);
	else
		return ipcget_public(ns, ids, ops, params);
}
async_cookie_t async_schedule(async_func_ptr *ptr, void *data)
{
	return __async_schedule(ptr, data, &async_running);
}
async_cookie_t async_schedule_domain(async_func_ptr *ptr, void *data,
				     struct list_head *running)
{
	return __async_schedule(ptr, data, running);
}
void async_synchronize_full_domain(struct list_head *list)
{
	async_synchronize_cookie_domain(next_cookie, list);
}
void async_synchronize_cookie(async_cookie_t cookie)
{
	async_synchronize_cookie_domain(cookie, &async_running);
}
static int audit_set_rate_limit(int limit, uid_t loginuid, u32 sessionid,
				u32 sid)
{
	return audit_do_config_change("audit_rate_limit", &audit_rate_limit,
				      limit, loginuid, sessionid, sid);
}
static int audit_set_backlog_limit(int limit, uid_t loginuid, u32 sessionid,
				   u32 sid)
{
	return audit_do_config_change("audit_backlog_limit", &audit_backlog_limit,
				      limit, loginuid, sessionid, sid);
}
void audit_schedule_prune(void)
{
	kthread_run(prune_tree_thread, NULL, "audit_prune_tree");
}
void audit_log_untrustedstring(struct audit_buffer *ab, const char *string)
{
	audit_log_n_untrustedstring(ab, string, strlen(string));
}
static inline void get_tree(struct audit_tree *tree)
{
	atomic_inc(&tree->count);
}
const char *audit_tree_path(struct audit_tree *tree)
{
	return tree->pathname;
}
void audit_put_tree(struct audit_tree *tree)
{
	put_tree(tree);
}
static inline void audit_get_watch(struct audit_watch *watch)
{
	atomic_inc(&watch->count);
}
static void backtrace_test_saved(void)
{
	printk("Saved backtrace test skipped.\n");
}
inline int cgroup_is_removed(const struct cgroup *cgrp)
{
	return test_bit(CGRP_REMOVED, &cgrp->flags);
}
static int notify_on_release(const struct cgroup *cgrp)
{
	return test_bit(CGRP_NOTIFY_ON_RELEASE, &cgrp->flags);
}
static inline void get_css_set(struct css_set *cg)
{
	atomic_inc(&cg->refcount);
}
static inline void put_css_set(struct css_set *cg)
{
	__put_css_set(cg, 0);
}
static inline void put_css_set_taskexit(struct css_set *cg)
{
	__put_css_set(cg, 1);
}
void cgroup_lock(void)
{
	mutex_lock(&cgroup_mutex);
}
void cgroup_unlock(void)
{
	mutex_unlock(&cgroup_mutex);
}
static inline struct cgroup *__d_cgrp(struct dentry *dentry)
{
	return dentry->d_fsdata;
}
static inline struct cftype *__d_cft(struct dentry *dentry)
{
	return dentry->d_fsdata;
}
void cgroup_iter_end(struct cgroup *cgrp, struct cgroup_iter *it)
{
	read_unlock(&css_set_lock);
}
static int cmppid(const void *a, const void *b)
{
	return *(pid_t *)a - *(pid_t *)b;
}
static int cgroup_tasks_show(struct seq_file *s, void *v)
{
	return seq_printf(s, "%d\n", *(int *)v);
}
static u64 cgroup_read_notify_on_release(struct cgroup *cgrp,
					    struct cftype *cft)
{
	return notify_on_release(cgrp);
}
static int cgroupstats_open(struct inode *inode, struct file *file)
{
	return single_open(file, proc_cgroupstats_show, NULL);
}
static void debug_destroy(struct cgroup_subsys *ss, struct cgroup *cont)
{
	kfree(cont->subsys[debug_subsys_id]);
}
static u64 cgroup_refcount_read(struct cgroup *cont, struct cftype *cft)
{
	return atomic_read(&cont->count);
}
static u64 current_css_set_read(struct cgroup *cont, struct cftype *cft)
{
	return (u64)(long)current->cgroups;
}
static u64 releasable_read(struct cgroup *cgrp, struct cftype *cft)
{
	return test_bit(CGRP_RELEASABLE, &cgrp->flags);
}
static int debug_populate(struct cgroup_subsys *ss, struct cgroup *cont)
{
	return cgroup_add_files(cont, ss, files, ARRAY_SIZE(files));
}
static inline struct freezer *cgroup_freezer(
		struct cgroup *cgroup)
{
	return container_of(
		cgroup_subsys_state(cgroup, freezer_subsys_id),
		struct freezer, css);
}
static inline struct freezer *task_freezer(struct task_struct *task)
{
	return container_of(task_subsys_state(task, freezer_subsys_id),
			    struct freezer, css);
}
static void freezer_destroy(struct cgroup_subsys *ss,
			    struct cgroup *cgroup)
{
	kfree(cgroup_freezer(cgroup));
}
static bool is_task_frozen_enough(struct task_struct *task)
{
	return frozen(task) ||
		(task_is_stopped_or_traced(task) && freezing(task));
}
static int compat_put_timeval(struct compat_timeval __user *o,
		struct timeval *i)
{
	return (put_user(i->tv_sec, &o->tv_sec) ||
		put_user(i->tv_usec, &o->tv_usec)) ? -EFAULT : 0;
}
int get_compat_timespec(struct timespec *ts, const struct compat_timespec __user *cts)
{
	return (!access_ok(VERIFY_READ, cts, sizeof(*cts)) ||
			__get_user(ts->tv_sec, &cts->tv_sec) ||
			__get_user(ts->tv_nsec, &cts->tv_nsec)) ? -EFAULT : 0;
}
int put_compat_timespec(const struct timespec *ts, struct compat_timespec __user *cts)
{
	return (!access_ok(VERIFY_WRITE, cts, sizeof(*cts)) ||
			__put_user(ts->tv_sec, &cts->tv_sec) ||
			__put_user(ts->tv_nsec, &cts->tv_nsec)) ? -EFAULT : 0;
}
static inline long get_compat_itimerval(struct itimerval *o,
		struct compat_itimerval __user *i)
{
	return (!access_ok(VERIFY_READ, i, sizeof(*i)) ||
		(__get_user(o->it_interval.tv_sec, &i->it_interval.tv_sec) |
		 __get_user(o->it_interval.tv_usec, &i->it_interval.tv_usec) |
		 __get_user(o->it_value.tv_sec, &i->it_value.tv_sec) |
		 __get_user(o->it_value.tv_usec, &i->it_value.tv_usec)));
}

static inline long put_compat_itimerval(struct compat_itimerval __user *o,
		struct itimerval *i)
{
	return (!access_ok(VERIFY_WRITE, o, sizeof(*o)) ||
		(__put_user(i->it_interval.tv_sec, &o->it_interval.tv_sec) |
		 __put_user(i->it_interval.tv_usec, &o->it_interval.tv_usec) |
		 __put_user(i->it_value.tv_sec, &o->it_value.tv_sec) |
		 __put_user(i->it_value.tv_usec, &o->it_value.tv_usec)));
}
static compat_clock_t clock_t_to_compat_clock_t(clock_t x)
{
	return compat_jiffies_to_clock_t(clock_t_to_jiffies(x));
}
static ssize_t
ikconfig_read_current(struct file *file, char __user *buf,
		      size_t len, loff_t * offset)
{
	return simple_read_from_buffer(buf, len, offset,
				       kernel_config_data + MAGIC_SIZE,
				       kernel_config_data_size);
}
static void __exit ikconfig_cleanup(void)
{
	remove_proc_entry("config.gz", NULL);
}
void cpu_maps_update_begin(void)
{
	mutex_lock(&cpu_add_remove_lock);
}
void cpu_maps_update_done(void)
{
	mutex_unlock(&cpu_add_remove_lock);
}
void init_cpu_present(const struct cpumask *src)
{
	cpumask_copy(to_cpumask(__cpu_present_bits), src);
}
void init_cpu_possible(const struct cpumask *src)
{
	cpumask_copy(to_cpumask(__cpu_possible_bits), src);
}
void init_cpu_online(const struct cpumask *src)
{
	cpumask_copy(to_cpumask(__cpu_online_bits), src);
}
static inline struct cpuset *cgroup_cs(struct cgroup *cont)
{
	return container_of(cgroup_subsys_state(cont, cpuset_subsys_id),
			    struct cpuset, css);
}
static inline struct cpuset *task_cs(struct task_struct *task)
{
	return container_of(task_subsys_state(task, cpuset_subsys_id),
			    struct cpuset, css);
}
static inline int is_cpu_exclusive(const struct cpuset *cs)
{
	return test_bit(CS_CPU_EXCLUSIVE, &cs->flags);
}
static inline int is_mem_exclusive(const struct cpuset *cs)
{
	return test_bit(CS_MEM_EXCLUSIVE, &cs->flags);
}
static inline int is_mem_hardwall(const struct cpuset *cs)
{
	return test_bit(CS_MEM_HARDWALL, &cs->flags);
}
static inline int is_sched_load_balance(const struct cpuset *cs)
{
	return test_bit(CS_SCHED_LOAD_BALANCE, &cs->flags);
}
static inline int is_memory_migrate(const struct cpuset *cs)
{
	return test_bit(CS_MEMORY_MIGRATE, &cs->flags);
}
static inline int is_spread_page(const struct cpuset *cs)
{
	return test_bit(CS_SPREAD_PAGE, &cs->flags);
}
static inline int is_spread_slab(const struct cpuset *cs)
{
	return test_bit(CS_SPREAD_SLAB, &cs->flags);
}
static int is_cpuset_subset(const struct cpuset *p, const struct cpuset *q)
{
	return	cpumask_subset(p->cpus_allowed, q->cpus_allowed) &&
		nodes_subset(p->mems_allowed, q->mems_allowed) &&
		is_cpu_exclusive(p) <= is_cpu_exclusive(q) &&
		is_mem_exclusive(p) <= is_mem_exclusive(q);
}
static int cpusets_overlap(struct cpuset *a, struct cpuset *b)
{
	return cpumask_intersects(a->cpus_allowed, b->cpus_allowed);
}
static void async_rebuild_sched_domains(void)
{
	queue_work(cpuset_wq, &rebuild_sched_domains_work);
}
void rebuild_sched_domains(void)
{
	do_rebuild_sched_domains(NULL);
}
static int cpuset_test_cpumask(struct task_struct *tsk,
			       struct cgroup_scanner *scan)
{
	return !cpumask_equal(&tsk->cpus_allowed,
			(cgroup_cs(scan->cg))->cpus_allowed);
}
static void cpuset_change_cpumask(struct task_struct *tsk,
				  struct cgroup_scanner *scan)
{
	set_cpus_allowed_ptr(tsk, ((cgroup_cs(scan->cg))->cpus_allowed));
}
int current_cpuset_is_being_rebound(void)
{
	return task_cs(current) == cpuset_being_rebound;
}
void cpuset_init_current_mems_allowed(void)
{
	nodes_setall(current->mems_allowed);
}
int cpuset_nodemask_valid_mems_allowed(nodemask_t *nodemask)
{
	return nodes_intersects(*nodemask, current->mems_allowed);
}
void cpuset_lock(void)
{
	mutex_lock(&callback_mutex);
}
void cpuset_unlock(void)
{
	mutex_unlock(&callback_mutex);
}
int cpuset_mems_allowed_intersects(const struct task_struct *tsk1,
				   const struct task_struct *tsk2)
{
	return nodes_intersects(tsk1->mems_allowed, tsk2->mems_allowed);
}
void __init cred_init(void)
{
	cred_jar = kmem_cache_create("cred_jar", sizeof(struct cred),
				     0, SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);
}
int set_security_override(struct cred *new, u32 secid)
{
	return security_kernel_act_as(new, secid);
}
static inline void delayacct_start(struct timespec *start)
{
	do_posix_clock_monotonic_gettime(start);
}
void __delayacct_blkio_start(void)
{
	delayacct_start(&current->delays->blkio_start);
}
void __delayacct_freepages_start(void)
{
	delayacct_start(&current->delays->freepages_start);
}
void __delayacct_freepages_end(void)
{
	delayacct_end(&current->delays->freepages_start,
			&current->delays->freepages_end,
			&current->delays->freepages_delay,
			&current->delays->freepages_count);
}
int request_dma(unsigned int dmanr, const char *device_id)
{
	return -EINVAL;
}
static int proc_dma_open(struct inode *inode, struct file *file)
{
	return single_open(file, proc_dma_show, NULL);
}
static int execdomains_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, execdomains_proc_show, NULL);
}
static inline int task_detached(struct task_struct *p)
{
	return p->exit_signal == -1;
}
void __init sort_main_extable(void)
{
	sort_extable(__start___ex_table, __stop___ex_table);
}
static inline void free_thread_info(struct thread_info *ti)
{
	free_pages((unsigned long)ti, THREAD_SIZE_ORDER);
}
static inline void mm_free_pgd(struct mm_struct * mm)
{
	pgd_free(mm, mm->pgd);
}
struct fs_struct *copy_fs_struct(struct fs_struct *old)
{
	return __copy_fs_struct(old);
}
void mm_init_owner(struct mm_struct *mm, struct task_struct *p)
{
	mm->owner = p;
}
static inline int match_futex(union futex_key *key1, union futex_key *key2)
{
	return (key1->both.word == key2->both.word
		&& key1->both.ptr == key2->both.ptr
		&& key1->both.offset == key2->both.offset);
}
static inline
void put_futex_key(int fshared, union futex_key *key)
{
	drop_futex_key_refs(key);
}
static inline void debug_hrtimer_init(struct hrtimer *timer)
{
	debug_object_init(timer, &hrtimer_debug_descr);
}
static inline void debug_hrtimer_activate(struct hrtimer *timer)
{
	debug_object_activate(timer, &hrtimer_debug_descr);
}
static inline void debug_hrtimer_deactivate(struct hrtimer *timer)
{
	debug_object_deactivate(timer, &hrtimer_debug_descr);
}
static inline void debug_hrtimer_free(struct hrtimer *timer)
{
	debug_object_free(timer, &hrtimer_debug_descr);
}
void destroy_hrtimer_on_stack(struct hrtimer *timer)
{
	debug_object_free(timer, &hrtimer_debug_descr);
}
static inline int hrtimer_is_hres_enabled(void)
{
	return hrtimer_hres_enabled;
}
static inline int hrtimer_hres_active(void)
{
	return __get_cpu_var(hrtimer_bases).hres_active;
}
void clock_was_set(void)
{
	on_each_cpu(retrigger_next_event, NULL, 1);
}
static inline int hrtimer_hres_active(void) { return 0; }
static inline int hrtimer_is_hres_enabled(void) { return 0; }
static inline int hrtimer_switch_to_hres(void) { return 0; }
static inline int hrtimer_enqueue_reprogram(struct hrtimer *timer,
					    struct hrtimer_clock_base *base)
{
	return 0;
}
static inline
void unlock_hrtimer_base(const struct hrtimer *timer, unsigned long *flags)
{
	spin_unlock_irqrestore(&timer->base->cpu_base->lock, *flags);
}
int
hrtimer_start(struct hrtimer *timer, ktime_t tim, const enum hrtimer_mode mode)
{
	return hrtimer_start_range_ns(timer, tim, 0, mode);
}
static void run_hrtimer_softirq(struct softirq_action *h)
{
	hrtimer_peek_ahead_timers();
}
int __sched schedule_hrtimeout(ktime_t *expires,
			       const enum hrtimer_mode mode)
{
	return schedule_hrtimeout_range(expires, 0, mode);
}
struct irq_desc *irq_to_desc(unsigned int irq)
{
	return (irq < NR_IRQS) ? irq_desc + irq : NULL;
}
struct irq_desc *irq_to_desc_alloc_cpu(unsigned int irq, int cpu)
{
	return irq_to_desc(irq);
}
static unsigned int noop_ret(unsigned int irq)
{
	return 0;
}
irqreturn_t no_action(int cpl, void *dev_id)
{
	return IRQ_NONE;
}
static inline int do_irq_select_affinity(unsigned int irq, struct irq_desc *d)
{
	return irq_select_affinity(irq);
}
static inline int do_irq_select_affinity(int irq, struct irq_desc *desc)
{
	return 0;
}
static int irq_affinity_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, irq_affinity_proc_show, PDE(inode)->data);
}
static int default_affinity_open(struct inode *inode, struct file *file)
{
	return single_open(file, default_affinity_show, NULL);
}
static void register_default_affinity_proc(void)
{
	proc_create("irq/default_smp_affinity", 0600, NULL,
		    &default_affinity_proc_fops);
}
void debug_poll_all_shared_irqs(void)
{
	poll_all_shared_irqs();
}
static char kallsyms_get_symbol_type(unsigned int off)
{
	return kallsyms_token_table[ kallsyms_token_index[ kallsyms_names[off+1] ] ];
}
unsigned long __attribute__ ((weak)) paddr_vmcoreinfo_note(void)
{
	return __pa((unsigned long)(char *)&vmcoreinfo_note);
}
int __weak kgdb_arch_remove_breakpoint(unsigned long addr, char *bundle)
{
	return probe_kernel_write((char *)addr,
				  (char *)bundle, BREAK_INSTR_SIZE);
}
unsigned long __weak kgdb_arch_pc(int exception, struct pt_regs *regs)
{
	return instruction_pointer(regs);
}
int __weak kgdb_arch_init(void)
{
	return 0;
}
int __weak kgdb_skipexception(int exception, struct pt_regs *regs)
{
	return 0;
}
void __weak
kgdb_post_primary_code(struct pt_regs *regs, int e_vector, int err_code)
{
	return;
}
void usermodehelper_enable(void)
{
	usermodehelper_disabled = 0;
}
void call_usermodehelper_setcleanup(struct subprocess_info *info,
				    void (*cleanup)(char **argv, char **envp))
{
	info->cleanup = cleanup;
}
static spinlock_t *kretprobe_table_lock_ptr(unsigned long hash)
{
	return &(kretprobe_table_locks[hash].lock);
}
static inline void set_kprobe_instance(struct kprobe *kp)
{
	__get_cpu_var(kprobe_instance) = kp;
}
static inline void reset_kprobe_instance(void)
{
	__get_cpu_var(kprobe_instance) = NULL;
}
void __kprobes unregister_kprobe(struct kprobe *p)
{
	unregister_kprobes(&p, 1);
}
unsigned long __weak arch_deref_entry_point(void *entry)
{
	return (unsigned long)entry;
}
int __kprobes register_jprobe(struct jprobe *jp)
{
	return register_jprobes(&jp, 1);
}
void __kprobes unregister_jprobe(struct jprobe *jp)
{
	unregister_jprobes(&jp, 1);
}
void __kprobes unregister_kretprobe(struct kretprobe *rp)
{
	unregister_kretprobes(&rp, 1);
}
int __kprobes register_kretprobe(struct kretprobe *rp)
{
	return -ENOSYS;
}
int __kprobes register_kretprobes(struct kretprobe **rps, int num)
{
	return -ENOSYS;
}
static int __kprobes pre_handler_kretprobe(struct kprobe *p,
					   struct pt_regs *regs)
{
	return 0;
}
static void __kprobes *kprobe_seq_start(struct seq_file *f, loff_t *pos)
{
	return (*pos < KPROBE_TABLE_SIZE) ? pos : NULL;
}
static int __kprobes kprobes_open(struct inode *inode, struct file *filp)
{
	return seq_open(filp, &kprobes_seq_ops);
}
static ssize_t uevent_seqnum_show(struct kobject *kobj,
				  struct kobj_attribute *attr, char *buf)
{
	return sprintf(buf, "%llu\n", (unsigned long long)uevent_seqnum);
}
static ssize_t uevent_helper_show(struct kobject *kobj,
				  struct kobj_attribute *attr, char *buf)
{
	return sprintf(buf, "%s\n", uevent_helper);
}
static ssize_t profiling_show(struct kobject *kobj,
				  struct kobj_attribute *attr, char *buf)
{
	return sprintf(buf, "%d\n", prof_on);
}
static ssize_t kexec_loaded_show(struct kobject *kobj,
				 struct kobj_attribute *attr, char *buf)
{
	return sprintf(buf, "%d\n", !!kexec_image);
}
static ssize_t kexec_crash_loaded_show(struct kobject *kobj,
				       struct kobj_attribute *attr, char *buf)
{
	return sprintf(buf, "%d\n", !!kexec_crash_image);
}
static ssize_t vmcoreinfo_show(struct kobject *kobj,
			       struct kobj_attribute *attr, char *buf)
{
	return sprintf(buf, "%lx %x\n",
		       paddr_vmcoreinfo_note(),
		       (unsigned int)vmcoreinfo_max_size);
}
int kthread_should_stop(void)
{
	return (kthread_stop_info.k == current);
}
static int lstats_open(struct inode *inode, struct file *filp)
{
	return single_open(filp, lstats_show, NULL);
}
static struct lock_class_stats *get_lock_stats(struct lock_class *class)
{
	return &get_cpu_var(lock_stats)[class - lock_classes];
}
static void put_lock_stats(struct lock_class_stats *stats)
{
	put_cpu_var(lock_stats);
}
void lockdep_off(void)
{
	current->lockdep_recursion++;
}
void lockdep_on(void)
{
	current->lockdep_recursion--;
}
static int class_filter(struct lock_class *class)
{
	return 0;
}
static int verbose(struct lock_class *class)
{
	return class_filter(class);
}
const char * __get_key_name(struct lockdep_subclass_key *key, char *str)
{
	return kallsyms_lookup((unsigned long)key, NULL, NULL, NULL, str);
}
static void print_kernel_version(void)
{
	printk("%s %.*s\n", init_utsname()->release,
		(int)strcspn(init_utsname()->version, " "),
		init_utsname()->version);
}
static int very_verbose(struct lock_class *class)
{
	return class_filter(class);
}
static inline int
check_prev_add_irq(struct task_struct *curr, struct held_lock *prev,
		struct held_lock *next)
{
	return 1;
}
static inline void inc_chains(void)
{
	nr_process_chains++;
}
struct lock_class *lock_chain_get_class(struct lock_chain *chain, int i)
{
	return lock_classes + chain_hlocks[chain->base + i];
}
static inline int validate_chain(struct task_struct *curr,
	       	struct lockdep_map *lock, struct held_lock *hlock,
		int chain_head, u64 chain_key)
{
	return 1;
}
static int hardirq_verbose(struct lock_class *class)
{
	return class_filter(class);
}
static int softirq_verbose(struct lock_class *class)
{
	return class_filter(class);
}
void early_boot_irqs_off(void)
{
	early_boot_irqs_enabled = 0;
}
void early_boot_irqs_on(void)
{
	early_boot_irqs_enabled = 1;
}
void trace_hardirqs_on(void)
{
	trace_hardirqs_on_caller(CALLER_ADDR0);
}
void trace_hardirqs_off(void)
{
	trace_hardirqs_off_caller(CALLER_ADDR0);
}
static inline int mark_irqflags(struct task_struct *curr,
		struct held_lock *hlock)
{
	return 1;
}
static inline int separate_irq_context(struct task_struct *curr,
		struct held_lock *hlock)
{
	return 0;
}
static inline int within(const void *addr, void *start, unsigned long size)
{
	return addr >= start && addr < start + size;
}
static inline int not_in_range(const void* mem_from, unsigned long mem_len,
				const void* lock_from, unsigned long lock_len)
{
	return lock_from + lock_len <= mem_from ||
		mem_from + mem_len <= lock_from;
}
void debug_show_held_locks(struct task_struct *task)
{
		__debug_show_held_locks(task);
}
static int lockdep_stats_open(struct inode *inode, struct file *file)
{
	return single_open(file, lockdep_stats_show, NULL);
}
static int init_markers(void)
{
	return register_module_notifier(&marker_module_nb);
}
int register_module_notifier(struct notifier_block * nb)
{
	return blocking_notifier_chain_register(&module_notify_list, nb);
}
int unregister_module_notifier(struct notifier_block * nb)
{
	return blocking_notifier_chain_unregister(&module_notify_list, nb);
}
static void *section_addr(Elf_Ehdr *hdr, Elf_Shdr *shdrs,
			  const char *secstrings, const char *name)
{
	return (void *)shdrs[find_sec(hdr, shdrs, secstrings, name)].sh_addr;
}
static unsigned int find_pcpusec(Elf_Ehdr *hdr,
				 Elf_Shdr *sechdrs,
				 const char *secstrings)
{
	return find_sec(hdr, sechdrs, secstrings, ".data.percpu");
}
static inline void *percpu_modalloc(unsigned long size, unsigned long align,
				    const char *name)
{
	return NULL;
}
static inline void percpu_modfree(void *pcpuptr)
{
	BUG();
}
static inline unsigned int find_pcpusec(Elf_Ehdr *hdr,
					Elf_Shdr *sechdrs,
					const char *secstrings)
{
	return 0;
}
static inline void percpu_modcopy(void *pcpudst, const void *src,
				  unsigned long size)
{
	BUG_ON(size != 0);
}
static inline int try_force_unload(unsigned int flags)
{
	return 0;
}
static ssize_t show_refcnt(struct module_attribute *mattr,
			   struct module *mod, char *buffer)
{
	return sprintf(buffer, "%u\n", module_refcount(mod));
}
static inline void print_unload_info(struct seq_file *m, struct module *mod)
{
	seq_printf(m, " - -");
}
static inline int use_module(struct module *a, struct module *b)
{
	return strong_try_module_get(b) == 0;
}
static inline int check_version(Elf_Shdr *sechdrs,
				unsigned int versindex,
				const char *symname,
				struct module *mod, 
				const unsigned long *crc)
{
	return 1;
}
static inline int check_modstruct_version(Elf_Shdr *sechdrs,
					  unsigned int versindex,
					  struct module *mod)
{
	return 1;
}
static inline int same_magic(const char *amagic, const char *bmagic,
			     bool has_crcs)
{
	return strcmp(amagic, bmagic) == 0;
}
static void mod_sysfs_fini(struct module *mod)
{
	kobject_put(&mod->mkobj.kobj);
}
unsigned int __weak arch_mod_section_prepend(struct module *mod,
					     unsigned int section)
{
	return 0;
}
static inline int within(unsigned long addr, void *start, unsigned long size)
{
	return ((void *)addr >= start && (void *)addr < start + size);
}
static inline int is_arm_mapping_symbol(const char *str)
{
	return str[0] == '$' && strchr("atd", str[1])
	       && (str[2] == '\0' || str[2] == '.');
}
static void *m_next(struct seq_file *m, void *p, loff_t *pos)
{
	return seq_list_next(p, &modules, pos);
}
static void m_stop(struct seq_file *m, void *p)
{
	mutex_unlock(&module_mutex);
}
static int modules_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &modules_op);
}
void struct_module(struct module *mod) { return; }
static __used noinline void
__mutex_unlock_slowpath(atomic_t *lock_count)
{
	__mutex_unlock_common_slowpath(lock_count, 1);
}
int __kprobes atomic_notifier_call_chain(struct atomic_notifier_head *nh,
		unsigned long val, void *v)
{
	return __atomic_notifier_call_chain(nh, val, v, -1, NULL);
}
int blocking_notifier_call_chain(struct blocking_notifier_head *nh,
		unsigned long val, void *v)
{
	return __blocking_notifier_call_chain(nh, val, v, -1, NULL);
}
int raw_notifier_chain_register(struct raw_notifier_head *nh,
		struct notifier_block *n)
{
	return notifier_chain_register(&nh->head, n);
}
int raw_notifier_chain_unregister(struct raw_notifier_head *nh,
		struct notifier_block *n)
{
	return notifier_chain_unregister(&nh->head, n);
}
int __raw_notifier_call_chain(struct raw_notifier_head *nh,
			      unsigned long val, void *v,
			      int nr_to_call, int *nr_calls)
{
	return notifier_call_chain(&nh->head, val, v, nr_to_call, nr_calls);
}
int raw_notifier_call_chain(struct raw_notifier_head *nh,
		unsigned long val, void *v)
{
	return __raw_notifier_call_chain(nh, val, v, -1, NULL);
}
int srcu_notifier_call_chain(struct srcu_notifier_head *nh,
		unsigned long val, void *v)
{
	return __srcu_notifier_call_chain(nh, val, v, -1, NULL);
}
int register_reboot_notifier(struct notifier_block *nb)
{
	return blocking_notifier_chain_register(&reboot_notifier_list, nb);
}
int unregister_reboot_notifier(struct notifier_block *nb)
{
	return blocking_notifier_chain_unregister(&reboot_notifier_list, nb);
}
int unregister_die_notifier(struct notifier_block *nb)
{
	return atomic_notifier_chain_unregister(&die_chain, nb);
}
static inline struct ns_cgroup *cgroup_to_ns(
		struct cgroup *cgroup)
{
	return container_of(cgroup_subsys_state(cgroup, ns_subsys_id),
			    struct ns_cgroup, css);
}
void exit_task_namespaces(struct task_struct *p)
{
	switch_task_namespaces(p, NULL);
}
static long no_blink(long time)
{
	return 0;
}
int test_taint(unsigned flag)
{
	return test_bit(flag, &tainted_mask);
}
unsigned long get_taint(void)
{
	return tainted_mask;
}
int oops_may_print(void)
{
	return pause_on_oops_flag == 0;
}
void __stack_chk_fail(void)
{
	panic("stack-protector: Kernel stack is corrupted in: %p\n",
		__builtin_return_address(0));
}
int param_get_charp(char *buffer, struct kernel_param *kp)
{
	return sprintf(buffer, "%s", *((char **)kp->arg));
}
int param_get_bool(char *buffer, struct kernel_param *kp)
{
	return sprintf(buffer, "%c", (*(int *)kp->arg) ? 'Y' : 'N');
}
int param_get_invbool(char *buffer, struct kernel_param *kp)
{
	return sprintf(buffer, "%c", (*(int *)kp->arg) ? 'N' : 'Y');
}
static inline int mk_pid(struct pid_namespace *pid_ns,
		struct pidmap *map, int off)
{
	return (map - pid_ns->pidmap)*BITS_PER_PAGE + off;
}
struct pid *find_vpid(int nr)
{
	return find_pid_ns(nr, current->nsproxy->pid_ns);
}
void detach_pid(struct task_struct *task, enum pid_type type)
{
	__change_pid(task, type, NULL);
}
struct task_struct *find_task_by_pid_type_ns(int type, int nr,
		struct pid_namespace *ns)
{
	return pid_task(find_pid_ns(nr, ns), type);
}
struct task_struct *find_task_by_vpid(pid_t vnr)
{
	return find_task_by_pid_type_ns(PIDTYPE_PID, vnr,
			current->nsproxy->pid_ns);
}
struct task_struct *find_task_by_pid_ns(pid_t nr, struct pid_namespace *ns)
{
	return find_task_by_pid_type_ns(PIDTYPE_PID, nr, ns);
}
pid_t pid_vnr(struct pid *pid)
{
	return pid_nr_ns(pid, current->nsproxy->pid_ns);
}
pid_t task_pid_nr_ns(struct task_struct *tsk, struct pid_namespace *ns)
{
	return pid_nr_ns(task_pid(tsk), ns);
}
pid_t task_tgid_nr_ns(struct task_struct *tsk, struct pid_namespace *ns)
{
	return pid_nr_ns(task_tgid(tsk), ns);
}
pid_t task_pgrp_nr_ns(struct task_struct *tsk, struct pid_namespace *ns)
{
	return pid_nr_ns(task_pgrp(tsk), ns);
}
pid_t task_session_nr_ns(struct task_struct *tsk, struct pid_namespace *ns)
{
	return pid_nr_ns(task_session(tsk), ns);
}
struct pid_namespace *task_active_pid_ns(struct task_struct *tsk)
{
	return ns_of_pid(task_pid(tsk));
}
static s32 max_compare(s32 v1, s32 v2)
{
	return max(v1, v2);
}
static s32 min_compare(s32 v1, s32 v2)
{
	return min(v1, v2);
}
int pm_qos_requirement(int pm_qos_class)
{
	return atomic_read(&pm_qos_array[pm_qos_class]->target_value);
}
static inline cputime_t prof_ticks(struct task_struct *p)
{
	return cputime_add(p->utime, p->stime);
}
static inline cputime_t virt_ticks(struct task_struct *p)
{
	return p->utime;
}
void posix_cpu_timers_exit(struct task_struct *tsk)
{
	cleanup_timers(tsk->cpu_timers,
		       tsk->utime, tsk->stime, tsk->se.sum_exec_runtime);
}
static int process_cpu_clock_getres(const clockid_t which_clock,
				    struct timespec *tp)
{
	return posix_cpu_clock_getres(PROCESS_CLOCK, tp);
}
static int process_cpu_clock_get(const clockid_t which_clock,
				 struct timespec *tp)
{
	return posix_cpu_clock_get(PROCESS_CLOCK, tp);
}
static int process_cpu_nsleep(const clockid_t which_clock, int flags,
			      struct timespec *rqtp,
			      struct timespec __user *rmtp)
{
	return posix_cpu_nsleep(PROCESS_CLOCK, flags, rqtp, rmtp);
}
static long process_cpu_nsleep_restart(struct restart_block *restart_block)
{
	return -EINVAL;
}
static int thread_cpu_clock_getres(const clockid_t which_clock,
				   struct timespec *tp)
{
	return posix_cpu_clock_getres(THREAD_CLOCK, tp);
}
static int thread_cpu_clock_get(const clockid_t which_clock,
				struct timespec *tp)
{
	return posix_cpu_clock_get(THREAD_CLOCK, tp);
}
static int thread_cpu_nsleep(const clockid_t which_clock, int flags,
			      struct timespec *rqtp, struct timespec __user *rmtp)
{
	return -EINVAL;
}
static long thread_cpu_nsleep_restart(struct restart_block *restart_block)
{
	return -EINVAL;
}
static inline void unlock_timer(struct k_itimer *timr, unsigned long flags)
{
	spin_unlock_irqrestore(&timr->it_lock, flags);
}
static inline int common_clock_set(const clockid_t which_clock,
				   struct timespec *tp)
{
	return do_sys_settimeofday(tp, NULL);
}
static int no_timer_create(struct k_itimer *new_timer)
{
	return -EOPNOTSUPP;
}
static inline int timer_delete_hook(struct k_itimer *timer)
{
	return CLOCK_DISPATCH(timer->it_clock, timer_del, (timer));
}
int do_posix_clock_nosettime(const clockid_t clockid, struct timespec *tp)
{
	return -EINVAL;
}
int do_posix_clock_nonanosleep(const clockid_t clock, int flags,
			       struct timespec *t, struct timespec __user *r)
{
#ifndef ENOTSUP
	return -EOPNOTSUPP;	/* aka ENOTSUP in userland for POSIX */
}
static int common_nsleep(const clockid_t which_clock, int flags,
			 struct timespec *tsave, struct timespec __user *rmtp)
{
	return hrtimer_nanosleep(tsave, rmtp, flags & TIMER_ABSTIME ?
				 HRTIMER_MODE_ABS : HRTIMER_MODE_REL,
				 which_clock);
}
static int common_nsleep_restart(struct restart_block *restart_block)
{
	return hrtimer_nanosleep_restart(restart_block);
}
bool system_entering_hibernation(void)
{
	return entering_platform_hibernation;
}
static int hibernation_testmode(int mode) { return 0; }
static int hibernation_test(int level) { return 0; }
static int platform_begin(int platform_mode)
{
	return (platform_mode && hibernation_ops) ?
		hibernation_ops->begin() : 0;
}
static int platform_pre_snapshot(int platform_mode)
{
	return (platform_mode && hibernation_ops) ?
		hibernation_ops->pre_snapshot() : 0;
}
static int platform_pre_restore(int platform_mode)
{
	return (platform_mode && hibernation_ops) ?
		hibernation_ops->pre_restore() : 0;
}
static ssize_t resume_show(struct kobject *kobj, struct kobj_attribute *attr,
			   char *buf)
{
	return sprintf(buf,"%d:%d\n", MAJOR(swsusp_resume_device),
		       MINOR(swsusp_resume_device));
}
static ssize_t image_size_show(struct kobject *kobj, struct kobj_attribute *attr,
			       char *buf)
{
	return sprintf(buf, "%lu\n", image_size);
}
static int __init pm_disk_init(void)
{
	return sysfs_create_group(power_kobj, &attr_group);
}
int register_pm_notifier(struct notifier_block *nb)
{
	return blocking_notifier_chain_register(&pm_chain_head, nb);
}
int unregister_pm_notifier(struct notifier_block *nb)
{
	return blocking_notifier_chain_unregister(&pm_chain_head, nb);
}
int pm_notifier_call_chain(unsigned long val)
{
	return (blocking_notifier_call_chain(&pm_chain_head, val, NULL)
			== NOTIFY_BAD) ? -EINVAL : 0;
}
static void suspend_test_start(void)
{
	suspend_test_start_time = jiffies;
}
int suspend_valid_only_mem(suspend_state_t state)
{
	return state == PM_SUSPEND_MEM;
}
void __attribute__ ((weak)) arch_suspend_disable_irqs(void)
{
	local_irq_disable();
}
void __attribute__ ((weak)) arch_suspend_enable_irqs(void)
{
	local_irq_enable();
}
static ssize_t pm_trace_show(struct kobject *kobj, struct kobj_attribute *attr,
			     char *buf)
{
	return sprintf(buf, "%d\n", pm_trace_enabled);
}
static void do_poweroff(struct work_struct *dummy)
{
	kernel_power_off();
}
static void handle_poweroff(int key, struct tty_struct *tty)
{
	schedule_work_on(cpumask_first(cpu_online_mask), &poweroff_work);
}
unsigned long get_safe_page(gfp_t gfp_mask)
{
	return (unsigned long)get_image_page(gfp_mask, PG_SAFE);
}
static inline unsigned long bm_block_bits(struct bm_block *bb)
{
	return bb->end_pfn - bb->start_pfn;
}
static int swsusp_page_is_free(struct page *page)
{
	return free_pages_map ?
		memory_bm_test_bit(free_pages_map, page_to_pfn(page)) : 0;
}
int swsusp_page_is_forbidden(struct page *page)
{
	return forbidden_pages_map ?
		memory_bm_test_bit(forbidden_pages_map, page_to_pfn(page)) : 0;
}
static inline void *saveable_highmem_page(struct zone *z, unsigned long p)
{
	return NULL;
}
static inline struct page *
page_is_saveable(struct zone *zone, unsigned long pfn)
{
	return is_highmem(zone) ?
		saveable_highmem_page(zone, pfn) : saveable_page(zone, pfn);
}
static inline void copy_data_page(unsigned long dst_pfn, unsigned long src_pfn)
{
	safe_copy_page(page_address(pfn_to_page(dst_pfn)),
				pfn_to_page(src_pfn));
}
static unsigned int
count_pages_for_highmem(unsigned int nr_highmem) { return 0; }
static inline int get_highmem_buffer(int safe_needed) { return 0; }
static inline unsigned int
alloc_highmem_image_pages(struct memory_bitmap *bm, unsigned int n) { return 0; }
unsigned long snapshot_get_image_size(void)
{
	return nr_copy_pages + nr_meta_pages + 1;
}
static inline int last_highmem_page_copied(void)
{
	return !last_highmem_page;
}
static inline int get_safe_write_buffer(void) { return 0; }
static unsigned int
count_highmem_image_pages(struct memory_bitmap *bm) { return 0; }
static inline int
prepare_highmem_image(struct memory_bitmap *bm, unsigned int *nr_highmem_p)
{
	return 0;
}
static inline void *
get_highmem_page_buffer(struct page *page, struct chain_allocator *ca)
{
	return ERR_PTR(-EINVAL);
}
static inline int last_highmem_page_copied(void) { return 1; }
int snapshot_image_loaded(struct snapshot_handle *handle)
{
	return !(!nr_copy_pages || !last_highmem_page_copied() ||
			handle->cur <= nr_meta_pages + nr_copy_pages);
}
static int bio_read_page(pgoff_t page_off, void *addr, struct bio **bio_chain)
{
	return submit(READ, page_off, virt_to_page(addr), bio_chain);
}
static int bio_write_page(pgoff_t page_off, void *addr, struct bio **bio_chain)
{
	return submit(WRITE, page_off, virt_to_page(addr), bio_chain);
}
static int flush_swap_writer(struct swap_map_handle *handle)
{
	if (handle->cur && handle->cur_swap)
		return write_page(handle->cur, handle->cur_swap, NULL);
	else
		return -EINVAL;
}
int swsusp_swap_in_use(void)
{
	return (swsusp_extents.rb_node != NULL);
}

static int __init snapshot_device_init(void)
{
	return misc_register(&snapshot_device);
}
static inline int can_use_console(unsigned int cpu)
{
	return cpu_online(cpu) || have_callable_console();
}
int add_preferred_console(char *name, int idx, char *options)
{
	return __add_preferred_console(name, idx, options, NULL);
}
int is_console_locked(void)
{
	return console_locked;
}
int printk_needs_cpu(int cpu)
{
	return per_cpu(printk_pending, cpu);
}
void console_print(const char *s)
{
	printk(KERN_EMERG "%s", s);
}
int printk_ratelimit(void)
{
	return __ratelimit(&printk_ratelimit_state);
}
void profile_task_exit(struct task_struct *task)
{
	blocking_notifier_call_chain(&task_exit_notifier, 0, task);
}
void profile_munmap(unsigned long addr)
{
	blocking_notifier_call_chain(&munmap_notifier, 0, (void *)addr);
}
int task_handoff_register(struct notifier_block *n)
{
	return atomic_notifier_chain_register(&task_free_notifier, n);
}
int task_handoff_unregister(struct notifier_block *n)
{
	return atomic_notifier_chain_unregister(&task_free_notifier, n);
}
void ptrace_fork(struct task_struct *child, unsigned long clone_flags)
{
	arch_ptrace_fork(child, clone_flags);
}
static inline void force_quiescent_state(struct rcu_data *rdp,
			struct rcu_ctrlblk *rcp)
{
	set_need_resched();
}
long rcu_batches_completed(void)
{
	return rcu_ctrlblk.completed;
}
long rcu_batches_completed_bh(void)
{
	return rcu_bh_ctrlblk.completed;
}
static inline void raise_rcu_softirq(void)
{
	raise_softirq(RCU_SOFTIRQ);
}
int rcu_pending(int cpu)
{
	return __rcu_pending(&rcu_ctrlblk, &per_cpu(rcu_data, cpu)) ||
		__rcu_pending(&rcu_bh_ctrlblk, &per_cpu(rcu_bh_data, cpu));
}
void rcu_barrier(void)
{
	_rcu_barrier(RCU_BARRIER_STD);
}
void rcu_barrier_bh(void)
{
	_rcu_barrier(RCU_BARRIER_BH);
}
void rcu_barrier_sched(void)
{
	_rcu_barrier(RCU_BARRIER_SCHED);
}
void __init rcu_init(void)
{
	__rcu_init();
}
long rcu_batches_completed(void)
{
	return rcu_ctrlblk.completed;
}
void rcu_nmi_enter(void)
{
	rcu_irq_enter();
}
void rcu_nmi_exit(void)
{
	rcu_irq_exit();
}
long *rcupreempt_flipctr(int cpu)
{
	return &RCU_DATA_CPU(cpu)->rcu_flipctr[0];
}
int rcupreempt_flip_flag(int cpu)
{
	return per_cpu(rcu_flip_flag, cpu);
}
int rcupreempt_mb_flag(int cpu)
{
	return per_cpu(rcu_mb_flag, cpu);
}
char *rcupreempt_try_flip_state_name(void)
{
	return rcu_try_flip_state_names[rcu_ctrlblk.rcu_try_flip_state];
}
void rcupreempt_trace_try_flip_1(struct rcupreempt_trace *trace)
{
	atomic_inc(&trace->rcu_try_flip_1);
}
void rcupreempt_trace_try_flip_e1(struct rcupreempt_trace *trace)
{
	atomic_inc(&trace->rcu_try_flip_e1);
}
void rcupreempt_trace_try_flip_i1(struct rcupreempt_trace *trace)
{
	trace->rcu_try_flip_i1++;
}
void rcupreempt_trace_try_flip_ie1(struct rcupreempt_trace *trace)
{
	trace->rcu_try_flip_ie1++;
}
void rcupreempt_trace_try_flip_g1(struct rcupreempt_trace *trace)
{
	trace->rcu_try_flip_g1++;
}
void rcupreempt_trace_try_flip_a1(struct rcupreempt_trace *trace)
{
	trace->rcu_try_flip_a1++;
}
void rcupreempt_trace_try_flip_ae1(struct rcupreempt_trace *trace)
{
	trace->rcu_try_flip_ae1++;
}
void rcupreempt_trace_try_flip_a2(struct rcupreempt_trace *trace)
{
	trace->rcu_try_flip_a2++;
}
void rcupreempt_trace_try_flip_z1(struct rcupreempt_trace *trace)
{
	trace->rcu_try_flip_z1++;
}
void rcupreempt_trace_try_flip_ze1(struct rcupreempt_trace *trace)
{
	trace->rcu_try_flip_ze1++;
}
void rcupreempt_trace_try_flip_z2(struct rcupreempt_trace *trace)
{
	trace->rcu_try_flip_z2++;
}
void rcupreempt_trace_try_flip_m1(struct rcupreempt_trace *trace)
{
	trace->rcu_try_flip_m1++;
}
void rcupreempt_trace_try_flip_me1(struct rcupreempt_trace *trace)
{
	trace->rcu_try_flip_me1++;
}
void rcupreempt_trace_try_flip_m2(struct rcupreempt_trace *trace)
{
	trace->rcu_try_flip_m2++;
}
void rcupreempt_trace_check_callbacks(struct rcupreempt_trace *trace)
{
	trace->rcu_check_callbacks++;
}
void rcupreempt_trace_invoke(struct rcupreempt_trace *trace)
{
	atomic_inc(&trace->done_invoked);
}
static void rcu_torture_read_unlock(int idx) __releases(RCU)
{
	rcu_read_unlock();
}
static int rcu_torture_completed(void)
{
	return rcu_batches_completed();
}
static void rcu_torture_deferred_free(struct rcu_torture *p)
{
	call_rcu(&p->rtort_rcu, rcu_torture_cb);
}
static void rcu_sync_torture_init(void)
{
	INIT_LIST_HEAD(&rcu_torture_removed);
}
static void rcu_bh_torture_read_unlock(int idx) __releases(RCU_BH)
{
	rcu_read_unlock_bh();
}
static int rcu_bh_torture_completed(void)
{
	return rcu_batches_completed_bh();
}
static void rcu_bh_torture_deferred_free(struct rcu_torture *p)
{
	call_rcu_bh(&p->rtort_rcu, rcu_torture_cb);
}
static int srcu_torture_read_lock(void) __acquires(&srcu_ctl)
{
	return srcu_read_lock(&srcu_ctl);
}
static void srcu_torture_read_unlock(int idx) __releases(&srcu_ctl)
{
	srcu_read_unlock(&srcu_ctl, idx);
}
static int srcu_torture_completed(void)
{
	return srcu_batches_completed(&srcu_ctl);
}
static void srcu_torture_synchronize(void)
{
	synchronize_srcu(&srcu_ctl);
}
static void sched_torture_read_unlock(int idx)
{
	preempt_enable();
}
static int sched_torture_completed(void)
{
	return 0;
}
static void rcu_sched_torture_deferred_free(struct rcu_torture *p)
{
	call_rcu_sched(&p->rtort_rcu, rcu_torture_cb);
}
static void sched_torture_synchronize(void)
{
	synchronize_sched();
}
static inline void
rcu_torture_print_module_parms(char *tag)
{
	printk(KERN_ALERT "%s" TORTURE_FLAG
		"--- %s: nreaders=%d nfakewriters=%d "
		"stat_interval=%d verbose=%d test_no_idle_hz=%d "
		"shuffle_interval=%d stutter=%d irqreader=%d\n",
		torture_type, tag, nrealreaders, nfakewriters,
		stat_interval, verbose, test_no_idle_hz, shuffle_interval,
		stutter, irqreader);
}
long rcu_batches_completed(void)
{
	return rcu_state.completed;
}
long rcu_batches_completed_bh(void)
{
	return rcu_bh_state.completed;
}
static int
cpu_has_callbacks_ready_to_invoke(struct rcu_data *rdp)
{
	return &rdp->nxtlist != rdp->nxttail[RCU_DONE_TAIL];
}
static int
cpu_needs_another_gp(struct rcu_state *rsp, struct rcu_data *rdp)
{
	return *rdp->nxttail[RCU_DONE_TAIL] &&
	       ACCESS_ONCE(rsp->completed) == ACCESS_ONCE(rsp->gpnum);
}
static struct rcu_node *rcu_get_root(struct rcu_state *rsp)
{
	return &rsp->node[0];
}
static void dyntick_record_completed(struct rcu_state *rsp, long comp)
{
	rsp->dynticks_completed = comp;
}
static long dyntick_recall_completed(struct rcu_state *rsp)
{
	return rsp->dynticks_completed;
}
static long dyntick_recall_completed(struct rcu_state *rsp)
{
	return rsp->completed;
}
static int dyntick_save_progress_counter(struct rcu_data *rdp)
{
	return 0;
}
static int rcu_implicit_dynticks_qs(struct rcu_data *rdp)
{
	return rcu_implicit_offline_qs(rdp);
}
static void force_quiescent_state(struct rcu_state *rsp, int relaxed)
{
	set_need_resched();
}
void call_rcu(struct rcu_head *head, void (*func)(struct rcu_head *rcu))
{
	__call_rcu(head, func, &rcu_state);
}
void call_rcu_bh(struct rcu_head *head, void (*func)(struct rcu_head *rcu))
{
	__call_rcu(head, func, &rcu_bh_state);
}
int rcu_pending(int cpu)
{
	return __rcu_pending(&rcu_state, &per_cpu(rcu_data, cpu)) ||
	       __rcu_pending(&rcu_bh_state, &per_cpu(rcu_bh_data, cpu));
}
int rcu_needs_cpu(int cpu)
{
	return per_cpu(rcu_data, cpu).nxtlist ||
	       per_cpu(rcu_bh_data, cpu).nxtlist;
}
static int rcudata_open(struct inode *inode, struct file *file)
{
	return single_open(file, show_rcudata, NULL);
}
static int rcudata_csv_open(struct inode *inode, struct file *file)
{
	return single_open(file, show_rcudata_csv, NULL);
}
static int rcuhier_open(struct inode *inode, struct file *file)
{
	return single_open(file, show_rcuhier, NULL);
}
static int rcugp_open(struct inode *inode, struct file *file)
{
	return single_open(file, show_rcugp, NULL);
}
static int relay_buf_empty(struct rchan_buf *buf)
{
	return (buf->subbufs_produced - buf->subbufs_consumed) ? 0 : 1;
}
static struct dentry *create_buf_file_default_callback(const char *filename,
						       struct dentry *parent,
						       int mode,
						       struct rchan_buf *buf,
						       int *is_global)
{
	return NULL;
}
static int remove_buf_file_default_callback(struct dentry *dentry)
{
	return -EINVAL;
}
u64 res_counter_read_u64(struct res_counter *counter, int member)
{
	return *res_counter_member(counter, member);
}
static void r_stop(struct seq_file *m, void *v)
{
	read_unlock(&resource_lock);
}
void debug_rt_mutex_unlock(struct rt_mutex *lock)
{
	TRACE_WARN_ON_LOCKED(rt_mutex_owner(lock) != current);
}
void debug_rt_mutex_proxy_unlock(struct rt_mutex *lock)
{
	TRACE_WARN_ON_LOCKED(!rt_mutex_owner(lock));
}
static inline void clear_rt_mutex_waiters(struct rt_mutex *lock)
{
	lock->owner = (struct task_struct *)
			((unsigned long)lock->owner & ~RT_MUTEX_HAS_WAITERS);
}
static inline void mark_rt_mutex_waiters(struct rt_mutex *lock)
{
	lock->owner = (struct task_struct *)
			((unsigned long)lock->owner | RT_MUTEX_HAS_WAITERS);
}
int __sched rt_mutex_trylock(struct rt_mutex *lock)
{
	return rt_mutex_fasttrylock(lock, rt_mutex_slowtrylock);
}
void __sched rt_mutex_unlock(struct rt_mutex *lock)
{
	rt_mutex_fastunlock(lock, rt_mutex_slowunlock);
}
void downgrade_write(struct rw_semaphore *sem)
{
	__downgrade_write(sem);
}
void up_read_non_owner(struct rw_semaphore *sem)
{
	__up_read(sem);
}
static inline u32 sg_div_cpu_power(const struct sched_group *sg, u32 load)
{
	return reciprocal_divide(load, sg->reciprocal_cpu_power);
}
static inline int task_has_rt_policy(struct task_struct *p)
{
	return rt_policy(p->policy);
}
static inline int rt_bandwidth_enabled(void)
{
	return sysctl_sched_rt_runtime >= 0;
}
static void destroy_rt_bandwidth(struct rt_bandwidth *rt_b)
{
	hrtimer_cancel(&rt_b->rt_period_timer);
}
void set_tg_uid(struct user_struct *user)
{
	user->tg->uid = user->uid;
}
static inline struct task_group *task_group(struct task_struct *p)
{
	return NULL;
}
static inline void check_preempt_curr(struct rq *rq, struct task_struct *p, int sync)
{
	rq->curr->sched_class->check_preempt_curr(rq, p, sync);
}
static inline int cpu_of(struct rq *rq)
{
	return rq->cpu;
}
static inline void update_rq_clock(struct rq *rq)
{
	rq->clock = sched_clock_cpu(cpu_of(rq));
}
static int sched_feat_open(struct inode *inode, struct file *filp)
{
	return single_open(filp, sched_feat_show, NULL);
}
static inline u64 global_rt_period(void)
{
	return (u64)sysctl_sched_rt_period * NSEC_PER_USEC;
}
static inline int task_current(struct rq *rq, struct task_struct *p)
{
	return rq->curr == p;
}
static inline int task_running(struct rq *rq, struct task_struct *p)
{
	return task_current(rq, p);
}
static inline int task_running(struct rq *rq, struct task_struct *p)
{
	return p->oncpu;
}
static void __task_rq_unlock(struct rq *rq)
{
	spin_unlock(&rq->lock);
}
static inline void task_rq_unlock(struct rq *rq, unsigned long *flags)
{
	spin_unlock_irqrestore(&rq->lock, *flags);
}
static __init void init_hrtick(void)
{
	hotcpu_notifier(hotplug_hrtick, 0);
}
static void hrtick_start(struct rq *rq, u64 delay)
{
	hrtimer_start(&rq->hrtick_timer, ns_to_ktime(delay), HRTIMER_MODE_REL);
}
static inline void inc_cpu_load(struct rq *rq, unsigned long load)
{
	update_load_add(&rq->load, load);
}
static inline void dec_cpu_load(struct rq *rq, unsigned long load)
{
	update_load_sub(&rq->load, load);
}
static int tg_nop(struct task_group *tg, void *data)
{
	return 0;
}
static void update_h_load(long cpu)
{
	walk_tg_tree(tg_load_down, tg_nop, (void *)cpu);
}
static void cfs_rq_set_shares(struct cfs_rq *cfs_rq, unsigned long shares)
{
	cfs_rq->shares = shares;
}
static void inc_nr_running(struct rq *rq)
{
	rq->nr_running++;
}
static void dec_nr_running(struct rq *rq)
{
	rq->nr_running--;
}
static inline int __normal_prio(struct task_struct *p)
{
	return p->static_prio;
}
inline int task_curr(const struct task_struct *p)
{
	return cpu_curr(task_cpu(p)) == p;
}
static unsigned long weighted_cpuload(const int cpu)
{
	return cpu_rq(cpu)->load.weight;
}
int wake_up_process(struct task_struct *p)
{
	return try_to_wake_up(p, TASK_ALL, 0);
}
int wake_up_state(struct task_struct *p, unsigned int state)
{
	return try_to_wake_up(p, state, 0);
}
void preempt_notifier_register(struct preempt_notifier *notifier)
{
	hlist_add_head(&notifier->link, &current->preempt_notifiers);
}
void preempt_notifier_unregister(struct preempt_notifier *notifier)
{
	hlist_del(&notifier->link);
}
void account_steal_ticks(unsigned long ticks)
{
	account_steal_time(jiffies_to_cputime(ticks));
}
void account_idle_ticks(unsigned long ticks)
{
	account_idle_time(jiffies_to_cputime(ticks));
}
cputime_t task_utime(struct task_struct *p)
{
	return p->utime;
}
cputime_t task_stime(struct task_struct *p)
{
	return p->stime;
}
inline cputime_t task_gtime(struct task_struct *p)
{
	return p->gtime;
}
int default_wake_function(wait_queue_t *curr, unsigned mode, int sync,
			  void *key)
{
	return try_to_wake_up(curr->private, mode, sync);
}
void __wake_up_locked(wait_queue_head_t *q, unsigned int mode)
{
	__wake_up_common(q, mode, 1, 0, NULL);
}
void __sched wait_for_completion(struct completion *x)
{
	wait_for_common(x, MAX_SCHEDULE_TIMEOUT, TASK_UNINTERRUPTIBLE);
}
unsigned long __sched
wait_for_completion_timeout(struct completion *x, unsigned long timeout)
{
	return wait_for_common(x, timeout, TASK_UNINTERRUPTIBLE);
}
unsigned long __sched
wait_for_completion_interruptible_timeout(struct completion *x,
					  unsigned long timeout)
{
	return wait_for_common(x, timeout, TASK_INTERRUPTIBLE);
}
void __sched interruptible_sleep_on(wait_queue_head_t *q)
{
	sleep_on_common(q, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);
}
long __sched
interruptible_sleep_on_timeout(wait_queue_head_t *q, long timeout)
{
	return sleep_on_common(q, TASK_INTERRUPTIBLE, timeout);
}
void __sched sleep_on(wait_queue_head_t *q)
{
	sleep_on_common(q, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);
}
long __sched sleep_on_timeout(wait_queue_head_t *q, long timeout)
{
	return sleep_on_common(q, TASK_UNINTERRUPTIBLE, timeout);
}
int task_prio(const struct task_struct *p)
{
	return p->prio - MAX_RT_PRIO;
}
int task_nice(const struct task_struct *p)
{
	return TASK_NICE(p);
}
int idle_cpu(int cpu)
{
	return cpu_curr(cpu) == cpu_rq(cpu)->idle;
}
struct task_struct *idle_task(int cpu)
{
	return cpu_rq(cpu)->idle;
}
static struct task_struct *find_process_by_pid(pid_t pid)
{
	return pid ? find_task_by_vpid(pid) : current;
}
int sched_setscheduler(struct task_struct *p, int policy,
		       struct sched_param *param)
{
	return __sched_setscheduler(p, policy, param, true);
}
int sched_setscheduler_nocheck(struct task_struct *p, int policy,
			       struct sched_param *param)
{
	return __sched_setscheduler(p, policy, param, false);
}
void __cpuinit init_idle_bootup_task(struct task_struct *idle)
{
	idle->sched_class = &idle_sched_class;
}
static int build_sched_domains(const struct cpumask *cpu_map)
{
	return __build_sched_domains(cpu_map, NULL);
}
int __attribute__((weak)) arch_update_cpu_topology(void)
{
	return 0;
}
static void arch_destroy_sched_domains(const struct cpumask *cpu_map,
				       struct cpumask *tmpmask)
{
	free_sched_groups(cpu_map, tmpmask);
}
static ssize_t sched_mc_power_savings_show(struct sysdev_class *class,
					   char *page)
{
	return sprintf(page, "%u\n", sched_mc_power_savings);
}
static ssize_t sched_mc_power_savings_store(struct sysdev_class *class,
					    const char *buf, size_t count)
{
	return sched_power_savings_store(buf, count, 0);
}
static ssize_t sched_smt_power_savings_show(struct sysdev_class *dev,
					    char *page)
{
	return sprintf(page, "%u\n", sched_smt_power_savings);
}
static ssize_t sched_smt_power_savings_store(struct sysdev_class *dev,
					     const char *buf, size_t count)
{
	return sched_power_savings_store(buf, count, 1);
}
void __init sched_init_smp(void)
{
	sched_init_granularity();
}
int in_sched_functions(unsigned long addr)
{
	return in_lock_functions(addr) ||
		(addr >= (unsigned long)__sched_text_start
		&& addr < (unsigned long)__sched_text_end);
}
struct task_struct *curr_task(int cpu)
{
	return cpu_curr(cpu);
}
void set_curr_task(int cpu, struct task_struct *p)
{
	cpu_curr(cpu) = p;
}
static inline void register_fair_sched_group(struct task_group *tg, int cpu)
{
	list_add_rcu(&tg->cfs_rq[cpu]->leaf_cfs_rq_list,
			&cpu_rq(cpu)->leaf_cfs_rq_list);
}
static inline void unregister_fair_sched_group(struct task_group *tg, int cpu)
{
	list_del_rcu(&tg->cfs_rq[cpu]->leaf_cfs_rq_list);
}
static inline
int alloc_fair_sched_group(struct task_group *tg, struct task_group *parent)
{
	return 1;
}
static inline void register_rt_sched_group(struct task_group *tg, int cpu)
{
	list_add_rcu(&tg->rt_rq[cpu]->leaf_rt_rq_list,
			&cpu_rq(cpu)->leaf_rt_rq_list);
}
static inline void unregister_rt_sched_group(struct task_group *tg, int cpu)
{
	list_del_rcu(&tg->rt_rq[cpu]->leaf_rt_rq_list);
}
static inline
int alloc_rt_sched_group(struct task_group *tg, struct task_group *parent)
{
	return 1;
}
static void free_sched_group_rcu(struct rcu_head *rhp)
{
	free_sched_group(container_of(rhp, struct task_group, rcu));
}
unsigned long sched_group_shares(struct task_group *tg)
{
	return tg->shares;
}
static inline struct task_group *cgroup_tg(struct cgroup *cgrp)
{
	return container_of(cgroup_subsys_state(cgrp, cpu_cgroup_subsys_id),
			    struct task_group, css);
}
static void
cpu_cgroup_attach(struct cgroup_subsys *ss, struct cgroup *cgrp,
			struct cgroup *old_cont, struct task_struct *tsk)
{
	sched_move_task(tsk);
}
static int cpu_shares_write_u64(struct cgroup *cgrp, struct cftype *cftype,
				u64 shareval)
{
	return sched_group_set_shares(cgroup_tg(cgrp), shareval);
}
static int cpu_rt_runtime_write(struct cgroup *cgrp, struct cftype *cft,
				s64 val)
{
	return sched_group_set_rt_runtime(cgroup_tg(cgrp), val);
}
static s64 cpu_rt_runtime_read(struct cgroup *cgrp, struct cftype *cft)
{
	return sched_group_rt_runtime(cgroup_tg(cgrp));
}
static int cpu_rt_period_write_uint(struct cgroup *cgrp, struct cftype *cftype,
		u64 rt_period_us)
{
	return sched_group_set_rt_period(cgroup_tg(cgrp), rt_period_us);
}
static u64 cpu_rt_period_read_uint(struct cgroup *cgrp, struct cftype *cft)
{
	return sched_group_rt_period(cgroup_tg(cgrp));
}
static int cpu_cgroup_populate(struct cgroup_subsys *ss, struct cgroup *cont)
{
	return cgroup_add_files(cont, ss, cpu_files, ARRAY_SIZE(cpu_files));
}
static inline struct cpuacct *cgroup_ca(struct cgroup *cgrp)
{
	return container_of(cgroup_subsys_state(cgrp, cpuacct_subsys_id),
			    struct cpuacct, css);
}
static inline struct cpuacct *task_ca(struct task_struct *tsk)
{
	return container_of(task_subsys_state(tsk, cpuacct_subsys_id),
			    struct cpuacct, css);
}
static int cpuacct_populate(struct cgroup_subsys *ss, struct cgroup *cgrp)
{
	return cgroup_add_files(cgrp, ss, files, ARRAY_SIZE(files));
}
unsigned long long __attribute__((weak)) sched_clock(void)
{
	return (unsigned long long)jiffies * (NSEC_PER_SEC / HZ);
}
static inline struct sched_clock_data *this_scd(void)
{
	return &__get_cpu_var(sched_clock_data);
}
static inline struct sched_clock_data *cpu_sdc(int cpu)
{
	return &per_cpu(sched_clock_data, cpu);
}
static inline u64 wrap_min(u64 x, u64 y)
{
	return (s64)(x - y) < 0 ? x : y;
}
static inline u64 wrap_max(u64 x, u64 y)
{
	return (s64)(x - y) > 0 ? x : y;
}
void sched_clock_idle_sleep_event(void)
{
	sched_clock_cpu(smp_processor_id());
}
void sched_clock_init(void)
{
	sched_clock_running = 1;
}
static void sysrq_sched_debug_show(void)
{
	sched_debug_show(NULL, NULL);
}
static int sched_debug_open(struct inode *inode, struct file *filp)
{
	return single_open(filp, sched_debug_show, NULL);
}
static inline struct task_struct *task_of(struct sched_entity *se)
{
	return container_of(se, struct task_struct, se);
}
static inline struct rq *rq_of(struct cfs_rq *cfs_rq)
{
	return cfs_rq->rq;
}
static inline struct cfs_rq *task_cfs_rq(struct task_struct *p)
{
	return p->se.cfs_rq;
}
static inline struct cfs_rq *cfs_rq_of(struct sched_entity *se)
{
	return se->cfs_rq;
}
static inline struct cfs_rq *group_cfs_rq(struct sched_entity *grp)
{
	return grp->my_q;
}
static inline struct cfs_rq *cpu_cfs_rq(struct cfs_rq *cfs_rq, int this_cpu)
{
	return cfs_rq->tg->cfs_rq[this_cpu];
}
static inline struct sched_entity *parent_entity(struct sched_entity *se)
{
	return se->parent;
}
static inline struct rq *rq_of(struct cfs_rq *cfs_rq)
{
	return container_of(cfs_rq, struct rq, cfs);
}
static inline struct cfs_rq *task_cfs_rq(struct task_struct *p)
{
	return &task_rq(p)->cfs;
}
static inline struct cfs_rq *group_cfs_rq(struct sched_entity *grp)
{
	return NULL;
}
static inline struct cfs_rq *cpu_cfs_rq(struct cfs_rq *cfs_rq, int this_cpu)
{
	return &cpu_rq(this_cpu)->cfs;
}
static inline int
is_same_group(struct sched_entity *se, struct sched_entity *pse)
{
	return 1;
}
static inline struct sched_entity *parent_entity(struct sched_entity *se)
{
	return NULL;
}
static inline s64 entity_key(struct cfs_rq *cfs_rq, struct sched_entity *se)
{
	return se->vruntime - cfs_rq->min_vruntime;
}
static u64 sched_vslice(struct cfs_rq *cfs_rq, struct sched_entity *se)
{
	return calc_delta_fair(sched_slice(cfs_rq, se), se);
}
static inline void
update_stats_wait_start(struct cfs_rq *cfs_rq, struct sched_entity *se)
{
	schedstat_set(se->wait_start, rq_of(cfs_rq)->clock);
}
static inline void
update_stats_curr_start(struct cfs_rq *cfs_rq, struct sched_entity *se)
{
	se->exec_start = rq_of(cfs_rq)->clock;
}
static void
add_cfs_task_weight(struct cfs_rq *cfs_rq, unsigned long weight)
{
	cfs_rq->task_weight += weight;
}
static inline int wake_idle(int cpu, struct task_struct *p)
{
	return cpu;
}
static inline unsigned long effective_load(struct task_group *tg, int cpu,
		unsigned long wl, unsigned long wg)
{
	return wl;
}
static unsigned long
load_balance_fair(struct rq *this_rq, int this_cpu, struct rq *busiest,
		  unsigned long max_load_move,
		  struct sched_domain *sd, enum cpu_idle_type idle,
		  int *all_pinned, int *this_best_prio)
{
	return __load_balance_fair(this_rq, this_cpu, busiest,
			max_load_move, sd, idle, all_pinned,
			this_best_prio, &busiest->cfs);
}
static int select_task_rq_idle(struct task_struct *p, int sync)
{
	return task_cpu(p); /* IDLE tasks as never migrated */
}
static void check_preempt_curr_idle(struct rq *rq, struct task_struct *p, int sync)
{
	resched_task(rq->idle);
}
static unsigned long
load_balance_idle(struct rq *this_rq, int this_cpu, struct rq *busiest,
		  unsigned long max_load_move,
		  struct sched_domain *sd, enum cpu_idle_type idle,
		  int *all_pinned, int *this_best_prio)
{
	return 0;
}
static int
move_one_task_idle(struct rq *this_rq, int this_cpu, struct rq *busiest,
		   struct sched_domain *sd, enum cpu_idle_type idle)
{
	return 0;
}
static inline struct task_struct *rt_task_of(struct sched_rt_entity *rt_se)
{
	return container_of(rt_se, struct task_struct, rt);
}
static inline struct rq *rq_of_rt_rq(struct rt_rq *rt_rq)
{
	return rt_rq->rq;
}
static inline struct rt_rq *rt_rq_of_se(struct sched_rt_entity *rt_se)
{
	return rt_se->rt_rq;
}
static inline struct rq *rq_of_rt_rq(struct rt_rq *rt_rq)
{
	return container_of(rt_rq, struct rq, rt);
}
static inline int rt_overloaded(struct rq *rq)
{
	return atomic_read(&rq->rd->rto_count);
}
static void dequeue_pushable_task(struct rq *rq, struct task_struct *p)
{
	plist_del(&p->pushable_tasks, &rq->rt.pushable_tasks);
}
static inline int on_rt_rq(struct sched_rt_entity *rt_se)
{
	return !list_empty(&rt_se->run_list);
}
static inline u64 sched_rt_period(struct rt_rq *rt_rq)
{
	return ktime_to_ns(rt_rq->tg->rt_bandwidth.rt_period);
}
static inline struct rt_rq *group_rt_rq(struct sched_rt_entity *rt_se)
{
	return rt_se->my_q;
}
static inline int rt_rq_throttled(struct rt_rq *rt_rq)
{
	return rt_rq->rt_throttled && !rt_rq->rt_nr_boosted;
}
static inline const struct cpumask *sched_rt_period_mask(void)
{
	return cpu_rq(smp_processor_id())->rd->span;
}
static inline const struct cpumask *sched_rt_period_mask(void)
{
	return cpu_online_mask;
}
static inline
struct rt_rq *sched_rt_period_rt_rq(struct rt_bandwidth *rt_b, int cpu)
{
	return container_of(rt_b, struct task_group, rt_bandwidth)->rt_rq[cpu];
}
static inline struct rt_bandwidth *sched_rt_bandwidth(struct rt_rq *rt_rq)
{
	return &rt_rq->tg->rt_bandwidth;
}
static inline u64 sched_rt_runtime(struct rt_rq *rt_rq)
{
	return rt_rq->rt_runtime;
}
static inline u64 sched_rt_period(struct rt_rq *rt_rq)
{
	return ktime_to_ns(def_rt_bandwidth.rt_period);
}
static inline struct rt_rq *group_rt_rq(struct sched_rt_entity *rt_se)
{
	return NULL;
}
static inline int rt_rq_throttled(struct rt_rq *rt_rq)
{
	return rt_rq->rt_throttled;
}
static inline const struct cpumask *sched_rt_period_mask(void)
{
	return cpu_online_mask;
}
static inline
struct rt_rq *sched_rt_period_rt_rq(struct rt_bandwidth *rt_b, int cpu)
{
	return &cpu_rq(cpu)->rt;
}
static inline struct rt_bandwidth *sched_rt_bandwidth(struct rt_rq *rt_rq)
{
	return &def_rt_bandwidth;
}
static inline int balance_runtime(struct rt_rq *rt_rq)
{
	return 0;
}
static void
inc_rt_group(struct sched_rt_entity *rt_se, struct rt_rq *rt_rq)
{
	start_rt_bandwidth(&def_rt_bandwidth);
}
static void yield_task_rt(struct rq *rq)
{
	requeue_task_rt(rq, rq->curr, 0);
}
static inline int has_pushable_tasks(struct rq *rq)
{
	return !plist_head_empty(&rq->rt.pushable_tasks);
}
static int needs_post_schedule_rt(struct rq *rq)
{
	return has_pushable_tasks(rq);
}
static unsigned long
load_balance_rt(struct rq *this_rq, int this_cpu, struct rq *busiest,
		unsigned long max_load_move,
		struct sched_domain *sd, enum cpu_idle_type idle,
		int *all_pinned, int *this_best_prio)
{
	return 0;
}
static int
move_one_task_rt(struct rq *this_rq, int this_cpu, struct rq *busiest,
		 struct sched_domain *sd, enum cpu_idle_type idle)
{
	return 0;
}
long prctl_get_seccomp(void)
{
	return current->seccomp.mode;
}
static noinline void __sched __down(struct semaphore *sem)
{
	__down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);
}
static noinline int __sched __down_interruptible(struct semaphore *sem)
{
	return __down_common(sem, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);
}
static noinline int __sched __down_killable(struct semaphore *sem)
{
	return __down_common(sem, TASK_KILLABLE, MAX_SCHEDULE_TIMEOUT);
}
static noinline int __sched __down_timeout(struct semaphore *sem, long jiffies)
{
	return __down_common(sem, TASK_UNINTERRUPTIBLE, jiffies);
}
static void __user *sig_handler(struct task_struct *t, int sig)
{
	return t->sighand->action[sig - 1].sa.sa_handler;
}
static int sig_handler_ignored(void __user *handler, int sig)
{
	return handler == SIG_IGN ||
		(handler == SIG_DFL && sig_kernel_ignore(sig));
}
static inline int legacy_queue(struct sigpending *signals, int sig)
{
	return (sig < SIGRTMIN) && sigismember(&signals->signal, sig);
}
int
__group_send_sig_info(int sig, struct siginfo *info, struct task_struct *p)
{
	return send_signal(sig, info, p, 1);
}
static int
specific_send_sig_info(int sig, struct siginfo *info, struct task_struct *t)
{
	return send_signal(sig, info, t, 0);
}
void
force_sig_specific(int sig, struct task_struct *t)
{
	force_sig_info(sig, SEND_SIG_FORCED, t);
}
int __fatal_signal_pending(struct task_struct *tsk)
{
	return sigismember(&tsk->pending.signal, SIGKILL);
}
int
send_sig(int sig, struct task_struct *p, int priv)
{
	return send_sig_info(sig, __si_special(priv), p);
}
void
force_sig(int sig, struct task_struct *p)
{
	force_sig_info(sig, SEND_SIG_PRIV, p);
}
int kill_pid(struct pid *pid, int sig, int priv)
{
	return kill_pid_info(sig, __si_special(priv), pid);
}
static inline void __wake_up_parent(struct task_struct *p,
				    struct task_struct *parent)
{
	wake_up_interruptible_sync(&parent->signal->wait_chldexit);
}
static int sigkill_pending(struct task_struct *tsk)
{
	return	sigismember(&tsk->pending.signal, SIGKILL) ||
		sigismember(&tsk->signal->shared_pending.signal, SIGKILL);
}
long do_no_restart_syscall(struct restart_block *param)
{
	return -EINTR;
}
__attribute__((weak)) const char *arch_vma_name(struct vm_area_struct *vma)
{
	return NULL;
}
void __init signals_init(void)
{
	sigqueue_cachep = KMEM_CACHE(sigqueue, SLAB_PANIC);
}
static inline bool slow_work_available(int vsmax)
{
	return !list_empty(&slow_work_queue) ||
		(!list_empty(&vslow_work_queue) &&
		 atomic_read(&vslow_work_executing_count) < vsmax);
}
static int slow_work_new_thread_get_ref(struct slow_work *work)
{
	return 0;
}
static void slow_work_oom_timeout(unsigned long data)
{
	slow_work_may_not_start_new_thread = false;
}
void ipi_call_lock(void)
{
	spin_lock(&call_function_lock);
}
void ipi_call_unlock(void)
{
	spin_unlock(&call_function_lock);
}
void ipi_call_lock_irq(void)
{
	spin_lock_irq(&call_function_lock);
}
void ipi_call_unlock_irq(void)
{
	spin_unlock_irq(&call_function_lock);
}
void local_bh_disable(void)
{
	__local_bh_disable((unsigned long)__builtin_return_address(0));
}
void local_bh_enable(void)
{
	_local_bh_enable_ip((unsigned long)__builtin_return_address(0));
}
void local_bh_enable_ip(unsigned long ip)
{
	_local_bh_enable_ip(ip);
}
void open_softirq(int nr, void (*action)(struct softirq_action *))
{
	softirq_vec[nr].action = action;
}
static int __try_remote_softirq(struct call_single_data *cp, int cpu, int softirq)
{
	return 1;
}
int __init __weak early_irq_init(void)
{
	return 0;
}
int __init __weak arch_probe_nr_irqs(void)
{
	return 0;
}
int __init __weak arch_early_irq_init(void)
{
	return 0;
}
int __weak arch_init_chip_data(struct irq_desc *desc, int cpu)
{
	return 0;
}
static unsigned long get_timestamp(int this_cpu)
{
	return cpu_clock(this_cpu) >> 30LL;  /* 2^30 ~= 10^9 */
}
void touch_softlockup_watchdog(void)
{
	__raw_get_cpu_var(touch_timestamp) = 0;
}
static int srcu_readers_active(struct srcu_struct *sp)
{
	return srcu_readers_active_idx(sp, 0) + srcu_readers_active_idx(sp, 1);
}
long srcu_batches_completed(struct srcu_struct *sp)
{
	return sp->completed;
}
__weak void
save_stack_trace_tsk(struct task_struct *tsk, struct stack_trace *trace)
{
	WARN_ONCE(1, KERN_INFO "save_stack_trace_tsk() not implemented yet.\n");
}
static int chill(void *unused)
{
	return 0;
}
void emergency_restart(void)
{
	machine_emergency_restart();
}
static void deferred_cad(struct work_struct *dummy)
{
	kernel_restart(NULL);
}
static void argv_cleanup(char **argv, char **envp)
{
	argv_free(argv);
}
asmlinkage long sys_ni_syscall(void)
{
	return -ENOSYS;
}
struct ctl_table_header *sysctl_head_next(struct ctl_table_header *prev)
{
	return __sysctl_head_next(current->nsproxy, prev);
}
struct ctl_table_header *register_sysctl_paths(const struct ctl_path *path,
						struct ctl_table *table)
{
	return __register_sysctl_paths(&sysctl_table_root, current->nsproxy,
					path, table);
}
struct ctl_table_header *register_sysctl_table(struct ctl_table * table)
{
	return NULL;
}
struct ctl_table_header *register_sysctl_paths(const struct ctl_path *path,
						    struct ctl_table *table)
{
	return NULL;
}
int proc_dostring(struct ctl_table *table, int write, struct file *filp,
		  void __user *buffer, size_t *lenp, loff_t *ppos)
{
	return _proc_do_string(table->data, table->maxlen, write, filp,
			       buffer, lenp, ppos);
}
static int do_proc_dointvec(struct ctl_table *table, int write, struct file *filp,
		  void __user *buffer, size_t *lenp, loff_t *ppos,
		  int (*conv)(int *negp, unsigned long *lvalp, int *valp,
			      int write, void *data),
		  void *data)
{
	return __do_proc_dointvec(table->data, table, write, filp,
			buffer, lenp, ppos, conv, data);
}
int proc_dointvec(struct ctl_table *table, int write, struct file *filp,
		     void __user *buffer, size_t *lenp, loff_t *ppos)
{
    return do_proc_dointvec(table,write,filp,buffer,lenp,ppos,
		    	    NULL,NULL);
}
static int do_proc_doulongvec_minmax(struct ctl_table *table, int write,
				     struct file *filp,
				     void __user *buffer,
				     size_t *lenp, loff_t *ppos,
				     unsigned long convmul,
				     unsigned long convdiv)
{
	return __do_proc_doulongvec_minmax(table->data, table, write,
			filp, buffer, lenp, ppos, convmul, convdiv);
}
int proc_doulongvec_minmax(struct ctl_table *table, int write, struct file *filp,
			   void __user *buffer, size_t *lenp, loff_t *ppos)
{
    return do_proc_doulongvec_minmax(table, write, filp, buffer, lenp, ppos, 1l, 1l);
}
int proc_doulongvec_ms_jiffies_minmax(struct ctl_table *table, int write,
				      struct file *filp,
				      void __user *buffer,
				      size_t *lenp, loff_t *ppos)
{
    return do_proc_doulongvec_minmax(table, write, filp, buffer,
				     lenp, ppos, HZ, 1000l);
}
int proc_dointvec_jiffies(struct ctl_table *table, int write, struct file *filp,
			  void __user *buffer, size_t *lenp, loff_t *ppos)
{
    return do_proc_dointvec(table,write,filp,buffer,lenp,ppos,
		    	    do_proc_dointvec_jiffies_conv,NULL);
}
int proc_dointvec_userhz_jiffies(struct ctl_table *table, int write, struct file *filp,
				 void __user *buffer, size_t *lenp, loff_t *ppos)
{
    return do_proc_dointvec(table,write,filp,buffer,lenp,ppos,
		    	    do_proc_dointvec_userhz_jiffies_conv,NULL);
}
int proc_dointvec_ms_jiffies(struct ctl_table *table, int write, struct file *filp,
			     void __user *buffer, size_t *lenp, loff_t *ppos)
{
	return do_proc_dointvec(table, write, filp, buffer, lenp, ppos,
				do_proc_dointvec_ms_jiffies_conv, NULL);
}
int proc_dostring(struct ctl_table *table, int write, struct file *filp,
		  void __user *buffer, size_t *lenp, loff_t *ppos)
{
	return -ENOSYS;
}
int proc_dointvec(struct ctl_table *table, int write, struct file *filp,
		  void __user *buffer, size_t *lenp, loff_t *ppos)
{
	return -ENOSYS;
}
int proc_dointvec_minmax(struct ctl_table *table, int write, struct file *filp,
		    void __user *buffer, size_t *lenp, loff_t *ppos)
{
	return -ENOSYS;
}
int proc_dointvec_jiffies(struct ctl_table *table, int write, struct file *filp,
		    void __user *buffer, size_t *lenp, loff_t *ppos)
{
	return -ENOSYS;
}
int proc_dointvec_userhz_jiffies(struct ctl_table *table, int write, struct file *filp,
		    void __user *buffer, size_t *lenp, loff_t *ppos)
{
	return -ENOSYS;
}
int proc_dointvec_ms_jiffies(struct ctl_table *table, int write, struct file *filp,
			     void __user *buffer, size_t *lenp, loff_t *ppos)
{
	return -ENOSYS;
}
int proc_doulongvec_minmax(struct ctl_table *table, int write, struct file *filp,
		    void __user *buffer, size_t *lenp, loff_t *ppos)
{
	return -ENOSYS;
}
int proc_doulongvec_ms_jiffies_minmax(struct ctl_table *table, int write,
				      struct file *filp,
				      void __user *buffer,
				      size_t *lenp, loff_t *ppos)
{
    return -ENOSYS;
}
int sysctl_data(struct ctl_table *table,
		  void __user *oldval, size_t __user *oldlenp,
		  void __user *newval, size_t newlen)
{
	return -ENOSYS;
}
int sysctl_string(struct ctl_table *table,
		  void __user *oldval, size_t __user *oldlenp,
		  void __user *newval, size_t newlen)
{
	return -ENOSYS;
}
int sysctl_intvec(struct ctl_table *table,
		void __user *oldval, size_t __user *oldlenp,
		void __user *newval, size_t newlen)
{
	return -ENOSYS;
}
int sysctl_jiffies(struct ctl_table *table,
		void __user *oldval, size_t __user *oldlenp,
		void __user *newval, size_t newlen)
{
	return -ENOSYS;
}
int sysctl_ms_jiffies(struct ctl_table *table,
		void __user *oldval, size_t __user *oldlenp,
		void __user *newval, size_t newlen)
{
	return -ENOSYS;
}
static noinline u32 kprobe_target(u32 value)
{
	return (value / div_factor);
}
static noinline u32 kprobe_target2(u32 value)
{
	return (value / div_factor) + 1;
}
unsigned int inline jiffies_to_msecs(const unsigned long j)
{
	return (MSEC_PER_SEC / HZ) * j;
}
unsigned int inline jiffies_to_usecs(const unsigned long j)
{
	return (USEC_PER_SEC / HZ) * j;
}
clock_t jiffies_to_clock_t(long x)
{
	return x * (USER_HZ / HZ);
}
u64 nsec_to_clock_t(u64 x)
{
	return div_u64(x, NSEC_PER_SEC / USER_HZ);
}
static void clockevents_do_notify(unsigned long reason, void *dev)
{
	raw_notifier_call_chain(&clockevents_chain, reason, dev);
}
static void clocksource_resume_watchdog(void)
{
	set_bit(0, &watchdog_resumed);
}
void clocksource_touch_watchdog(void)
{
	clocksource_resume_watchdog();
}
static cycle_t jiffies_read(void)
{
	return (cycle_t) jiffies;
}
static int __init init_jiffies_clocksource(void)
{
	return clocksource_register(&clocksource_jiffies);
}
struct tick_device *tick_get_broadcast_device(void)
{
	return &tick_broadcast_device;
}
struct cpumask *tick_get_broadcast_mask(void)
{
	return to_cpumask(tick_broadcast_mask);
}
int tick_is_broadcast_device(struct clock_event_device *dev)
{
	return (dev && tick_broadcast_device.evtdev == dev);
}
struct cpumask *tick_get_broadcast_oneshot_mask(void)
{
	return to_cpumask(tick_broadcast_oneshot_mask);
}
static void tick_broadcast_clear_oneshot(int cpu)
{
	cpumask_clear_cpu(cpu, tick_get_broadcast_oneshot_mask());
}
int tick_broadcast_oneshot_active(void)
{
	return tick_broadcast_device.mode == TICKDEV_MODE_ONESHOT;
}
struct tick_device *tick_get_device(int cpu)
{
	return &per_cpu(tick_cpu_device, cpu);
}
void __init tick_init(void)
{
	clockevents_register_notifier(&tick_notifier);
}
int tick_init_highres(void)
{
	return tick_switch_to_oneshot(hrtimer_interrupt);
}
struct tick_sched *tick_get_tick_sched(int cpu)
{
	return &per_cpu(tick_cpu_sched, cpu);
}
unsigned long __attribute__((weak)) read_persistent_clock(void)
{
	return 0;
}
void getboottime(struct timespec *ts)
{
	set_normalized_timespec(ts,
		- (wall_to_monotonic.tv_sec + total_sleep_time),
		- wall_to_monotonic.tv_nsec);
}
void monotonic_to_bootbased(struct timespec *ts)
{
	ts->tv_sec += total_sleep_time;
}
unsigned long get_seconds(void)
{
	return xtime_cache.tv_sec;
}
void sysrq_timer_list_show(void)
{
	timer_list_show(NULL, NULL);
}
static int timer_list_open(struct inode *inode, struct file *filp)
{
	return single_open(filp, timer_list_show, NULL);
}
static int match_entries(struct entry *entry1, struct entry *entry2)
{
	return entry1->timer       == entry2->timer	  &&
	       entry1->start_func  == entry2->start_func  &&
	       entry1->expire_func == entry2->expire_func &&
	       entry1->pid	   == entry2->pid;
}
static int tstats_open(struct inode *inode, struct file *filp)
{
	return single_open(filp, tstats_show, NULL);
}
static inline unsigned int tbase_get_deferrable(struct tvec_base *base)
{
	return ((unsigned int)(unsigned long)base & TBASE_DEFERRABLE_FLAG);
}
static inline struct tvec_base *tbase_get_base(struct tvec_base *base)
{
	return ((struct tvec_base *)((unsigned long)base & ~TBASE_DEFERRABLE_FLAG));
}
static inline void timer_set_deferrable(struct timer_list *timer)
{
	timer->base = ((struct tvec_base *)((unsigned long)(timer->base) |
				       TBASE_DEFERRABLE_FLAG));
}
static inline void
timer_set_base(struct timer_list *timer, struct tvec_base *new_base)
{
	timer->base = (struct tvec_base *)((unsigned long)(new_base) |
				      tbase_get_deferrable(timer->base));
}
unsigned long __round_jiffies(unsigned long j, int cpu)
{
	return round_jiffies_common(j, cpu, false);
}
unsigned long round_jiffies(unsigned long j)
{
	return round_jiffies_common(j, raw_smp_processor_id(), false);
}
unsigned long round_jiffies_relative(unsigned long j)
{
	return __round_jiffies_relative(j, raw_smp_processor_id());
}
unsigned long __round_jiffies_up(unsigned long j, int cpu)
{
	return round_jiffies_common(j, cpu, true);
}
unsigned long round_jiffies_up(unsigned long j)
{
	return round_jiffies_common(j, raw_smp_processor_id(), true);
}
unsigned long round_jiffies_up_relative(unsigned long j)
{
	return __round_jiffies_up_relative(j, raw_smp_processor_id());
}
static inline void set_running_timer(struct tvec_base *base,
					struct timer_list *timer)
{
	base->running_timer = timer;
}
static inline void debug_timer_init(struct timer_list *timer)
{
	debug_object_init(timer, &timer_debug_descr);
}
static inline void debug_timer_activate(struct timer_list *timer)
{
	debug_object_activate(timer, &timer_debug_descr);
}
static inline void debug_timer_deactivate(struct timer_list *timer)
{
	debug_object_deactivate(timer, &timer_debug_descr);
}
static inline void debug_timer_free(struct timer_list *timer)
{
	debug_object_free(timer, &timer_debug_descr);
}
void destroy_timer_on_stack(struct timer_list *timer)
{
	debug_object_free(timer, &timer_debug_descr);
}
static unsigned long count_active_tasks(void)
{
	return nr_active() * FIXED_1;
}
static void process_timeout(unsigned long __data)
{
	wake_up_process((struct task_struct *)__data);
}
static inline int record_frozen(struct dyn_ftrace *rec)
{
	return rec->flags & FTRACE_FL_FROZEN;
}
static void ftrace_run_update_code(int command)
{
	stop_machine(__ftrace_modify_code, &command, NULL);
}
static int
ftrace_filter_open(struct inode *inode, struct file *file)
{
	return ftrace_regex_open(inode, file, 1);
}
static int
ftrace_notrace_open(struct inode *inode, struct file *file)
{
	return ftrace_regex_open(inode, file, 0);
}
static ssize_t
ftrace_regex_read(struct file *file, char __user *ubuf,
		       size_t cnt, loff_t *ppos)
{
	if (file->f_mode & FMODE_READ)
		return seq_read(file, ubuf, cnt, ppos);
	else
		return -EPERM;
}
static ssize_t
ftrace_filter_write(struct file *file, const char __user *ubuf,
		    size_t cnt, loff_t *ppos)
{
	return ftrace_regex_write(file, ubuf, cnt, ppos, 1);
}
static ssize_t
ftrace_notrace_write(struct file *file, const char __user *ubuf,
		     size_t cnt, loff_t *ppos)
{
	return ftrace_regex_write(file, ubuf, cnt, ppos, 0);
}
void ftrace_set_filter(unsigned char *buf, int len, int reset)
{
	ftrace_set_regex(buf, len, reset, 1);
}
void ftrace_set_notrace(unsigned char *buf, int len, int reset)
{
	ftrace_set_regex(buf, len, reset, 0);
}
static int
ftrace_filter_release(struct inode *inode, struct file *file)
{
	return ftrace_regex_release(inode, file, 1);
}
static int
ftrace_notrace_release(struct inode *inode, struct file *file)
{
	return ftrace_regex_release(inode, file, 0);
}
static void g_stop(struct seq_file *m, void *p)
{
	mutex_unlock(&graph_lock);
}
static ssize_t
ftrace_graph_read(struct file *file, char __user *ubuf,
		       size_t cnt, loff_t *ppos)
{
	if (file->f_mode & FMODE_READ)
		return seq_read(file, ubuf, cnt, ppos);
	else
		return -EPERM;
}
static inline int ftrace_init_dyn_debugfs(struct dentry *d_tracer) { return 0; }
int ftrace_graph_entry_stub(struct ftrace_graph_ent *trace)
{
	return 0;
}
void ftrace_graph_stop(void)
{
	ftrace_stop();
}
static void kmem_trace_reset(struct trace_array *tr)
{
	kmem_tracing_enabled = false;
}
static int __init init_kmem_tracer(void)
{
	return register_tracer(&kmem_tracer);
}
void tracing_on(void)
{
	set_bit(RB_BUFFERS_ON_BIT, &ring_buffer_flags);
}
void tracing_off(void)
{
	clear_bit(RB_BUFFERS_ON_BIT, &ring_buffer_flags);
}
void tracing_off_permanent(void)
{
	set_bit(RB_BUFFERS_DISABLED_BIT, &ring_buffer_flags);
}
void ring_buffer_normalize_time_stamp(int cpu, u64 *ts)
{
	*ts >>= DEBUG_SHIFT;
}
void *ring_buffer_event_data(struct ring_buffer_event *event)
{
	return rb_event_data(event);
}
static void rb_init_page(struct buffer_data_page *bpage)
{
	local_set(&bpage->commit, 0);
}
static inline int rb_null_event(struct ring_buffer_event *event)
{
	return event->type == RINGBUF_TYPE_PADDING;
}
static inline void *
__rb_data_page_index(struct buffer_data_page *bpage, unsigned index)
{
	return bpage->data + index;
}
static inline void *__rb_page_index(struct buffer_page *bpage, unsigned index)
{
	return bpage->page->data + index;
}
static inline struct ring_buffer_event *
rb_reader_event(struct ring_buffer_per_cpu *cpu_buffer)
{
	return __rb_page_index(cpu_buffer->reader_page,
			       cpu_buffer->reader_page->read);
}
static inline struct ring_buffer_event *
rb_head_event(struct ring_buffer_per_cpu *cpu_buffer)
{
	return __rb_page_index(cpu_buffer->head_page,
			       cpu_buffer->head_page->read);
}
static inline struct ring_buffer_event *
rb_iter_head_event(struct ring_buffer_iter *iter)
{
	return __rb_page_index(iter->head_page, iter->head);
}
static inline unsigned rb_page_write(struct buffer_page *bpage)
{
	return local_read(&bpage->write);
}
static inline unsigned rb_page_commit(struct buffer_page *bpage)
{
	return local_read(&bpage->page->commit);
}
static inline unsigned rb_page_size(struct buffer_page *bpage)
{
	return rb_page_commit(bpage);
}
static inline unsigned
rb_commit_index(struct ring_buffer_per_cpu *cpu_buffer)
{
	return rb_page_commit(cpu_buffer->commit_page);
}
static inline unsigned rb_head_size(struct ring_buffer_per_cpu *cpu_buffer)
{
	return rb_page_commit(cpu_buffer->head_page);
}
void ring_buffer_record_disable(struct ring_buffer *buffer)
{
	atomic_inc(&buffer->record_disabled);
}
void ring_buffer_record_enable(struct ring_buffer *buffer)
{
	atomic_dec(&buffer->record_disabled);
}
unsigned long ring_buffer_size(struct ring_buffer *buffer)
{
	return BUF_PAGE_SIZE * buffer->pages;
}
void ring_buffer_free_read_page(struct ring_buffer *buffer, void *data)
{
	free_page((unsigned long)data);
}
static int dummy_set_flag(u32 old_flags, u32 bit, int set)
{
	return 0;
}
int tracing_is_enabled(void)
{
	return tracer_enabled;
}
unsigned long nsecs_to_usecs(unsigned long nsecs)
{
	return nsecs / 1000;
}
void __trace_stack(struct trace_array *tr,
		   unsigned long flags,
		   int skip, int pc)
{
	__ftrace_trace_stack(tr, flags, skip, pc);
}
void __trace_userstack(struct trace_array *tr, unsigned long flags)
{
	ftrace_trace_userstack(tr, flags, preempt_count());
}
void
__trace_special(void *__tr, void *__data,
		unsigned long arg1, unsigned long arg2, unsigned long arg3)
{
	ftrace_trace_special(__tr, arg1, arg2, arg3, preempt_count());
}
struct trace_entry *trace_find_next_entry(struct trace_iterator *iter,
					  int *ent_cpu, u64 *ent_ts)
{
	return __find_next_entry(iter, ent_cpu, ent_ts);
}
static void t_stop(struct seq_file *m, void *p)
{
	mutex_unlock(&trace_types_lock);
}
static ssize_t
tracing_readme_read(struct file *filp, char __user *ubuf,
		       size_t cnt, loff_t *ppos)
{
	return simple_read_from_buffer(ubuf, cnt, ppos,
					readme_msg, strlen(readme_msg));
}
int __weak ftrace_arch_read_dyn_info(char *buf, int size)
{
	return 0;
}
void start_boot_trace(void)
{
	pre_initcalls_finished = true;
}
static void start_branch_trace(struct trace_array *tr)
{
	enable_branch_tracing(tr);
}
static void stop_branch_trace(struct trace_array *tr)
{
	disable_branch_tracing();
}
static void branch_trace_reset(struct trace_array *tr)
{
	stop_branch_trace(tr);
}
static void *annotated_branch_stat_start(void)
{
	return __start_annotated_branch_profile;
}
static void *all_branch_stat_start(void)
{
	return __start_branch_profile;
}
static void function_trace_start(struct trace_array *tr)
{
	tracing_reset_online_cpus(tr);
}
static __init int init_function_trace(void)
{
	return register_tracer(&function_trace);
}
static void graph_trace_close(struct trace_iterator *iter)
{
	percpu_free(iter->private);
}
static __init int init_graph_trace(void)
{
	return register_tracer(&graph_trace);
}
static void bts_trace_print_header(struct seq_file *m)
{
	seq_puts(m, "# CPU#        TO  <-  FROM\n");
}
static void trace_bts_close(struct trace_iterator *iter)
{
	tracing_reset_online_cpus(iter->tr);
}
__init static int init_bts_trace(void)
{
	return register_tracer(&bts_tracer);
}
static inline int
preempt_trace(void)
{
	return ((trace_type & TRACER_PREEMPT_OFF) && preempt_count());
}
static inline int
irq_trace(void)
{
	return ((trace_type & TRACER_IRQS_OFF) &&
		irqs_disabled());
}
static void irqsoff_tracer_reset(struct trace_array *tr)
{
	stop_irqsoff_tracer(tr);
}
static void irqsoff_tracer_start(struct trace_array *tr)
{
	tracer_enabled = 1;
}
static void irqsoff_tracer_stop(struct trace_array *tr)
{
	tracer_enabled = 0;
}
__init static int init_mmio_trace(void)
{
	return register_tracer(&mmio_tracer);
}
int mmio_trace_printk(const char *fmt, va_list args)
{
	return trace_vprintk(0, -1, fmt, args);
}
static void nop_trace_reset(struct trace_array *tr)
{
	stop_nop_trace(tr);
}
static inline const char *kretprobed(const char *name)
{
	return name;
}
static int
lat_print_timestamp(struct trace_seq *s, u64 abs_usecs,
		    unsigned long rel_usecs)
{
	return trace_seq_printf(s, " %4lldus%c: ", abs_usecs,
				rel_usecs > preempt_mark_thresh ? '!' :
				  rel_usecs > 1 ? '+' : ' ');
}
enum print_line_t trace_nop_print(struct trace_iterator *iter, int flags)
{
	return TRACE_TYPE_HANDLED;
}
static enum print_line_t trace_ctx_print(struct trace_iterator *iter, int flags)
{
	return trace_ctxwake_print(iter, "==>");
}
static enum print_line_t trace_wake_print(struct trace_iterator *iter,
					  int flags)
{
	return trace_ctxwake_print(iter, "  +");
}
static enum print_line_t trace_ctx_raw(struct trace_iterator *iter, int flags)
{
	return trace_ctxwake_raw(iter, 0);
}
static enum print_line_t trace_wake_raw(struct trace_iterator *iter, int flags)
{
	return trace_ctxwake_raw(iter, '+');
}
static enum print_line_t trace_ctx_hex(struct trace_iterator *iter, int flags)
{
	return trace_ctxwake_hex(iter, 0);
}
static enum print_line_t trace_wake_hex(struct trace_iterator *iter, int flags)
{
	return trace_ctxwake_hex(iter, '+');
}
static void start_power_trace(struct trace_array *tr)
{
	trace_power_enabled = 1;
}
static void stop_power_trace(struct trace_array *tr)
{
	trace_power_enabled = 0;
}
static int init_power_trace(void)
{
	return register_tracer(&power_tracer);
}
void tracing_start_cmdline_record(void)
{
	tracing_start_sched_switch();
}
void tracing_stop_cmdline_record(void)
{
	tracing_stop_sched_switch();
}
void tracing_sched_switch_assign_trace(struct trace_array *tr)
{
	ctx_trace = tr;
}
static void stop_sched_trace(struct trace_array *tr)
{
	tracing_stop_sched_switch_record();
}
static void sched_switch_trace_stop(struct trace_array *tr)
{
	tracing_stop_sched_switch();
}
__init static int init_sched_switch_trace(void)
{
	return register_tracer(&sched_switch_trace);
}
static void wakeup_tracer_stop(struct trace_array *tr)
{
	tracer_enabled = 0;
}
static inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)
{
	printk(KERN_WARNING "Failed to init %s tracer, init returned %d\n",
		trace->name, init_ret);
}
int
trace_selftest_startup_nop(struct tracer *trace, struct trace_array *tr)
{
	return 0;
}
int DYN_FTRACE_TEST_NAME(void)
{
	return 0;
}
static int dummy_cmp(void *p1, void *p2)
{
	return 1;
}
static int backtrace_stack(void *data, char *name)
{
	return -1;
}
static void start_stack_timers(void)
{
	on_each_cpu(start_stack_timer, NULL, 1);
}
static void stack_trace_reset(struct trace_array *tr)
{
	stop_stack_trace(tr);
}
__init static int init_stack_trace(void)
{
	return register_tracer(&stack_trace);
}
static void rcu_free_old_probes(struct rcu_head *head)
{
	kfree(container_of(head, struct tp_probes, u.rcu));
}
void tracepoint_iter_start(struct tracepoint_iter *iter)
{
	tracepoint_get_iter(iter);
}
static int init_tracepoints(void)
{
	return register_module_notifier(&tracepoint_module_nb);
}
static void uid_hash_insert(struct user_struct *up, struct hlist_head *hashent)
{
	hlist_add_head(&up->uidhash_node, hashent);
}
static void sched_destroy_user(struct user_struct *up)
{
	sched_destroy_group(up->tg);
}
static int sched_create_user(struct user_struct *up) { return 0; }
static inline void uids_mutex_lock(void)
{
	mutex_lock(&uids_mutex);
}
static inline void uids_mutex_unlock(void)
{
	mutex_unlock(&uids_mutex);
}
static void uids_release(struct kobject *kobj)
{
	return;
}
int uids_sysfs_init(void) { return 0; }
static inline int uids_user_create(struct user_struct *up) { return 0; }
void wake_up_bit(void *word, int bit)
{
	__wake_up_bit(bit_waitqueue(word, bit), word, bit);
}
static inline int is_wq_single_threaded(struct workqueue_struct *wq)
{
	return wq->singlethread;
}
static const struct cpumask *wq_cpu_map(struct workqueue_struct *wq)
{
	return is_wq_single_threaded(wq)
		? cpu_singlethread_map : cpu_populated_map;
}
static inline
struct cpu_workqueue_struct *get_wq_data(struct work_struct *work)
{
	return (void *) (atomic_long_read(&work->data) & WORK_STRUCT_WQ_DATA_MASK);
}
int cancel_work_sync(struct work_struct *work)
{
	return __cancel_work_timer(work, NULL);
}
int cancel_delayed_work_sync(struct delayed_work *dwork)
{
	return __cancel_work_timer(&dwork->work, &dwork->timer);
}
int schedule_work(struct work_struct *work)
{
	return queue_work(keventd_wq, work);
}
int schedule_work_on(int cpu, struct work_struct *work)
{
	return queue_work_on(cpu, keventd_wq, work);
}
int schedule_delayed_work(struct delayed_work *dwork,
					unsigned long delay)
{
	return queue_delayed_work(keventd_wq, dwork, delay);
}
int schedule_delayed_work_on(int cpu,
			struct delayed_work *dwork, unsigned long delay)
{
	return queue_delayed_work_on(cpu, keventd_wq, dwork, delay);
}
void flush_scheduled_work(void)
{
	flush_workqueue(keventd_wq);
}
int keventd_up(void)
{
	return keventd_wq != NULL;
}
int audit_classify_arch(int arch)
{
	return 0;
}
unsigned bcd2bin(unsigned char val)
{
	return (val & 0x0f) + (val >> 4) * 10;
}
unsigned char bin2bcd(unsigned val)
{
	return ((val / 10) << 4) + val % 10;
}
void bitmap_release_region(unsigned long *bitmap, int pos, int order)
{
	__reg_op(bitmap, pos, order, REG_OP_RELEASE);
}
u16 bitrev16(u16 x)
{
	return (bitrev8(x & 0xff) << 8) | bitrev8(x >> 8);
}
u32 bitrev32(u32 x)
{
	return (bitrev16(x & 0xffff) << 16) | bitrev16(x >> 16);
}
static inline unsigned long bug_addr(const struct bug_entry *bug)
{
	return bug->bug_addr;
}
void module_bug_cleanup(struct module *mod)
{
	list_del(&mod->bug_list);
}
static inline const struct bug_entry *module_find_bug(unsigned long bugaddr)
{
	return NULL;
}
int __first_cpu(const cpumask_t *srcp)
{
	return min_t(int, NR_CPUS, find_first_bit(srcp->bits, NR_CPUS));
}
int __next_cpu(int n, const cpumask_t *srcp)
{
	return min_t(int, NR_CPUS, find_next_bit(srcp->bits, NR_CPUS, n+1));
}
int __next_cpu_nr(int n, const cpumask_t *srcp)
{
	return min_t(int, nr_cpu_ids,
				find_next_bit(srcp->bits, nr_cpu_ids, n+1));
}
bool alloc_cpumask_var(cpumask_var_t *mask, gfp_t flags)
{
	return alloc_cpumask_var_node(mask, flags, numa_node_id());
}
void __init alloc_bootmem_cpumask_var(cpumask_var_t *mask)
{
	*mask = alloc_bootmem(cpumask_size());
}
void free_cpumask_var(cpumask_var_t mask)
{
	kfree(mask);
}
void __init free_bootmem_cpumask_var(cpumask_var_t mask)
{
	free_bootmem((unsigned long)mask, cpumask_size());
}
static int debug_stats_open(struct inode *inode, struct file *filp)
{
	return single_open(filp, debug_stats_show, NULL);
}
void devm_ioremap_release(struct device *dev, void *res)
{
	iounmap(*(void __iomem **)res);
}
static int devm_ioremap_match(struct device *dev, void *res, void *match_data)
{
	return *(void **)res == match_data;
}
static void devm_ioport_map_release(struct device *dev, void *res)
{
	ioport_unmap(*(void __iomem **)res);
}
static int devm_ioport_map_match(struct device *dev, void *res,
				 void *match_data)
{
	return *(void **)res == match_data;
}
u32 iter_div_u64_rem(u64 dividend, u32 divisor, u64 *remainder)
{
	return __iter_div_u64_rem(dividend, divisor, remainder);
}
void dump_stack(void)
{
	printk(KERN_NOTICE
		"This architecture does not implement dump_stack()\n");
}
void sort_extable(struct exception_table_entry *start,
		  struct exception_table_entry *finish)
{
	sort(start, finish - start, sizeof(struct exception_table_entry),
	     cmp_ex, NULL);
}
static bool fail_task(struct fault_attr *attr, struct task_struct *task)
{
	return !in_interrupt() && task->make_it_fail;
}
static inline bool fail_stacktrace(struct fault_attr *attr)
{
	return true;
}
static struct dentry *debugfs_create_ul(const char *name, mode_t mode,
				struct dentry *parent, unsigned long *value)
{
	return debugfs_create_file(name, mode, parent, value, &fops_ul);
}
static struct dentry *debugfs_create_ul_MAX_STACK_TRACE_DEPTH(
	const char *name, mode_t mode,
	struct dentry *parent, unsigned long *value)
{
	return debugfs_create_file(name, mode, parent, value,
				   &fops_ul_MAX_STACK_TRACE_DEPTH);
}
static struct dentry *debugfs_create_atomic_t(const char *name, mode_t mode,
				struct dentry *parent, atomic_t *value)
{
	return debugfs_create_file(name, mode, parent, value, &fops_atomic_t);
}
static inline unsigned long ext2_swabp(const unsigned long * x)
{
	return (unsigned long) __swab64p((u64 *) x);
}
static inline unsigned long ext2_swab(const unsigned long y)
{
	return (unsigned long) __swab64((u64) y);
}
void print_hex_dump_bytes(const char *prefix_str, int prefix_type,
			const void *buf, size_t len)
{
	print_hex_dump(KERN_DEBUG, prefix_str, prefix_type, 16, 1,
			buf, len, 1);
}
unsigned long hweight64(__u64 w)
{
	return hweight32((unsigned int)(w >> 32)) + hweight32((unsigned int)w);
}
static inline void free_layer(struct idr_layer *p)
{
	call_rcu(&p->rcu_head, idr_layer_rcu_free);
}
void __init idr_init_cache(void)
{
	idr_layer_cache = kmem_cache_create("idr_layer_cache",
				sizeof(struct idr_layer), 0, SLAB_PANIC, NULL);
}
int ida_get_new(struct ida *ida, int *p_id)
{
	return ida_get_new_above(ida, 0, p_id);
}
void iowrite8(u8 val, void __iomem *addr)
{
	IO_COND(addr, outb(val,port), writeb(val, addr));
}
void iowrite16(u16 val, void __iomem *addr)
{
	IO_COND(addr, outw(val,port), writew(val, addr));
}
void iowrite16be(u16 val, void __iomem *addr)
{
	IO_COND(addr, pio_write16be(val,port), mmio_write16be(val, addr));
}
void iowrite32(u32 val, void __iomem *addr)
{
	IO_COND(addr, outl(val,port), writel(val, addr));
}
void iowrite32be(u32 val, void __iomem *addr)
{
	IO_COND(addr, pio_write32be(val,port), mmio_write32be(val, addr));
}
void ioread8_rep(void __iomem *addr, void *dst, unsigned long count)
{
	IO_COND(addr, insb(port,dst,count), mmio_insb(addr, dst, count));
}
void ioread16_rep(void __iomem *addr, void *dst, unsigned long count)
{
	IO_COND(addr, insw(port,dst,count), mmio_insw(addr, dst, count));
}
void ioread32_rep(void __iomem *addr, void *dst, unsigned long count)
{
	IO_COND(addr, insl(port,dst,count), mmio_insl(addr, dst, count));
}
void iowrite8_rep(void __iomem *addr, const void *src, unsigned long count)
{
	IO_COND(addr, outsb(port, src, count), mmio_outsb(addr, src, count));
}
void iowrite16_rep(void __iomem *addr, const void *src, unsigned long count)
{
	IO_COND(addr, outsw(port, src, count), mmio_outsw(addr, src, count));
}
void iowrite32_rep(void __iomem *addr, const void *src, unsigned long count)
{
	IO_COND(addr, outsl(port, src,count), mmio_outsl(addr, src, count));
}
void pci_iounmap(struct pci_dev *dev, void __iomem * addr)
{
	IO_COND(addr, /* nothing */, iounmap(addr));
}
static inline void __lock_kernel(void)
{
	_raw_spin_lock(&kernel_flag);
}
static struct klist *knode_klist(struct klist_node *knode)
{
	return (struct klist *)
		((unsigned long)knode->n_klist & KNODE_KLIST_MASK);
}
static bool knode_dead(struct klist_node *knode)
{
	return (unsigned long)knode->n_klist & KNODE_DEAD;
}
static int klist_dec_and_del(struct klist_node *n)
{
	return kref_put(&n->n_ref, klist_release);
}
void klist_del(struct klist_node *n)
{
	klist_put(n, true);
}
int klist_node_attached(struct klist_node *n)
{
	return (n->n_klist != NULL);
}
void klist_iter_init(struct klist *k, struct klist_iter *i)
{
	klist_iter_init_node(k, i, NULL);
}
static struct klist_node *to_klist_node(struct list_head *n)
{
	return container_of(n, struct klist_node, n_node);
}
static void kobject_release(struct kref *kref)
{
	kobject_cleanup(container_of(kref, struct kobject, kref));
}
int kobject_uevent(struct kobject *kobj, enum kobject_action action)
{
	return kobject_uevent_env(kobj, action, NULL);
}
void kref_init(struct kref *kref)
{
	kref_set(kref, 1);
}
static void __exit libcrc32c_mod_fini(void)
{
	crypto_free_shash(tfm);
}
static unsigned long lmb_addrs_overlap(u64 base1, u64 size1, u64 base2,
					u64 size2)
{
	return ((base1 < (base2 + size2)) && (base2 < (base1 + size1)));
}
static u64 lmb_align_down(u64 addr, u64 size)
{
	return addr & ~(size - 1);
}
static u64 lmb_align_up(u64 addr, u64 size)
{
	return (addr + (size - 1)) & ~(size - 1);
}
u64 __init lmb_alloc(u64 size, u64 align)
{
	return lmb_alloc_base(size, align, LMB_ALLOC_ANYWHERE);
}
u64 __init lmb_phys_mem_size(void)
{
	return lmb.memory.size;
}
static void name(void) { E(); }
static inline void print_testname(const char *testname)
{
	printk("%33s:", testname);
}
int match_int(substring_t *s, int *result)
{
	return match_number(s, result, 0);
}
int match_octal(substring_t *s, int *result)
{
	return match_number(s, result, 8);
}
int match_hex(substring_t *s, int *result)
{
	return match_number(s, result, 16);
}
static void plist_check_prev_next(struct list_head *t, struct list_head *p,
				  struct list_head *n)
{
	WARN(n->prev != p || p->next != n,
			"top: %p, n: %p, p: %p\n"
			"prev: %p, n: %p, p: %p\n"
			"next: %p, n: %p, p: %p\n",
			 t, t->next, t->prev,
			p, p->next, p->prev,
			n, n->next, n->prev);
}
void heap_free(struct ptr_heap *heap)
{
	kfree(heap->ptrs);
}
static inline unsigned long prio_tree_maxindex(unsigned int bits)
{
	return index_bits_to_maxindex[bits - 1];
}
static inline int overlap(struct prio_tree_iter *iter,
		unsigned long r_index, unsigned long h_index)
{
	return iter->h_index >= r_index && iter->r_index <= h_index;
}
static void prop_put_global(struct prop_descriptor *pd, struct prop_global *pg)
{
	rcu_read_unlock();
}
void prop_local_destroy_percpu(struct prop_local_percpu *pl)
{
	percpu_counter_destroy(&pl->events);
}
static inline gfp_t root_gfp_mask(struct radix_tree_root *root)
{
	return root->gfp_mask & __GFP_BITS_MASK;
}
static inline void tag_set(struct radix_tree_node *node, unsigned int tag,
		int offset)
{
	__set_bit(offset, node->tags[tag]);
}
static inline void tag_clear(struct radix_tree_node *node, unsigned int tag,
		int offset)
{
	__clear_bit(offset, node->tags[tag]);
}
static inline int tag_get(struct radix_tree_node *node, unsigned int tag,
		int offset)
{
	return test_bit(offset, node->tags[tag]);
}
static inline void root_tag_set(struct radix_tree_root *root, unsigned int tag)
{
	root->gfp_mask |= (__force gfp_t)(1 << (tag + __GFP_BITS_SHIFT));
}
static inline void root_tag_clear(struct radix_tree_root *root, unsigned int tag)
{
	root->gfp_mask &= (__force gfp_t)~(1 << (tag + __GFP_BITS_SHIFT));
}
static inline void root_tag_clear_all(struct radix_tree_root *root)
{
	root->gfp_mask &= __GFP_BITS_MASK;
}
static inline int root_tag_get(struct radix_tree_root *root, unsigned int tag)
{
	return (__force unsigned)root->gfp_mask & (1 << (tag + __GFP_BITS_SHIFT));
}
static inline void
radix_tree_node_free(struct radix_tree_node *node)
{
	call_rcu(&node->rcu_head, radix_tree_node_rcu_free);
}
static inline unsigned long radix_tree_maxindex(unsigned int height)
{
	return height_to_maxindex[height];
}
int radix_tree_tagged(struct radix_tree_root *root, unsigned int tag)
{
	return root_tag_get(root, tag);
}
static void
radix_tree_node_ctor(void *node)
{
	memset(node, 0, sizeof(struct radix_tree_node));
}
static inline u32 __seed(u32 x, u32 m)
{
	return (x < m) ? x + m : x;
}
struct rs_control *init_rs(int symsize, int gfpoly, int fcr, int prim,
                           int nroots)
{
	return init_rs_internal(symsize, gfpoly, NULL, fcr, prim, nroots);
}
struct rs_control *init_rs_non_canonical(int symsize, int (*gffunc)(int),
                                         int fcr, int prim, int nroots)
{
	return init_rs_internal(symsize, 0, gffunc, fcr, prim, nroots);
}
void __sched __down_write(struct rw_semaphore *sem)
{
	__down_write_nested(sem, 0);
}
static struct scatterlist *sg_kmalloc(unsigned int nents, gfp_t gfp_mask)
{
	if (nents == SG_MAX_SINGLE_ALLOC)
		return (struct scatterlist *) __get_free_page(gfp_mask);
	else
		return kmalloc(nents * sizeof(struct scatterlist), gfp_mask);
}
void sg_free_table(struct sg_table *table)
{
	__sg_free_table(table, SG_MAX_SINGLE_ALLOC, sg_kfree);
}
size_t sg_copy_from_buffer(struct scatterlist *sgl, unsigned int nents,
			   void *buf, size_t buflen)
{
	return sg_copy_buffer(sgl, nents, buf, buflen, 0);
}
size_t sg_copy_to_buffer(struct scatterlist *sgl, unsigned int nents,
			 void *buf, size_t buflen)
{
	return sg_copy_buffer(sgl, nents, buf, buflen, 1);
}
void * __weak __init swiotlb_alloc_boot(size_t size, unsigned long nslabs)
{
	return alloc_bootmem_low_pages(size);
}
void * __weak swiotlb_alloc(unsigned order, unsigned long nslabs)
{
	return (void *)__get_free_pages(GFP_DMA | __GFP_NOWARN, order);
}
dma_addr_t __weak swiotlb_phys_to_bus(struct device *hwdev, phys_addr_t paddr)
{
	return paddr;
}
phys_addr_t __weak swiotlb_bus_to_phys(dma_addr_t baddr)
{
	return baddr;
}
static dma_addr_t swiotlb_virt_to_bus(struct device *hwdev,
				      volatile void *address)
{
	return swiotlb_phys_to_bus(hwdev, virt_to_phys(address));
}
static void *swiotlb_bus_to_virt(dma_addr_t address)
{
	return phys_to_virt(swiotlb_bus_to_phys(address));
}
int __weak swiotlb_arch_range_needs_mapping(phys_addr_t paddr, size_t size)
{
	return 0;
}
void __init
swiotlb_init(void)
{
	swiotlb_init_with_default_size(64 * (1<<20));	/* default to 64MB */
}
static int
address_needs_mapping(struct device *hwdev, dma_addr_t addr, size_t size)
{
	return !is_buffer_dma_capable(dma_get_mask(hwdev), addr, size);
}
static inline int range_needs_mapping(phys_addr_t paddr, size_t size)
{
	return swiotlb_force || swiotlb_arch_range_needs_mapping(paddr, size);
}
static int is_swiotlb_buffer(char *addr)
{
	return addr >= io_tlb_start && addr < io_tlb_end;
}
void
swiotlb_sync_single_for_cpu(struct device *hwdev, dma_addr_t dev_addr,
			    size_t size, enum dma_data_direction dir)
{
	swiotlb_sync_single(hwdev, dev_addr, size, dir, SYNC_FOR_CPU);
}
void
swiotlb_sync_single_for_device(struct device *hwdev, dma_addr_t dev_addr,
			       size_t size, enum dma_data_direction dir)
{
	swiotlb_sync_single(hwdev, dev_addr, size, dir, SYNC_FOR_DEVICE);
}
void
swiotlb_sync_single_range_for_cpu(struct device *hwdev, dma_addr_t dev_addr,
				  unsigned long offset, size_t size,
				  enum dma_data_direction dir)
{
	swiotlb_sync_single_range(hwdev, dev_addr, offset, size, dir,
				  SYNC_FOR_CPU);
}
void
swiotlb_sync_single_range_for_device(struct device *hwdev, dma_addr_t dev_addr,
				     unsigned long offset, size_t size,
				     enum dma_data_direction dir)
{
	swiotlb_sync_single_range(hwdev, dev_addr, offset, size, dir,
				  SYNC_FOR_DEVICE);
}
int
swiotlb_map_sg(struct device *hwdev, struct scatterlist *sgl, int nelems,
	       int dir)
{
	return swiotlb_map_sg_attrs(hwdev, sgl, nelems, dir, NULL);
}
void
swiotlb_unmap_sg(struct device *hwdev, struct scatterlist *sgl, int nelems,
		 int dir)
{
	return swiotlb_unmap_sg_attrs(hwdev, sgl, nelems, dir, NULL);
}
void
swiotlb_sync_sg_for_cpu(struct device *hwdev, struct scatterlist *sg,
			int nelems, enum dma_data_direction dir)
{
	swiotlb_sync_sg(hwdev, sg, nelems, dir, SYNC_FOR_CPU);
}
void
swiotlb_sync_sg_for_device(struct device *hwdev, struct scatterlist *sg,
			   int nelems, enum dma_data_direction dir)
{
	swiotlb_sync_sg(hwdev, sg, nelems, dir, SYNC_FOR_DEVICE);
}
int
swiotlb_dma_mapping_error(struct device *hwdev, dma_addr_t dma_addr)
{
	return (dma_addr == swiotlb_virt_to_bus(hwdev, io_tlb_overflow_buffer));
}
int
swiotlb_dma_supported(struct device *hwdev, u64 mask)
{
	return swiotlb_virt_to_bus(hwdev, io_tlb_end - 1) <= mask;
}
static int __init init_bm(void)
{
	return textsearch_register(&bm_ops);
}
static void __exit exit_bm(void)
{
	textsearch_unregister(&bm_ops);
}
static inline int match_token(struct ts_fsm_token *t, u8 d)
{
	if (t->type)
		return (token_lookup_tbl[d] & t->type) != 0;
	else
		return t->value == d;
}
static int __init init_fsm(void)
{
	return textsearch_register(&fsm_ops);
}
static void __exit exit_fsm(void)
{
	textsearch_unregister(&fsm_ops);
}
static int __init init_kmp(void)
{
	return textsearch_register(&kmp_ops);
}
static void __exit exit_kmp(void)
{
	textsearch_unregister(&kmp_ops);
}
int vsprintf(char *buf, const char *fmt, va_list args)
{
	return vsnprintf(buf, INT_MAX, fmt, args);
}
int zlib_deflate_workspacesize(void)
{
    return sizeof(deflate_workspace);
}
int zlib_inflate_workspacesize(void)
{
    return sizeof(struct inflate_workspace);
}
static void bdi_debug_init(void)
{
	bdi_debug_root = debugfs_create_dir("bdi", NULL);
}
static int bdi_debug_stats_open(struct inode *inode, struct file *file)
{
	return single_open(file, bdi_debug_stats_show, inode->i_private);
}
int bdi_register_dev(struct backing_dev_info *bdi, dev_t dev)
{
	return bdi_register(bdi, NULL, "%u:%u", MAJOR(dev), MINOR(dev));
}
unsigned long __init init_bootmem_node(pg_data_t *pgdat, unsigned long freepfn,
				unsigned long startpfn, unsigned long endpfn)
{
	return init_bootmem_core(pgdat->bdata, freepfn, startpfn, endpfn);
}
unsigned long __init free_all_bootmem(void)
{
	return free_all_bootmem_core(NODE_DATA(0)->bdata);
}
void * __init __alloc_bootmem_nopanic(unsigned long size, unsigned long align,
					unsigned long goal)
{
	return ___alloc_bootmem_nopanic(size, align, goal, 0);
}
void * __init __alloc_bootmem(unsigned long size, unsigned long align,
			      unsigned long goal)
{
	return ___alloc_bootmem(size, align, goal, 0);
}
void * __init __alloc_bootmem_node(pg_data_t *pgdat, unsigned long size,
				   unsigned long align, unsigned long goal)
{
	return ___alloc_bootmem_node(pgdat->bdata, size, align, goal, 0);
}
void * __init __alloc_bootmem_low(unsigned long size, unsigned long align,
				  unsigned long goal)
{
	return ___alloc_bootmem(size, align, goal, ARCH_LOW_ADDRESS_LIMIT);
}
void * __init __alloc_bootmem_low_node(pg_data_t *pgdat, unsigned long size,
				       unsigned long align, unsigned long goal)
{
	return ___alloc_bootmem_node(pgdat->bdata, size, align,
				goal, ARCH_LOW_ADDRESS_LIMIT);
}
static void *mempool_alloc_pages_isa(gfp_t gfp_mask, void *data)
{
	return mempool_alloc_pages(gfp_mask | GFP_DMA, data);
}
static void bounce_end_io_write(struct bio *bio, int err)
{
	bounce_end_io(bio, page_pool, err);
}
static void bounce_end_io_write_isa(struct bio *bio, int err)
{
	bounce_end_io(bio, isa_page_pool, err);
}
static void bounce_end_io_read(struct bio *bio, int err)
{
	__bounce_end_io_read(bio, page_pool, err);
}
static void bounce_end_io_read_isa(struct bio *bio, int err)
{
	__bounce_end_io_read(bio, isa_page_pool, err);
}
static inline int is_page_busy(struct dma_page *page)
{
	return page->in_use != 0;
}
static int dmam_pool_match(struct device *dev, void *res, void *match_data)
{
	return *(struct dma_pool **)res == match_data;
}
asmlinkage long SyS_fadvise64_64(long fd, loff_t offset, loff_t len, long advice)
{
	return SYSC_fadvise64_64((int) fd, offset, len, (int) advice);
}
asmlinkage long SyS_fadvise64(long fd, loff_t offset, long len, long advice)
{
	return SYSC_fadvise64((int) fd, offset, (size_t)len, (int)advice);
}
static int __init setup_failslab(char *str)
{
	return setup_fault_attr(&failslab.attr, str);
}
static inline int __filemap_fdatawrite(struct address_space *mapping,
	int sync_mode)
{
	return __filemap_fdatawrite_range(mapping, 0, LLONG_MAX, sync_mode);
}
int filemap_fdatawrite(struct address_space *mapping)
{
	return __filemap_fdatawrite(mapping, WB_SYNC_ALL);
}
int filemap_fdatawrite_range(struct address_space *mapping, loff_t start,
				loff_t end)
{
	return __filemap_fdatawrite_range(mapping, start, end, WB_SYNC_ALL);
}
int filemap_flush(struct address_space *mapping)
{
	return __filemap_fdatawrite(mapping, WB_SYNC_NONE);
}
static inline void wake_up_page(struct page *page, int bit)
{
	__wake_up_bit(page_waitqueue(page), &page->flags, bit);
}
asmlinkage long SyS_readahead(long fd, loff_t offset, long count)
{
	return SYSC_readahead((int) fd, offset, (size_t) count);
}
int generic_file_mmap(struct file * file, struct vm_area_struct * vma)
{
	return -ENOSYS;
}
int generic_file_readonly_mmap(struct file * file, struct vm_area_struct * vma)
{
	return -ENOSYS;
}
static struct page_address_slot *page_slot(struct page *page)
{
	return &page_address_htable[hash_ptr(page, PA_HASH_ORDER)];
}
static pgoff_t vma_hugecache_offset(struct hstate *h,
			struct vm_area_struct *vma, unsigned long address)
{
	return ((address - vma->vm_start) >> huge_page_shift(h)) +
			(vma->vm_pgoff >> huge_page_order(h));
}
unsigned long vma_mmu_pagesize(struct vm_area_struct *vma)
{
	return vma_kernel_pagesize(vma);
}
static unsigned long get_vma_private_data(struct vm_area_struct *vma)
{
	return (unsigned long)vma->vm_private_data;
}
static void set_vma_private_data(struct vm_area_struct *vma,
							unsigned long value)
{
	vma->vm_private_data = (void *)value;
}
static int huge_zeropage_ok(pte_t *ptep, int write, int shared)
{
	if (!ptep || write || shared)
		return 0;
	else
		return huge_pte_none(huge_ptep_get(ptep));
}
static int color_white(const struct kmemleak_object *object)
{
	return object->count != -1 && object->count < object->min_count;
}
static int color_gray(const struct kmemleak_object *object)
{
	return object->min_count != -1 && object->count >= object->min_count;
}
static int unreferenced_object(struct kmemleak_object *object)
{
	if (color_white(object) &&
	    (object->flags & OBJECT_ALLOCATED) &&
	    time_is_before_eq_jiffies(object->jiffies + jiffies_min_age))
		return 1;
	else
		return 0;
}
static int get_object(struct kmemleak_object *object)
{
	return atomic_inc_not_zero(&object->use_count);
}
static inline void __mem_cgroup_stat_add_safe(struct mem_cgroup_stat_cpu *stat,
		enum mem_cgroup_stat_index idx, int val)
{
	stat->count[idx] += val;
}
static struct mem_cgroup_per_zone *
mem_cgroup_zoneinfo(struct mem_cgroup *mem, int nid, int zid)
{
	return &mem->info.nodeinfo[nid]->zoneinfo[zid];
}
static struct mem_cgroup *mem_cgroup_from_cont(struct cgroup *cont)
{
	return container_of(cgroup_subsys_state(cont,
				mem_cgroup_subsys_id), struct mem_cgroup,
				css);
}
void mem_cgroup_del_lru(struct page *page)
{
	mem_cgroup_del_lru_list(page, page_lru(page));
}
int mem_cgroup_force_empty_write(struct cgroup *cont, unsigned int event)
{
	return mem_cgroup_force_empty(mem_cgroup_from_cont(cont), true);
}
static u64 mem_cgroup_hierarchy_read(struct cgroup *cont, struct cftype *cft)
{
	return mem_cgroup_from_cont(cont)->use_hierarchy;
}
static int register_memsw_files(struct cgroup *cont, struct cgroup_subsys *ss)
{
	return 0;
}
static void free_mem_cgroup_per_zone_info(struct mem_cgroup *mem, int node)
{
	kfree(mem->info.nodeinfo[node]);
}
static void mem_cgroup_get(struct mem_cgroup *mem)
{
	atomic_inc(&mem->refcnt);
}
static inline int is_cow_mapping(unsigned int flags)
{
	return (flags & (VM_SHARED | VM_MAYWRITE)) == VM_MAYWRITE;
}
struct vm_area_struct *get_gate_vma(struct task_struct *tsk)
{
	return &gate_vma;
}
static int __remove_section(struct zone *zone, struct mem_section *ms)
{
	return -EBUSY;
}
static inline int pageblock_free(struct page *page)
{
	return PageBuddy(page) && page_order(page) >= pageblock_order;
}
static struct page *
hotremove_migrate_alloc(struct page *page, unsigned long private, int **x)
{
	return alloc_page(GFP_HIGHUSER_MOVABLE);
}
static void
offline_isolated_pages(unsigned long start_pfn, unsigned long end_pfn)
{
	walk_memory_resource(start_pfn, end_pfn - start_pfn, NULL,
				offline_isolated_pages_cb);
}
int remove_memory(u64 start, u64 size)
{
	return -EINVAL;
}
static inline int mpol_store_user_nodemask(const struct mempolicy *pol)
{
	return pol->flags & (MPOL_F_STATIC_NODES | MPOL_F_RELATIVE_NODES);
}
void mpol_rebind_task(struct task_struct *tsk, const nodemask_t *new)
{
	mpol_rebind_policy(tsk->mempolicy, new);
}
static void mpol_set_task_struct_flag(void)
{
	mpol_fix_fork_child_flag(current);
}
static struct page *new_node_page(struct page *page, unsigned long node, int **x)
{
	return alloc_pages_node(node, GFP_HIGHUSER_MOVABLE, 0);
}
int do_migrate_pages(struct mm_struct *mm,
	const nodemask_t *from_nodes, const nodemask_t *to_nodes, int flags)
{
	return -ENOSYS;
}
static struct page *new_vma_page(struct page *page, unsigned long private, int **x)
{
	return NULL;
}
void numa_default_policy(void)
{
	do_set_mempolicy(MPOL_DEFAULT, 0, NULL);
}
mempool_t *mempool_create(int min_nr, mempool_alloc_t *alloc_fn,
				mempool_free_t *free_fn, void *pool_data)
{
	return  mempool_create_node(min_nr,alloc_fn,free_fn, pool_data,-1);
}
void mempool_kfree(void *element, void *pool_data)
{
	kfree(element);
}
int fail_migrate_page(struct address_space *mapping,
			struct page *newpage, struct page *page)
{
	return -EIO;
}
static inline int __mlock_posix_error_return(long retval)
{
	return 0;
}
pgprot_t vm_get_page_prot(unsigned long vm_flags)
{
	return __pgprot(pgprot_val(protection_map[vm_flags &
				(VM_READ|VM_WRITE|VM_EXEC|VM_SHARED)]) |
			pgprot_val(arch_vm_get_page_prot(vm_flags)));
}
static inline int is_mergeable_anon_vma(struct anon_vma *anon_vma1,
					struct anon_vma *anon_vma2)
{
	return !anon_vma1 || !anon_vma2 || (anon_vma1 == anon_vma2);
}
int expand_stack_downwards(struct vm_area_struct *vma, unsigned long address)
{
	return expand_downwards(vma, address);
}
int expand_stack(struct vm_area_struct *vma, unsigned long address)
{
	return expand_upwards(vma, address);
}
int expand_stack(struct vm_area_struct *vma, unsigned long address)
{
	return expand_downwards(vma, address);
}
void __init mmap_init(void)
{
	vm_area_cachep = kmem_cache_create("vm_area_struct",
			sizeof(struct vm_area_struct), 0,
			SLAB_PANIC, NULL);
}
int mmu_notifier_register(struct mmu_notifier *mn, struct mm_struct *mm)
{
	return do_mmu_notifier_register(mn, mm, 1);
}
int __mmu_notifier_register(struct mmu_notifier *mn, struct mm_struct *mm)
{
	return do_mmu_notifier_register(mn, mm, 0);
}
struct pglist_data *first_online_pgdat(void)
{
	return NODE_DATA(first_online_node);
}
static inline int zref_in_nodemask(struct zoneref *zref, nodemask_t *nodes)
{
	return node_isset(zonelist_node_idx(zref), *nodes);
}
static inline pgprot_t pgprot_modify(pgprot_t oldprot, pgprot_t newprot)
{
	return newprot;
}
void vfree(const void *addr)
{
	kfree(addr);
}
void *__vmalloc(unsigned long size, gfp_t gfp_mask, pgprot_t prot)
{
	return kmalloc(size, (gfp_mask | __GFP_COMP) & ~__GFP_HIGHMEM);
}
struct page *vmalloc_to_page(const void *addr)
{
	return virt_to_page(addr);
}
unsigned long vmalloc_to_pfn(const void *addr)
{
	return page_to_pfn(virt_to_page(addr));
}
void *vmalloc(unsigned long size)
{
       return __vmalloc(size, GFP_KERNEL | __GFP_HIGHMEM, PAGE_KERNEL);
}
void *vmalloc_node(unsigned long size, int node)
{
	return vmalloc(size);
}
void *vmalloc_exec(unsigned long size)
{
	return __vmalloc(size, GFP_KERNEL | __GFP_HIGHMEM, PAGE_KERNEL_EXEC);
}
void *vmalloc_32(unsigned long size)
{
	return __vmalloc(size, GFP_KERNEL, PAGE_KERNEL);
}
void *vmalloc_32_user(unsigned long size)
{
	return vmalloc_user(size);
}
void vunmap(const void *addr)
{
	BUG();
}
void vm_unmap_ram(const void *mem, unsigned int count)
{
	BUG();
}
int vm_insert_page(struct vm_area_struct *vma, unsigned long addr,
		   struct page *page)
{
	return -EINVAL;
}
struct vm_area_struct *find_extend_vma(struct mm_struct *mm, unsigned long addr)
{
	return find_vma(mm, addr);
}
int expand_stack(struct vm_area_struct *vma, unsigned long address)
{
	return -ENOMEM;
}
unsigned long do_brk(unsigned long addr, unsigned long len)
{
	return -ENOMEM;
}
struct page *follow_page(struct vm_area_struct *vma, unsigned long address,
			unsigned int foll_flags)
{
	return NULL;
}
unsigned long arch_get_unmapped_area(struct file *file, unsigned long addr,
	unsigned long len, unsigned long pgoff, unsigned long flags)
{
	return -ENOMEM;
}
int in_gate_area_no_task(unsigned long addr)
{
	return 0;
}
int register_oom_notifier(struct notifier_block *nb)
{
	return blocking_notifier_chain_register(&oom_notify_list, nb);
}
int unregister_oom_notifier(struct notifier_block *nb)
{
	return blocking_notifier_chain_unregister(&oom_notify_list, nb);
}
static inline long sync_writeback_pages(void)
{
	return ratelimit_pages + ratelimit_pages / 2;
}
static inline void __bdi_writeout_inc(struct backing_dev_info *bdi)
{
	__prop_inc_percpu_max(&vm_completions, &bdi->completions,
			      bdi->max_prop_frac);
}
static inline void task_dirty_inc(struct task_struct *tsk)
{
	prop_inc_single(&vm_dirties, &tsk->dirties);
}
static inline void task_dirties_fraction(struct task_struct *tsk,
		long *numerator, long *denominator)
{
	prop_fraction_single(&vm_dirties, &tsk->dirties,
				numerator, denominator);
}
static void laptop_flush(unsigned long unused)
{
	sys_sync();
}
static void laptop_timer_fn(unsigned long unused)
{
	pdflush_operation(laptop_flush, 0);
}
void laptop_io_completion(void)
{
	mod_timer(&laptop_mode_wb_timer, jiffies + laptop_mode);
}
void laptop_sync_completion(void)
{
	del_timer(&laptop_mode_wb_timer);
}
static void set_pageblock_migratetype(struct page *page, int migratetype)
{
	set_pageblock_flags_group(page, (unsigned long)migratetype,
					PB_migrate, PB_migrate_end);
}
static inline int bad_range(struct zone *zone, struct page *page)
{
	return 0;
}
static void free_compound_page(struct page *page)
{
	__free_pages_ok(page, compound_order(page));
}
static inline unsigned long
__find_combined_index(unsigned long page_idx, unsigned int order)
{
	return (page_idx & ~(1 << order));
}
void drain_local_pages(void *arg)
{
	drain_pages(smp_processor_id());
}
void drain_all_pages(void)
{
	on_each_cpu(drain_local_pages, NULL, 1);
}
void free_hot_page(struct page *page)
{
	free_hot_cold_page(page, 0);
}
void free_cold_page(struct page *page)
{
	free_hot_cold_page(page, 1);
}
static int __init setup_fail_page_alloc(char *str)
{
	return setup_fault_attr(&fail_page_alloc.attr, str);
}
static inline int should_fail_alloc_page(gfp_t gfp_mask, unsigned int order)
{
	return 0;
}
static nodemask_t *zlc_setup(struct zonelist *zonelist, int alloc_flags)
{
	return NULL;
}
static int zlc_zone_worth_trying(struct zonelist *zonelist, struct zoneref *z,
				nodemask_t *allowednodes)
{
	return 1;
}
unsigned int nr_free_buffer_pages(void)
{
	return nr_free_zone_pages(gfp_zone(GFP_USER));
}
unsigned int nr_free_pagecache_pages(void)
{
	return nr_free_zone_pages(gfp_zone(GFP_HIGHUSER_MOVABLE));
}
static void set_zonelist_order(void)
{
	current_zonelist_order = ZONELIST_ORDER_ZONE;
}
static void build_zonelist_cache(pg_data_t *pgdat)
{
	pgdat->node_zonelists[0].zlcache_ptr = NULL;
}
static inline unsigned long wait_table_hash_nr_entries(unsigned long pages)
{
	return 4096UL;
}
static inline unsigned long wait_table_bits(unsigned long size)
{
	return ffz(~size);
}
unsigned long __init absent_pages_in_range(unsigned long start_pfn,
							unsigned long end_pfn)
{
	return __absent_pages_in_range(MAX_NUMNODES, start_pfn, end_pfn);
}
static inline unsigned long __meminit zone_spanned_pages_in_node(int nid,
					unsigned long zone_type,
					unsigned long *zones_size)
{
	return zones_size[zone_type];
}
static inline int pageblock_default_order(unsigned int order)
{
	return MAX_ORDER-1;
}
static void __init sort_node_map(void)
{
	sort(early_node_map, (size_t)nr_nodemap_entries,
			sizeof(struct node_active_region),
			cmp_node_active_region, NULL);
}
unsigned long __init find_min_pfn_with_active_regions(void)
{
	return find_min_pfn_for_node(MAX_NUMNODES);
}
static int __init cmdline_parse_kernelcore(char *p)
{
	return cmdline_parse_core(p, &required_kernelcore);
}
static int __init cmdline_parse_movablecore(char *p)
{
	return cmdline_parse_core(p, &required_movablecore);
}
void __init set_dma_reserve(unsigned long new_dma_reserve)
{
	dma_reserve = new_dma_reserve;
}
void __init free_area_init(unsigned long *zones_size)
{
	free_area_init_node(0, zones_size,
			__pa(PAGE_OFFSET) >> PAGE_SHIFT, NULL);
}
void __init page_alloc_init(void)
{
	hotcpu_notifier(page_alloc_cpu_notify, 0);
}
static inline unsigned long *get_pageblock_bitmap(struct zone *zone,
							unsigned long pfn)
{
	return __pfn_to_section(pfn)->pageblock_flags;
}
void __meminit pgdat_page_cgroup_init(struct pglist_data *pgdat)
{
	pgdat->node_page_cgroup = NULL;
}
void __meminit pgdat_page_cgroup_init(struct pglist_data *pgdat)
{
	return;
}
static void start_one_pdflush_thread(void)
{
	kthread_run(pdflush, NULL, "pdflush");
}
unsigned long max_sane_readahead(unsigned long nr)
{
	return min(nr, (node_page_state(numa_node_id(), NR_INACTIVE_FILE)
		+ node_page_state(numa_node_id(), NR_FREE_PAGES)) / 2);
}
static inline struct anon_vma *anon_vma_alloc(void)
{
	return kmem_cache_alloc(anon_vma_cachep, GFP_KERNEL);
}
static inline void anon_vma_free(struct anon_vma *anon_vma)
{
	kmem_cache_free(anon_vma_cachep, anon_vma);
}
void __init anon_vma_init(void)
{
	anon_vma_cachep = kmem_cache_create("anon_vma", sizeof(struct anon_vma),
			0, SLAB_DESTROY_BY_RCU|SLAB_PANIC, anon_vma_ctor);
}
static unsigned long shmem_default_max_blocks(void)
{
	return totalram_pages / 2;
}
static unsigned long shmem_default_max_inodes(void)
{
	return min(totalram_pages - totalhigh_pages, totalram_pages / 2);
}
static inline struct page *shmem_dir_alloc(gfp_t gfp_mask)
{
	return alloc_pages((gfp_mask & ~GFP_MOVABLE_MASK) | __GFP_ZERO,
				PAGE_CACHE_SHIFT-PAGE_SHIFT);
}
static inline void shmem_dir_free(struct page *page)
{
	__free_pages(page, PAGE_CACHE_SHIFT-PAGE_SHIFT);
}
static struct page **shmem_dir_map(struct page *page)
{
	return (struct page **)kmap_atomic(page, KM_USER0);
}
static inline void shmem_dir_unmap(struct page **dir)
{
	kunmap_atomic(dir, KM_USER0);
}
static swp_entry_t *shmem_swp_map(struct page *page)
{
	return (swp_entry_t *)kmap_atomic(page, KM_USER1);
}
static inline void shmem_swp_balance_unmap(void)
{
	(void) kmap_atomic(ZERO_PAGE(0), KM_USER1);
}
static inline void shmem_swp_unmap(swp_entry_t *entry)
{
	kunmap_atomic(entry, KM_USER1);
}
static inline struct shmem_sb_info *SHMEM_SB(struct super_block *sb)
{
	return sb->s_fs_info;
}
static inline int shmem_acct_size(unsigned long flags, loff_t size)
{
	return (flags & VM_ACCOUNT) ?
		security_vm_enough_memory_kern(VM_ACCT(size)) : 0;
}
static inline int shmem_acct_block(unsigned long flags)
{
	return (flags & VM_ACCOUNT) ?
		0 : security_vm_enough_memory_kern(VM_ACCT(PAGE_CACHE_SIZE));
}
static void shmem_truncate(struct inode *inode)
{
	shmem_truncate_range(inode, inode->i_size, (loff_t)-1);
}
static inline struct page *shmem_swapin(swp_entry_t entry, gfp_t gfp,
			struct shmem_inode_info *info, unsigned long idx)
{
	return swapin_readahead(entry, gfp, NULL, 0);
}
static inline struct page *shmem_alloc_page(gfp_t gfp,
			struct shmem_inode_info *info, unsigned long idx)
{
	return alloc_page(gfp);
}
static inline struct mempolicy *shmem_get_sbmpol(struct shmem_sb_info *sbinfo)
{
	return NULL;
}
static int shmem_create(struct inode *dir, struct dentry *dentry, int mode,
		struct nameidata *nd)
{
	return shmem_mknod(dir, dentry, mode | S_IFREG, 0);
}
static size_t shmem_xattr_security_list(struct inode *inode, char *list,
					size_t list_len, const char *name,
					size_t name_len)
{
	return security_inode_listsecurity(inode, list, list_len);
}
static struct dentry *shmem_get_parent(struct dentry *child)
{
	return ERR_PTR(-ESTALE);
}
static void destroy_inodecache(void)
{
	kmem_cache_destroy(shmem_inode_cachep);
}
static int shmem_get_sb(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_nodev(fs_type, flags, data, shmem_fill_super, mnt);
}
int shmem_unuse(swp_entry_t entry, struct page *page)
{
	return 0;
}
static size_t
shmem_list_acl_access(struct inode *inode, char *list, size_t list_size,
		      const char *name, size_t name_len)
{
	return generic_acl_list(inode, &shmem_acl_ops, ACL_TYPE_ACCESS,
				list, list_size);
}
static size_t
shmem_list_acl_default(struct inode *inode, char *list, size_t list_size,
		       const char *name, size_t name_len)
{
	return generic_acl_list(inode, &shmem_acl_ops, ACL_TYPE_DEFAULT,
				list, list_size);
}
int
shmem_acl_init(struct inode *inode, struct inode *dir)
{
	return generic_acl_init(inode, dir, &shmem_acl_ops);
}
int
shmem_permission(struct inode *inode, int mask)
{
	return generic_permission(inode, mask, shmem_check_acl);
}
static int obj_offset(struct kmem_cache *cachep)
{
	return cachep->obj_offset;
}
static int obj_size(struct kmem_cache *cachep)
{
	return cachep->obj_size;
}
size_t slab_buffer_size(struct kmem_cache *cachep)
{
	return cachep->buffer_size;
}
static inline void page_set_cache(struct page *page, struct kmem_cache *cache)
{
	page->lru.next = (struct list_head *)cache;
}
static inline void page_set_slab(struct page *page, struct slab *slab)
{
	page->lru.prev = (struct list_head *)slab;
}
static inline void *index_to_obj(struct kmem_cache *cache, struct slab *slab,
				 unsigned int idx)
{
	return slab->s_mem + cache->buffer_size * idx;
}
int slab_is_available(void)
{
	return g_cpucache_up == FULL;
}
static inline struct array_cache *cpu_cache_get(struct kmem_cache *cachep)
{
	return cachep->array[smp_processor_id()];
}
static struct kmem_cache *kmem_find_general_cachep(size_t size, gfp_t gfpflags)
{
	return __find_general_cachep(size, gfpflags);
}
static size_t slab_mgmt_size(size_t nr_objs, size_t align)
{
	return ALIGN(sizeof(struct slab)+nr_objs*sizeof(kmem_bufctl_t), align);
}
static inline struct array_cache **alloc_alien_cache(int node, int limit)
{
	return (struct array_cache **)BAD_ALIEN_MAGIC;
}
static inline int cache_free_alien(struct kmem_cache *cachep, void *objp)
{
	return 0;
}
static inline void *alternate_node_alloc(struct kmem_cache *cachep,
		gfp_t flags)
{
	return NULL;
}
static inline void *____cache_alloc_node(struct kmem_cache *cachep,
		 gfp_t flags, int nodeid)
{
	return NULL;
}
static void check_irq_off(void)
{
	BUG_ON(!irqs_disabled());
}
static void check_irq_on(void)
{
	BUG_ON(irqs_disabled());
}
static inline kmem_bufctl_t *slab_bufctl(struct slab *slabp)
{
	return (kmem_bufctl_t *) (slabp + 1);
}
static __always_inline void *
__do_cache_alloc(struct kmem_cache *cachep, gfp_t flags)
{
	return ____cache_alloc(cachep, flags);
}
void *kmem_cache_alloc_notrace(struct kmem_cache *cachep, gfp_t flags)
{
	return __cache_alloc(cachep, flags, __builtin_return_address(0));
}
void *kmem_cache_alloc_node_notrace(struct kmem_cache *cachep,
				    gfp_t flags,
				    int nodeid)
{
	return __cache_alloc_node(cachep, flags, nodeid,
				  __builtin_return_address(0));
}
void *__kmalloc_node(size_t size, gfp_t flags, int node)
{
	return __do_kmalloc_node(size, flags, node,
			__builtin_return_address(0));
}
void *__kmalloc_node_track_caller(size_t size, gfp_t flags,
		int node, unsigned long caller)
{
	return __do_kmalloc_node(size, flags, node, (void *)caller);
}
void *__kmalloc_node(size_t size, gfp_t flags, int node)
{
	return __do_kmalloc_node(size, flags, node, NULL);
}
void *__kmalloc(size_t size, gfp_t flags)
{
	return __do_kmalloc(size, flags, __builtin_return_address(0));
}
void *__kmalloc_track_caller(size_t size, gfp_t flags, unsigned long caller)
{
	return __do_kmalloc(size, flags, (void *)caller);
}
void *__kmalloc(size_t size, gfp_t flags)
{
	return __do_kmalloc(size, flags, NULL);
}
unsigned int kmem_cache_size(struct kmem_cache *cachep)
{
	return obj_size(cachep);
}
const char *kmem_cache_name(struct kmem_cache *cachep)
{
	return cachep->name;
}
static void *s_next(struct seq_file *m, void *p, loff_t *pos)
{
	return seq_list_next(p, &cache_chain, pos);
}
static void s_stop(struct seq_file *m, void *p)
{
	mutex_unlock(&cache_chain_mutex);
}
static int slabinfo_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &slabinfo_op);
}
static inline void struct_slob_page_wrong_size(void)
{ BUILD_BUG_ON(sizeof(struct slob_page) != sizeof(struct page)); }
static inline int is_slob_page(struct slob_page *sp)
{
	return PageSlobPage((struct page *)sp);
}
static inline void set_slob_page(struct slob_page *sp)
{
	__SetPageSlobPage((struct page *)sp);
}
static inline void clear_slob_page(struct slob_page *sp)
{
	__ClearPageSlobPage((struct page *)sp);
}
static inline struct slob_page *slob_page(const void *addr)
{
	return (struct slob_page *)virt_to_page(addr);
}
static inline int slob_page_free(struct slob_page *sp)
{
	return PageSlobFree((struct page *)sp);
}
static int slob_last(slob_t *s)
{
	return !((unsigned long)slob_next(s) & ~PAGE_MASK);
}
static void slob_free_pages(void *b, int order)
{
	free_pages((unsigned long)b, order);
}
unsigned int kmem_cache_size(struct kmem_cache *c)
{
	return c->size;
}
const char *kmem_cache_name(struct kmem_cache *c)
{
	return c->name;
}
int kmem_cache_shrink(struct kmem_cache *d)
{
	return 0;
}
int kmem_ptr_validate(struct kmem_cache *a, const void *b)
{
	return 0;
}
int slab_is_available(void)
{
	return slob_ready;
}
void __init kmem_cache_init(void)
{
	slob_ready = 1;
}
static inline void struct_slqb_page_wrong_size(void)
{ BUILD_BUG_ON(sizeof(struct slqb_page) != sizeof(struct page)); }
static inline int slab_numa(struct kmem_cache *s)
{
	return s->flags & SLAB_NUMA;
}
static inline int slab_numa(struct kmem_cache *s)
{
	return 0;
}
static inline int slab_hiwater(struct kmem_cache *s)
{
	return s->hiwater;
}
static inline int slab_freebatch(struct kmem_cache *s)
{
	return s->freebatch;
}
static inline void slqb_stat_inc(struct kmem_cache_list *list,
				enum stat_item si)
{
	list->stats[si]++;
}
static inline void slqb_stat_add(struct kmem_cache_list *list,
				enum stat_item si, unsigned long nr)
{
	list->stats[si] += nr;
}
static inline int slqb_page_to_nid(struct slqb_page *page)
{
	return page_to_nid(&page->page);
}
static inline void *slqb_page_address(struct slqb_page *page)
{
	return page_address(&page->page);
}
static inline struct zone *slqb_page_zone(struct slqb_page *page)
{
	return page_zone(&page->page);
}
static inline int virt_to_nid(const void *addr)
{
	return page_to_nid(virt_to_page_fast(addr));
}
static inline int slab_debug(struct kmem_cache *s)
{
	return (s->flags &
			(SLAB_DEBUG_FREE |
			 SLAB_RED_ZONE |
			 SLAB_POISON |
			 SLAB_STORE_USER |
			 SLAB_TRACE));
}
static inline int slab_poison(struct kmem_cache *s)
{
	return s->flags & SLAB_POISON;
}
static inline int slab_debug(struct kmem_cache *s)
{
	return 0;
}
static inline int slab_poison(struct kmem_cache *s)
{
	return 0;
}
static inline int sysfs_slab_add(struct kmem_cache *s)
{
	return 0;
}
static inline void sysfs_slab_remove(struct kmem_cache *s)
{
	kmem_cache_free(&kmem_cache_cache, s);
}
int slab_is_available(void)
{
	return __slab_is_available;
}
static inline void *get_freepointer(struct kmem_cache *s, void *object)
{
	return *(void **)(object + s->offset);
}
static inline void set_freepointer(struct kmem_cache *s, void *object, void *fp)
{
	*(void **)(object + s->offset) = fp;
}
static void print_page_info(struct slqb_page *page)
{
	printk(KERN_ERR "INFO: Slab 0x%p used=%u fp=0x%p flags=0x%04lx\n",
		page, page->inuse, page->freelist, page->flags);
}
static inline int alloc_debug_processing(struct kmem_cache *s,
			void *object, void *addr)
{
	return 0;
}
static inline int free_debug_processing(struct kmem_cache *s,
			void *object, void *addr)
{
	return 0;
}
static inline int slab_pad_check(struct kmem_cache *s, struct slqb_page *page)
{
	return 1;
}
static inline int check_object(struct kmem_cache *s, struct slqb_page *page,
			void *object, int active)
{
	return 1;
}
void *kmem_cache_alloc(struct kmem_cache *s, gfp_t gfpflags)
{
	return __kmem_cache_alloc(s, gfpflags, __builtin_return_address(0));
}
void *kmem_cache_alloc_node(struct kmem_cache *s, gfp_t gfpflags, int node)
{
	return slab_alloc(s, gfpflags, node, __builtin_return_address(0));
}
static int alloc_kmem_cache_nodes(struct kmem_cache *s)
{
	return 1;
}
unsigned int kmem_cache_size(struct kmem_cache *s)
{
	return s->objsize;
}
const char *kmem_cache_name(struct kmem_cache *s)
{
	return s->name;
}
static void slab_mem_going_offline_callback(void *arg)
{
	kmem_cache_reap();
}
ssize_t slabinfo_write(struct file *file, const char __user * buffer,
		       size_t count, loff_t *ppos)
{
	return -EINVAL;
}
static void *s_next(struct seq_file *m, void *p, loff_t *pos)
{
	return seq_list_next(p, &slab_caches, pos);
}
static void s_stop(struct seq_file *m, void *p)
{
	up_read(&slqb_lock);
}
static int slabinfo_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &slabinfo_op);
}
static ssize_t slab_size_show(struct kmem_cache *s, char *buf)
{
	return sprintf(buf, "%d\n", s->size);
}
static ssize_t align_show(struct kmem_cache *s, char *buf)
{
	return sprintf(buf, "%d\n", s->align);
}
static ssize_t object_size_show(struct kmem_cache *s, char *buf)
{
	return sprintf(buf, "%d\n", s->objsize);
}
static ssize_t objs_per_slab_show(struct kmem_cache *s, char *buf)
{
	return sprintf(buf, "%d\n", s->objects);
}
static ssize_t order_show(struct kmem_cache *s, char *buf)
{
	return sprintf(buf, "%d\n", s->order);
}
static ssize_t reclaim_account_show(struct kmem_cache *s, char *buf)
{
	return sprintf(buf, "%d\n", !!(s->flags & SLAB_RECLAIM_ACCOUNT));
}
static ssize_t hwcache_align_show(struct kmem_cache *s, char *buf)
{
	return sprintf(buf, "%d\n", !!(s->flags & SLAB_HWCACHE_ALIGN));
}
static ssize_t cache_dma_show(struct kmem_cache *s, char *buf)
{
	return sprintf(buf, "%d\n", !!(s->flags & SLAB_CACHE_DMA));
}
static ssize_t destroy_by_rcu_show(struct kmem_cache *s, char *buf)
{
	return sprintf(buf, "%d\n", !!(s->flags & SLAB_DESTROY_BY_RCU));
}
static ssize_t red_zone_show(struct kmem_cache *s, char *buf)
{
	return sprintf(buf, "%d\n", !!(s->flags & SLAB_RED_ZONE));
}
static ssize_t poison_show(struct kmem_cache *s, char *buf)
{
	return sprintf(buf, "%d\n", !!(s->flags & SLAB_POISON));
}
static ssize_t store_user_show(struct kmem_cache *s, char *buf)
{
	return sprintf(buf, "%d\n", !!(s->flags & SLAB_STORE_USER));
}
static ssize_t hiwater_show(struct kmem_cache *s, char *buf)
{
	return sprintf(buf, "%d\n", slab_hiwater(s));
}
static ssize_t freebatch_show(struct kmem_cache *s, char *buf)
{
	return sprintf(buf, "%d\n", slab_freebatch(s));
}
static inline int sysfs_slab_add(struct kmem_cache *s) { return 0; }
static inline int sysfs_slab_alias(struct kmem_cache *s, const char *p)
							{ return 0; }
static inline void sysfs_slab_remove(struct kmem_cache *s)
{
	kfree(s);
}
static inline void stat(struct kmem_cache_cpu *c, enum stat_item si)
{
	c->stat[si]++;
}
int slab_is_available(void)
{
	return slab_state >= UP;
}
static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)
{
	return s->node[node];
}
static inline struct kmem_cache_cpu *get_cpu_slab(struct kmem_cache *s, int cpu)
{
	return s->cpu_slab[cpu];
}
static inline void *get_freepointer(struct kmem_cache *s, void *object)
{
	return *(void **)(object + s->offset);
}
static inline void set_freepointer(struct kmem_cache *s, void *object, void *fp)
{
	*(void **)(object + s->offset) = fp;
}
static inline int slab_index(void *p, struct kmem_cache *s, void *addr)
{
	return (p - addr) / s->size;
}
static inline int oo_order(struct kmem_cache_order_objects x)
{
	return x.x >> OO_SHIFT;
}
static inline int oo_objects(struct kmem_cache_order_objects x)
{
	return x.x & OO_MASK;
}
static void print_page_info(struct page *page)
{
	printk(KERN_ERR "INFO: Slab 0x%p objects=%u used=%u fp=0x%p flags=0x%04lx\n",
		page, page->objects, page->inuse, page->freelist, page->flags);
}
static inline int alloc_debug_processing(struct kmem_cache *s,
	struct page *page, void *object, unsigned long addr) { return 0; }
static inline int free_debug_processing(struct kmem_cache *s,
	struct page *page, void *object, unsigned long addr) { return 0; }
static inline int slab_pad_check(struct kmem_cache *s, struct page *page)
			{ return 1; }
static inline int check_object(struct kmem_cache *s, struct page *page,
			void *object, int active) { return 1; }
static inline unsigned long kmem_cache_flags(unsigned long objsize,
	unsigned long flags, const char *name,
	void (*ctor)(void *))
{
	return flags;
}
static inline unsigned long slabs_node(struct kmem_cache *s, int node)
							{ return 0; }
static __always_inline void slab_lock(struct page *page)
{
	bit_spin_lock(PG_locked, &page->flags);
}
static __always_inline void slab_unlock(struct page *page)
{
	__bit_spin_unlock(PG_locked, &page->flags);
}
static void flush_all(struct kmem_cache *s)
{
	on_each_cpu(flush_cpu_slab, s, 1);
}
void *kmem_cache_alloc_notrace(struct kmem_cache *s, gfp_t gfpflags)
{
	return slab_alloc(s, gfpflags, -1, _RET_IP_);
}
void *kmem_cache_alloc_node_notrace(struct kmem_cache *s,
				    gfp_t gfpflags,
				    int node)
{
	return slab_alloc(s, gfpflags, node, _RET_IP_);
}
unsigned int kmem_cache_size(struct kmem_cache *s)
{
	return s->objsize;
}
const char *kmem_cache_name(struct kmem_cache *s)
{
	return s->name;
}
static int count_inuse(struct page *page)
{
	return page->inuse;
}
static int count_total(struct page *page)
{
	return page->objects;
}
static int count_free(struct page *page)
{
	return page->objects - page->inuse;
}
static ssize_t slab_size_show(struct kmem_cache *s, char *buf)
{
	return sprintf(buf, "%d\n", s->size);
}
static ssize_t align_show(struct kmem_cache *s, char *buf)
{
	return sprintf(buf, "%d\n", s->align);
}
static ssize_t object_size_show(struct kmem_cache *s, char *buf)
{
	return sprintf(buf, "%d\n", s->objsize);
}
static ssize_t objs_per_slab_show(struct kmem_cache *s, char *buf)
{
	return sprintf(buf, "%d\n", oo_objects(s->oo));
}
static ssize_t order_show(struct kmem_cache *s, char *buf)
{
	return sprintf(buf, "%d\n", oo_order(s->oo));
}
static ssize_t aliases_show(struct kmem_cache *s, char *buf)
{
	return sprintf(buf, "%d\n", s->refcount - 1);
}
static ssize_t slabs_show(struct kmem_cache *s, char *buf)
{
	return show_slab_objects(s, buf, SO_ALL);
}
static ssize_t partial_show(struct kmem_cache *s, char *buf)
{
	return show_slab_objects(s, buf, SO_PARTIAL);
}
static ssize_t cpu_slabs_show(struct kmem_cache *s, char *buf)
{
	return show_slab_objects(s, buf, SO_CPU);
}
static ssize_t objects_show(struct kmem_cache *s, char *buf)
{
	return show_slab_objects(s, buf, SO_ALL|SO_OBJECTS);
}
static ssize_t objects_partial_show(struct kmem_cache *s, char *buf)
{
	return show_slab_objects(s, buf, SO_PARTIAL|SO_OBJECTS);
}
static ssize_t total_objects_show(struct kmem_cache *s, char *buf)
{
	return show_slab_objects(s, buf, SO_ALL|SO_TOTAL);
}
static ssize_t sanity_checks_show(struct kmem_cache *s, char *buf)
{
	return sprintf(buf, "%d\n", !!(s->flags & SLAB_DEBUG_FREE));
}
static ssize_t trace_show(struct kmem_cache *s, char *buf)
{
	return sprintf(buf, "%d\n", !!(s->flags & SLAB_TRACE));
}
static ssize_t reclaim_account_show(struct kmem_cache *s, char *buf)
{
	return sprintf(buf, "%d\n", !!(s->flags & SLAB_RECLAIM_ACCOUNT));
}
static ssize_t hwcache_align_show(struct kmem_cache *s, char *buf)
{
	return sprintf(buf, "%d\n", !!(s->flags & SLAB_HWCACHE_ALIGN));
}
static ssize_t cache_dma_show(struct kmem_cache *s, char *buf)
{
	return sprintf(buf, "%d\n", !!(s->flags & SLAB_CACHE_DMA));
}
static ssize_t destroy_by_rcu_show(struct kmem_cache *s, char *buf)
{
	return sprintf(buf, "%d\n", !!(s->flags & SLAB_DESTROY_BY_RCU));
}
static ssize_t red_zone_show(struct kmem_cache *s, char *buf)
{
	return sprintf(buf, "%d\n", !!(s->flags & SLAB_RED_ZONE));
}
static ssize_t poison_show(struct kmem_cache *s, char *buf)
{
	return sprintf(buf, "%d\n", !!(s->flags & SLAB_POISON));
}
static ssize_t store_user_show(struct kmem_cache *s, char *buf)
{
	return sprintf(buf, "%d\n", !!(s->flags & SLAB_STORE_USER));
}
static ssize_t validate_show(struct kmem_cache *s, char *buf)
{
	return 0;
}
static ssize_t shrink_show(struct kmem_cache *s, char *buf)
{
	return 0;
}
static ssize_t remote_node_defrag_ratio_show(struct kmem_cache *s, char *buf)
{
	return sprintf(buf, "%d\n", s->remote_node_defrag_ratio / 10);
}
static void *s_next(struct seq_file *m, void *p, loff_t *pos)
{
	return seq_list_next(p, &slab_caches, pos);
}
static void s_stop(struct seq_file *m, void *p)
{
	up_read(&slub_lock);
}
static int slabinfo_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &slabinfo_op);
}
static void * __init_refok __earlyonly_bootmem_alloc(int node,
				unsigned long size,
				unsigned long align,
				unsigned long goal)
{
	return __alloc_bootmem_node(NODE_DATA(node), size, align, goal);
}
int page_to_nid(struct page *page)
{
	return section_to_node_table[page_to_section(page)];
}
static void set_section_nid(unsigned long section_nr, int nid)
{
	section_to_node_table[section_nr] = nid;
}
static inline int sparse_index_init(unsigned long section_nr, int nid)
{
	return 0;
}
static inline unsigned long sparse_encode_early_nid(int nid)
{
	return (nid << SECTION_NID_SHIFT);
}
static inline int sparse_early_nid(struct mem_section *section)
{
	return (section->section_mem_map >> SECTION_NID_SHIFT);
}
static unsigned long sparse_encode_mem_map(struct page *mem_map, unsigned long pnum)
{
	return (unsigned long)(mem_map - (section_nr_to_pfn(pnum)));
}
static unsigned long *__kmalloc_section_usemap(void)
{
	return kmalloc(usemap_size(), GFP_KERNEL);
}
static unsigned long * __init
sparse_early_usemap_alloc_pgdat_section(struct pglist_data *pgdat)
{
	return NULL;
}
static inline struct page *kmalloc_section_memmap(unsigned long pnum, int nid,
						 unsigned long nr_pages)
{
	return sparse_mem_map_populate(pnum, nid);
}
static void __kfree_section_memmap(struct page *memmap, unsigned long nr_pages)
{
	return; /* XXX: Not implemented yet */
}
static inline struct page *kmalloc_section_memmap(unsigned long pnum, int nid,
						  unsigned long nr_pages)
{
	return __kmalloc_section_memmap(nr_pages);
}
static void lru_add_drain_per_cpu(struct work_struct *dummy)
{
	lru_add_drain();
}
int lru_add_drain_all(void)
{
	return schedule_on_each_cpu(lru_add_drain_per_cpu);
}
static void swap_stop(struct seq_file *swap, void *v)
{
	mutex_unlock(&swapon_mutex);
}
static int swaps_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &swaps_op);
}
struct swap_info_struct *
get_swap_info_struct(unsigned type)
{
	return &swap_info[type];
}
void truncate_inode_pages(struct address_space *mapping, loff_t lstart)
{
	truncate_inode_pages_range(mapping, lstart, (loff_t)-1);
}
unsigned long invalidate_mapping_pages(struct address_space *mapping,
				pgoff_t start, pgoff_t end)
{
	return __invalidate_mapping_pages(mapping, start, end, false);
}
int invalidate_inode_pages2(struct address_space *mapping)
{
	return invalidate_inode_pages2_range(mapping, 0, -1);
}
unsigned long vmalloc_to_pfn(const void *vmalloc_addr)
{
	return page_to_pfn(vmalloc_to_page(vmalloc_addr));
}
static void unmap_vmap_area(struct vmap_area *va)
{
	vunmap_page_range(va->va_start, va->va_end);
}
struct vm_struct *__get_vm_area(unsigned long size, unsigned long flags,
				unsigned long start, unsigned long end)
{
	return __get_vm_area_node(size, flags, start, end, -1, GFP_KERNEL,
						__builtin_return_address(0));
}
struct vm_struct *get_vm_area(unsigned long size, unsigned long flags)
{
	return __get_vm_area_node(size, flags, VMALLOC_START, VMALLOC_END,
				-1, GFP_KERNEL, __builtin_return_address(0));
}
struct vm_struct *get_vm_area_caller(unsigned long size, unsigned long flags,
				void *caller)
{
	return __get_vm_area_node(size, flags, VMALLOC_START, VMALLOC_END,
						-1, GFP_KERNEL, caller);
}
struct vm_struct *get_vm_area_node(unsigned long size, unsigned long flags,
				   int node, gfp_t gfp_mask)
{
	return __get_vm_area_node(size, flags, VMALLOC_START, VMALLOC_END, node,
				  gfp_mask, __builtin_return_address(0));
}
void *__vmalloc(unsigned long size, gfp_t gfp_mask, pgprot_t prot)
{
	return __vmalloc_node(size, gfp_mask, prot, -1,
				__builtin_return_address(0));
}
void *vmalloc(unsigned long size)
{
	return __vmalloc_node(size, GFP_KERNEL | __GFP_HIGHMEM, PAGE_KERNEL,
					-1, __builtin_return_address(0));
}
void *vmalloc_node(unsigned long size, int node)
{
	return __vmalloc_node(size, GFP_KERNEL | __GFP_HIGHMEM, PAGE_KERNEL,
					node, __builtin_return_address(0));
}
void *vmalloc_exec(unsigned long size)
{
	return __vmalloc_node(size, GFP_KERNEL | __GFP_HIGHMEM, PAGE_KERNEL_EXEC,
			      -1, __builtin_return_address(0));
}
void *vmalloc_32(unsigned long size)
{
	return __vmalloc_node(size, GFP_VMALLOC32, PAGE_KERNEL,
			      -1, __builtin_return_address(0));
}
static int f(pte_t *pte, pgtable_t table, unsigned long addr, void *data)
{
	return 0;
}
static void s_stop(struct seq_file *m, void *p)
{
	read_unlock(&vmlist_lock);
}
static inline int is_page_cache_freeable(struct page *page)
{
	return page_count(page) - !!page_has_private(page) == 2;
}
unsigned long global_lru_pages(void)
{
	return global_page_state(NR_ACTIVE_ANON)
		+ global_page_state(NR_ACTIVE_FILE)
		+ global_page_state(NR_INACTIVE_ANON)
		+ global_page_state(NR_INACTIVE_FILE);
}
static ssize_t read_scan_unevictable_node(struct sys_device *dev,
					  struct sysdev_attribute *attr,
					  char *buf)
{
	return sprintf(buf, "0\n");	/* always zero; should fit... */
}
int scan_unevictable_register_node(struct node *node)
{
	return sysdev_create_file(&node->sysdev, &attr_scan_unevictable_pages);
}
void scan_unevictable_unregister_node(struct node *node)
{
	sysdev_remove_file(&node->sysdev, &attr_scan_unevictable_pages);
}
void __inc_zone_page_state(struct page *page, enum zone_stat_item item)
{
	__inc_zone_state(page_zone(page), item);
}
void __dec_zone_page_state(struct page *page, enum zone_stat_item item)
{
	__dec_zone_state(page_zone(page), item);
}
static int fragmentation_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &fragmentation_op);
}
static int pagetypeinfo_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &pagetypeinfo_op);
}
static int zoneinfo_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &zoneinfo_op);
}
static int vmstat_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &vmstat_op);
}
struct net_device *alloc_fcdev(int sizeof_priv)
{
	return alloc_netdev(sizeof_priv, "fc%d", fc_setup);
}
struct net_device *alloc_fddidev(int sizeof_priv)
{
	return alloc_netdev(sizeof_priv, "fddi%d", fddi_setup);
}
void garp_unregister_application(struct garp_application *appl)
{
	stp_proto_unregister(&appl->proto);
}
struct net_device *alloc_hippi_dev(int sizeof_priv)
{
	return alloc_netdev(sizeof_priv, "hip%d", hippi_setup);
}
void destroy_8023_client(struct datalink_proto *dl)
{
	kfree(dl);
}
static void __exit snap_exit(void)
{
	llc_sap_put(snap_sap);
}
static void rif_seq_stop(struct seq_file *seq, void *v)
{
	spin_unlock_irq(&rif_lock);
}
static int rif_seq_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &rif_seq_ops);
}
struct net_device *alloc_trdev(int sizeof_priv)
{
	return alloc_netdev(sizeof_priv, "tr%d", tr_setup);
}
static inline unsigned int vlan_grp_hashfn(unsigned int idx)
{
	return ((idx >> VLAN_GRP_HASH_SHIFT) ^ idx) & VLAN_GRP_HASH_MASK;
}
static void vlan_rcu_free(struct rcu_head *rcu)
{
	vlan_group_free(container_of(rcu, struct vlan_group, rcu));
}
struct net_device *vlan_dev_real_dev(const struct net_device *dev)
{
	return vlan_dev_info(dev)->real_dev;
}
u16 vlan_dev_vlan_id(const struct net_device *dev)
{
	return vlan_dev_info(dev)->vlan_id;
}
void vlan_dev_get_realdev_name(const struct net_device *dev, char *result)
{
	strncpy(result, vlan_dev_info(dev)->real_dev->name, 23);
}
static void vlan_dev_set_lockdep_one(struct net_device *dev,
				     struct netdev_queue *txq,
				     void *_subclass)
{
	lockdep_set_class_and_subclass(&txq->_xmit_lock,
				       &vlan_netdev_xmit_lock_key,
				       *(int *)_subclass);
}
int vlan_gvrp_init_applicant(struct net_device *dev)
{
	return garp_init_applicant(dev, &vlan_gvrp_app);
}
void vlan_gvrp_uninit_applicant(struct net_device *dev)
{
	garp_uninit_applicant(dev, &vlan_gvrp_app);
}
int __init vlan_gvrp_init(void)
{
	return garp_register_application(&vlan_gvrp_app);
}
void vlan_gvrp_uninit(void)
{
	garp_unregister_application(&vlan_gvrp_app);
}
int __init vlan_netlink_init(void)
{
	return rtnl_link_register(&vlan_link_ops);
}
void __exit vlan_netlink_fini(void)
{
	rtnl_link_unregister(&vlan_link_ops);
}
static int vlan_seq_open(struct inode *inode, struct file *file)
{
	return seq_open_net(inode, file, &vlan_seq_ops,
			sizeof(struct seq_net_private));
}
static int vlandev_seq_open(struct inode *inode, struct file *file)
{
	return single_open(file, vlandev_seq_show, PDE(inode)->data);
}
static void vlan_seq_stop(struct seq_file *seq, void *v)
{
	read_unlock(&dev_base_lock);
}
int p9pdu_prepare(struct p9_fcall *pdu, int16_t tag, int8_t type)
{
	return p9pdu_writef(pdu, 0, "dbw", 0, type, tag);
}
static void
handle_send(struct p9_client *client, struct p9_trans_rdma *rdma,
	    struct p9_rdma_context *c, enum ib_wc_status status, u32 byte_len)
{
	ib_dma_unmap_single(rdma->cm_id->device,
			    c->busa, c->req->tc->size,
			    DMA_TO_DEVICE);
}
static void qp_event_handler(struct ib_event *event, void *context)
{
	P9_DPRINTK(P9_DEBUG_ERROR, "QP event %d context %p\n", event->event,
								context);
}
static void cq_event_handler(struct ib_event *e, void *v)
{
	P9_DPRINTK(P9_DEBUG_ERROR, "CQ event %d context %p\n", e->event, v);
}
static int rdma_cancel(struct p9_client *client, struct p9_req_t *req)
{
	return 1;
}
static void __exit p9_trans_rdma_exit(void)
{
	v9fs_unregister_trans(&p9_rdma_trans);
}
static unsigned int rest_of_page(void *data)
{
	return PAGE_SIZE - ((unsigned long)data % PAGE_SIZE);
}
static int p9_virtio_cancel(struct p9_client *client, struct p9_req_t *req)
{
	return 1;
}
int p9_idpool_check(int id, struct p9_idpool *p)
{
	return idr_find(&p->pool, id) != NULL;
}
static void aarp_seq_stop(struct seq_file *seq, void *v)
{
	read_unlock_bh(&aarp_lock);
}
static int aarp_seq_open(struct inode *inode, struct file *file)
{
	return seq_open_private(file, &aarp_seq_ops,
			sizeof(struct aarp_iter_state));
}
static void atalk_seq_interface_stop(struct seq_file *seq, void *v)
{
	read_unlock_bh(&atalk_interfaces_lock);
}
static void atalk_seq_route_stop(struct seq_file *seq, void *v)
{
	read_unlock_bh(&atalk_routes_lock);
}
static void atalk_seq_socket_stop(struct seq_file *seq, void *v)
{
	read_unlock_bh(&atalk_sockets_lock);
}
static int atalk_seq_interface_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &atalk_seq_interface_ops);
}
static int atalk_seq_route_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &atalk_seq_route_ops);
}
static int atalk_seq_socket_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &atalk_seq_socket_ops);
}
static inline void __atalk_insert_socket(struct sock *sk)
{
	sk_add_node(sk, &atalk_sockets);
}
static __inline__ int is_ip_over_ddp(struct sk_buff *skb)
{
	return skb->data[12] == 22;
}
static int atalk_compat_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)
{
	return -ENOIOCTLCMD;
}
static int ltalk_change_mtu(struct net_device *dev, int mtu)
{
	return -EINVAL;
}
struct net_device *alloc_ltalkdev(int sizeof_priv)
{
	return alloc_netdev(sizeof_priv, "lt%d", ltalk_setup);
}
void atalk_register_sysctl(void)
{
	atalk_table_header = register_sysctl_paths(atalk_path, atalk_table);
}
void atalk_unregister_sysctl(void)
{
	unregister_sysctl_table(atalk_table_header);
}
int __init atm_sysfs_init(void)
{
	return class_register(&atm_class);
}
void __exit atm_sysfs_exit(void)
{
	class_unregister(&atm_class);
}
static inline struct br2684_dev *BRPRIV(const struct net_device *net_dev)
{
	return (struct br2684_dev *)netdev_priv(net_dev);
}
static inline struct net_device *list_entry_brdev(const struct list_head *le)
{
	return list_entry(le, struct br2684_dev, br2684_devs)->net_dev;
}
static inline struct br2684_vcc *BR2684_VCC(const struct atm_vcc *atmvcc)
{
	return (struct br2684_vcc *)(atmvcc->user_back);
}
static inline struct br2684_vcc *list_entry_brvcc(const struct list_head *le)
{
	return list_entry(le, struct br2684_vcc, brvccs);
}
static inline struct br2684_vcc *pick_outgoing_vcc(const struct sk_buff *skb,
						   const struct br2684_dev *brdev)
{
	return list_empty(&brdev->brvccs) ? NULL : list_entry_brvcc(brdev->brvccs.next);	/* 1 vcc/dev right now */
}
static void *br2684_seq_next(struct seq_file *seq, void *v, loff_t * pos)
{
	return seq_list_next(v, &br2684_devs, pos);
}
static void br2684_seq_stop(struct seq_file *seq, void *v)
{
	read_unlock(&devs_lock);
}
static int br2684_proc_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &br2684_seq_ops);
}
static u32 clip_hash(const void *pkey, const struct net_device *dev)
{
	return jhash_2words(*(u32 *) pkey, dev->ifindex, clip_tbl.hash_rnd);
}
static int arp_seq_open(struct inode *inode, struct file *file)
{
	return seq_open_net(inode, file, &arp_seq_ops,
			    sizeof(struct clip_seq_state));
}
int vcc_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)
{
	return do_vcc_ioctl(sock, cmd, arg, 0);
}
int vcc_compat_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)
{
	return do_vcc_ioctl(sock, cmd, arg, 1);
}
static inline void lec_arp_hold(struct lec_arp_table *entry)
{
	atomic_inc(&entry->usage);
}
static void lec_set_multicast_list(struct net_device *dev)
{
	return;
}
static int lec_is_data_direct(struct atm_vcc *vcc)
{
	return ((vcc->sap.blli[0].l3.tr9577.snap[4] == LEC_DATA_DIRECT_8023) ||
		(vcc->sap.blli[0].l3.tr9577.snap[4] == LEC_DATA_DIRECT_8025));
}
static int lec_seq_open(struct inode *inode, struct file *file)
{
	return seq_open_private(file, &lec_seq_ops, sizeof(struct lec_state));
}
static int proc_mpc_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &mpc_op);
}
void mpc_proc_clean(void)
{
	remove_proc_entry(STAT_FILE_NAME,atm_proc_root);
}
static inline struct pppoatm_vcc *atmvcc_to_pvcc(const struct atm_vcc *atmvcc)
{
	return (struct pppoatm_vcc *) (atmvcc->user_back);
}
static inline struct pppoatm_vcc *chan_to_pvcc(const struct ppp_channel *chan)
{
	return (struct pppoatm_vcc *) (chan->private);
}
static void pppoatm_wakeup_sender(unsigned long arg)
{
	ppp_output_wakeup((struct ppp_channel *) arg);
}
static void __exit pppoatm_exit(void)
{
	deregister_atm_ioctl(&pppoatm_ioctl_ops);
}
static void add_stats(struct seq_file *seq, const char *aal,
  const struct k_atm_aal_stats *stats)
{
	seq_printf(seq, "%s ( %d %d %d %d %d )", aal,
	    atomic_read(&stats->tx),atomic_read(&stats->tx_err),
	    atomic_read(&stats->rx),atomic_read(&stats->rx_err),
	    atomic_read(&stats->rx_drop));
}
static inline int compare_family(struct sock *sk, int family)
{
	return !family || (sk->sk_family == family);
}
static inline void *vcc_walk(struct vcc_state *state, loff_t l)
{
	return __vcc_walk(&state->sk, state->family, &state->bucket, l) ?
	       state : NULL;
}
static void vcc_seq_stop(struct seq_file *seq, void *v)
{
	read_unlock(&vcc_sklist_lock);
}
static int atm_dev_seq_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &atm_dev_seq_ops);
}
static int pvc_seq_open(struct inode *inode, struct file *file)
{
	return __vcc_seq_open(inode, file, PF_ATMPVC, &pvc_seq_ops);
}
static int vcc_seq_open(struct inode *inode, struct file *file)
{
	return __vcc_seq_open(inode, file, 0, &vcc_seq_ops);
}
static int svc_seq_open(struct inode *inode, struct file *file)
{
	return __vcc_seq_open(inode, file, PF_ATMSVC, &svc_seq_ops);
}
void atm_proc_exit(void)
{
	atm_proc_dirs_remove();
}
static int pvc_shutdown(struct socket *sock,int how)
{
	return 0;
}
static int pvc_connect(struct socket *sock,struct sockaddr *sockaddr,
    int sockaddr_len,int flags)
{
	return pvc_bind(sock,sockaddr,sockaddr_len);
}
int __init atmpvc_init(void)
{
	return sock_register(&pvc_family_ops);
}
void atmpvc_exit(void)
{
	sock_unregister(PF_ATMPVC);
}
void atm_dev_seq_stop(struct seq_file *seq, void *v)
{
	mutex_unlock(&atm_dev_mutex);
}
void sigd_enq(struct atm_vcc *vcc,enum atmsvc_msg_type type,
    struct atm_vcc *listen_vcc,const struct sockaddr_atmpvc *pvc,
    const struct sockaddr_atmsvc *svc)
{
	sigd_enq2(vcc,type,listen_vcc,pvc,svc,vcc ? &vcc->qos : NULL,0);
}
static int svc_shutdown(struct socket *sock,int how)
{
	return 0;
}
int __init atmsvc_init(void)
{
	return sock_register(&svc_family_ops);
}
void atmsvc_exit(void)
{
	sock_unregister(PF_ATMSVC);
}
static void ax25_free_sock(struct sock *sk)
{
	ax25_cb_put(ax25_sk(sk));
}
static int ax25_shutdown(struct socket *sk, int how)
{
	return -EOPNOTSUPP;
}
static void ax25_info_stop(struct seq_file *seq, void *v)
{
	spin_unlock_bh(&ax25_list_lock);
}
static int ax25_info_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &ax25_info_seqops);
}
void ax25_ds_nr_error_recovery(ax25_cb *ax25)
{
	ax25_ds_establish_data_link(ax25);
}
void ax25_ds_setup_timer(ax25_dev *ax25_dev)
{
	setup_timer(&ax25_dev->dama.slave_timer, ax25_ds_timeout,
		    (unsigned long)ax25_dev);
}
int ax25_hard_header(struct sk_buff *skb, struct net_device *dev,
		     unsigned short type, const void *daddr,
		     const void *saddr, unsigned len)
{
	return -AX25_HEADER_LEN;
}

int ax25_rebuild_header(struct sk_buff *skb)
{
	return 1;
}
static void ax25_rt_seq_stop(struct seq_file *seq, void *v)
{
	read_unlock(&ax25_route_lock);
}
static int ax25_rt_info_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &ax25_rt_seqops);
}
void ax25_std_nr_error_recovery(ax25_cb *ax25)
{
	ax25_std_establish_data_link(ax25);
}
void ax25_start_heartbeat(ax25_cb *ax25)
{
	mod_timer(&ax25->timer, jiffies + 5 * HZ);
}
void ax25_start_t1timer(ax25_cb *ax25)
{
	mod_timer(&ax25->t1timer, jiffies + ax25->t1);
}
void ax25_start_t2timer(ax25_cb *ax25)
{
	mod_timer(&ax25->t2timer, jiffies + ax25->t2);
}
void ax25_stop_heartbeat(ax25_cb *ax25)
{
	del_timer(&ax25->timer);
}
void ax25_stop_t1timer(ax25_cb *ax25)
{
	del_timer(&ax25->t1timer);
}
void ax25_stop_t2timer(ax25_cb *ax25)
{
	del_timer(&ax25->t2timer);
}
void ax25_stop_t3timer(ax25_cb *ax25)
{
	del_timer(&ax25->t3timer);
}
void ax25_stop_idletimer(ax25_cb *ax25)
{
	del_timer(&ax25->idletimer);
}
int ax25_t1timer_running(ax25_cb *ax25)
{
	return timer_pending(&ax25->t1timer);
}
static void ax25_uid_seq_stop(struct seq_file *seq, void *v)
{
	read_unlock(&ax25_uid_lock);
}
static int ax25_uid_info_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &ax25_uid_seqops);
}
static void __exit bnep_exit(void)
{
	bnep_sock_cleanup();
}
static char *cmtp_procinfo(struct capi_ctr *ctrl)
{
	return "CAPI Message Transport Protocol";
}
static inline void cmtp_free_block_id(struct cmtp_session *session, int id)
{
	clear_bit(id, &session->blockids);
}
static void __exit cmtp_exit(void)
{
	cmtp_cleanup_sockets();
}
static void hci_cc_remote_name_req_cancel(struct hci_dev *hdev, struct sk_buff *skb)
{
	BT_DBG("%s", hdev->name);
}
static void hci_cs_remote_name_req(struct hci_dev *hdev, __u8 status)
{
	BT_DBG("%s status 0x%x", hdev->name, status);
}
static inline void hci_remote_version_evt(struct hci_dev *hdev, struct sk_buff *skb)
{
	BT_DBG("%s", hdev->name);
}
static inline void hci_qos_setup_complete_evt(struct hci_dev *hdev, struct sk_buff *skb)
{
	BT_DBG("%s", hdev->name);
}
static inline void hci_pin_code_request_evt(struct hci_dev *hdev, struct sk_buff *skb)
{
	BT_DBG("%s", hdev->name);
}
static inline void hci_link_key_request_evt(struct hci_dev *hdev, struct sk_buff *skb)
{
	BT_DBG("%s", hdev->name);
}
static inline void hci_link_key_notify_evt(struct hci_dev *hdev, struct sk_buff *skb)
{
	BT_DBG("%s", hdev->name);
}
static inline void hci_sync_conn_changed_evt(struct hci_dev *hdev, struct sk_buff *skb)
{
	BT_DBG("%s", hdev->name);
}
static inline int hci_test_bit(int nr, void *addr)
{
	return *((__u32 *) addr + (nr >> 5)) & ((__u32) 1 << (nr & 31));
}
static int __match_tty(struct device *dev, void *data)
{
	return !strncmp(dev_name(dev), "rfcomm", 6);
}
static int hidp_open(struct hid_device *hid)
{
	return 0;
}
void l2cap_load(void)
{
	return;
}
static inline u8 __fcs(u8 *data)
{
	return (0xff - __crc(data));
}
static inline u8 __fcs2(u8 *data)
{
	return (0xff - rfcomm_crc_table[__crc(data) ^ data[2]]);
}
static inline void rfcomm_dev_hold(struct rfcomm_dev *dev)
{
	atomic_inc(&dev->refcnt);
}
static inline unsigned int rfcomm_room(struct rfcomm_dlc *dlc)
{
	return dlc->mtu * (dlc->tx_credits?:1);
}
static void rfcomm_tty_send_xchar(struct tty_struct *tty, char ch)
{
	BT_DBG("tty %p ch %c", tty, ch);
}
static void rfcomm_tty_wait_until_sent(struct tty_struct *tty, int timeout)
{
	BT_DBG("tty %p timeout %d", tty, timeout);
}
static int rfcomm_tty_read_proc(char *buf, char **start, off_t offset, int len, int *eof, void *unused)
{
	return 0;
}
void br_fdb_fini(void)
{
	kmem_cache_destroy(br_fdb_cache);
}
static inline unsigned long hold_time(const struct net_bridge *br)
{
	return br->topology_change ? br->forward_delay : br->ageing_time;
}
static inline int has_expired(const struct net_bridge *br,
				  const struct net_bridge_fdb_entry *fdb)
{
	return !fdb->is_static
		&& time_before_eq(fdb->ageing_timer + hold_time(br), jiffies);
}
static inline int should_deliver(const struct net_bridge_port *p,
				 const struct sk_buff *skb)
{
	return (skb->dev != p->dev && p->state == BR_STATE_FORWARDING);
}
static inline unsigned packet_length(const struct sk_buff *skb)
{
	return skb->len - (skb->protocol == htons(ETH_P_8021Q) ? VLAN_HLEN : 0);
}
int br_forward_finish(struct sk_buff *skb)
{
	return NF_HOOK(PF_BRIDGE, NF_BR_POST_ROUTING, skb, NULL, skb->dev,
		       br_dev_queue_push_xmit);
}
void br_flood_deliver(struct net_bridge *br, struct sk_buff *skb)
{
	br_flood(br, skb, __br_deliver);
}
void br_flood_forward(struct net_bridge *br, struct sk_buff *skb)
{
	br_flood(br, skb, __br_forward);
}
static inline __be16 vlan_proto(const struct sk_buff *skb)
{
	return vlan_eth_hdr(skb)->h_vlan_encapsulated_proto;
}
static inline __be16 pppoe_proto(const struct sk_buff *skb)
{
	return *((__be16 *)(skb_mac_header(skb) + ETH_HLEN +
			    sizeof(struct pppoe_hdr)));
}
static int br_nf_dev_queue_xmit(struct sk_buff *skb)
{
	if (skb->protocol == htons(ETH_P_IP) &&
	    skb->len > skb->dev->mtu &&
	    !skb_is_gso(skb))
		return ip_fragment(skb, br_dev_queue_push_xmit);
	else
		return br_dev_queue_push_xmit(skb);
}
static inline size_t br_nlmsg_size(void)
{
	return NLMSG_ALIGN(sizeof(struct ifinfomsg))
	       + nla_total_size(IFNAMSIZ) /* IFLA_IFNAME */
	       + nla_total_size(MAX_ADDR_LEN) /* IFLA_ADDRESS */
	       + nla_total_size(4) /* IFLA_MASTER */
	       + nla_total_size(4) /* IFLA_MTU */
	       + nla_total_size(4) /* IFLA_LINK */
	       + nla_total_size(1) /* IFLA_OPERSTATE */
	       + nla_total_size(1); /* IFLA_PROTINFO */
}
void __exit br_netlink_fini(void)
{
	rtnl_unregister_all(PF_BRIDGE);
}
void br_log_state(const struct net_bridge_port *p)
{
	pr_info("%s: port %d(%s) entering %s state\n",
		p->br->dev->name, p->port_no, p->dev->name,
		br_port_state_names[p->state]);
}
void br_transmit_tcn(struct net_bridge *br)
{
	br_send_tcn_bpdu(br_get_port(br, br->root_port));
}
static inline void br_reply(struct net_bridge_port *p)
{
	br_transmit_config(p);
}
static inline port_id br_make_port_id(__u8 priority, __u16 port_no)
{
	return ((u16)priority << BR_PORT_BITS)
		| (port_no & ((1<<BR_PORT_BITS)-1));
}
ssize_t br_show_bridge_id(char *buf, const struct bridge_id *id)
{
	return sprintf(buf, "%.2x%.2x.%.2x%.2x%.2x%.2x%.2x%.2x\n",
	       id->prio[0], id->prio[1],
	       id->addr[0], id->addr[1], id->addr[2],
	       id->addr[3], id->addr[4], id->addr[5]);
}
unsigned long br_timer_value(const struct timer_list *timer)
{
	return timer_pending(timer)
		? jiffies_to_clock_t(timer->expires - jiffies) : 0;
}
static ssize_t store_forward_delay(struct device *d,
				   struct device_attribute *attr,
				   const char *buf, size_t len)
{
	return store_bridge_parm(d, buf, len, set_forward_delay);
}
static ssize_t show_hello_time(struct device *d, struct device_attribute *attr,
			       char *buf)
{
	return sprintf(buf, "%lu\n",
		       jiffies_to_clock_t(to_bridge(d)->hello_time));
}
static ssize_t store_hello_time(struct device *d,
				struct device_attribute *attr, const char *buf,
				size_t len)
{
	return store_bridge_parm(d, buf, len, set_hello_time);
}
static ssize_t show_max_age(struct device *d, struct device_attribute *attr,
			    char *buf)
{
	return sprintf(buf, "%lu\n",
		       jiffies_to_clock_t(to_bridge(d)->max_age));
}
static ssize_t store_max_age(struct device *d, struct device_attribute *attr,
			     const char *buf, size_t len)
{
	return store_bridge_parm(d, buf, len, set_max_age);
}
static ssize_t store_ageing_time(struct device *d,
				 struct device_attribute *attr,
				 const char *buf, size_t len)
{
	return store_bridge_parm(d, buf, len, set_ageing_time);
}
static ssize_t store_priority(struct device *d, struct device_attribute *attr,
			       const char *buf, size_t len)
{
	return store_bridge_parm(d, buf, len, set_priority);
}
static ssize_t show_root_id(struct device *d, struct device_attribute *attr,
			    char *buf)
{
	return br_show_bridge_id(buf, &to_bridge(d)->designated_root);
}
static ssize_t show_bridge_id(struct device *d, struct device_attribute *attr,
			      char *buf)
{
	return br_show_bridge_id(buf, &to_bridge(d)->bridge_id);
}
static ssize_t show_root_port(struct device *d, struct device_attribute *attr,
			      char *buf)
{
	return sprintf(buf, "%d\n", to_bridge(d)->root_port);
}
static ssize_t show_root_path_cost(struct device *d,
				   struct device_attribute *attr, char *buf)
{
	return sprintf(buf, "%d\n", to_bridge(d)->root_path_cost);
}
static ssize_t show_topology_change(struct device *d,
				    struct device_attribute *attr, char *buf)
{
	return sprintf(buf, "%d\n", to_bridge(d)->topology_change);
}
static ssize_t show_path_cost(struct net_bridge_port *p, char *buf)
{
	return sprintf(buf, "%d\n", p->path_cost);
}
static ssize_t show_priority(struct net_bridge_port *p, char *buf)
{
	return sprintf(buf, "%d\n", p->priority);
}
static ssize_t show_designated_root(struct net_bridge_port *p, char *buf)
{
	return br_show_bridge_id(buf, &p->designated_root);
}
static ssize_t show_designated_bridge(struct net_bridge_port *p, char *buf)
{
	return br_show_bridge_id(buf, &p->designated_bridge);
}
static ssize_t show_designated_port(struct net_bridge_port *p, char *buf)
{
	return sprintf(buf, "%d\n", p->designated_port);
}
static ssize_t show_designated_cost(struct net_bridge_port *p, char *buf)
{
	return sprintf(buf, "%d\n", p->designated_cost);
}
static ssize_t show_port_id(struct net_bridge_port *p, char *buf)
{
	return sprintf(buf, "0x%x\n", p->port_id);
}
static ssize_t show_port_no(struct net_bridge_port *p, char *buf)
{
	return sprintf(buf, "0x%x\n", p->port_no);
}
static ssize_t show_change_ack(struct net_bridge_port *p, char *buf)
{
	return sprintf(buf, "%d\n", p->topology_change_ack);
}
static ssize_t show_config_pending(struct net_bridge_port *p, char *buf)
{
	return sprintf(buf, "%d\n", p->config_pending);
}
static ssize_t show_port_state(struct net_bridge_port *p, char *buf)
{
	return sprintf(buf, "%d\n", p->state);
}
static ssize_t show_message_age_timer(struct net_bridge_port *p,
					    char *buf)
{
	return sprintf(buf, "%ld\n", br_timer_value(&p->message_age_timer));
}
static ssize_t show_forward_delay_timer(struct net_bridge_port *p,
					    char *buf)
{
	return sprintf(buf, "%ld\n", br_timer_value(&p->forward_delay_timer));
}
static ssize_t show_hold_timer(struct net_bridge_port *p,
					    char *buf)
{
	return sprintf(buf, "%ld\n", br_timer_value(&p->hold_timer));
}
static int __init ebt_802_3_init(void)
{
	return xt_register_match(&ebt_802_3_mt_reg);
}
static void __exit ebt_802_3_fini(void)
{
	xt_unregister_match(&ebt_802_3_mt_reg);
}
static int __init ebt_among_init(void)
{
	return xt_register_match(&ebt_among_mt_reg);
}
static void __exit ebt_among_fini(void)
{
	xt_unregister_match(&ebt_among_mt_reg);
}
static int __init ebt_arp_init(void)
{
	return xt_register_match(&ebt_arp_mt_reg);
}
static void __exit ebt_arp_fini(void)
{
	xt_unregister_match(&ebt_arp_mt_reg);
}
static int __init ebt_arpreply_init(void)
{
	return xt_register_target(&ebt_arpreply_tg_reg);
}
static void __exit ebt_arpreply_fini(void)
{
	xt_unregister_target(&ebt_arpreply_tg_reg);
}
static int __init ebt_dnat_init(void)
{
	return xt_register_target(&ebt_dnat_tg_reg);
}
static void __exit ebt_dnat_fini(void)
{
	xt_unregister_target(&ebt_dnat_tg_reg);
}
static int __init ebt_ip_init(void)
{
	return xt_register_match(&ebt_ip_mt_reg);
}
static void __exit ebt_ip_fini(void)
{
	xt_unregister_match(&ebt_ip_mt_reg);
}
static int __init ebt_ip6_init(void)
{
	return xt_register_match(&ebt_ip6_mt_reg);
}
static void __exit ebt_ip6_fini(void)
{
	xt_unregister_match(&ebt_ip6_mt_reg);
}
static int __init ebt_limit_init(void)
{
	return xt_register_match(&ebt_limit_mt_reg);
}
static void __exit ebt_limit_fini(void)
{
	xt_unregister_match(&ebt_limit_mt_reg);
}
static int __init ebt_mark_init(void)
{
	return xt_register_target(&ebt_mark_tg_reg);
}
static void __exit ebt_mark_fini(void)
{
	xt_unregister_target(&ebt_mark_tg_reg);
}
static int __init ebt_mark_m_init(void)
{
	return xt_register_match(&ebt_mark_mt_reg);
}
static void __exit ebt_mark_m_fini(void)
{
	xt_unregister_match(&ebt_mark_mt_reg);
}
static int __init ebt_nflog_init(void)
{
	return xt_register_target(&ebt_nflog_tg_reg);
}
static void __exit ebt_nflog_fini(void)
{
	xt_unregister_target(&ebt_nflog_tg_reg);
}
static int __init ebt_pkttype_init(void)
{
	return xt_register_match(&ebt_pkttype_mt_reg);
}
static void __exit ebt_pkttype_fini(void)
{
	xt_unregister_match(&ebt_pkttype_mt_reg);
}
static int __init ebt_redirect_init(void)
{
	return xt_register_target(&ebt_redirect_tg_reg);
}
static void __exit ebt_redirect_fini(void)
{
	xt_unregister_target(&ebt_redirect_tg_reg);
}
static int __init ebt_snat_init(void)
{
	return xt_register_target(&ebt_snat_tg_reg);
}
static void __exit ebt_snat_fini(void)
{
	xt_unregister_target(&ebt_snat_tg_reg);
}
static int __init ebt_stp_init(void)
{
	return xt_register_match(&ebt_stp_mt_reg);
}
static void __exit ebt_stp_fini(void)
{
	xt_unregister_match(&ebt_stp_mt_reg);
}
static void __exit ebt_vlan_fini(void)
{
	xt_unregister_match(&ebt_vlan_mt_reg);
}
static unsigned int
ebt_in_hook(unsigned int hook, struct sk_buff *skb, const struct net_device *in,
   const struct net_device *out, int (*okfn)(struct sk_buff *))
{
	return ebt_do_table(hook, skb, in, out, dev_net(in)->xt.frame_filter);
}
static unsigned int
ebt_out_hook(unsigned int hook, struct sk_buff *skb, const struct net_device *in,
   const struct net_device *out, int (*okfn)(struct sk_buff *))
{
	return ebt_do_table(hook, skb, in, out, dev_net(out)->xt.frame_filter);
}
static unsigned int
ebt_nat_in(unsigned int hook, struct sk_buff *skb, const struct net_device *in
   , const struct net_device *out, int (*okfn)(struct sk_buff *))
{
	return ebt_do_table(hook, skb, in, out, dev_net(in)->xt.frame_nat);
}
static unsigned int
ebt_nat_out(unsigned int hook, struct sk_buff *skb, const struct net_device *in
   , const struct net_device *out, int (*okfn)(struct sk_buff *))
{
	return ebt_do_table(hook, skb, in, out, dev_net(out)->xt.frame_nat);
}
static void *
find_inlist_lock(struct list_head *head, const char *name, const char *prefix,
   int *error, struct mutex *mutex)
{
	return try_then_request_module(
			find_inlist_lock_noload(head, name, error, mutex),
			"%s%s", prefix, name);
}
static inline struct ebt_table *
find_table_lock(struct net *net, const char *name, int *error,
		struct mutex *mutex)
{
	return find_inlist_lock(&net->xt.tables[NFPROTO_BRIDGE], name,
				"ebtable_", error, mutex);
}
static void can_sock_destruct(struct sock *sk)
{
	skb_queue_purge(&sk->sk_receive_queue);
}
static inline u64 GET_U64(const struct can_frame *cp)
{
	return *(u64 *)cp->data;
}
static inline struct bcm_sock *bcm_sk(const struct sock *sk)
{
	return (struct bcm_sock *)sk;
}
static struct proc_dir_entry *can_create_proc_readentry(const char *name,
							mode_t mode,
							read_proc_t *read_proc,
							void *data)
{
	if (can_dir)
		return create_proc_read_entry(name, mode, can_dir, read_proc,
					      data);
	else
		return NULL;
}
static inline struct raw_sock *raw_sk(const struct sock *sk)
{
	return (struct raw_sock *)sk;
}
static __exit void raw_module_exit(void)
{
	can_proto_unregister(&raw_can_proto);
}
asmlinkage long compat_sys_sendmsg(int fd, struct compat_msghdr __user *msg, unsigned flags)
{
	return sys_sendmsg(fd, (struct msghdr __user *)msg, flags | MSG_CMSG_COMPAT);
}
asmlinkage long compat_sys_recvmsg(int fd, struct compat_msghdr __user *msg, unsigned int flags)
{
	return sys_recvmsg(fd, (struct msghdr __user *)msg, flags | MSG_CMSG_COMPAT);
}
static inline int connection_based(struct sock *sk)
{
	return sk->sk_type == SOCK_SEQPACKET || sk->sk_type == SOCK_STREAM;
}
__sum16 __skb_checksum_complete(struct sk_buff *skb)
{
	return __skb_checksum_complete_head(skb, skb->len);
}
static inline struct hlist_head *dev_index_hash(struct net *net, int ifindex)
{
	return &net->dev_index_head[ifindex & ((1 << NETDEV_HASHBITS) - 1)];
}
void netdev_features_change(struct net_device *dev)
{
	call_netdevice_notifiers(NETDEV_FEAT_CHANGE, dev);
}
void netdev_bonding_change(struct net_device *dev)
{
	call_netdevice_notifiers(NETDEV_BONDING_FAILOVER, dev);
}
int call_netdevice_notifiers(unsigned long val, struct net_device *dev)
{
	return raw_notifier_call_chain(&netdev_chain, val, dev);
}
void net_enable_timestamp(void)
{
	atomic_inc(&netstamp_needed);
}
void net_disable_timestamp(void)
{
	atomic_dec(&netstamp_needed);
}
static bool can_checksum_protocol(unsigned long features, __be16 protocol)
{
	return ((features & NETIF_F_GEN_CSUM) ||
		((features & NETIF_F_IP_CSUM) &&
		 protocol == htons(ETH_P_IP)) ||
		((features & NETIF_F_IPV6_CSUM) &&
		 protocol == htons(ETH_P_IPV6)));
}
void dev_seq_stop(struct seq_file *seq, void *v)
{
	read_unlock(&dev_base_lock);
}
static void *softnet_seq_start(struct seq_file *seq, loff_t *pos)
{
	return softnet_get_online(pos);
}
static int dev_seq_open(struct inode *inode, struct file *file)
{
	return seq_open_net(inode, file, &dev_seq_ops,
			    sizeof(struct seq_net_private));
}
static int softnet_seq_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &softnet_seq_ops);
}
static void ptype_seq_stop(struct seq_file *seq, void *v)
{
	rcu_read_unlock();
}
static int ptype_seq_open(struct inode *inode, struct file *file)
{
	return seq_open_net(inode, file, &ptype_seq_ops,
			sizeof(struct seq_net_private));
}
static int __init dev_proc_init(void)
{
	return register_pernet_subsys(&dev_proc_ops);
}
static void net_set_todo(struct net_device *dev)
{
	list_add_tail(&dev->todo_list, &net_todo_list);
}
static void netdev_init_one_queue(struct net_device *dev,
				  struct netdev_queue *queue,
				  void *_unused)
{
	queue->dev = dev;
}
static int dev_mc_seq_open(struct inode *inode, struct file *file)
{
	return seq_open_net(inode, file, &dev_mc_seq_ops,
			    sizeof(struct seq_net_private));
}
void __init dev_mcast_init(void)
{
	register_pernet_subsys(&dev_mc_net_ops);
}
void __init dst_init(void)
{
	register_netdevice_notifier(&dst_dev_notifier);
}
u32 ethtool_op_get_link(struct net_device *dev)
{
	return netif_carrier_ok(dev) ? 1 : 0;
}
u32 ethtool_op_get_tx_csum(struct net_device *dev)
{
	return (dev->features & NETIF_F_ALL_CSUM) != 0;
}
u32 ethtool_op_get_sg(struct net_device *dev)
{
	return (dev->features & NETIF_F_SG) != 0;
}
u32 ethtool_op_get_tso(struct net_device *dev)
{
	return (dev->features & NETIF_F_TSO) != 0;
}
u32 ethtool_op_get_ufo(struct net_device *dev)
{
	return (dev->features & NETIF_F_UFO) != 0;
}
u32 ethtool_op_get_flags(struct net_device *dev)
{
	return dev->features & flags_dup_features;
}
int
gnet_stats_start_copy(struct sk_buff *skb, int type, spinlock_t *lock,
	struct gnet_dump *d)
{
	return gnet_stats_start_copy_compat(skb, type, 0, 0, lock, d);
}
static bool linkwatch_urgent_event(struct net_device *dev)
{
	return netif_running(dev) && netif_carrier_ok(dev) &&
		qdisc_tx_changing(dev);
}
void linkwatch_run_queue(void)
{
	__linkwatch_run_queue(0);
}
unsigned long neigh_rand_reach_time(unsigned long base)
{
	return (base ? (net_random() % base) + (base >> 1) : 0);
}
static inline size_t neigh_nlmsg_size(void)
{
	return NLMSG_ALIGN(sizeof(struct ndmsg))
	       + nla_total_size(MAX_ADDR_LEN) /* NDA_DST */
	       + nla_total_size(MAX_ADDR_LEN) /* NDA_LLADDR */
	       + nla_total_size(sizeof(struct nda_cacheinfo))
	       + nla_total_size(4); /* NDA_PROBES */
}
void neigh_app_ns(struct neighbour *n)
{
	__neigh_notify(n, RTM_GETNEIGH, NLM_F_REQUEST);
}
static inline int dev_isalive(const struct net_device *dev)
{
	return dev->reg_state <= NETREG_REGISTERED;
}
static int change_mtu(struct net_device *net, unsigned long new_mtu)
{
	return dev_set_mtu(net, (int) new_mtu);
}
static ssize_t store_mtu(struct device *dev, struct device_attribute *attr,
			 const char *buf, size_t len)
{
	return netdev_store(dev, attr, buf, len, change_mtu);
}
static int change_flags(struct net_device *net, unsigned long new_flags)
{
	return dev_change_flags(net, (unsigned) new_flags);
}
static ssize_t store_flags(struct device *dev, struct device_attribute *attr,
			   const char *buf, size_t len)
{
	return netdev_store(dev, attr, buf, len, change_flags);
}
static ssize_t store_tx_queue_len(struct device *dev,
				  struct device_attribute *attr,
				  const char *buf, size_t len)
{
	return netdev_store(dev, attr, buf, len, change_tx_queue_len);
}
int netdev_class_create_file(struct class_attribute *class_attr)
{
	return class_create_file(&net_class, class_attr);
}
void netdev_class_remove_file(struct class_attribute *class_attr)
{
	class_remove_file(&net_class, class_attr);
}
int netdev_kobject_init(void)
{
	return class_register(&net_class);
}
static struct net *net_alloc(void)
{
	return kmem_cache_zalloc(net_cachep, GFP_KERNEL);
}
int unregister_netevent_notifier(struct notifier_block *nb)
{
	return atomic_notifier_chain_unregister(&netevent_notif_chain, nb);
}
int call_netevent_notifiers(unsigned long val, void *v)
{
	return atomic_notifier_call_chain(&netevent_notif_chain, val, v);
}
int netpoll_trap(void)
{
	return atomic_read(&trapped);
}
static int pgctrl_open(struct inode *inode, struct file *file)
{
	return single_open(file, pgctrl_show, PDE(inode)->data);
}
static int pktgen_if_open(struct inode *inode, struct file *file)
{
	return single_open(file, pktgen_if_show, PDE(inode)->data);
}
static int pktgen_thread_open(struct inode *inode, struct file *file)
{
	return single_open(file, pktgen_thread_show, PDE(inode)->data);
}
static inline int f_seen(struct pktgen_dev *pkt_dev, int flow)
{
	if (pkt_dev->flows[flow].flags & F_INIT)
		return 1;
	else
		return 0;
}
static inline __be16 build_tci(unsigned int id, unsigned int cfi,
			       unsigned int prio)
{
	return htons(id | (cfi << 12) | (prio << 13));
}
static char tohex(char hexdigit)
{
	return hexdigit > 9 ? hexdigit + 'a' - 10 : hexdigit + '0';
}
static inline struct sk_buff *fill_packet(struct net_device *odev,
					  struct pktgen_dev *pkt_dev)
{
	if (pkt_dev->flags & F_IPV6)
		return fill_packet_ipv6(odev, pkt_dev);
	else
		return fill_packet_ipv4(odev, pkt_dev);
}
void rtnl_lock(void)
{
	mutex_lock(&rtnl_mutex);
}
void __rtnl_unlock(void)
{
	mutex_unlock(&rtnl_mutex);
}
void rtnl_unlock(void)
{
	netdev_run_todo();
}
int rtnl_trylock(void)
{
	return mutex_trylock(&rtnl_mutex);
}
int rtnl_is_locked(void)
{
	return mutex_is_locked(&rtnl_mutex);
}
static inline size_t if_nlmsg_size(const struct net_device *dev)
{
	return NLMSG_ALIGN(sizeof(struct ifinfomsg))
	       + nla_total_size(IFNAMSIZ) /* IFLA_IFNAME */
	       + nla_total_size(IFALIASZ) /* IFLA_IFALIAS */
	       + nla_total_size(IFNAMSIZ) /* IFLA_QDISC */
	       + nla_total_size(sizeof(struct rtnl_link_ifmap))
	       + nla_total_size(sizeof(struct rtnl_link_stats))
	       + nla_total_size(MAX_ADDR_LEN) /* IFLA_ADDRESS */
	       + nla_total_size(MAX_ADDR_LEN) /* IFLA_BROADCAST */
	       + nla_total_size(4) /* IFLA_TXQLEN */
	       + nla_total_size(4) /* IFLA_WEIGHT */
	       + nla_total_size(4) /* IFLA_MTU */
	       + nla_total_size(4) /* IFLA_LINK */
	       + nla_total_size(4) /* IFLA_MASTER */
	       + nla_total_size(1) /* IFLA_OPERSTATE */
	       + nla_total_size(1) /* IFLA_LINKMODE */
	       + rtnl_link_get_size(dev); /* IFLA_LINKINFO */
}
static inline void sock_lock_init(struct sock *sk)
{
	sock_lock_init_class_and_name(sk,
			af_family_slock_key_strings[sk->sk_family],
			af_family_slock_keys + sk->sk_family,
			af_family_key_strings[sk->sk_family],
			af_family_keys + sk->sk_family);
}
struct sk_buff *sock_alloc_send_skb(struct sock *sk, unsigned long size,
				    int noblock, int *errcode)
{
	return sock_alloc_send_pskb(sk, size, 0, noblock, errcode);
}
int sock_no_bind(struct socket *sock, struct sockaddr *saddr, int len)
{
	return -EOPNOTSUPP;
}
int sock_no_connect(struct socket *sock, struct sockaddr *saddr,
		    int len, int flags)
{
	return -EOPNOTSUPP;
}
int sock_no_socketpair(struct socket *sock1, struct socket *sock2)
{
	return -EOPNOTSUPP;
}
int sock_no_accept(struct socket *sock, struct socket *newsock, int flags)
{
	return -EOPNOTSUPP;
}
int sock_no_getname(struct socket *sock, struct sockaddr *saddr,
		    int *len, int peer)
{
	return -EOPNOTSUPP;
}
unsigned int sock_no_poll(struct file * file, struct socket *sock, poll_table *pt)
{
	return 0;
}
int sock_no_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)
{
	return -EOPNOTSUPP;
}
int sock_no_listen(struct socket *sock, int backlog)
{
	return -EOPNOTSUPP;
}
int sock_no_shutdown(struct socket *sock, int how)
{
	return -EOPNOTSUPP;
}
int sock_no_setsockopt(struct socket *sock, int level, int optname,
		    char __user *optval, int optlen)
{
	return -EOPNOTSUPP;
}
int sock_no_getsockopt(struct socket *sock, int level, int optname,
		    char __user *optval, int __user *optlen)
{
	return -EOPNOTSUPP;
}
int sock_no_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *m,
		    size_t len)
{
	return -EOPNOTSUPP;
}
int sock_no_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *m,
		    size_t len, int flags)
{
	return -EOPNOTSUPP;
}
int sock_no_mmap(struct file *file, struct socket *sock, struct vm_area_struct *vma)
{
	return -ENODEV;
}
static void sock_def_destruct(struct sock *sk)
{
	kfree(sk->sk_protinfo);
}
static void sock_inuse_exit_net(struct net *net)
{
	free_percpu(net->core.inuse);
}
void sock_prot_inuse_add(struct net *net, struct proto *prot, int val)
{
	__get_cpu_var(prot_inuse).val[prot->inuse_idx] += val;
}
static void *proto_seq_next(struct seq_file *seq, void *v, loff_t *pos)
{
	return seq_list_next(v, &proto_list, pos);
}
static void proto_seq_stop(struct seq_file *seq, void *v)
{
	read_unlock(&proto_list_lock);
}
static char proto_method_implemented(const void *method)
{
	return method == NULL ? 'n' : 'y';
}
static void proto_seq_printf(struct seq_file *seq, struct proto *proto)
{
	seq_printf(seq, "%-9s %4u %6d  %6d   %-3s %6u   %-3s  %-10s "
			"%2c %2c %2c %2c %2c %2c %2c %2c %2c %2c %2c %2c %2c %2c %2c %2c %2c %2c %2c\n",
		   proto->name,
		   proto->obj_size,
		   sock_prot_inuse_get(seq_file_net(seq), proto),
		   proto->memory_allocated != NULL ? atomic_read(proto->memory_allocated) : -1,
		   proto->memory_pressure != NULL ? *proto->memory_pressure ? "yes" : "no" : "NI",
		   proto->max_header,
		   proto->slab == NULL ? "no" : "yes",
		   module_name(proto->owner),
		   proto_method_implemented(proto->close),
		   proto_method_implemented(proto->connect),
		   proto_method_implemented(proto->disconnect),
		   proto_method_implemented(proto->accept),
		   proto_method_implemented(proto->ioctl),
		   proto_method_implemented(proto->init),
		   proto_method_implemented(proto->destroy),
		   proto_method_implemented(proto->shutdown),
		   proto_method_implemented(proto->setsockopt),
		   proto_method_implemented(proto->getsockopt),
		   proto_method_implemented(proto->sendmsg),
		   proto_method_implemented(proto->recvmsg),
		   proto_method_implemented(proto->sendpage),
		   proto_method_implemented(proto->bind),
		   proto_method_implemented(proto->backlog_rcv),
		   proto_method_implemented(proto->hash),
		   proto_method_implemented(proto->unhash),
		   proto_method_implemented(proto->get_port),
		   proto_method_implemented(proto->enter_memory_pressure));
}
static int proto_seq_open(struct inode *inode, struct file *file)
{
	return seq_open_net(inode, file, &proto_seq_ops,
			    sizeof(struct seq_net_private));
}
static int __init proto_init(void)
{
	return register_pernet_subsys(&proto_net_ops);
}
static inline int sk_stream_closing(struct sock *sk)
{
	return (1 << sk->sk_state) &
	       (TCPF_FIN_WAIT1 | TCPF_CLOSING | TCPF_LAST_ACK);
}
int net_ratelimit(void)
{
	return __ratelimit(&net_ratelimit_state);
}
static int dcbnl_pgtx_getcfg(struct net_device *netdev, struct nlattr **tb,
                             u32 pid, u32 seq, u16 flags)
{
	return __dcbnl_pg_getcfg(netdev, tb, pid, seq, flags, 0);
}
static int dcbnl_pgrx_getcfg(struct net_device *netdev, struct nlattr **tb,
                             u32 pid, u32 seq, u16 flags)
{
	return __dcbnl_pg_getcfg(netdev, tb, pid, seq, flags, 1);
}
static int dcbnl_pgtx_setcfg(struct net_device *netdev, struct nlattr **tb,
                             u32 pid, u32 seq, u16 flags)
{
	return __dcbnl_pg_setcfg(netdev, tb, pid, seq, flags, 0);
}
static int dcbnl_pgrx_setcfg(struct net_device *netdev, struct nlattr **tb,
                             u32 pid, u32 seq, u16 flags)
{
	return __dcbnl_pg_setcfg(netdev, tb, pid, seq, flags, 1);
}
static inline u8 dccp_ackvec_state(const struct dccp_ackvec *av,
				   const u32 index)
{
	return av->av_buf[index] & DCCP_ACKVEC_STATE_MASK;
}
static inline u8 dccp_ackvec_len(const struct dccp_ackvec *av,
				 const u32 index)
{
	return av->av_buf[index] & DCCP_ACKVEC_LEN_MASK;
}
static inline u8 LIH_INDEX(const u8 ctr)
{
	return (LIH_SIZE - 1 - (ctr % LIH_SIZE));
}
static inline struct tfrc_loss_interval *tfrc_lh_peek(struct tfrc_loss_hist *lh)
{
	return lh->counter ? lh->ring[LIH_INDEX(lh->counter - 1)] : NULL;
}
static inline u8 tfrc_lh_is_new_loss(struct tfrc_loss_interval *cur,
				     struct tfrc_rx_hist_entry *new_loss)
{
	return	dccp_delta_seqno(cur->li_seqno, new_loss->tfrchrx_seqno) > 0 &&
		(cur->li_is_closed || SUB16(new_loss->tfrchrx_ccval, cur->li_ccval) > 4);
}
static inline struct tfrc_rx_hist_entry *
			tfrc_rx_hist_rtt_last_s(const struct tfrc_rx_hist *h)
{
	return h->ring[0];
}
static inline struct tfrc_rx_hist_entry *
			tfrc_rx_hist_rtt_prev_s(const struct tfrc_rx_hist *h)
{
	return h->ring[h->rtt_sample_prev];
}
static int __init dccp_diag_init(void)
{
	return inet_diag_register(&dccp_diag_handler);
}
static void __exit dccp_diag_fini(void)
{
	inet_diag_unregister(&dccp_diag_handler);
}
static inline int dccp_feat_must_be_understood(u8 feat_num)
{
	return	feat_num == DCCPF_CCID || feat_num == DCCPF_SHORT_SEQNOS ||
		feat_num == DCCPF_SEQUENCE_WINDOW;
}
static int dccp_push_empty_confirm(struct list_head *fn_list, u8 feat, u8 local)
{
	return dccp_feat_push_confirm(fn_list, feat, local, NULL);
}
static inline __sum16 dccp_v4_csum_finish(struct sk_buff *skb,
				      __be32 src, __be32 dst)
{
	return csum_tcpudp_magic(src, dst, skb->len, IPPROTO_DCCP, skb->csum);
}
static inline u64 dccp_v4_init_sequence(const struct sk_buff *skb)
{
	return secure_dccp_sequence_number(ip_hdr(skb)->daddr,
					   ip_hdr(skb)->saddr,
					   dccp_hdr(skb)->dccph_dport,
					   dccp_hdr(skb)->dccph_sport);
}
static void dccp_v4_exit_net(struct net *net)
{
	inet_ctl_sock_destroy(net->dccp.v4_ctl_sk);
}
static inline __sum16 dccp_v6_csum_finish(struct sk_buff *skb,
				      struct in6_addr *saddr,
				      struct in6_addr *daddr)
{
	return csum_ipv6_magic(saddr, daddr, skb->len, IPPROTO_DCCP, skb->csum);
}
static inline __u32 secure_dccpv6_sequence_number(__be32 *saddr, __be32 *daddr,
						  __be16 sport, __be16 dport   )
{
	return secure_tcpv6_sequence_number(saddr, daddr, sport, dport);
}
static inline __u32 dccp_v6_init_sequence(struct sk_buff *skb)
{
	return secure_dccpv6_sequence_number(ipv6_hdr(skb)->daddr.s6_addr32,
					     ipv6_hdr(skb)->saddr.s6_addr32,
					     dccp_hdr(skb)->dccph_dport,
					     dccp_hdr(skb)->dccph_sport     );
}
static void dccp_v6_exit_net(struct net *net)
{
	inet_ctl_sock_destroy(net->dccp.v6_ctl_sk);
}
void dccp_reqsk_send_ack(struct sock *sk, struct sk_buff *skb,
			 struct request_sock *rsk)
{
	DCCP_BUG("DCCP-ACK packets are never sent in LISTEN/RESPOND state");
}
static inline int dccp_elapsed_time_len(const u32 elapsed_time)
{
	return elapsed_time == 0 ? 0 : elapsed_time <= 0xFFFF ? 2 : 4;
}
static inline void dccp_event_ack_sent(struct sock *sk)
{
	inet_csk_clear_xmit_timer(sk, ICSK_TIME_DACK);
}
static inline int dccp_need_reset(int state)
{
	return state != DCCP_CLOSED && state != DCCP_LISTEN &&
	       state != DCCP_REQUESTING;
}
void dccp_shutdown(struct sock *sk, int how)
{
	dccp_pr_debug("called shutdown(%x)\n", how);
}
static inline int dccp_mib_init(void)
{
	return snmp_mib_init((void**)dccp_statistics, sizeof(struct dccp_mib));
}
static inline void dccp_mib_exit(void)
{
	snmp_mib_free((void**)dccp_statistics);
}
static void dccp_response_timer(struct sock *sk)
{
	inet_csk_reqsk_queue_prune(sk, TCP_SYNQ_INTERVAL, DCCP_TIMEOUT_INIT,
				   DCCP_RTO_MAX);
}
void __init dccp_timestamping_init(void)
{
	dccp_timestamp_seed = ktime_get_real();
}
static void *dn_socket_seq_start(struct seq_file *seq, loff_t *pos)
{
	return *pos ? dn_socket_get_idx(seq, *pos - 1) : SEQ_START_TOKEN;
}
static int dn_socket_seq_open(struct inode *inode, struct file *file)
{
	return seq_open_private(file, &dn_socket_seq_ops,
			sizeof(struct dn_iter_state));
}
static __inline__ void dn_dev_free_ifa(struct dn_ifaddr *ifa)
{
	kfree(ifa);
}
static inline size_t dn_ifaddr_nlmsg_size(void)
{
	return NLMSG_ALIGN(sizeof(struct ifaddrmsg))
	       + nla_total_size(IFNAMSIZ) /* IFA_LABEL */
	       + nla_total_size(2) /* IFA_ADDRESS */
	       + nla_total_size(2); /* IFA_LOCAL */
}
void dn_dev_init_pkt(struct sk_buff *skb)
{
	return;
}
void dn_dev_veri_pkt(struct sk_buff *skb)
{
	return;
}
void dn_dev_hello(struct sk_buff *skb)
{
	return;
}
int register_dnaddr_notifier(struct notifier_block *nb)
{
	return blocking_notifier_chain_register(&dnaddr_chain, nb);
}
int unregister_dnaddr_notifier(struct notifier_block *nb)
{
	return blocking_notifier_chain_unregister(&dnaddr_chain, nb);
}
static inline int is_dn_dev(struct net_device *dev)
{
	return dev->dn_ptr != NULL;
}
static void dn_dev_seq_stop(struct seq_file *seq, void *v)
{
	read_unlock(&dev_base_lock);
}
static int dn_dev_seq_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &dn_dev_seq_ops);
}
static void dn_fib_add_ifaddr(struct dn_ifaddr *ifa)
{
	fib_magic(RTM_NEWROUTE, RTN_LOCAL, ifa->ifa_local, 16, ifa);
}
static u32 dn_neigh_hash(const void *pkey, const struct net_device *dev)
{
	return jhash_2words(*(__u16 *)pkey, 0, dn_neigh_table.hash_rnd);
}
void dn_neigh_pointopoint_hello(struct sk_buff *skb)
{
	kfree_skb(skb);
}
static void *dn_neigh_seq_start(struct seq_file *seq, loff_t *pos)
{
	return neigh_seq_start(seq, pos, &dn_neigh_table,
			       NEIGH_SEQ_NEIGH_ONLY);
}
static int dn_neigh_seq_open(struct inode *inode, struct file *file)
{
	return seq_open_net(inode, file, &dn_neigh_seq_ops,
			    sizeof(struct neigh_seq_state));
}
int dn_nsp_rx(struct sk_buff *skb)
{
	return NF_HOOK(PF_DECnet, NF_DN_LOCAL_IN, skb, skb->dev, NULL, dn_nsp_rx_packet);
}
static inline void dnrt_free(struct dn_route *rt)
{
	call_rcu_bh(&rt->u.dst.rcu_head, dst_rcu_free);
}
static struct dst_entry *dn_dst_check(struct dst_entry *dst, __u32 cookie)
{
	return NULL;
}
static void dn_dst_link_failure(struct sk_buff *skb)
{
	return;
}
static inline int compare_keys(struct flowi *fl1, struct flowi *fl2)
{
	return ((fl1->nl_u.dn_u.daddr ^ fl2->nl_u.dn_u.daddr) |
		(fl1->nl_u.dn_u.saddr ^ fl2->nl_u.dn_u.saddr) |
		(fl1->mark ^ fl2->mark) |
		(fl1->nl_u.dn_u.scope ^ fl2->nl_u.dn_u.scope) |
		(fl1->oif ^ fl2->oif) |
		(fl1->iif ^ fl2->iif)) == 0;
}
static inline __le16 __dn_fib_res_prefsrc(struct dn_fib_res *res)
{
	return dnet_select_source(DN_FIB_RES_DEV(*res), DN_FIB_RES_GW(*res), res->scope);
}
static int dn_rt_cache_seq_open(struct inode *inode, struct file *file)
{
	return seq_open_private(file, &dn_rt_cache_seq_ops,
			sizeof(struct dn_rt_cache_iter_state));
}
static void dn_fib_rule_flush_cache(struct fib_rules_ops *ops)
{
	dn_rt_cache_flush(-1);
}
void __exit dn_fib_rules_cleanup(void)
{
	fib_rules_unregister(&dn_fib_rules_ops);
}
static inline struct dn_fib_node **dn_chain_p(dn_fib_key_t key, struct dn_zone *dz)
{
	return &dz->dz_hash[dn_hash(key, dz).datum];
}
static inline struct dn_fib_node *dz_chain(dn_fib_key_t key, struct dn_zone *dz)
{
	return dz->dz_hash[dn_hash(key, dz).datum];
}
static inline int dn_key_eq(dn_fib_key_t a, dn_fib_key_t b)
{
	return a.datum == b.datum;
}
static inline int dn_key_leq(dn_fib_key_t a, dn_fib_key_t b)
{
	return a.datum <= b.datum;
}
void __init dn_fib_table_init(void)
{
	dn_hash_kmem = kmem_cache_create("dn_fib_info_cache",
					sizeof(struct dn_fib_info),
					0, SLAB_HWCACHE_ALIGN,
					NULL);
}
void dn_stop_slow_timer(struct sock *sk)
{
	del_timer(&sk->sk_timer);
}
void dn_register_sysctl(void)
{
	dn_table_header = register_sysctl_paths(dn_path, dn_table);
}
void dn_unregister_sysctl(void)
{
	unregister_sysctl_table(dn_table_header);
}
static int __init dsa_init_module(void)
{
	return platform_driver_register(&dsa_driver);
}
static void __exit dsa_cleanup_module(void)
{
	platform_driver_unregister(&dsa_driver);
}
static int reg_read(struct dsa_switch *ds, int addr, int reg)
{
	return mdiobus_read(ds->master_mii_bus, addr, reg);
}
static int reg_write(struct dsa_switch *ds, int addr, int reg, u16 val)
{
	return mdiobus_write(ds->master_mii_bus, addr, reg, val);
}
static void __exit mv88e6060_cleanup(void)
{
	unregister_switch_driver(&mv88e6060_switch_driver);
}
static void
mv88e6123_61_65_get_strings(struct dsa_switch *ds, int port, uint8_t *data)
{
	mv88e6xxx_get_strings(ds, ARRAY_SIZE(mv88e6123_61_65_hw_stats),
			      mv88e6123_61_65_hw_stats, port, data);
}
static void
mv88e6123_61_65_get_ethtool_stats(struct dsa_switch *ds,
				  int port, uint64_t *data)
{
	mv88e6xxx_get_ethtool_stats(ds, ARRAY_SIZE(mv88e6123_61_65_hw_stats),
				    mv88e6123_61_65_hw_stats, port, data);
}
static int mv88e6123_61_65_get_sset_count(struct dsa_switch *ds)
{
	return ARRAY_SIZE(mv88e6123_61_65_hw_stats);
}
static void __exit mv88e6123_61_65_cleanup(void)
{
	unregister_switch_driver(&mv88e6123_61_65_switch_driver);
}
static void
mv88e6131_get_strings(struct dsa_switch *ds, int port, uint8_t *data)
{
	mv88e6xxx_get_strings(ds, ARRAY_SIZE(mv88e6131_hw_stats),
			      mv88e6131_hw_stats, port, data);
}
static void
mv88e6131_get_ethtool_stats(struct dsa_switch *ds,
				  int port, uint64_t *data)
{
	mv88e6xxx_get_ethtool_stats(ds, ARRAY_SIZE(mv88e6131_hw_stats),
				    mv88e6131_hw_stats, port, data);
}
static int mv88e6131_get_sset_count(struct dsa_switch *ds)
{
	return ARRAY_SIZE(mv88e6131_hw_stats);
}
static void __exit mv88e6131_cleanup(void)
{
	unregister_switch_driver(&mv88e6131_switch_driver);
}
static void __exit dsa_cleanup_module(void)
{
	dev_remove_pack(&dsa_packet_type);
}
static void __exit edsa_cleanup_module(void)
{
	dev_remove_pack(&edsa_packet_type);
}
static void __exit trailer_cleanup_module(void)
{
	dev_remove_pack(&trailer_packet_type);
}
static void econet_hw_initialise(void)
{
	dev_add_pack(&econet_packet_type);
}
void eth_header_cache_update(struct hh_cache *hh,
			     const struct net_device *dev,
			     const unsigned char *haddr)
{
	memcpy(((u8 *) hh->hh_data) + HH_DATA_OFF(sizeof(struct ethhdr)),
	       haddr, ETH_ALEN);
}
struct net_device *alloc_etherdev_mq(int sizeof_priv, unsigned int queue_count)
{
	return alloc_netdev_mq(sizeof_priv, "eth%d", ether_setup, queue_count);
}
void destroy_EII_client(struct datalink_proto *dl)
{
	kfree(dl);
}
static int __init init_ipv4_mibs(void)
{
	return register_pernet_subsys(&ipv4_mib_ops);
}
static int __init ipv4_proc_init(void)
{
	return 0;
}
static u32 arp_hash(const void *pkey, const struct net_device *dev)
{
	return jhash_2words(*(u32 *)pkey, dev->ifindex, arp_tbl.hash_rnd);
}
void arp_xmit(struct sk_buff *skb)
{
	NF_HOOK(NFPROTO_ARP, NF_ARP_OUT, skb, NULL, skb->dev, dev_queue_xmit);
}
static void parp_redo(struct sk_buff *skb)
{
	arp_process(skb);
}
void arp_ifdown(struct net_device *dev)
{
	neigh_ifdown(&arp_tbl, dev);
}
static void *arp_seq_start(struct seq_file *seq, loff_t *pos)
{
	return neigh_seq_start(seq, pos, &arp_tbl, NEIGH_SEQ_SKIP_NOARP);
}
static int arp_seq_open(struct inode *inode, struct file *file)
{
	return seq_open_net(inode, file, &arp_seq_ops,
			    sizeof(struct neigh_seq_state));
}
static int __init arp_proc_init(void)
{
	return register_pernet_subsys(&arp_net_ops);
}
static int __init arp_proc_init(void)
{
	return 0;
}
static u32 cipso_v4_map_cache_hash(const unsigned char *key, u32 key_len)
{
	return jhash(key, key_len, 0);
}
int cipso_v4_skbuff_getattr(const struct sk_buff *skb,
			    struct netlbl_lsm_secattr *secattr)
{
	return cipso_v4_getattr(CIPSO_V4_OPTPTR(skb), secattr);
}
static struct in_ifaddr *inet_alloc_ifa(void)
{
	return kzalloc(sizeof(struct in_ifaddr), GFP_KERNEL);
}
static inline void inet_free_ifa(struct in_ifaddr *ifa)
{
	call_rcu(&ifa->rcu_head, inet_rcu_free_ifa);
}
static void inet_del_ifa(struct in_device *in_dev, struct in_ifaddr **ifap,
			 int destroy)
{
	__inet_del_ifa(in_dev, ifap, destroy, NULL, 0);
}
static int inet_insert_ifa(struct in_ifaddr *ifa)
{
	return __inet_insert_ifa(ifa, NULL, 0);
}
int register_inetaddr_notifier(struct notifier_block *nb)
{
	return blocking_notifier_chain_register(&inetaddr_chain, nb);
}
int unregister_inetaddr_notifier(struct notifier_block *nb)
{
	return blocking_notifier_chain_unregister(&inetaddr_chain, nb);
}
static inline bool inetdev_valid_mtu(unsigned mtu)
{
	return mtu >= 68;
}
static inline size_t inet_nlmsg_size(void)
{
	return NLMSG_ALIGN(sizeof(struct ifaddrmsg))
	       + nla_total_size(4) /* IFA_ADDRESS */
	       + nla_total_size(4) /* IFA_LOCAL */
	       + nla_total_size(4) /* IFA_BROADCAST */
	       + nla_total_size(IFNAMSIZ); /* IFA_LABEL */
}
static inline u8 *esp_tmp_iv(struct crypto_aead *aead, void *tmp)
{
	return crypto_aead_ivsize(aead) ?
	       PTR_ALIGN((u8 *)tmp, crypto_aead_alignmask(aead) + 1) : tmp;
}
static inline struct scatterlist *esp_req_sg(struct crypto_aead *aead,
					     struct aead_request *req)
{
	return (void *)ALIGN((unsigned long)(req + 1) +
			     crypto_aead_reqsize(aead),
			     __alignof__(struct scatterlist));
}
static inline struct scatterlist *esp_givreq_sg(
	struct crypto_aead *aead, struct aead_givcrypt_request *req)
{
	return (void *)ALIGN((unsigned long)(req + 1) +
			     crypto_aead_reqsize(aead),
			     __alignof__(struct scatterlist));
}
unsigned int inet_addr_type(struct net *net, __be32 addr)
{
	return __inet_dev_addr_type(net, NULL, addr);
}
unsigned int inet_dev_addr_type(struct net *net, const struct net_device *dev,
				__be32 addr)
{
       return __inet_dev_addr_type(net, dev, addr);
}
static inline __be32 sk_extract_addr(struct sockaddr *addr)
{
	return ((struct sockaddr_in *) addr)->sin_addr.s_addr;
}
static inline __be32 fz_key(__be32 dst, struct fn_zone *fz)
{
	return dst & FZ_MASK(fz);
}
static inline void fn_free_node(struct fib_node * f)
{
	kmem_cache_free(fn_hash_kmem, f);
}
static void fib_seq_stop(struct seq_file *seq, void *v)
{
	read_unlock(&fib_hash_lock);
}
static int fib_seq_open(struct inode *inode, struct file *file)
{
	return seq_open_net(inode, file, &fib_seq_ops,
			    sizeof(struct fib_iter_state));
}
u32 fib_rules_tclass(struct fib_result *res)
{
	return res->r ? ((struct fib4_rule *) res->r)->tclassid : 0;
}
static size_t fib4_rule_nlmsg_payload(struct fib_rule *rule)
{
	return nla_total_size(4) /* dst */
	       + nla_total_size(4) /* src */
	       + nla_total_size(4); /* flow */
}
static void fib4_rule_flush_cache(struct fib_rules_ops *ops)
{
	rt_cache_flush(ops->fro_net, -1);
}
static struct hlist_head *fib_hash_alloc(int bytes)
{
	if (bytes <= PAGE_SIZE)
		return kzalloc(bytes, GFP_KERNEL);
	else
		return (struct hlist_head *)
			__get_free_pages(GFP_KERNEL | __GFP_ZERO, get_order(bytes));
}
__be32 __fib_res_prefsrc(struct fib_result *res)
{
	return inet_select_addr(FIB_RES_DEV(*res), FIB_RES_GW(*res), res->scope);
}
static inline struct tnode *node_parent(struct node *node)
{
	return (struct tnode *)(node->parent & ~NODE_TYPE_MASK);
}
static inline int tnode_child_length(const struct tnode *tn)
{
	return 1 << tn->bits;
}
static inline t_key mask_pfx(t_key k, unsigned short l)
{
	return (l == 0) ? 0 : k >> (KEYLENGTH-l) << (KEYLENGTH-l);
}
static inline t_key tkey_extract_bits(t_key a, int offset, int bits)
{
	if (offset < KEYLENGTH)
		return ((t_key)(a << offset)) >> (KEYLENGTH - bits);
	else
		return 0;
}
static inline int tkey_equals(t_key a, t_key b)
{
	return a == b;
}
static inline void check_tnode(const struct tnode *tn)
{
	WARN_ON(tn && tn->pos+tn->bits > 32);
}
static inline void alias_free_mem_rcu(struct fib_alias *fa)
{
	call_rcu(&fa->rcu, __alias_free_mem);
}
static inline void free_leaf(struct leaf *l)
{
	call_rcu_bh(&l->rcu, __leaf_free_rcu);
}
static void __leaf_info_free_rcu(struct rcu_head *head)
{
	kfree(container_of(head, struct leaf_info, rcu));
}
static inline void free_leaf_info(struct leaf_info *leaf)
{
	call_rcu(&leaf->rcu, __leaf_info_free_rcu);
}
static struct tnode *tnode_alloc(size_t size)
{
	if (size <= PAGE_SIZE)
		return kzalloc(size, GFP_KERNEL);
	else
		return __vmalloc(size, GFP_KERNEL | __GFP_ZERO, PAGE_KERNEL);
}
static inline void put_child(struct trie *t, struct tnode *tn, int i,
			     struct node *n)
{
	tnode_put_child_reorg(tn, i, n, -1);
}
static int fib_triestat_seq_open(struct inode *inode, struct file *file)
{
	return single_open_net(inode, file, fib_triestat_seq_show);
}
static void fib_trie_seq_stop(struct seq_file *seq, void *v)
{
	rcu_read_unlock();
}
static int fib_trie_seq_open(struct inode *inode, struct file *file)
{
	return seq_open_net(inode, file, &fib_trie_seq_ops,
			    sizeof(struct fib_trie_iter));
}
static void fib_route_seq_stop(struct seq_file *seq, void *v)
{
	rcu_read_unlock();
}
static int fib_route_seq_open(struct inode *inode, struct file *file)
{
	return seq_open_net(inode, file, &fib_route_seq_ops,
			    sizeof(struct fib_route_iter));
}
static struct sock *icmp_sk(struct net *net)
{
	return net->ipv4.icmp_sk[smp_processor_id()];
}
static inline void icmp_xmit_unlock(struct sock *sk)
{
	spin_unlock_bh(&sk->sk_lock.slock);
}
int __init icmp_init(void)
{
	return register_pernet_device(&icmp_sk_ops);
}
static int grec_size(struct ip_mc_list *pmc, int type, int gdel, int sdel)
{
	return sizeof(struct igmpv3_grec) + 4*igmp_scount(pmc, type, gdel, sdel);
}
static int igmp_mc_seq_open(struct inode *inode, struct file *file)
{
	return seq_open_net(inode, file, &igmp_mc_seq_ops,
			sizeof(struct igmp_mc_iter_state));
}
static int igmp_mcf_seq_open(struct inode *inode, struct file *file)
{
	return seq_open_net(inode, file, &igmp_mcf_seq_ops,
			sizeof(struct igmp_mcf_iter_state));
}
int __init igmp_mc_proc_init(void)
{
	return register_pernet_subsys(&igmp_net_ops);
}
void inet_csk_delete_keepalive_timer(struct sock *sk)
{
	sk_stop_timer(sk, &sk->sk_timer);
}
void inet_csk_reset_keepalive_timer(struct sock *sk, unsigned long len)
{
	sk_reset_timer(sk, &sk->sk_timer, jiffies + len);
}
static inline u32 inet_synq_hash(const __be32 raddr, const __be16 rport,
				 const u32 rnd, const u32 synq_hsize)
{
	return jhash_2words((__force u32)raddr, (__force u32)rport, rnd) & (synq_hsize - 1);
}
static inline void inet_diag_unlock_handler(
	const struct inet_diag_handler *handler)
{
	mutex_unlock(&inet_diag_table_mutex);
}
void inet_frags_fini(struct inet_frags *f)
{
	del_timer(&f->secret_timer);
}
int inet_hash_connect(struct inet_timewait_death_row *death_row,
		      struct sock *sk)
{
	return __inet_hash_connect(death_row, sk, inet_sk_port_offset(sk),
			__inet_check_established, __inet_hash_nolisten);
}
static inline void lro_clear_desc(struct net_lro_desc *lro_desc)
{
	memset(lro_desc, 0, sizeof(struct net_lro_desc));
}
int ip_frag_nqueues(struct net *net)
{
	return net->ipv4.frags.nqueues;
}
int ip_frag_mem(struct net *net)
{
	return atomic_read(&net->ipv4.frags.mem);
}
static unsigned int ipqhashfn(__be16 id, __be32 saddr, __be32 daddr, u8 prot)
{
	return jhash_3words((__force u32)id << 16 | prot,
			    (__force u32)saddr, (__force u32)daddr,
			    ip4_frags.rnd) & (INETFRAGS_HASHSZ - 1);
}
static __inline__ void ipq_put(struct ipq *ipq)
{
	inet_frag_put(&ipq->q, &ip4_frags);
}
static void ipq_kill(struct ipq *ipq)
{
	inet_frag_kill(&ipq->q, &ip4_frags);
}
static void ip4_frags_ctl_register(void)
{
	register_net_sysctl_rotable(net_ipv4_ctl_path, ip4_frags_ctl_table);
}
static inline int ip4_frags_ns_ctl_register(struct net *net)
{
	return 0;
}
static inline struct ip_tunnel **ipgre_bucket(struct ipgre_net *ign,
		struct ip_tunnel *t)
{
	return __ipgre_bucket(ign, &t->parms);
}
static size_t ipgre_get_size(const struct net_device *dev)
{
	return
		nla_total_size(4) +
		nla_total_size(2) +
		nla_total_size(2) +
		nla_total_size(4) +
		nla_total_size(4) +
		nla_total_size(4) +
		nla_total_size(4) +
		nla_total_size(1) +
		nla_total_size(1) +
		nla_total_size(1) +
		0;
}
static struct ip_options *ip_options_get_alloc(const int optlen)
{
	return kzalloc(sizeof(struct ip_options) + ((optlen + 3) & ~3),
		       GFP_KERNEL);
}
static void ip_cmsg_recv_tos(struct msghdr *msg, struct sk_buff *skb)
{
	put_cmsg(msg, SOL_IP, IP_TOS, 1, &ip_hdr(skb)->tos);
}
static inline void __init ic_rarp_init(void)
{
	dev_add_pack(&rarp_packet_type);
}
static inline void __init ic_rarp_cleanup(void)
{
	dev_remove_pack(&rarp_packet_type);
}
static inline void __init ic_bootp_cleanup(void)
{
	dev_remove_pack(&bootp_packet_type);
}
static int pnp_seq_open(struct inode *indoe, struct file *file)
{
	return single_open(file, pnp_seq_show, NULL);
}
static int __init nfsaddrs_config_setup(char *addrs)
{
	return ip_auto_config_setup(addrs);
}
static inline struct ip_tunnel **ipip_bucket(struct ipip_net *ipn,
		struct ip_tunnel *t)
{
	return __ipip_bucket(ipn, &t->parms);
}
static void ipmr_vif_seq_stop(struct seq_file *seq, void *v)
{
	read_unlock(&mrt_lock);
}
static int ipmr_vif_open(struct inode *inode, struct file *file)
{
	return seq_open_net(inode, file, &ipmr_vif_seq_ops,
			    sizeof(struct ipmr_vif_iter));
}
static int ipmr_mfc_open(struct inode *inode, struct file *file)
{
	return seq_open_net(inode, file, &ipmr_mfc_seq_ops,
			    sizeof(struct ipmr_mfc_iter));
}
static int nf_ip_route(struct dst_entry **dst, struct flowi *fl)
{
	return ip_route_output_key(&init_net, (struct rtable **)dst, fl);
}
static int ipv4_netfilter_init(void)
{
	return nf_register_afinfo(&nf_ip_afinfo);
}
static void ipv4_netfilter_fini(void)
{
	nf_unregister_afinfo(&nf_ip_afinfo);
}
static inline struct arpt_entry *get_entry(void *base, unsigned int offset)
{
	return (struct arpt_entry *)(base + offset);
}
static int __init arpt_mangle_init(void)
{
	return xt_register_target(&arpt_mangle_reg);
}
static void __exit arpt_mangle_fini(void)
{
	xt_unregister_target(&arpt_mangle_reg);
}
static unsigned int arpt_in_hook(unsigned int hook,
				 struct sk_buff *skb,
				 const struct net_device *in,
				 const struct net_device *out,
				 int (*okfn)(struct sk_buff *))
{
	return arpt_do_table(skb, hook, in, out,
			     dev_net(in)->ipv4.arptable_filter);
}
static unsigned int arpt_out_hook(unsigned int hook,
				  struct sk_buff *skb,
				  const struct net_device *in,
				  const struct net_device *out,
				  int (*okfn)(struct sk_buff *))
{
	return arpt_do_table(skb, hook, in, out,
			     dev_net(out)->ipv4.arptable_filter);
}
static void
ipq_dev_drop(int ifindex)
{
	ipq_flush(dev_cmp, ifindex);
}
static int ip_queue_open(struct inode *inode, struct file *file)
{
	return single_open(file, ip_queue_show, NULL);
}
static inline struct ipt_entry *
get_entry(void *base, unsigned int offset)
{
	return (struct ipt_entry *)(base + offset);
}
static inline bool
icmp_type_code_match(u_int8_t test_type, u_int8_t min_code, u_int8_t max_code,
		     u_int8_t type, u_int8_t code,
		     bool invert)
{
	return ((test_type == 0xFF) ||
		(type == test_type && code >= min_code && code <= max_code))
		^ invert;
}
static inline void
clusterip_config_get(struct clusterip_config *c)
{
	atomic_inc(&c->refcount);
}
static inline int
clusterip_responsible(const struct clusterip_config *config, u_int32_t hash)
{
	return test_bit(hash - 1, &config->local_nodes);
}
static void clusterip_seq_stop(struct seq_file *s, void *v)
{
	kfree(v);
}
static int __init ecn_tg_init(void)
{
	return xt_register_target(&ecn_tg_reg);
}
static void __exit ecn_tg_exit(void)
{
	xt_unregister_target(&ecn_tg_reg);
}
static int __init netmap_tg_init(void)
{
	return xt_register_target(&netmap_tg_reg);
}
static void __exit netmap_tg_exit(void)
{
	xt_unregister_target(&netmap_tg_reg);
}
static int __init redirect_tg_init(void)
{
	return xt_register_target(&redirect_tg_reg);
}
static void __exit redirect_tg_exit(void)
{
	xt_unregister_target(&redirect_tg_reg);
}
static inline void send_unreach(struct sk_buff *skb_in, int code)
{
	icmp_send(skb_in, ICMP_DEST_UNREACH, code, 0);
}
static int __init reject_tg_init(void)
{
	return xt_register_target(&reject_tg_reg);
}
static void __exit reject_tg_exit(void)
{
	xt_unregister_target(&reject_tg_reg);
}
static int __init ttl_tg_init(void)
{
	return xt_register_target(&ttl_tg_reg);
}
static void __exit ttl_tg_exit(void)
{
	xt_unregister_target(&ttl_tg_reg);
}
static inline bool match_type(struct net *net, const struct net_device *dev,
			      __be32 addr, u_int16_t mask)
{
	return !!(mask & (1 << inet_dev_addr_type(net, dev, addr)));
}
static int __init addrtype_mt_init(void)
{
	return xt_register_matches(addrtype_mt_reg,
				   ARRAY_SIZE(addrtype_mt_reg));
}
static void __exit addrtype_mt_exit(void)
{
	xt_unregister_matches(addrtype_mt_reg, ARRAY_SIZE(addrtype_mt_reg));
}
static int __init ah_mt_init(void)
{
	return xt_register_match(&ah_mt_reg);
}
static void __exit ah_mt_exit(void)
{
	xt_unregister_match(&ah_mt_reg);
}
static inline bool match_ip(const struct sk_buff *skb,
			    const struct ipt_ecn_info *einfo)
{
	return (ip_hdr(skb)->tos & IPT_ECN_IP_MASK) == einfo->ip_ect;
}
static int __init ecn_mt_init(void)
{
	return xt_register_match(&ecn_mt_reg);
}
static void __exit ecn_mt_exit(void)
{
	xt_unregister_match(&ecn_mt_reg);
}
static int __init ttl_mt_init(void)
{
	return xt_register_match(&ttl_mt_reg);
}
static void __exit ttl_mt_exit(void)
{
	xt_unregister_match(&ttl_mt_reg);
}
static unsigned int
ipt_local_in_hook(unsigned int hook,
		  struct sk_buff *skb,
		  const struct net_device *in,
		  const struct net_device *out,
		  int (*okfn)(struct sk_buff *))
{
	return ipt_do_table(skb, hook, in, out,
			    dev_net(in)->ipv4.iptable_filter);
}
static unsigned int
ipt_hook(unsigned int hook,
	 struct sk_buff *skb,
	 const struct net_device *in,
	 const struct net_device *out,
	 int (*okfn)(struct sk_buff *))
{
	return ipt_do_table(skb, hook, in, out,
			    dev_net(in)->ipv4.iptable_filter);
}
static unsigned int
ipt_pre_routing_hook(unsigned int hook,
		     struct sk_buff *skb,
		     const struct net_device *in,
		     const struct net_device *out,
		     int (*okfn)(struct sk_buff *))
{
	return ipt_do_table(skb, hook, in, out,
			    dev_net(in)->ipv4.iptable_mangle);
}
static unsigned int
ipt_post_routing_hook(unsigned int hook,
		      struct sk_buff *skb,
		      const struct net_device *in,
		      const struct net_device *out,
		      int (*okfn)(struct sk_buff *))
{
	return ipt_do_table(skb, hook, in, out,
			    dev_net(out)->ipv4.iptable_mangle);
}
static unsigned int
ipt_local_in_hook(unsigned int hook,
		  struct sk_buff *skb,
		  const struct net_device *in,
		  const struct net_device *out,
		  int (*okfn)(struct sk_buff *))
{
	return ipt_do_table(skb, hook, in, out,
			    dev_net(in)->ipv4.iptable_mangle);
}
static unsigned int
ipt_forward_hook(unsigned int hook,
	 struct sk_buff *skb,
	 const struct net_device *in,
	 const struct net_device *out,
	 int (*okfn)(struct sk_buff *))
{
	return ipt_do_table(skb, hook, in, out,
			    dev_net(in)->ipv4.iptable_mangle);
}
static unsigned int
ipt_hook(unsigned int hook,
	 struct sk_buff *skb,
	 const struct net_device *in,
	 const struct net_device *out,
	 int (*okfn)(struct sk_buff *))
{
	return ipt_do_table(skb, hook, in, out,
			    dev_net(in)->ipv4.iptable_raw);
}
static unsigned int
ipt_local_in_hook(unsigned int hook,
		  struct sk_buff *skb,
		  const struct net_device *in,
		  const struct net_device *out,
		  int (*okfn)(struct sk_buff *))
{
	return ipt_do_table(skb, hook, in, out,
			    dev_net(in)->ipv4.iptable_security);
}
static unsigned int
ipt_forward_hook(unsigned int hook,
		 struct sk_buff *skb,
		 const struct net_device *in,
		 const struct net_device *out,
		 int (*okfn)(struct sk_buff *))
{
	return ipt_do_table(skb, hook, in, out,
			    dev_net(in)->ipv4.iptable_security);
}
static int ipv4_print_tuple(struct seq_file *s,
			    const struct nf_conntrack_tuple *tuple)
{
	return seq_printf(s, "src=%pI4 dst=%pI4 ",
			  &tuple->src.u3.ip, &tuple->dst.u3.ip);
}
static unsigned int ipv4_conntrack_in(unsigned int hooknum,
				      struct sk_buff *skb,
				      const struct net_device *in,
				      const struct net_device *out,
				      int (*okfn)(struct sk_buff *))
{
	return nf_conntrack_in(dev_net(in), PF_INET, hooknum, skb);
}
void need_ipv4_conntrack(void)
{
	return;
}
static void ct_seq_stop(struct seq_file *s, void *v)
{
	rcu_read_unlock();
}
static int ct_open(struct inode *inode, struct file *file)
{
	return seq_open_net(inode, file, &ct_seq_ops,
			    sizeof(struct ct_iter_state));
}
static void exp_seq_stop(struct seq_file *seq, void *v)
{
	rcu_read_unlock();
}
static int exp_open(struct inode *inode, struct file *file)
{
	return seq_open_net(inode, file, &exp_seq_ops,
			    sizeof(struct ct_expect_iter_state));
}
static int ct_cpu_seq_open(struct inode *inode, struct file *file)
{
	return seq_open_net(inode, file, &ct_cpu_seq_ops,
			    sizeof(struct seq_net_private));
}
int __init nf_conntrack_ipv4_compat_init(void)
{
	return register_pernet_subsys(&ip_conntrack_net_ops);
}
void __exit nf_conntrack_ipv4_compat_fini(void)
{
	unregister_pernet_subsys(&ip_conntrack_net_ops);
}
static int icmp_print_tuple(struct seq_file *s,
			    const struct nf_conntrack_tuple *tuple)
{
	return seq_printf(s, "type=%u code=%u id=%u ",
			  tuple->dst.u.icmp.type,
			  tuple->dst.u.icmp.code,
			  ntohs(tuple->src.u.icmp.id));
}
static int __init nf_defrag_init(void)
{
	return nf_register_hooks(ipv4_defrag_ops, ARRAY_SIZE(ipv4_defrag_ops));
}
static void __exit nf_defrag_fini(void)
{
	nf_unregister_hooks(ipv4_defrag_ops, ARRAY_SIZE(ipv4_defrag_ops));
}
static inline const struct nf_nat_protocol *
__nf_nat_proto_find(u_int8_t protonum)
{
	return rcu_dereference(nf_nat_protos[protonum]);
}
void
nf_nat_proto_put(const struct nf_nat_protocol *p)
{
	module_put(p->me);
}
static int
nfnetlink_parse_nat_setup(struct nf_conn *ct,
			  enum nf_nat_manip_type manip,
			  struct nlattr *attr)
{
	return -EOPNOTSUPP;
}
static int set_h225_addr(struct sk_buff *skb,
			 unsigned char **data, int dataoff,
			 TransportAddress *taddr,
			 union nf_inet_addr *addr, __be16 port)
{
	return set_addr(skb, data, dataoff, taddr->ipAddress.ip,
			addr->ip, port);
}
static int set_h245_addr(struct sk_buff *skb,
			 unsigned char **data, int dataoff,
			 H245_TransportAddress *taddr,
			 union nf_inet_addr *addr, __be16 port)
{
	return set_addr(skb, data, dataoff,
			taddr->unicastAddress.iPAddress.network,
			addr->ip, port);
}
static bool
dccp_unique_tuple(struct nf_conntrack_tuple *tuple,
		  const struct nf_nat_range *range,
		  enum nf_nat_manip_type maniptype,
		  const struct nf_conn *ct)
{
	return nf_nat_proto_unique_tuple(tuple, range, maniptype, ct,
					 &dccp_port_rover);
}
static int __init nf_nat_proto_dccp_init(void)
{
	return nf_nat_protocol_register(&nf_nat_protocol_dccp);
}
static void __exit nf_nat_proto_dccp_fini(void)
{
	nf_nat_protocol_unregister(&nf_nat_protocol_dccp);
}
static int __init nf_nat_proto_gre_init(void)
{
	return nf_nat_protocol_register(&gre);
}
static void __exit nf_nat_proto_gre_fini(void)
{
	nf_nat_protocol_unregister(&gre);
}
void nf_nat_need_gre(void)
{
	return;
}
static bool
icmp_in_range(const struct nf_conntrack_tuple *tuple,
	      enum nf_nat_manip_type maniptype,
	      const union nf_conntrack_man_proto *min,
	      const union nf_conntrack_man_proto *max)
{
	return ntohs(tuple->src.u.icmp.id) >= ntohs(min->icmp.id) &&
	       ntohs(tuple->src.u.icmp.id) <= ntohs(max->icmp.id);
}
static bool
sctp_unique_tuple(struct nf_conntrack_tuple *tuple,
		  const struct nf_nat_range *range,
		  enum nf_nat_manip_type maniptype,
		  const struct nf_conn *ct)
{
	return nf_nat_proto_unique_tuple(tuple, range, maniptype, ct,
					 &nf_sctp_port_rover);
}
static int __init nf_nat_proto_sctp_init(void)
{
	return nf_nat_protocol_register(&nf_nat_protocol_sctp);
}
static void __exit nf_nat_proto_sctp_exit(void)
{
	nf_nat_protocol_unregister(&nf_nat_protocol_sctp);
}
static bool
tcp_unique_tuple(struct nf_conntrack_tuple *tuple,
		 const struct nf_nat_range *range,
		 enum nf_nat_manip_type maniptype,
		 const struct nf_conn *ct)
{
	return nf_nat_proto_unique_tuple(tuple, range, maniptype, ct,
					 &tcp_port_rover);
}
static bool
udp_unique_tuple(struct nf_conntrack_tuple *tuple,
		 const struct nf_nat_range *range,
		 enum nf_nat_manip_type maniptype,
		 const struct nf_conn *ct)
{
	return nf_nat_proto_unique_tuple(tuple, range, maniptype, ct,
					 &udp_port_rover);
}
static bool
udplite_unique_tuple(struct nf_conntrack_tuple *tuple,
		     const struct nf_nat_range *range,
		     enum nf_nat_manip_type maniptype,
		     const struct nf_conn *ct)
{
	return nf_nat_proto_unique_tuple(tuple, range, maniptype, ct,
					 &udplite_port_rover);
}
static int __init nf_nat_proto_udplite_init(void)
{
	return nf_nat_protocol_register(&nf_nat_protocol_udplite);
}
static void __exit nf_nat_proto_udplite_fini(void)
{
	nf_nat_protocol_unregister(&nf_nat_protocol_udplite);
}
static bool unknown_in_range(const struct nf_conntrack_tuple *tuple,
			     enum nf_nat_manip_type manip_type,
			     const union nf_conntrack_man_proto *min,
			     const union nf_conntrack_man_proto *max)
{
	return true;
}
static bool unknown_unique_tuple(struct nf_conntrack_tuple *tuple,
				 const struct nf_nat_range *range,
				 enum nf_nat_manip_type maniptype,
				 const struct nf_conn *ct)
{
	return false;
}
static bool
unknown_manip_pkt(struct sk_buff *skb,
		  unsigned int iphdroff,
		  const struct nf_conntrack_tuple *tuple,
		  enum nf_nat_manip_type maniptype)
{
	return true;
}
static int sockstat_seq_open(struct inode *inode, struct file *file)
{
	return single_open_net(inode, file, sockstat_seq_show);
}
static int snmp_seq_open(struct inode *inode, struct file *file)
{
	return single_open_net(inode, file, snmp_seq_show);
}
static int netstat_seq_open(struct inode *inode, struct file *file)
{
	return single_open_net(inode, file, netstat_seq_show);
}
int __init ip_misc_proc_init(void)
{
	return register_pernet_subsys(&ip_proc_ops);
}
static int raw_v4_seq_open(struct inode *inode, struct file *file)
{
	return raw_seq_open(inode, file, &raw_v4_hashinfo, &raw_seq_ops);
}
int __init raw_proc_init(void)
{
	return register_pernet_subsys(&raw_net_ops);
}
void __init raw_proc_exit(void)
{
	unregister_pernet_subsys(&raw_net_ops);
}
static inline unsigned int rt_hash(__be32 daddr, __be32 saddr, int idx,
		int genid)
{
	return jhash_3words((__force u32)(__be32)(daddr),
			    (__force u32)(__be32)(saddr),
			    idx, genid)
		& rt_hash_mask;
}
static inline int rt_genid(struct net *net)
{
	return atomic_read(&net->ipv4.rt_genid);
}
static int rt_cache_seq_open(struct inode *inode, struct file *file)
{
	return seq_open_net(inode, file, &rt_cache_seq_ops,
			sizeof(struct rt_cache_iter_state));
}
static int rt_cpu_seq_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &rt_cpu_seq_ops);
}
static int __init ip_rt_proc_init(void)
{
	return register_pernet_subsys(&ip_rt_proc_ops);
}
static inline int ip_rt_proc_init(void)
{
	return 0;
}
static inline void rt_free(struct rtable *rt)
{
	call_rcu_bh(&rt->u.dst.rcu_head, dst_rcu_free);
}
static inline int rt_fast_clean(struct rtable *rth)
{
	return (rth->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST)) &&
		rth->fl.iif && rth->u.dst.rt_next;
}
static inline int rt_valuable(struct rtable *rth)
{
	return (rth->rt_flags & (RTCF_REDIRECTED | RTCF_NOTIFY)) ||
		rth->u.dst.expires;
}
static inline bool rt_caching(const struct net *net)
{
	return net->ipv4.current_rt_cache_rebuild_count <=
		net->ipv4.sysctl_rt_cache_rebuild_count;
}
static inline bool compare_hash_inputs(const struct flowi *fl1,
					const struct flowi *fl2)
{
	return (__force u32)(((fl1->nl_u.ip4_u.daddr ^ fl2->nl_u.ip4_u.daddr) |
		(fl1->nl_u.ip4_u.saddr ^ fl2->nl_u.ip4_u.saddr) |
		(fl1->iif ^ fl2->iif)) == 0);
}
static inline int compare_keys(struct flowi *fl1, struct flowi *fl2)
{
	return ((__force u32)((fl1->nl_u.ip4_u.daddr ^ fl2->nl_u.ip4_u.daddr) |
		(fl1->nl_u.ip4_u.saddr ^ fl2->nl_u.ip4_u.saddr)) |
		(fl1->mark ^ fl2->mark) |
		(*(u16 *)&fl1->nl_u.ip4_u.tos ^
		 *(u16 *)&fl2->nl_u.ip4_u.tos) |
		(fl1->oif ^ fl2->oif) |
		(fl1->iif ^ fl2->iif)) == 0;
}
static inline int compare_netns(struct rtable *rt1, struct rtable *rt2)
{
	return dev_net(rt1->u.dst.dev) == dev_net(rt2->u.dst.dev);
}
static inline int rt_is_expired(struct rtable *rth)
{
	return rth->rt_genid != rt_genid(dev_net(rth->u.dst.dev));
}
static struct dst_entry *ipv4_dst_check(struct dst_entry *dst, u32 cookie)
{
	return NULL;
}
int ip_route_output_key(struct net *net, struct rtable **rp, struct flowi *flp)
{
	return ip_route_output_flow(net, rp, flp, NULL, 0);
}
void ip_rt_multicast_event(struct in_device *in_dev)
{
	rt_cache_flush(dev_net(in_dev->dev), 0);
}
void __init ip_static_sysctl_init(void)
{
	register_sysctl_paths(ipv4_path, ipv4_skeleton);
}
static __u32 secure_tcp_syn_cookie(__be32 saddr, __be32 daddr, __be16 sport,
				   __be16 dport, __u32 sseq, __u32 count,
				   __u32 data)
{
	return (cookie_hash(saddr, daddr, sport, dport, 0, 0) +
		sseq + (count << COOKIEBITS) +
		((cookie_hash(saddr, daddr, sport, dport, count, 1) + data)
		 & COOKIEMASK));
}
static inline int forced_push(struct tcp_sock *tp)
{
	return after(tp->write_seq, tp->pushed_seq + (tp->max_window >> 1));
}
static inline int tcp_need_reset(int state)
{
	return (1 << state) &
	       (TCPF_ESTABLISHED | TCPF_CLOSE_WAIT | TCPF_FIN_WAIT1 |
		TCPF_FIN_WAIT2 | TCPF_SYN_RECV);
}
void __tcp_put_md5sig_pool(void)
{
	tcp_free_md5sig_pool();
}
static void __exit bictcp_unregister(void)
{
	tcp_unregister_congestion_control(&bictcp);
}
static int __init tcp_congestion_default(void)
{
	return tcp_set_default_congestion_control(CONFIG_DEFAULT_TCP_CONG);
}
static void __exit cubictcp_unregister(void)
{
	tcp_unregister_congestion_control(&cubictcp);
}
static int __init tcp_diag_init(void)
{
	return inet_diag_register(&tcp_diag_handler);
}
static void __exit tcp_diag_exit(void)
{
	inet_diag_unregister(&tcp_diag_handler);
}
static void __exit hstcp_unregister(void)
{
	tcp_unregister_congestion_control(&tcp_highspeed);
}
static inline u32 htcp_cong_time(const struct htcp *ca)
{
	return jiffies - ca->last_cong;
}
static inline u32 htcp_ccount(const struct htcp *ca)
{
	return htcp_cong_time(ca) / ca->minRTT;
}
static void __exit htcp_unregister(void)
{
	tcp_unregister_congestion_control(&htcp);
}
static void __exit hybla_unregister(void)
{
	tcp_unregister_congestion_control(&tcp_hybla);
}
static inline u32 max_delay(const struct illinois *ca)
{
	return ca->max_rtt - ca->base_rtt;
}
static void __exit tcp_illinois_unregister(void)
{
	tcp_unregister_congestion_control(&tcp_illinois);
}
static inline void TCP_ECN_withdraw_cwr(struct tcp_sock *tp)
{
	tp->ecn_flags &= ~TCP_ECN_DEMAND_CWR;
}
static void tcp_dsack_seen(struct tcp_sock *tp)
{
	tp->rx_opt.sack_ok |= 4;
}
static int tcp_skb_seglen(struct sk_buff *skb)
{
	return tcp_skb_pcount(skb) == 1 ? skb->len : tcp_skb_mss(skb);
}
static int skb_can_shift(struct sk_buff *skb)
{
	return !skb_headlen(skb) && skb_is_nonlinear(skb);
}
static int tcp_sack_cache_ok(struct tcp_sock *tp, struct tcp_sack_block *cache)
{
	return cache < tp->recv_sack_cache + ARRAY_SIZE(tp->recv_sack_cache);
}
static inline void tcp_reset_reno_sack(struct tcp_sock *tp)
{
	tp->sacked_out = 0;
}
static int tcp_is_sackfrto(const struct tcp_sock *tp)
{
	return (sysctl_tcp_frto == 0x2) && !tcp_is_reno(tp);
}
static inline int tcp_fackets_out(struct tcp_sock *tp)
{
	return tcp_is_reno(tp) ? tp->sacked_out + 1 : tp->fackets_out;
}
static inline int tcp_dupack_heurestics(struct tcp_sock *tp)
{
	return tcp_is_fack(tp) ? tp->fackets_out : tp->sacked_out + 1;
}
static inline int tcp_skb_timedout(struct sock *sk, struct sk_buff *skb)
{
	return (tcp_time_stamp - TCP_SKB_CB(skb)->when > inet_csk(sk)->icsk_rto);
}
static inline int tcp_packet_delayed(struct tcp_sock *tp)
{
	return !tp->retrans_stamp ||
		(tp->rx_opt.saw_tstamp && tp->rx_opt.rcv_tsecr &&
		 before(tp->rx_opt.rcv_tsecr, tp->retrans_stamp));
}
static inline int tcp_may_undo(struct tcp_sock *tp)
{
	return tp->undo_marker && (!tp->undo_retrans || tcp_packet_delayed(tp));
}
static inline int tcp_ack_is_dubious(const struct sock *sk, const int flag)
{
	return (!(flag & FLAG_NOT_DUP) || (flag & FLAG_CA_ALERT) ||
		inet_csk(sk)->icsk_ca_state != TCP_CA_Open);
}
static inline int tcp_may_update_window(const struct tcp_sock *tp,
					const u32 ack, const u32 ack_seq,
					const u32 nwin)
{
	return (after(ack, tp->snd_una) ||
		after(ack_seq, tp->snd_wl1) ||
		(ack_seq == tp->snd_wl1 && nwin > tp->snd_wnd));
}
static void tcp_ratehalving_spur_to_response(struct sock *sk)
{
	tcp_enter_cwr(sk, 0);
}
static inline int tcp_sequence(struct tcp_sock *tp, u32 seq, u32 end_seq)
{
	return	!before(end_seq, tp->rcv_wup) &&
		!after(seq, tp->rcv_nxt + tcp_receive_window(tp));
}
static inline int tcp_checksum_complete_user(struct sock *sk,
					     struct sk_buff *skb)
{
	return !skb_csum_unnecessary(skb) &&
	       __tcp_checksum_complete_user(sk, skb);
}
static inline
struct tcp_md5sig_key *tcp_v4_md5_do_lookup(struct sock *sk, __be32 addr)
{
	return NULL;
}
static inline __u32 tcp_v4_init_sequence(struct sk_buff *skb)
{
	return secure_tcp_sequence_number(ip_hdr(skb)->daddr,
					  ip_hdr(skb)->saddr,
					  tcp_hdr(skb)->dest,
					  tcp_hdr(skb)->source);
}
static void tcp_v4_reqsk_send_ack(struct sock *sk, struct sk_buff *skb,
				  struct request_sock *req)
{
	tcp_v4_send_ack(skb, tcp_rsk(req)->snt_isn + 1,
			tcp_rsk(req)->rcv_isn + 1, req->rcv_wnd,
			req->ts_recent,
			0,
			tcp_v4_md5_do_lookup(sk, ip_hdr(skb)->daddr),
			inet_rsk(req)->no_srccheck ? IP_REPLY_ARG_NOSRCCHECK : 0);
}
static int tcp_v4_send_synack(struct sock *sk, struct request_sock *req)
{
	return __tcp_v4_send_synack(sk, req, NULL);
}
static void tcp_v4_reqsk_destructor(struct request_sock *req)
{
	kfree(inet_rsk(req)->opt);
}
struct tcp_md5sig_key *tcp_v4_md5_lookup(struct sock *sk,
					 struct sock *addr_sk)
{
	return tcp_v4_md5_do_lookup(sk, inet_sk(addr_sk)->daddr);
}
static struct tcp_md5sig_key *tcp_v4_reqsk_md5_lookup(struct sock *sk,
						      struct request_sock *req)
{
	return tcp_v4_md5_do_lookup(sk, inet_rsk(req)->rmt_addr);
}
static int tcp_v4_md5_add_func(struct sock *sk, struct sock *addr_sk,
			       u8 *newkey, u8 newkeylen)
{
	return tcp_v4_md5_do_add(sk, inet_sk(addr_sk)->daddr,
				 newkey, newkeylen);
}
static inline struct inet_timewait_sock *tw_head(struct hlist_nulls_head *head)
{
	return hlist_nulls_empty(head) ? NULL :
		list_entry(head->first, struct inet_timewait_sock, tw_node);
}
static inline struct inet_timewait_sock *tw_next(struct inet_timewait_sock *tw)
{
	return !is_a_nulls(tw->tw_node.next) ?
		hlist_nulls_entry(tw->tw_node.next, typeof(*tw), tw_node) : NULL;
}
static inline int empty_bucket(struct tcp_iter_state *st)
{
	return hlist_nulls_empty(&tcp_hashinfo.ehash[st->bucket].chain) &&
		hlist_nulls_empty(&tcp_hashinfo.ehash[st->bucket].twchain);
}
void tcp_proc_unregister(struct net *net, struct tcp_seq_afinfo *afinfo)
{
	proc_net_remove(net, afinfo->name);
}
static int tcp4_proc_init_net(struct net *net)
{
	return tcp_proc_register(net, &tcp4_seq_afinfo);
}
static void tcp4_proc_exit_net(struct net *net)
{
	tcp_proc_unregister(net, &tcp4_seq_afinfo);
}
int __init tcp4_proc_init(void)
{
	return register_pernet_subsys(&tcp4_net_ops);
}
void tcp4_proc_exit(void)
{
	unregister_pernet_subsys(&tcp4_net_ops);
}
static void __exit tcp_lp_unregister(void)
{
	tcp_unregister_congestion_control(&tcp_lp);
}
static inline void TCP_ECN_openreq_child(struct tcp_sock *tp,
					 struct request_sock *req)
{
	tp->ecn_flags = inet_rsk(req)->ecn_ok ? TCP_ECN_OK : 0;
}
static inline int tcp_urg_mode(const struct tcp_sock *tp)
{
	return tp->snd_una != tp->snd_up;
}
static int tcp_bound_to_half_wnd(struct tcp_sock *tp, int pktsize)
{
	if (tp->max_window && pktsize > (tp->max_window >> 1))
		return max(tp->max_window >> 1, 68U - tp->tcp_header_len);
	else
		return pktsize;
}
static inline int tcp_minshall_check(const struct tcp_sock *tp)
{
	return after(tp->snd_sml, tp->snd_una) &&
		!after(tp->snd_sml, tp->snd_nxt);
}
static inline int tcp_nagle_check(const struct tcp_sock *tp,
				  const struct sk_buff *skb,
				  unsigned mss_now, int nonagle)
{
	return (skb->len < mss_now &&
		((nonagle & TCP_NAGLE_CORK) ||
		 (!nonagle && tp->packets_out && tcp_minshall_check(tp))));
}
static inline int tcp_probe_used(void)
{
	return (tcp_probe.head - tcp_probe.tail) % bufsize;
}
static inline int tcp_probe_avail(void)
{
	return bufsize - tcp_probe_used();
}
static int __init tcp_scalable_register(void)
{
	return tcp_register_congestion_control(&tcp_scalable);
}
static void __exit tcp_scalable_unregister(void)
{
	tcp_unregister_congestion_control(&tcp_scalable);
}
void tcp_init_xmit_timers(struct sock *sk)
{
	inet_csk_init_xmit_timers(sk, &tcp_write_timer, &tcp_delack_timer,
				  &tcp_keepalive_timer);
}
static void tcp_synack_timer(struct sock *sk)
{
	inet_csk_reqsk_queue_prune(sk, TCP_SYNQ_INTERVAL,
				   TCP_TIMEOUT_INIT, TCP_RTO_MAX);
}
static void __exit tcp_vegas_unregister(void)
{
	tcp_unregister_congestion_control(&tcp_vegas);
}
static void __exit tcp_veno_unregister(void)
{
	tcp_unregister_congestion_control(&tcp_veno);
}
static inline u32 westwood_do_filter(u32 a, u32 b)
{
	return (((7 * a) + b) >> 3);
}
static void __exit tcp_westwood_unregister(void)
{
	tcp_unregister_congestion_control(&tcp_westwood);
}
static void __exit tcp_yeah_unregister(void)
{
	tcp_unregister_congestion_control(&tcp_yeah);
}
static inline struct xfrm_tunnel **fam_handlers(unsigned short family)
{
	return (family == AF_INET) ? &tunnel4_handlers : &tunnel64_handlers;
}
int udp_v4_get_port(struct sock *sk, unsigned short snum)
{
	return udp_lib_get_port(sk, snum, ipv4_rcv_saddr_equal);
}
struct sock *udp4_lib_lookup(struct net *net, __be32 saddr, __be16 sport,
			     __be32 daddr, __be16 dport, int dif)
{
	return __udp4_lib_lookup(net, saddr, sport, daddr, dport, dif, &udp_table);
}
void udp_err(struct sk_buff *skb, u32 info)
{
	__udp4_lib_err(skb, info, &udp_table);
}
int udp_rcv(struct sk_buff *skb)
{
	return __udp4_lib_rcv(skb, &udp_table, IPPROTO_UDP);
}
static void *udp_seq_start(struct seq_file *seq, loff_t *pos)
{
	return *pos ? udp_get_idx(seq, *pos-1) : SEQ_START_TOKEN;
}
void udp_proc_unregister(struct net *net, struct udp_seq_afinfo *afinfo)
{
	proc_net_remove(net, afinfo->name);
}
static int udp4_proc_init_net(struct net *net)
{
	return udp_proc_register(net, &udp4_seq_afinfo);
}
static void udp4_proc_exit_net(struct net *net)
{
	udp_proc_unregister(net, &udp4_seq_afinfo);
}
int __init udp4_proc_init(void)
{
	return register_pernet_subsys(&udp4_net_ops);
}
void udp4_proc_exit(void)
{
	unregister_pernet_subsys(&udp4_net_ops);
}
static int udplite_rcv(struct sk_buff *skb)
{
	return __udp4_lib_rcv(skb, &udplite_table, IPPROTO_UDPLITE);
}
static void udplite_err(struct sk_buff *skb, u32 info)
{
	__udp4_lib_err(skb, info, &udplite_table);
}
static int udplite4_proc_init_net(struct net *net)
{
	return udp_proc_register(net, &udplite4_seq_afinfo);
}
static void udplite4_proc_exit_net(struct net *net)
{
	udp_proc_unregister(net, &udplite4_seq_afinfo);
}
static __init int udplite4_proc_init(void)
{
	return register_pernet_subsys(&udplite4_net_ops);
}
static inline int udplite4_proc_init(void)
{
	return 0;
}
int xfrm4_extract_input(struct xfrm_state *x, struct sk_buff *skb)
{
	return xfrm4_extract_header(skb);
}
int xfrm4_rcv(struct sk_buff *skb)
{
	return xfrm4_rcv_spi(skb, ip_hdr(skb)->protocol, 0);
}
static int __init xfrm4_beet_init(void)
{
	return xfrm_register_mode(&xfrm4_beet_mode, AF_INET);
}
static int __init xfrm4_transport_init(void)
{
	return xfrm_register_mode(&xfrm4_transport_mode, AF_INET);
}
static int __init xfrm4_mode_tunnel_init(void)
{
	return xfrm_register_mode(&xfrm4_tunnel_mode, AF_INET);
}
int xfrm4_output(struct sk_buff *skb)
{
	return NF_HOOK_COND(PF_INET, NF_INET_POST_ROUTING, skb,
			    NULL, skb->dst->dev, xfrm4_output_finish,
			    !(IPCB(skb)->flags & IPSKB_REROUTED));
}
static int xfrm4_get_tos(struct flowi *fl)
{
	return fl->fl4_tos;
}
static int xfrm4_init_path(struct xfrm_dst *path, struct dst_entry *dst,
			   int nfheader_len)
{
	return 0;
}
static void __init xfrm4_policy_init(void)
{
	xfrm_policy_register_afinfo(&xfrm4_policy_afinfo);
}
static void __exit xfrm4_policy_fini(void)
{
	xfrm_policy_unregister_afinfo(&xfrm4_policy_afinfo);
}
void __init xfrm4_state_init(void)
{
	xfrm_state_register_afinfo(&xfrm4_state_afinfo);
}
static int ipip_xfrm_rcv(struct xfrm_state *x, struct sk_buff *skb)
{
	return ip_hdr(skb)->protocol;
}
static int xfrm_tunnel_rcv(struct sk_buff *skb)
{
	return xfrm4_rcv_spi(skb, IPPROTO_IPIP, ip_hdr(skb)->saddr);
}
static int xfrm_tunnel_err(struct sk_buff *skb, u32 info)
{
	return -ENOENT;
}
static inline bool addrconf_qdisc_ok(const struct net_device *dev)
{
	return !qdisc_tx_is_noop(dev);
}
static inline int addrconf_is_prefix_route(const struct rt6_info *rt)
{
	return ((rt->rt6i_flags & (RTF_GATEWAY | RTF_DEFAULT)) == 0);
}
static void if6_seq_stop(struct seq_file *seq, void *v)
{
	read_unlock_bh(&addrconf_hash_lock);
}
static int if6_seq_open(struct inode *inode, struct file *file)
{
	return seq_open_net(inode, file, &if6_seq_ops,
			    sizeof(struct if6_iter_state));
}
static void if6_proc_net_exit(struct net *net)
{
       proc_net_remove(net, "if_inet6");
}
int __init if6_proc_init(void)
{
	return register_pernet_subsys(&if6_proc_net_ops);
}
void if6_proc_exit(void)
{
	unregister_pernet_subsys(&if6_proc_net_ops);
}
static inline int rt_scope(int ifa_scope)
{
	if (ifa_scope & IFA_HOST)
		return RT_SCOPE_HOST;
	else if (ifa_scope & IFA_LINK)
		return RT_SCOPE_LINK;
	else if (ifa_scope & IFA_SITE)
		return RT_SCOPE_SITE;
	else
		return RT_SCOPE_UNIVERSE;
}
static inline int inet6_ifaddr_msgsize(void)
{
	return NLMSG_ALIGN(sizeof(struct ifaddrmsg))
	       + nla_total_size(16) /* IFA_ADDRESS */
	       + nla_total_size(sizeof(struct ifa_cacheinfo));
}
static inline size_t inet6_if_nlmsg_size(void)
{
	return NLMSG_ALIGN(sizeof(struct ifinfomsg))
	       + nla_total_size(IFNAMSIZ) /* IFLA_IFNAME */
	       + nla_total_size(MAX_ADDR_LEN) /* IFLA_ADDRESS */
	       + nla_total_size(4) /* IFLA_MTU */
	       + nla_total_size(4) /* IFLA_LINK */
	       + nla_total_size( /* IFLA_PROTINFO */
			nla_total_size(4) /* IFLA_INET6_FLAGS */
			+ nla_total_size(sizeof(struct ifla_cacheinfo))
			+ nla_total_size(DEVCONF_MAX * 4) /* IFLA_INET6_CONF */
			+ nla_total_size(IPSTATS_MIB_MAX * 8) /* IFLA_INET6_STATS */
			+ nla_total_size(ICMP6_MIB_MAX * 8) /* IFLA_INET6_ICMP6STATS */
		 );
}
static inline size_t inet6_prefix_nlmsg_size(void)
{
	return NLMSG_ALIGN(sizeof(struct prefixmsg))
	       + nla_total_size(sizeof(struct in6_addr))
	       + nla_total_size(sizeof(struct prefix_cacheinfo));
}
int register_inet6addr_notifier(struct notifier_block *nb)
{
	return atomic_notifier_chain_register(&inet6addr_chain, nb);
}
int unregister_inet6addr_notifier(struct notifier_block *nb)
{
	return atomic_notifier_chain_unregister(&inet6addr_chain,nb);
}
static inline
struct net *ip6addrlbl_net(const struct ip6addrlbl_entry *lbl)
{
	return lbl->lbl_net;
}
static void ip6addrlbl_free_rcu(struct rcu_head *h)
{
	ip6addrlbl_free(container_of(h, struct ip6addrlbl_entry, rcu));
}
static inline int ip6addrlbl_hold(struct ip6addrlbl_entry *p)
{
	return atomic_inc_not_zero(&p->refcnt);
}
static inline int ip6addrlbl_msgsize(void)
{
	return (NLMSG_ALIGN(sizeof(struct ifaddrlblmsg))
		+ nla_total_size(16)	/* IFAL_ADDRESS */
		+ nla_total_size(4)	/* IFAL_LABEL */
	);
}
static void ipv6_packet_cleanup(void)
{
	dev_remove_pack(&ipv6_packet_type);
}
static int ac6_seq_open(struct inode *inode, struct file *file)
{
	return seq_open_net(inode, file, &ac6_seq_ops,
			    sizeof(struct ac6_iter_state));
}
void ac6_proc_exit(struct net *net)
{
	proc_net_remove(net, "anycast6");
}
static inline u8 *esp_tmp_iv(struct crypto_aead *aead, void *tmp)
{
	return crypto_aead_ivsize(aead) ?
	       PTR_ALIGN((u8 *)tmp, crypto_aead_alignmask(aead) + 1) : tmp;
}
static inline struct scatterlist *esp_req_sg(struct crypto_aead *aead,
					     struct aead_request *req)
{
	return (void *)ALIGN((unsigned long)(req + 1) +
			     crypto_aead_reqsize(aead),
			     __alignof__(struct scatterlist));
}
static inline struct scatterlist *esp_givreq_sg(
	struct crypto_aead *aead, struct aead_givcrypt_request *req)
{
	return (void *)ALIGN((unsigned long)(req + 1) +
			     crypto_aead_reqsize(aead),
			     __alignof__(struct scatterlist));
}
static inline struct inet6_dev *ipv6_skb_idev(struct sk_buff *skb)
{
	return skb->dst ? ip6_dst_idev(skb->dst) : __in6_dev_get(skb->dev);
}
int ipv6_ext_hdr(u8 nexthdr)
{
	return ( (nexthdr == NEXTHDR_HOP)	||
		 (nexthdr == NEXTHDR_ROUTING)	||
		 (nexthdr == NEXTHDR_FRAGMENT)	||
		 (nexthdr == NEXTHDR_AUTH)	||
		 (nexthdr == NEXTHDR_NONE)	||
		 (nexthdr == NEXTHDR_DEST) );
}
static u32 fib6_rule_default_pref(struct fib_rules_ops *ops)
{
	return 0x3FFF;
}
static size_t fib6_rule_nlmsg_payload(struct fib_rule *rule)
{
	return nla_total_size(16) /* dst */
	       + nla_total_size(16); /* src */
}
int __init fib6_rules_init(void)
{
	return register_pernet_subsys(&fib6_rules_net_ops);
}
void fib6_rules_cleanup(void)
{
	unregister_pernet_subsys(&fib6_rules_net_ops);
}
static inline struct sock *icmpv6_sk(struct net *net)
{
	return net->ipv6.icmp_sk[smp_processor_id()];
}
static __inline__ void icmpv6_xmit_unlock(struct sock *sk)
{
	spin_unlock_bh(&sk->sk_lock.slock);
}
int inet6_hash_connect(struct inet_timewait_death_row *death_row,
		       struct sock *sk)
{
	return __inet_hash_connect(death_row, sk, inet6_sk_port_offset(sk),
			__inet6_check_established, __inet6_hash);
}
static __inline__ void node_free(struct fib6_node * fn)
{
	kmem_cache_free(fib6_node_kmem, fn);
}
struct fib6_table *fib6_new_table(struct net *net, u32 id)
{
	return fib6_get_table(net, id);
}
struct fib6_table *fib6_get_table(struct net *net, u32 id)
{
	  return net->ipv6.fib6_main_tbl;
}
struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi *fl,
				   int flags, pol_lookup_t lookup)
{
	return (struct dst_entry *) lookup(net, net->ipv6.fib6_main_tbl, fl, flags);
}
static void fib6_tables_init(struct net *net)
{
	fib6_link_table(net, net->ipv6.fib6_main_tbl);
}
static void fib6_prune_clones(struct net *net, struct fib6_node *fn,
			      struct rt6_info *rt)
{
	fib6_clean_tree(net, fn, fib6_prune_clone, 1, rt);
}
static void fib6_gc_timer_cb(unsigned long arg)
{
	fib6_run_gc(0, (struct net *)arg);
}
static void ip6fl_seq_stop(struct seq_file *seq, void *v)
{
	read_unlock_bh(&ip6_fl_lock);
}
static int ip6fl_seq_open(struct inode *inode, struct file *file)
{
	return seq_open_net(inode, file, &ip6fl_seq_ops,
			    sizeof(struct ip6fl_iter_state));
}
static void ip6_flowlabel_proc_fini(struct net *net)
{
	proc_net_remove(net, "ip6_flowlabel");
}
static inline int ip6_flowlabel_proc_init(struct net *net)
{
	return 0;
}
static inline void ip6_flowlabel_proc_fini(struct net *net)
{
	return ;
}
int ip6_flowlabel_init(void)
{
	return register_pernet_subsys(&ip6_flowlabel_net_ops);
}
int ip6_input(struct sk_buff *skb)
{
	return NF_HOOK(PF_INET6, NF_INET_LOCAL_IN, skb, skb->dev, NULL,
		       ip6_input_finish);
}
static inline int ip6_forward_finish(struct sk_buff *skb)
{
	return dst_output(skb);
}
static inline int ip6_rt_check(struct rt6key *rt_key,
			       struct in6_addr *fl_addr,
			       struct in6_addr *addr_cache)
{
	return ((rt_key->plen != 128 || !ipv6_addr_equal(fl_addr, &rt_key->addr)) &&
		(addr_cache == NULL || !ipv6_addr_equal(fl_addr, addr_cache)));
}
static inline struct ipv6_opt_hdr *ip6_opt_dup(struct ipv6_opt_hdr *src,
					       gfp_t gfp)
{
	return src ? kmemdup(src, (src->hdrlen + 1) * 8, gfp) : NULL;
}
static inline struct ipv6_rt_hdr *ip6_rthdr_dup(struct ipv6_rt_hdr *src,
						gfp_t gfp)
{
	return src ? kmemdup(src, (src->hdrlen + 1) * 8, gfp) : NULL;
}
static int ip4ip6_rcv(struct sk_buff *skb)
{
	return ip6_tnl_rcv(skb, ETH_P_IP, IPPROTO_IPIP,
			   ip4ip6_dscp_ecn_decapsulate);
}
static int ip6ip6_rcv(struct sk_buff *skb)
{
	return ip6_tnl_rcv(skb, ETH_P_IPV6, IPPROTO_IPV6,
			   ip6ip6_dscp_ecn_decapsulate);
}
static inline int
ip6_tnl_addr_conflict(struct ip6_tnl *t, struct ipv6hdr *hdr)
{
	return ipv6_addr_equal(&t->parms.raddr, &hdr->saddr);
}
static void ip6mr_vif_seq_stop(struct seq_file *seq, void *v)
{
	read_unlock(&mrt_lock);
}
static int ip6mr_vif_open(struct inode *inode, struct file *file)
{
	return seq_open_net(inode, file, &ip6mr_vif_seq_ops,
			    sizeof(struct ipmr_vif_iter));
}
static int ipmr_mfc_open(struct inode *inode, struct file *file)
{
	return seq_open_net(inode, file, &ipmr_mfc_seq_ops,
			    sizeof(struct ipmr_mfc_iter));
}
static int grec_size(struct ifmcaddr6 *pmc, int type, int gdel, int sdel)
{
	return sizeof(struct mld2_grec) + 16 * mld_scount(pmc,type,gdel,sdel);
}
static int igmp6_mc_seq_open(struct inode *inode, struct file *file)
{
	return seq_open_net(inode, file, &igmp6_mc_seq_ops,
			    sizeof(struct igmp6_mc_iter_state));
}
static int igmp6_mcf_seq_open(struct inode *inode, struct file *file)
{
	return seq_open_net(inode, file, &igmp6_mcf_seq_ops,
			    sizeof(struct igmp6_mcf_iter_state));
}
static int igmp6_proc_init(struct net *net)
{
	return 0;
}
static void igmp6_proc_exit(struct net *net)
{
	;
}
int __init igmp6_init(void)
{
	return register_pernet_subsys(&igmp6_net_ops);
}
void igmp6_cleanup(void)
{
	unregister_pernet_subsys(&igmp6_net_ops);
}
static inline unsigned int calc_padlen(unsigned int len, unsigned int n)
{
	return (n - len + 16) & 0x7;
}
static inline void mip6_param_prob(struct sk_buff *skb, int code, int pos)
{
	icmpv6_send(skb, ICMPV6_PARAMPROB, code, pos, skb->dev);
}
static inline int ndisc_opt_addr_space(struct net_device *dev)
{
	return NDISC_OPT_SPACE(dev->addr_len + ndisc_addr_option_pad(dev->type));
}
static inline int ndisc_is_useropt(struct nd_opt_hdr *opt)
{
	return (opt->nd_opt_type == ND_OPT_RDNSS);
}
static void ndisc_net_exit(struct net *net)
{
	inet_ctl_sock_destroy(net->ipv6.ndisc_sk);
}
int __init ipv6_netfilter_init(void)
{
	return nf_register_afinfo(&nf_ip6_afinfo);
}
void ipv6_netfilter_fini(void)
{
	nf_unregister_afinfo(&nf_ip6_afinfo);
}
static void
ipq_dev_drop(int ifindex)
{
	ipq_flush(dev_cmp, ifindex);
}
static int ip6_queue_open(struct inode *inode, struct file *file)
{
	return single_open(file, ip6_queue_show, NULL);
}
int
ip6t_ext_hdr(u8 nexthdr)
{
	return ( (nexthdr == IPPROTO_HOPOPTS)   ||
		 (nexthdr == IPPROTO_ROUTING)   ||
		 (nexthdr == IPPROTO_FRAGMENT)  ||
		 (nexthdr == IPPROTO_ESP)       ||
		 (nexthdr == IPPROTO_AH)        ||
		 (nexthdr == IPPROTO_NONE)      ||
		 (nexthdr == IPPROTO_DSTOPTS) );
}
static inline struct ip6t_entry *
get_entry(void *base, unsigned int offset)
{
	return (struct ip6t_entry *)(base + offset);
}
static inline bool
icmp6_type_code_match(u_int8_t test_type, u_int8_t min_code, u_int8_t max_code,
		     u_int8_t type, u_int8_t code,
		     bool invert)
{
	return (type == test_type && code >= min_code && code <= max_code)
		^ invert;
}
static int __init hl_tg6_init(void)
{
	return xt_register_target(&hl_tg6_reg);
}
static void __exit hl_tg6_exit(void)
{
	xt_unregister_target(&hl_tg6_reg);
}
static int __init reject_tg6_init(void)
{
	return xt_register_target(&reject_tg6_reg);
}
static void __exit reject_tg6_exit(void)
{
	xt_unregister_target(&reject_tg6_reg);
}
static int __init ah_mt6_init(void)
{
	return xt_register_match(&ah_mt6_reg);
}
static void __exit ah_mt6_exit(void)
{
	xt_unregister_match(&ah_mt6_reg);
}
static int __init eui64_mt6_init(void)
{
	return xt_register_match(&eui64_mt6_reg);
}
static void __exit eui64_mt6_exit(void)
{
	xt_unregister_match(&eui64_mt6_reg);
}
static int __init frag_mt6_init(void)
{
	return xt_register_match(&frag_mt6_reg);
}
static void __exit frag_mt6_exit(void)
{
	xt_unregister_match(&frag_mt6_reg);
}
static int __init hbh_mt6_init(void)
{
	return xt_register_matches(hbh_mt6_reg, ARRAY_SIZE(hbh_mt6_reg));
}
static void __exit hbh_mt6_exit(void)
{
	xt_unregister_matches(hbh_mt6_reg, ARRAY_SIZE(hbh_mt6_reg));
}
static int __init hl_mt6_init(void)
{
	return xt_register_match(&hl_mt6_reg);
}
static void __exit hl_mt6_exit(void)
{
	xt_unregister_match(&hl_mt6_reg);
}
static int __init ipv6header_mt6_init(void)
{
	return xt_register_match(&ipv6header_mt6_reg);
}
static void __exit ipv6header_mt6_exit(void)
{
	xt_unregister_match(&ipv6header_mt6_reg);
}
static inline bool
type_match(u_int8_t min, u_int8_t max, u_int8_t type, bool invert)
{
	return (type >= min && type <= max) ^ invert;
}
static int __init mh_mt6_init(void)
{
	return xt_register_match(&mh_mt6_reg);
}
static void __exit mh_mt6_exit(void)
{
	xt_unregister_match(&mh_mt6_reg);
}
static int __init rt_mt6_init(void)
{
	return xt_register_match(&rt_mt6_reg);
}
static void __exit rt_mt6_exit(void)
{
	xt_unregister_match(&rt_mt6_reg);
}
static unsigned int
ip6t_in_hook(unsigned int hook,
		   struct sk_buff *skb,
		   const struct net_device *in,
		   const struct net_device *out,
		   int (*okfn)(struct sk_buff *))
{
	return ip6t_do_table(skb, hook, in, out,
			     dev_net(in)->ipv6.ip6table_filter);
}
static unsigned int
ip6t_local_out_hook(unsigned int hook,
		   struct sk_buff *skb,
		   const struct net_device *in,
		   const struct net_device *out,
		   int (*okfn)(struct sk_buff *))
{
	return ip6t_do_table(skb, hook, in, out,
			     dev_net(out)->ipv6.ip6table_filter);
}
static unsigned int
ip6t_in_hook(unsigned int hook,
	 struct sk_buff *skb,
	 const struct net_device *in,
	 const struct net_device *out,
	 int (*okfn)(struct sk_buff *))
{
	return ip6t_do_table(skb, hook, in, out,
			     dev_net(in)->ipv6.ip6table_mangle);
}
static unsigned int
ip6t_post_routing_hook(unsigned int hook,
		struct sk_buff *skb,
		const struct net_device *in,
		const struct net_device *out,
		int (*okfn)(struct sk_buff *))
{
	return ip6t_do_table(skb, hook, in, out,
			     dev_net(out)->ipv6.ip6table_mangle);
}
static unsigned int
ip6t_pre_routing_hook(unsigned int hook,
	 struct sk_buff *skb,
	 const struct net_device *in,
	 const struct net_device *out,
	 int (*okfn)(struct sk_buff *))
{
	return ip6t_do_table(skb, hook, in, out,
			     dev_net(in)->ipv6.ip6table_raw);
}
static unsigned int
ip6t_local_out_hook(unsigned int hook,
	 struct sk_buff *skb,
	 const struct net_device *in,
	 const struct net_device *out,
	 int (*okfn)(struct sk_buff *))
{
	return ip6t_do_table(skb, hook, in, out,
			     dev_net(out)->ipv6.ip6table_raw);
}
static unsigned int
ip6t_local_in_hook(unsigned int hook,
		   struct sk_buff *skb,
		   const struct net_device *in,
		   const struct net_device *out,
		   int (*okfn)(struct sk_buff *))
{
	return ip6t_do_table(skb, hook, in, out,
			     dev_net(in)->ipv6.ip6table_security);
}
static unsigned int
ip6t_forward_hook(unsigned int hook,
		  struct sk_buff *skb,
		  const struct net_device *in,
		  const struct net_device *out,
		  int (*okfn)(struct sk_buff *))
{
	return ip6t_do_table(skb, hook, in, out,
			     dev_net(in)->ipv6.ip6table_security);
}
static unsigned int
ip6t_local_out_hook(unsigned int hook,
		    struct sk_buff *skb,
		    const struct net_device *in,
		    const struct net_device *out,
		    int (*okfn)(struct sk_buff *))
{
	return ip6t_do_table(skb, hook, in, out,
			     dev_net(out)->ipv6.ip6table_security);
}
static int ipv6_print_tuple(struct seq_file *s,
			    const struct nf_conntrack_tuple *tuple)
{
	return seq_printf(s, "src=%pI6 dst=%pI6 ",
			  tuple->src.u3.ip6, tuple->dst.u3.ip6);
}
static unsigned int ipv6_conntrack_in(unsigned int hooknum,
				      struct sk_buff *skb,
				      const struct net_device *in,
				      const struct net_device *out,
				      int (*okfn)(struct sk_buff *))
{
	return __ipv6_conntrack_in(dev_net(in), hooknum, skb, okfn);
}
static int icmpv6_print_tuple(struct seq_file *s,
			      const struct nf_conntrack_tuple *tuple)
{
	return seq_printf(s, "type=%u code=%u id=%u ",
			  tuple->dst.u.icmp.type,
			  tuple->dst.u.icmp.code,
			  ntohs(tuple->src.u.icmp.id));
}
static __inline__ void fq_put(struct nf_ct_frag6_queue *fq)
{
	inet_frag_put(&fq->q, &nf_frags);
}
static __inline__ void fq_kill(struct nf_ct_frag6_queue *fq)
{
	inet_frag_kill(&fq->q, &nf_frags);
}
static int sockstat6_seq_open(struct inode *inode, struct file *file)
{
	return single_open_net(inode, file, sockstat6_seq_show);
}
static int snmp6_seq_open(struct inode *inode, struct file *file)
{
	return single_open_net(inode, file, snmp6_seq_show);
}
static int snmp6_dev_seq_open(struct inode *inode, struct file *file)
{
	return single_open(file, snmp6_dev_seq_show, PDE(inode)->data);
}
int __init ipv6_misc_proc_init(void)
{
	return register_pernet_subsys(&ipv6_proc_ops);
}
void ipv6_misc_proc_exit(void)
{
	unregister_pernet_subsys(&ipv6_proc_ops);
}
static int raw6_seq_open(struct inode *inode, struct file *file)
{
	return raw_seq_open(inode, file, &raw_v6_hashinfo, &raw6_seq_ops);
}
static void raw6_exit_net(struct net *net)
{
	proc_net_remove(net, "raw6");
}
int __init raw6_proc_init(void)
{
	return register_pernet_subsys(&raw6_net_ops);
}
void raw6_proc_exit(void)
{
	unregister_pernet_subsys(&raw6_net_ops);
}
void rawv6_exit(void)
{
	inet6_unregister_protosw(&rawv6_protosw);
}
int ip6_frag_nqueues(struct net *net)
{
	return net->ipv6.frags.nqueues;
}
int ip6_frag_mem(struct net *net)
{
	return atomic_read(&net->ipv6.frags.mem);
}
static __inline__ void fq_put(struct frag_queue *fq)
{
	inet_frag_put(&fq->q, &ip6_frags);
}
static __inline__ void fq_kill(struct frag_queue *fq)
{
	inet_frag_kill(&fq->q, &ip6_frags);
}
static void ip6_frags_sysctl_unregister(void)
{
	unregister_net_sysctl_table(ip6_ctl_header);
}
static inline int ip6_frags_ns_sysctl_register(struct net *net)
{
	return 0;
}
static inline int ip6_frags_sysctl_register(void)
{
	return 0;
}
static inline struct rt6_info *ip6_dst_alloc(struct dst_ops *ops)
{
	return (struct rt6_info *)dst_alloc(ops);
}
static __inline__ int rt6_check_expired(const struct rt6_info *rt)
{
	return (rt->rt6i_flags & RTF_EXPIRES &&
		time_after(jiffies, rt->rt6i_expires));
}
static inline int rt6_need_strict(struct in6_addr *daddr)
{
	return (ipv6_addr_type(daddr) &
		(IPV6_ADDR_MULTICAST | IPV6_ADDR_LINKLOCAL | IPV6_ADDR_LOOPBACK));
}
static inline void rt6_probe(struct rt6_info *rt)
{
	return;
}
static struct rt6_info *ip6_pol_route_input(struct net *net, struct fib6_table *table,
					    struct flowi *fl, int flags)
{
	return ip6_pol_route(net, table, fl->iif, fl, flags);
}
static struct rt6_info *ip6_pol_route_output(struct net *net, struct fib6_table *table,
					     struct flowi *fl, int flags)
{
	return ip6_pol_route(net, table, fl->oif, fl, flags);
}
static int ip6_pkt_discard(struct sk_buff *skb)
{
	return ip6_pkt_drop(skb, ICMPV6_NOROUTE, IPSTATS_MIB_INNOROUTES);
}
static int ip6_pkt_prohibit(struct sk_buff *skb)
{
	return ip6_pkt_drop(skb, ICMPV6_ADM_PROHIBITED, IPSTATS_MIB_INNOROUTES);
}
static inline size_t rt6_nlmsg_size(void)
{
	return NLMSG_ALIGN(sizeof(struct rtmsg))
	       + nla_total_size(16) /* RTA_SRC */
	       + nla_total_size(16) /* RTA_DST */
	       + nla_total_size(16) /* RTA_GATEWAY */
	       + nla_total_size(16) /* RTA_PREFSRC */
	       + nla_total_size(4) /* RTA_TABLE */
	       + nla_total_size(4) /* RTA_IIF */
	       + nla_total_size(4) /* RTA_OIF */
	       + nla_total_size(4) /* RTA_PRIORITY */
	       + RTAX_MAX * nla_total_size(4) /* RTA_METRICS */
	       + nla_total_size(sizeof(struct rta_cacheinfo));
}
static int ipv6_route_open(struct inode *inode, struct file *file)
{
	return single_open_net(inode, file, ipv6_route_show);
}
static int rt6_stats_seq_open(struct inode *inode, struct file *file)
{
	return single_open_net(inode, file, rt6_stats_seq_show);
}
static inline struct ip_tunnel **ipip6_bucket(struct sit_net *sitn,
		struct ip_tunnel *t)
{
	return __ipip6_bucket(sitn, &t->parms);
}
static __u32 secure_tcp_syn_cookie(struct in6_addr *saddr, struct in6_addr *daddr,
				   __be16 sport, __be16 dport, __u32 sseq,
				   __u32 count, __u32 data)
{
	return (cookie_hash(saddr, daddr, sport, dport, 0, 0) +
		sseq + (count << COOKIEBITS) +
		((cookie_hash(saddr, daddr, sport, dport, count, 1) + data)
		& COOKIEMASK));
}
void ipv6_static_sysctl_unregister(void)
{
	unregister_net_sysctl_table(ip6_base);
}
static struct tcp_md5sig_key *tcp_v6_md5_do_lookup(struct sock *sk,
						   struct in6_addr *addr)
{
	return NULL;
}
static __inline__ __sum16 tcp_v6_check(int len,
				   struct in6_addr *saddr,
				   struct in6_addr *daddr,
				   __wsum base)
{
	return csum_ipv6_magic(saddr, daddr, len, IPPROTO_TCP, base);
}
static __u32 tcp_v6_init_sequence(struct sk_buff *skb)
{
	return secure_tcpv6_sequence_number(ipv6_hdr(skb)->daddr.s6_addr32,
					    ipv6_hdr(skb)->saddr.s6_addr32,
					    tcp_hdr(skb)->dest,
					    tcp_hdr(skb)->source);
}
static struct tcp_md5sig_key *tcp_v6_md5_lookup(struct sock *sk,
						struct sock *addr_sk)
{
	return tcp_v6_md5_do_lookup(sk, &inet6_sk(addr_sk)->daddr);
}
static struct tcp_md5sig_key *tcp_v6_reqsk_md5_lookup(struct sock *sk,
						      struct request_sock *req)
{
	return tcp_v6_md5_do_lookup(sk, &inet6_rsk(req)->rmt_addr);
}
static int tcp_v6_md5_add_func(struct sock *sk, struct sock *addr_sk,
			       u8 *newkey, __u8 newkeylen)
{
	return tcp_v6_md5_do_add(sk, &inet6_sk(addr_sk)->daddr,
				 newkey, newkeylen);
}
static void tcp_v6_send_ack(struct sk_buff *skb, u32 seq, u32 ack, u32 win, u32 ts,
			    struct tcp_md5sig_key *key)
{
	tcp_v6_send_response(skb, seq, ack, win, ts, key, 0);
}
static void tcp_v6_reqsk_send_ack(struct sock *sk, struct sk_buff *skb,
				  struct request_sock *req)
{
	tcp_v6_send_ack(skb, tcp_rsk(req)->snt_isn + 1, tcp_rsk(req)->rcv_isn + 1, req->rcv_wnd, req->ts_recent,
			tcp_v6_md5_do_lookup(sk, &ipv6_hdr(skb)->daddr));
}
static int tcp_v6_remember_stamp(struct sock *sk)
{
	return 0;
}
int tcp6_proc_init(struct net *net)
{
	return tcp_proc_register(net, &tcp6_seq_afinfo);
}
void tcp6_proc_exit(struct net *net)
{
	tcp_proc_unregister(net, &tcp6_seq_afinfo);
}
static int tcpv6_net_init(struct net *net)
{
	return inet_ctl_sock_create(&net->ipv6.tcp_sk, PF_INET6,
				    SOCK_RAW, IPPROTO_TCP, net);
}
int udp_v6_get_port(struct sock *sk, unsigned short snum)
{
	return udp_lib_get_port(sk, snum, ipv6_rcv_saddr_equal);
}
static __inline__ void udpv6_err(struct sk_buff *skb,
				 struct inet6_skb_parm *opt, int type,
				 int code, int offset, __be32 info     )
{
	__udp6_lib_err(skb, opt, type, code, offset, info, &udp_table);
}
static __inline__ int udpv6_rcv(struct sk_buff *skb)
{
	return __udp6_lib_rcv(skb, &udp_table, IPPROTO_UDP);
}
int udp6_proc_init(struct net *net)
{
	return udp_proc_register(net, &udp6_seq_afinfo);
}
void udp6_proc_exit(struct net *net) {
	udp_proc_unregister(net, &udp6_seq_afinfo);
}
static int udplitev6_rcv(struct sk_buff *skb)
{
	return __udp6_lib_rcv(skb, &udplite_table, IPPROTO_UDPLITE);
}
static void udplitev6_err(struct sk_buff *skb,
			  struct inet6_skb_parm *opt,
			  int type, int code, int offset, __be32 info)
{
	__udp6_lib_err(skb, opt, type, code, offset, info, &udplite_table);
}
static int udplite6_proc_init_net(struct net *net)
{
	return udp_proc_register(net, &udplite6_seq_afinfo);
}
static void udplite6_proc_exit_net(struct net *net)
{
	udp_proc_unregister(net, &udplite6_seq_afinfo);
}
int __init udplite6_proc_init(void)
{
	return register_pernet_subsys(&udplite6_net_ops);
}
void udplite6_proc_exit(void)
{
	unregister_pernet_subsys(&udplite6_net_ops);
}
int xfrm6_extract_input(struct xfrm_state *x, struct sk_buff *skb)
{
	return xfrm6_extract_header(skb);
}
int xfrm6_rcv(struct sk_buff *skb)
{
	return xfrm6_rcv_spi(skb, skb_network_header(skb)[IP6CB(skb)->nhoff],
			     0);
}
static int __init xfrm6_beet_init(void)
{
	return xfrm_register_mode(&xfrm6_beet_mode, AF_INET6);
}
static int __init xfrm6_ro_init(void)
{
	return xfrm_register_mode(&xfrm6_ro_mode, AF_INET6);
}
static int __init xfrm6_transport_init(void)
{
	return xfrm_register_mode(&xfrm6_transport_mode, AF_INET6);
}
static int __init xfrm6_mode_tunnel_init(void)
{
	return xfrm_register_mode(&xfrm6_tunnel_mode, AF_INET6);
}
int xfrm6_find_1stfragopt(struct xfrm_state *x, struct sk_buff *skb,
			  u8 **prevhdr)
{
	return ip6_find_1stfragopt(skb, prevhdr);
}
int xfrm6_output(struct sk_buff *skb)
{
	return NF_HOOK(PF_INET6, NF_INET_POST_ROUTING, skb, NULL, skb->dst->dev,
		       xfrm6_output_finish);
}
static int xfrm6_get_tos(struct flowi *fl)
{
	return 0;
}
static int __init xfrm6_policy_init(void)
{
	return xfrm_policy_register_afinfo(&xfrm6_policy_afinfo);
}
static void xfrm6_policy_fini(void)
{
	xfrm_policy_unregister_afinfo(&xfrm6_policy_afinfo);
}
static int
__xfrm6_state_sort(struct xfrm_state **dst, struct xfrm_state **src, int n)
{
	return __xfrm6_sort((void **)dst, (void **)src, n,
			    __xfrm6_state_sort_cmp, 6);
}
static int
__xfrm6_tmpl_sort(struct xfrm_tmpl **dst, struct xfrm_tmpl **src, int n)
{
	return __xfrm6_sort((void **)dst, (void **)src, n,
			    __xfrm6_tmpl_sort_cmp, 5);
}
int __init xfrm6_state_init(void)
{
	return xfrm_state_register_afinfo(&xfrm6_state_afinfo);
}
void xfrm6_state_fini(void)
{
	xfrm_state_unregister_afinfo(&xfrm6_state_afinfo);
}
static inline unsigned xfrm6_tunnel_spi_hash_byspi(u32 spi)
{
	return spi % XFRM6_TUNNEL_SPI_BYSPI_HSIZE;
}
static int xfrm6_tunnel_input(struct xfrm_state *x, struct sk_buff *skb)
{
	return skb_network_header(skb)[IP6CB(skb)->nhoff];
}
static void xfrm6_tunnel_destroy(struct xfrm_state *x)
{
	xfrm6_tunnel_free_spi((xfrm_address_t *)&x->props.saddr);
}
static int ipxitf_add_local_route(struct ipx_interface *intrfc)
{
	return ipxrtr_add_route(intrfc->if_netnum, intrfc, NULL);
}
const char *ipx_device_name(struct ipx_interface *intrfc)
{
	return intrfc->if_internal ? "Internal" :
		intrfc->if_dev ? intrfc->if_dev->name : "Unknown";
}
static void ipx_seq_interface_stop(struct seq_file *seq, void *v)
{
	spin_unlock_bh(&ipx_interfaces_lock);
}
static void ipx_seq_route_stop(struct seq_file *seq, void *v)
{
	read_unlock_bh(&ipx_routes_lock);
}
static int ipx_seq_route_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &ipx_seq_route_ops);
}
static int ipx_seq_interface_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &ipx_seq_interface_ops);
}
static int ipx_seq_socket_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &ipx_seq_socket_ops);
}
int __init ipx_proc_init(void)
{
	return 0;
}
void ipx_register_sysctl(void)
{
	ipx_table_header = register_sysctl_paths(ipx_path, ipx_table);
}
void ipx_unregister_sysctl(void)
{
	unregister_sysctl_table(ipx_table_header);
}
static int irda_compat_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)
{
	return -ENOIOCTLCMD;
}
static void discovery_seq_stop(struct seq_file *seq, void *v)
{
	spin_unlock_irq(&irlmp->cachelog->hb_spinlock);
}
static void ircomm_seq_stop(struct seq_file *seq, void *v)
{
	spin_unlock_irq(&ircomm->hb_spinlock);
}
static int ircomm_seq_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &ircomm_seq_ops);
}
static void ircomm_tty_send_xchar(struct tty_struct *tty, char ch)
{
	IRDA_DEBUG(0, "%s(), not impl\n", __func__ );
}
static inline void ircomm_tty_next_state(struct ircomm_tty_cb *self, IRCOMM_TTY_STATE state)
{
	self->state = state;
}
static int ircomm_tty_set_serial_info(struct ircomm_tty_cb *self,
				      struct serial_struct __user *new_info)
{
	return 0;
}
struct net_device *alloc_irdadev(int sizeof_priv)
{
	return alloc_netdev(sizeof_priv, "irda%d", irda_device_setup);
}
static inline void iriap_start_watchdog_timer(struct iriap_cb *self,
					      int timeout)
{
	irda_start_timer(&self->watchdog_timer, timeout, self,
			 iriap_watchdog_timer_expired);
}
static void irias_seq_stop(struct seq_file *seq, void *v)
{
	spin_unlock_irq(&irias_objects->hb_spinlock);
}
static void state_s_calling(struct iriap_cb *self, IRIAP_EVENT event,
			    struct sk_buff *skb)
{
	IRDA_DEBUG(0, "%s(), Not implemented\n", __func__);
}
static void state_s_replying(struct iriap_cb *self, IRIAP_EVENT event,
			     struct sk_buff *skb)
{
	IRDA_DEBUG(0, "%s(), Not implemented\n", __func__);
}
static void state_s_wait_for_call(struct iriap_cb *self, IRIAP_EVENT event,
				  struct sk_buff *skb)
{
	IRDA_DEBUG(0, "%s(), Not implemented\n", __func__);
}
static void state_s_wait_active(struct iriap_cb *self, IRIAP_EVENT event,
				struct sk_buff *skb)
{
	IRDA_DEBUG(0, "%s(), Not implemented\n", __func__);
}
static void state_r_waiting(struct iriap_cb *self, IRIAP_EVENT event,
			    struct sk_buff *skb)
{
	IRDA_DEBUG(0, "%s(), Not implemented\n", __func__);
}
static void state_r_wait_active(struct iriap_cb *self, IRIAP_EVENT event,
				struct sk_buff *skb)
{
	IRDA_DEBUG(0, "%s(), Not implemented\n", __func__);
}
int irlan_insert_byte_param(struct sk_buff *skb, char *param, __u8 value)
{
	return __irlan_insert_param(skb, param, IRLAN_BYTE, value, 0, NULL, 0);
}
int irlan_insert_short_param(struct sk_buff *skb, char *param, __u16 value)
{
	return __irlan_insert_param(skb, param, IRLAN_SHORT, 0, value, NULL, 0);
}
int irlan_insert_array_param(struct sk_buff *skb, char *name, __u8 *array,
			     __u16 array_len)
{
	return __irlan_insert_param(skb, name, IRLAN_ARRAY, 0, 0, array,
				    array_len);
}
static void irlan_seq_stop(struct seq_file *seq, void *v)
{
	rcu_read_unlock();
}
static int irlan_seq_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &irlan_seq_ops);
}
struct net_device *alloc_irlandev(const char *name)
{
	return alloc_netdev(sizeof(struct irlan_cb), name,
			    irlan_eth_setup);
}
void irlap_reset_confirm(void)
{
	IRDA_DEBUG(1, "%s()\n", __func__);
}
static void irlap_seq_stop(struct seq_file *seq, void *v)
{
	spin_unlock_irq(&irlap->hb_spinlock);
}
static inline void irlap_recv_ua_frame(struct irlap_cb *self,
				       struct sk_buff *skb,
				       struct irlap_info *info)
{
	irlap_do_event(self, RECV_UA_RSP, skb, info);
}
static inline void irlmp_next_lap_state(struct lap_cb *self,
					IRLMP_STATE state)
{
	self->lap_state = state;
}
static inline void irlmp_next_lsap_state(struct lsap_cb *self,
					 LSAP_STATE state)
{
	self->lsap_state = state;
}
static int irnet_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, irnet_proc_show, NULL);
}
void irda_nl_unregister(void)
{
	genl_unregister_family(&irda_nl_family);
}
void irda_sysctl_unregister(void)
{
	unregister_sysctl_table(irda_table_header);
}
static inline void irttp_start_todo_timer(struct tsap_cb *self, int timeout)
{
	mod_timer(&self->todo_timer, jiffies + timeout);
}
static void irttp_seq_stop(struct seq_file *seq, void *v)
{
	spin_unlock_irq(&irttp->tsaps->hb_spinlock);
}
static int irttp_seq_open(struct inode *inode, struct file *file)
{
	return seq_open_private(file, &irttp_seq_ops,
			sizeof(struct irttp_iter_state));
}
static inline __u32 index_value(int index, __u32 *array)
{
	return array[index];
}
void irlap_start_slot_timer(struct irlap_cb *self, int timeout)
{
	irda_start_timer(&self->slot_timer, timeout, (void *) self,
			 irlap_slot_timer_expired);
}
void irlap_start_final_timer(struct irlap_cb *self, int timeout)
{
	irda_start_timer(&self->final_timer, timeout, (void *) self,
			 irlap_final_timer_expired);
}
void irlap_start_wd_timer(struct irlap_cb *self, int timeout)
{
	irda_start_timer(&self->wd_timer, timeout, (void *) self,
			 irlap_wd_timer_expired);
}
void irlap_start_backoff_timer(struct irlap_cb *self, int timeout)
{
	irda_start_timer(&self->backoff_timer, timeout, (void *) self,
			 irlap_backoff_timer_expired);
}
void irlap_start_mbusy_timer(struct irlap_cb *self, int timeout)
{
	irda_start_timer(&self->media_busy_timer, timeout,
			 (void *) self, irlap_media_busy_expired);
}
void irlmp_start_watchdog_timer(struct lsap_cb *self, int timeout)
{
	irda_start_timer(&self->watchdog_timer, timeout, (void *) self,
			 irlmp_watchdog_timer_expired);
}
void irlmp_start_discovery_timer(struct irlmp_cb *self, int timeout)
{
	irda_start_timer(&self->discovery_timer, timeout, (void *) self,
			 irlmp_discovery_timer_expired);
}
void irlmp_start_idle_timer(struct lap_cb *self, int timeout)
{
	irda_start_timer(&self->idle_timer, timeout, (void *) self,
			 irlmp_idle_timer_expired);
}
void irlmp_stop_idle_timer(struct lap_cb *self)
{
	del_timer(&self->idle_timer);
}
static inline void high_nmcpy(unsigned char *dst, char *src)
{
       memcpy(dst, src, 8);
}
static inline void low_nmcpy(unsigned char *dst, char *src)
{
       memcpy(&dst[8], src, 8);
}
static void iucv_sock_clear_timer(struct sock *sk)
{
	sk_stop_timer(sk, &sk->sk_timer);
}
static int iucv_bus_match(struct device *dev, struct device_driver *drv)
{
	return 0;
}
static inline struct pfkey_sock *pfkey_sk(struct sock *sk)
{
	return (struct pfkey_sock *)sk;
}
static inline void pfkey_hdr_dup(struct sadb_msg *new, struct sadb_msg *orig)
{
	*new = *orig;
}
static inline int pfkey_sec_ctx_len(struct sadb_x_sec_ctx *sec_ctx)
{
	return DIV_ROUND_UP(sizeof(struct sadb_x_sec_ctx) +
			    sec_ctx->sadb_x_ctx_len,
			    sizeof(uint64_t));
}
static uint8_t pfkey_proto_to_xfrm(uint8_t proto)
{
	return (proto == IPSEC_PROTO_ANY ? 0 : proto);
}
static uint8_t pfkey_proto_from_xfrm(uint8_t proto)
{
	return (proto ? proto : IPSEC_PROTO_ANY);
}
static
int pfkey_sadb_addr2xfrm_addr(struct sadb_address *addr, xfrm_address_t *xaddr)
{
	return pfkey_sockaddr_extract((struct sockaddr *)(addr + 1),
				      xaddr);
}
static int
pfkey_sockaddr_size(sa_family_t family)
{
	return PFKEY_ALIGN8(pfkey_sockaddr_len(family));
}
static inline struct sk_buff *pfkey_xfrm_state2msg_expire(struct xfrm_state *x,
							  int hsc)
{
	return __pfkey_xfrm_state2msg(x, 0, hsc);
}
static int pfkey_reserved(struct sock *sk, struct sk_buff *skb, struct sadb_msg *hdr, void **ext_hdrs)
{
	return -EOPNOTSUPP;
}
static void pfkey_dump_sa_done(struct pfkey_sock *pfk)
{
	xfrm_state_walk_done(&pfk->dump.u.state);
}
static int pfkey_sockaddr_pair_size(sa_family_t family)
{
	return PFKEY_ALIGN8(pfkey_sockaddr_len(family) * 2);
}
static int pfkey_migrate(struct sock *sk, struct sk_buff *skb,
			 struct sadb_msg *hdr, void **ext_hdrs)
{
	return -ENOPROTOOPT;
}
static void pfkey_dump_sp_done(struct pfkey_sock *pfk)
{
	xfrm_policy_walk_done(&pfk->dump.u.policy);
}
static int key_notify_policy_expire(struct xfrm_policy *xp, struct km_event *c)
{
	return 0;
}
static int pfkey_send_migrate(struct xfrm_selector *sel, u8 dir, u8 type,
			      struct xfrm_migrate *m, int num_bundles,
			      struct xfrm_kmaddress *k)
{
	return -ENOPROTOOPT;
}
static void pfkey_seq_stop(struct seq_file *f, void *v)
{
	read_unlock(&pfkey_table_lock);
}
static int pfkey_seq_open(struct inode *inode, struct file *file)
{
	return seq_open_net(inode, file, &pfkey_seq_ops,
			    sizeof(struct seq_net_private));
}
static void pfkey_exit_proc(struct net *net)
{
	proc_net_remove(net, "pfkey");
}
static void lapb_free_cb(struct lapb_cb *lapb)
{
	kfree(lapb);
}
static __inline__ void lapb_hold(struct lapb_cb *lapb)
{
	atomic_inc(&lapb->refcnt);
}
static int __init lapb_init(void)
{
	return 0;
}
static void __exit lapb_exit(void)
{
	WARN_ON(!list_empty(&lapb_list));
}
void lapb_stop_t1timer(struct lapb_cb *lapb)
{
	del_timer(&lapb->t1timer);
}
void lapb_stop_t2timer(struct lapb_cb *lapb)
{
	del_timer(&lapb->t2timer);
}
int lapb_t1timer_running(struct lapb_cb *lapb)
{
	return timer_pending(&lapb->t1timer);
}
static inline u16 llc_ui_next_link_no(int sap)
{
	return llc_ui_sap_link_no_max[sap]++;
}
static inline __be16 llc_proto_type(u16 arphrd)
{
	return arphrd == ARPHRD_IEEE802_TR ?
			 htons(ETH_P_TR_802_2) : htons(ETH_P_802_2);
}
static inline u8 llc_ui_addr_null(struct sockaddr_llc *addr)
{
	return !memcmp(addr, &llc_ui_addrnull, sizeof(*addr));
}
static int llc_ui_ioctl(struct socket *sock, unsigned int cmd,
			unsigned long arg)
{
	return -ENOIOCTLCMD;
}
void llc_conn_pf_cycle_tmr_cb(unsigned long timeout_data)
{
	llc_conn_tmr_common_cb(timeout_data, LLC_CONN_EV_TYPE_P_TMR);
}
void llc_conn_busy_tmr_cb(unsigned long timeout_data)
{
	llc_conn_tmr_common_cb(timeout_data, LLC_CONN_EV_TYPE_BUSY_TMR);
}
void llc_conn_ack_tmr_cb(unsigned long timeout_data)
{
	llc_conn_tmr_common_cb(timeout_data, LLC_CONN_EV_TYPE_ACK_TMR);
}
void llc_conn_rej_tmr_cb(unsigned long timeout_data)
{
	llc_conn_tmr_common_cb(timeout_data, LLC_CONN_EV_TYPE_REJ_TMR);
}
int llc_conn_disc(struct sock *sk, struct sk_buff *skb)
{
	return 0;
}
static u16 llc_util_ns_inside_rx_window(u8 ns, u8 vr, u8 rw)
{
	return !llc_circular_between(vr, ns,
				     (vr + rw - 1) % LLC_2_SEQ_NBR_MODULO);
}
int llc_conn_ev_rx_bad_pdu(struct sock *sk, struct sk_buff *skb)
{
	return 1;
}
int llc_conn_ev_rx_any_frame(struct sock *sk, struct sk_buff *skb)
{
	return 0;
}
int llc_conn_ev_init_p_f_cycle(struct sock *sk, struct sk_buff *skb)
{
	return 1;
}
int llc_conn_ev_qlfy_data_flag_eq_1(struct sock *sk, struct sk_buff *skb)
{
	return llc_sk(sk)->data_flag != 1;
}
int llc_conn_ev_qlfy_data_flag_eq_0(struct sock *sk, struct sk_buff *skb)
{
	return llc_sk(sk)->data_flag;
}
int llc_conn_ev_qlfy_data_flag_eq_2(struct sock *sk, struct sk_buff *skb)
{
	return llc_sk(sk)->data_flag != 2;
}
int llc_conn_ev_qlfy_p_flag_eq_1(struct sock *sk, struct sk_buff *skb)
{
	return llc_sk(sk)->p_flag != 1;
}
int llc_conn_ev_qlfy_last_frame_eq_1(struct sock *sk, struct sk_buff *skb)
{
	return !(skb_queue_len(&llc_sk(sk)->pdu_unack_q) + 1 == llc_sk(sk)->k);
}
int llc_conn_ev_qlfy_last_frame_eq_0(struct sock *sk, struct sk_buff *skb)
{
	return skb_queue_len(&llc_sk(sk)->pdu_unack_q) + 1 == llc_sk(sk)->k;
}
int llc_conn_ev_qlfy_p_flag_eq_0(struct sock *sk, struct sk_buff *skb)
{
	return llc_sk(sk)->p_flag;
}
int llc_conn_ev_qlfy_remote_busy_eq_0(struct sock *sk, struct sk_buff *skb)
{
	return llc_sk(sk)->remote_busy_flag;
}
int llc_conn_ev_qlfy_remote_busy_eq_1(struct sock *sk, struct sk_buff *skb)
{
	return !llc_sk(sk)->remote_busy_flag;
}
int llc_conn_ev_qlfy_retry_cnt_lt_n2(struct sock *sk, struct sk_buff *skb)
{
	return !(llc_sk(sk)->retry_count < llc_sk(sk)->n2);
}
int llc_conn_ev_qlfy_retry_cnt_gte_n2(struct sock *sk, struct sk_buff *skb)
{
	return !(llc_sk(sk)->retry_count >= llc_sk(sk)->n2);
}
int llc_conn_ev_qlfy_s_flag_eq_1(struct sock *sk, struct sk_buff *skb)
{
	return !llc_sk(sk)->s_flag;
}
int llc_conn_ev_qlfy_s_flag_eq_0(struct sock *sk, struct sk_buff *skb)
{
	return llc_sk(sk)->s_flag;
}
int llc_conn_ev_qlfy_cause_flag_eq_1(struct sock *sk, struct sk_buff *skb)
{
	return !llc_sk(sk)->cause_flag;
}
int llc_conn_ev_qlfy_cause_flag_eq_0(struct sock *sk, struct sk_buff *skb)
{
	return llc_sk(sk)->cause_flag;
}
u8 llc_data_accept_state(u8 state)
{
	return state != LLC_CONN_STATE_NORMAL && state != LLC_CONN_STATE_BUSY &&
	       state != LLC_CONN_STATE_REJ;
}
static void llc_add_sap(struct llc_sap *sap)
{
	list_add_tail(&sap->node, &llc_sap_list);
}
void llc_set_station_handler(void (*handler)(struct sk_buff *skb))
{
	llc_station_handler = handler;
}
void llc_pdu_set_cmd_rsp(struct sk_buff *skb, u8 pdu_type)
{
	llc_pdu_un_hdr(skb)->ssap |= pdu_type;
}
static void llc_ui_format_mac(struct seq_file *seq, u8 *addr)
{
	seq_printf(seq, "%pM", addr);
}
static int llc_seq_socket_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &llc_seq_socket_ops);
}
static int llc_seq_core_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &llc_seq_core_ops);
}
int llc_sap_action_report_status(struct llc_sap *sap, struct sk_buff *skb)
{
	return 0;
}
static __inline__ struct llc_station_state_ev *
					llc_station_ev(struct sk_buff *skb)
{
	return (struct llc_station_state_ev *)skb->cb;
}
static int llc_station_ac_report_status(struct sk_buff *skb)
{
	return 0;
}
void __exit llc_station_exit(void)
{
	llc_set_station_handler(NULL);
}
static inline bool _chg_mesh_attr(enum nl80211_meshconf_params parm, u32 mask)
{
	return (mask >> (parm-1)) & 0x1;
}
static int ieee80211_suspend(struct wiphy *wiphy)
{
	return __ieee80211_suspend(wiphy_priv(wiphy));
}
static int ieee80211_resume(struct wiphy *wiphy)
{
	return __ieee80211_resume(wiphy_priv(wiphy));
}
static ssize_t ieee80211_if_fmt_##name(					\
	const struct ieee80211_sub_if_data *sdata, char *buf,		\
	int buflen)							\
{									\
	return scnprintf(buf, buflen, format_string, sdata->field);	\
}
static ssize_t ieee80211_if_fmt_##name(					\
	const struct ieee80211_sub_if_data *sdata,			\
	char *buf, int buflen)						\
{									\
	return scnprintf(buf, buflen, "%d\n", atomic_read(&sdata->field));\
}
static ssize_t ieee80211_if_fmt_##name(					\
	const struct ieee80211_sub_if_data *sdata, char *buf,		\
	int buflen)							\
{									\
	return scnprintf(buf, buflen, "%pM\n", sdata->field);		\
}
static ssize_t ieee80211_if_fmt_flags(
	const struct ieee80211_sub_if_data *sdata, char *buf, int buflen)
{
	return scnprintf(buf, buflen, "%s%s%s%s%s%s%s\n",
		 sdata->u.sta.flags & IEEE80211_STA_SSID_SET ? "SSID\n" : "",
		 sdata->u.sta.flags & IEEE80211_STA_BSSID_SET ? "BSSID\n" : "",
		 sdata->u.sta.flags & IEEE80211_STA_PREV_BSSID_SET ? "prev BSSID\n" : "",
		 sdata->u.sta.flags & IEEE80211_STA_AUTHENTICATED ? "AUTH\n" : "",
		 sdata->u.sta.flags & IEEE80211_STA_ASSOCIATED ? "ASSOC\n" : "",
		 sdata->u.sta.flags & IEEE80211_STA_PROBEREQ_POLL ? "PROBEREQ POLL\n" : "",
		 sdata->vif.bss_conf.use_cts_prot ? "CTS prot\n" : "");
}
static ssize_t ieee80211_if_fmt_num_buffered_multicast(
	const struct ieee80211_sub_if_data *sdata, char *buf, int buflen)
{
	return scnprintf(buf, buflen, "%u\n",
			 skb_queue_len(&sdata->u.ap.ps_bc_buf));
}
static inline int identical_mac_addr_allowed(int type1, int type2)
{
	return type1 == NL80211_IFTYPE_MONITOR ||
		type2 == NL80211_IFTYPE_MONITOR ||
		(type1 == NL80211_IFTYPE_AP && type2 == NL80211_IFTYPE_WDS) ||
		(type1 == NL80211_IFTYPE_WDS &&
			(type2 == NL80211_IFTYPE_WDS ||
			 type2 == NL80211_IFTYPE_AP)) ||
		(type1 == NL80211_IFTYPE_AP && type2 == NL80211_IFTYPE_AP_VLAN) ||
		(type1 == NL80211_IFTYPE_AP_VLAN &&
			(type2 == NL80211_IFTYPE_AP ||
			 type2 == NL80211_IFTYPE_AP_VLAN));
}
static void key_todo(struct work_struct *work)
{
	ieee80211_key_todo();
}
static void ieee80211_key_lock(void)
{
	mutex_lock(&key_mutex);
}
static void ieee80211_key_unlock(void)
{
	mutex_unlock(&key_mutex);
}
static void assert_key_lock(void)
{
	WARN_ON(!mutex_is_locked(&key_mutex));
}
bool mesh_peer_accepts_plinks(struct ieee802_11_elems *ie)
{
	return (*(ie->mesh_config + CAPAB_OFFSET) & ACCEPT_PLINKS) != 0;
}
u32 mesh_table_hash(u8 *addr, struct ieee80211_sub_if_data *sdata, struct mesh_table *tbl)
{
	return jhash_2words(*(u32 *)(addr+2), sdata->dev->ifindex, tbl->hash_rnd)
		& tbl->hash_mask;
}
void mesh_path_assign_nexthop(struct mesh_path *mpath, struct sta_info *sta)
{
	rcu_assign_pointer(mpath->next_hop, sta);
}
static int ecw2cw(int ecw)
{
	return (1 << ecw) - 1;
}
static int ieee80211_sta_join_ibss(struct ieee80211_sub_if_data *sdata,
				   struct ieee80211_if_sta *ifsta,
				   struct ieee80211_bss *bss)
{
	return __ieee80211_sta_join_ibss(sdata, ifsta,
					 bss->cbss.bssid,
					 bss->cbss.beacon_interval,
					 bss->cbss.channel->center_freq,
					 bss->supp_rates_len, bss->supp_rates,
					 bss->cbss.capability);
}
static void ieee80211_rate_control_ops_put(struct rate_control_ops *ops)
{
	module_put(ops->module);
}
void rate_control_put(struct rate_control_ref *ref)
{
	kref_put(&ref->kref, rate_control_release);
}
static void
minstrel_free(void *priv)
{
	kfree(priv);
}
int __init
rc80211_minstrel_init(void)
{
	return ieee80211_rate_control_register(&mac80211_minstrel);
}
void
rc80211_minstrel_exit(void)
{
	ieee80211_rate_control_unregister(&mac80211_minstrel);
}
static void rate_control_pid_free_sta(void *priv, struct ieee80211_sta *sta,
				      void *priv_sta)
{
	kfree(priv_sta);
}
int __init rc80211_pid_init(void)
{
	return ieee80211_rate_control_register(&mac80211_rcpid);
}
void rc80211_pid_exit(void)
{
	ieee80211_rate_control_unregister(&mac80211_rcpid);
}
static inline int seq_less(u16 sq1, u16 sq2)
{
	return ((sq1 - sq2) & SEQ_MASK) > (SEQ_MODULO >> 1);
}
static inline u16 seq_inc(u16 sq)
{
	return (sq + 1) & SEQ_MASK;
}
static inline u16 seq_sub(u16 sq1, u16 sq2)
{
	return (sq1 - sq2) & SEQ_MASK;
}
struct ieee80211_bss *
ieee80211_rx_bss_get(struct ieee80211_local *local, u8 *bssid, int freq,
		     u8 *ssid, u8 ssid_len)
{
	return (void *)cfg80211_get_bss(local->hw.wiphy,
					ieee80211_get_channel(local->hw.wiphy,
							      freq),
					bssid, ssid, ssid_len,
					0, 0);
}
void ieee80211_rx_bss_put(struct ieee80211_local *local,
			  struct ieee80211_bss *bss)
{
	cfg80211_put_bss((struct cfg80211_bss *)bss);
}
void ieee80211_process_measurement_req(struct ieee80211_sub_if_data *sdata,
				       struct ieee80211_mgmt *mgmt,
				       size_t len)
{
	ieee80211_send_refuse_measurement_request(sdata,
			&mgmt->u.action.u.measurement.msr_elem,
			mgmt->sa, mgmt->bssid,
			mgmt->u.action.u.measurement.dialog_token);
}
static inline void __bss_tim_set(struct ieee80211_if_ap *bss, u16 aid)
{
	bss->tim[aid / 8] |= (1 << (aid % 8));
}
static inline void __bss_tim_clear(struct ieee80211_if_ap *bss, u16 aid)
{
	bss->tim[aid / 8] &= ~(1 << (aid % 8));
}
static u16 tkipS(u16 val)
{
	return tkip_sbox[val & 0xff] ^ swab16(tkip_sbox[val >> 8]);
}
static int inline is_ieee80211_device(struct ieee80211_local *local,
				      struct net_device *dev)
{
	return local == wdev_priv(dev->ieee80211_ptr);
}
void ieee80211_wake_queue(struct ieee80211_hw *hw, int queue)
{
	ieee80211_wake_queue_by_reason(hw, queue,
				       IEEE80211_QUEUE_STOP_REASON_DRIVER);
}
void ieee80211_stop_queue(struct ieee80211_hw *hw, int queue)
{
	ieee80211_stop_queue_by_reason(hw, queue,
				       IEEE80211_QUEUE_STOP_REASON_DRIVER);
}
void ieee80211_stop_queues(struct ieee80211_hw *hw)
{
	ieee80211_stop_queues_by_reason(hw,
					IEEE80211_QUEUE_STOP_REASON_DRIVER);
}
void ieee80211_wake_queues(struct ieee80211_hw *hw)
{
	ieee80211_wake_queues_by_reason(hw, IEEE80211_QUEUE_STOP_REASON_DRIVER);
}
static inline int ip_vs_app_get(struct ip_vs_app *app)
{
	return try_module_get(app->module);
}
static inline void ip_vs_app_put(struct ip_vs_app *app)
{
	module_put(app->module);
}
int ip_vs_bind_app(struct ip_vs_conn *cp, struct ip_vs_protocol *pp)
{
	return pp->app_conn_bind(cp);
}
static void ip_vs_app_seq_stop(struct seq_file *seq, void *v)
{
	mutex_unlock(&__ip_vs_app_mutex);
}
static int ip_vs_app_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &ip_vs_app_seq_ops);
}
void ip_vs_app_cleanup(void)
{
	proc_net_remove(&init_net, "ip_vs_app");
}
static inline void ct_read_lock(unsigned key)
{
	read_lock(&__ip_vs_conntbl_lock_array[key&CT_LOCKARRAY_MASK].l);
}
static inline void ct_read_unlock(unsigned key)
{
	read_unlock(&__ip_vs_conntbl_lock_array[key&CT_LOCKARRAY_MASK].l);
}
static inline void ct_write_lock(unsigned key)
{
	write_lock(&__ip_vs_conntbl_lock_array[key&CT_LOCKARRAY_MASK].l);
}
static inline void ct_write_unlock(unsigned key)
{
	write_unlock(&__ip_vs_conntbl_lock_array[key&CT_LOCKARRAY_MASK].l);
}
static inline void ct_read_lock_bh(unsigned key)
{
	read_lock_bh(&__ip_vs_conntbl_lock_array[key&CT_LOCKARRAY_MASK].l);
}
static inline void ct_read_unlock_bh(unsigned key)
{
	read_unlock_bh(&__ip_vs_conntbl_lock_array[key&CT_LOCKARRAY_MASK].l);
}
static inline void ct_write_lock_bh(unsigned key)
{
	write_lock_bh(&__ip_vs_conntbl_lock_array[key&CT_LOCKARRAY_MASK].l);
}
static inline void ct_write_unlock_bh(unsigned key)
{
	write_unlock_bh(&__ip_vs_conntbl_lock_array[key&CT_LOCKARRAY_MASK].l);
}
static inline int ip_vs_dest_totalconns(struct ip_vs_dest *dest)
{
	return atomic_read(&dest->activeconns)
		+ atomic_read(&dest->inactconns);
}
static int ip_vs_conn_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &ip_vs_conn_seq_ops);
}
static const char *ip_vs_origin_name(unsigned flags)
{
	if (flags & IP_VS_CONN_F_SYNC)
		return "SYNC";
	else
		return "LOCAL";
}
static int ip_vs_conn_sync_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &ip_vs_conn_sync_seq_ops);
}
__sum16 ip_vs_checksum_complete(struct sk_buff *skb, int offset)
{
	return csum_fold(skb_checksum(skb, offset, skb->len - offset, 0));
}
static inline int ip_vs_gather_frags_v6(struct sk_buff *skb, u_int32_t user)
{
	return 0;
}
int ip_vs_get_debug_level(void)
{
	return sysctl_ip_vs_debug_level;
}
int
ip_vs_use_count_inc(void)
{
	return try_module_get(THIS_MODULE);
}
void
ip_vs_use_count_dec(void)
{
	module_put(THIS_MODULE);
}
static __inline__ unsigned ip_vs_svc_fwm_hashkey(__u32 fwmark)
{
	return fwmark & IP_VS_SVC_TAB_MASK;
}
static void ip_vs_info_seq_stop(struct seq_file *seq, void *v)
{
	read_unlock_bh(&__ip_vs_svc_lock);
}
static int ip_vs_info_open(struct inode *inode, struct file *file)
{
	return seq_open_private(file, &ip_vs_info_seq_ops,
			sizeof(struct ip_vs_iter));
}
static int ip_vs_stats_seq_open(struct inode *inode, struct file *file)
{
	return single_open(file, ip_vs_stats_show, NULL);
}
static void ip_vs_genl_unregister(void)
{
	genl_unregister_family(&ip_vs_genl_family);
}
static inline struct ip_vs_dest *
ip_vs_dh_get(int af, struct ip_vs_dh_bucket *tbl,
	     const union nf_inet_addr *addr)
{
	return (tbl[ip_vs_dh_hashkey(af, addr)]).dest;
}
static inline int is_overloaded(struct ip_vs_dest *dest)
{
	return dest->flags & IP_VS_DEST_F_OVERLOAD;
}
static int __init ip_vs_dh_init(void)
{
	return register_ip_vs_scheduler(&ip_vs_dh_scheduler);
}
static void __exit ip_vs_dh_cleanup(void)
{
	unregister_ip_vs_scheduler(&ip_vs_dh_scheduler);
}
void ip_vs_estimator_cleanup(void)
{
	del_timer_sync(&est_timer);
}
static int
ip_vs_ftp_init_conn(struct ip_vs_app *app, struct ip_vs_conn *cp)
{
	return 0;
}
static int
ip_vs_ftp_done_conn(struct ip_vs_app *app, struct ip_vs_conn *cp)
{
	return 0;
}
static void __exit ip_vs_ftp_exit(void)
{
	unregister_ip_vs_app(&ip_vs_ftp);
}
static inline unsigned int
ip_vs_lc_dest_overhead(struct ip_vs_dest *dest)
{
	return (atomic_read(&dest->activeconns) << 8) +
		atomic_read(&dest->inactconns);
}
static int __init ip_vs_lc_init(void)
{
	return register_ip_vs_scheduler(&ip_vs_lc_scheduler) ;
}
static void __exit ip_vs_lc_cleanup(void)
{
	unregister_ip_vs_scheduler(&ip_vs_lc_scheduler);
}
static inline unsigned int
ip_vs_nq_dest_overhead(struct ip_vs_dest *dest)
{
	return atomic_read(&dest->activeconns) + 1;
}
static int __init ip_vs_nq_init(void)
{
	return register_ip_vs_scheduler(&ip_vs_nq_scheduler);
}
static void __exit ip_vs_nq_cleanup(void)
{
	unregister_ip_vs_scheduler(&ip_vs_nq_scheduler);
}
int *
ip_vs_create_timeout_table(int *table, int size)
{
	return kmemdup(table, size, GFP_ATOMIC);
}
static int
tcp_set_state_timeout(struct ip_vs_protocol *pp, char *sname, int to)
{
	return ip_vs_set_state_timeout(pp->timeout_table, IP_VS_TCP_S_LAST,
				       tcp_state_name_table, sname, to);
}
static inline __u16 tcp_app_hashkey(__be16 port)
{
	return (((__force u16)port >> TCP_APP_TAB_BITS) ^ (__force u16)port)
		& TCP_APP_TAB_MASK;
}
static inline __u16 udp_app_hashkey(__be16 port)
{
	return (((__force u16)port >> UDP_APP_TAB_BITS) ^ (__force u16)port)
		& UDP_APP_TAB_MASK;
}
static int
udp_set_state_timeout(struct ip_vs_protocol *pp, char *sname, int to)
{
	return ip_vs_set_state_timeout(pp->timeout_table, IP_VS_UDP_S_LAST,
				       udp_state_name_table, sname, to);
}
static int __init ip_vs_rr_init(void)
{
	return register_ip_vs_scheduler(&ip_vs_rr_scheduler);
}
static void __exit ip_vs_rr_cleanup(void)
{
	unregister_ip_vs_scheduler(&ip_vs_rr_scheduler);
}
static inline unsigned int
ip_vs_sed_dest_overhead(struct ip_vs_dest *dest)
{
	return atomic_read(&dest->activeconns) + 1;
}
static int __init ip_vs_sed_init(void)
{
	return register_ip_vs_scheduler(&ip_vs_sed_scheduler);
}
static void __exit ip_vs_sed_cleanup(void)
{
	unregister_ip_vs_scheduler(&ip_vs_sed_scheduler);
}
static inline struct ip_vs_dest *
ip_vs_sh_get(int af, struct ip_vs_sh_bucket *tbl,
	     const union nf_inet_addr *addr)
{
	return (tbl[ip_vs_sh_hashkey(af, addr)]).dest;
}
static inline int is_overloaded(struct ip_vs_dest *dest)
{
	return dest->flags & IP_VS_DEST_F_OVERLOAD;
}
static int __init ip_vs_sh_init(void)
{
	return register_ip_vs_scheduler(&ip_vs_sh_scheduler);
}
static void __exit ip_vs_sh_cleanup(void)
{
	unregister_ip_vs_scheduler(&ip_vs_sh_scheduler);
}
static inline unsigned int
ip_vs_wlc_dest_overhead(struct ip_vs_dest *dest)
{
	return (atomic_read(&dest->activeconns) << 8) +
		atomic_read(&dest->inactconns);
}
static int __init ip_vs_wlc_init(void)
{
	return register_ip_vs_scheduler(&ip_vs_wlc_scheduler);
}
static void __exit ip_vs_wlc_cleanup(void)
{
	unregister_ip_vs_scheduler(&ip_vs_wlc_scheduler);
}
static int __init ip_vs_wrr_init(void)
{
	return register_ip_vs_scheduler(&ip_vs_wrr_scheduler) ;
}
static void __exit ip_vs_wrr_cleanup(void)
{
	unregister_ip_vs_scheduler(&ip_vs_wrr_scheduler);
}
int
ip_vs_null_xmit(struct sk_buff *skb, struct ip_vs_conn *cp,
		struct ip_vs_protocol *pp)
{
	return NF_ACCEPT;
}
static int nf_conntrack_acct_init_sysctl(struct net *net)
{
	return 0;
}
static inline u_int32_t hash_conntrack(const struct nf_conntrack_tuple *tuple)
{
	return __hash_conntrack(tuple, nf_conntrack_htable_size,
				nf_conntrack_hash_rnd);
}
void nf_conntrack_ecache_fini(struct net *net)
{
	free_percpu(net->ct.ecache);
}
int nf_conntrack_register_notifier(struct notifier_block *nb)
{
	return atomic_notifier_chain_register(&nf_conntrack_chain, nb);
}
int nf_conntrack_unregister_notifier(struct notifier_block *nb)
{
	return atomic_notifier_chain_unregister(&nf_conntrack_chain, nb);
}
int nf_ct_expect_register_notifier(struct notifier_block *nb)
{
	return atomic_notifier_chain_register(&nf_ct_expect_chain, nb);
}
int nf_ct_expect_unregister_notifier(struct notifier_block *nb)
{
	return atomic_notifier_chain_unregister(&nf_ct_expect_chain, nb);
}
static inline int expect_matches(const struct nf_conntrack_expect *a,
				 const struct nf_conntrack_expect *b)
{
	return a->master == b->master && a->class == b->class
		&& nf_ct_tuple_equal(&a->tuple, &b->tuple)
		&& nf_ct_tuple_mask_equal(&a->mask, &b->mask);
}
static void exp_seq_stop(struct seq_file *seq, void *v)
{
	rcu_read_unlock();
}
static int exp_open(struct inode *inode, struct file *file)
{
	return seq_open_net(inode, file, &exp_seq_ops,
			sizeof(struct ct_expect_iter_state));
}
static void exp_proc_remove(struct net *net)
{
	proc_net_remove(net, "nf_conntrack_expect");
}
static unsigned int helper_hash(const struct nf_conntrack_tuple *tuple)
{
	return (((tuple->src.l3num << 8) | tuple->dst.protonum) ^
		(__force __u16)tuple->src.u.all) % nf_ct_helper_hsize;
}
static int generic_print_tuple(struct seq_file *s,
			    const struct nf_conntrack_tuple *tuple)
{
	return 0;
}
static int generic_get_l4proto(const struct sk_buff *skb, unsigned int nhoff,
			       unsigned int *dataoff, u_int8_t *protonum)
{
	return -NF_ACCEPT;
}
static void __exit nf_conntrack_netbios_ns_fini(void)
{
	nf_conntrack_helper_unregister(&helper);
}
static int
ctnetlink_change_expect(struct nf_conntrack_expect *x, struct nlattr *cda[])
{
	return -EOPNOTSUPP;
}
static void nf_conntrack_pptp_net_exit(struct net *net)
{
	nf_ct_gre_keymap_flush(net);
}
void nf_ct_l4proto_put(struct nf_conntrack_l4proto *p)
{
	module_put(p->me);
}
void nf_ct_l3proto_put(struct nf_conntrack_l3proto *p)
{
	module_put(p->me);
}
static int kill_l3proto(struct nf_conn *i, void *data)
{
	return nf_ct_l3num(i) == ((struct nf_conntrack_l3proto *)data)->l3proto;
}
static int dccp_print_tuple(struct seq_file *s,
			    const struct nf_conntrack_tuple *tuple)
{
	return seq_printf(s, "sport=%hu dport=%hu ",
			  ntohs(tuple->src.u.dccp.port),
			  ntohs(tuple->dst.u.dccp.port));
}
static int dccp_print_conntrack(struct seq_file *s, const struct nf_conn *ct)
{
	return seq_printf(s, "%s ", dccp_state_names[ct->proto.dccp.state]);
}
static int generic_print_tuple(struct seq_file *s,
			       const struct nf_conntrack_tuple *tuple)
{
	return 0;
}
static bool new(struct nf_conn *ct, const struct sk_buff *skb,
		unsigned int dataoff)
{
	return true;
}
static inline int gre_key_cmpfn(const struct nf_ct_gre_keymap *km,
				const struct nf_conntrack_tuple *t)
{
	return km->tuple.src.l3num == t->src.l3num &&
	       !memcmp(&km->tuple.src.u3, &t->src.u3, sizeof(t->src.u3)) &&
	       !memcmp(&km->tuple.dst.u3, &t->dst.u3, sizeof(t->dst.u3)) &&
	       km->tuple.dst.protonum == t->dst.protonum &&
	       km->tuple.dst.u.all == t->dst.u.all;
}
static int gre_print_tuple(struct seq_file *s,
			   const struct nf_conntrack_tuple *tuple)
{
	return seq_printf(s, "srckey=0x%x dstkey=0x%x ",
			  ntohs(tuple->src.u.gre.key),
			  ntohs(tuple->dst.u.gre.key));
}
static int gre_print_conntrack(struct seq_file *s,
			       const struct nf_conn *ct)
{
	return seq_printf(s, "timeout=%u, stream_timeout=%u ",
			  (ct->proto.gre.timeout / HZ),
			  (ct->proto.gre.stream_timeout / HZ));
}
static int sctp_print_tuple(struct seq_file *s,
			    const struct nf_conntrack_tuple *tuple)
{
	return seq_printf(s, "sport=%hu dport=%hu ",
			  ntohs(tuple->src.u.sctp.port),
			  ntohs(tuple->dst.u.sctp.port));
}
static int tcp_print_tuple(struct seq_file *s,
			   const struct nf_conntrack_tuple *tuple)
{
	return seq_printf(s, "sport=%hu dport=%hu ",
			  ntohs(tuple->src.u.tcp.port),
			  ntohs(tuple->dst.u.tcp.port));
}
static unsigned int get_conntrack_index(const struct tcphdr *tcph)
{
	if (tcph->rst) return TCP_RST_SET;
	else if (tcph->syn) return (tcph->ack ? TCP_SYNACK_SET : TCP_SYN_SET);
	else if (tcph->fin) return TCP_FIN_SET;
	else if (tcph->ack) return TCP_ACK_SET;
	else return TCP_NONE_SET;
}
static inline __u32 segment_seq_plus_len(__u32 seq,
					 size_t len,
					 unsigned int dataoff,
					 const struct tcphdr *tcph)
{
	return (seq + len - dataoff - tcph->doff*4
		+ (tcph->syn ? 1 : 0) + (tcph->fin ? 1 : 0));
}
static int udp_print_tuple(struct seq_file *s,
			   const struct nf_conntrack_tuple *tuple)
{
	return seq_printf(s, "sport=%hu dport=%hu ",
			  ntohs(tuple->src.u.udp.port),
			  ntohs(tuple->dst.u.udp.port));
}
static bool udp_new(struct nf_conn *ct, const struct sk_buff *skb,
		    unsigned int dataoff)
{
	return true;
}
static int udplite_print_tuple(struct seq_file *s,
			       const struct nf_conntrack_tuple *tuple)
{
	return seq_printf(s, "sport=%hu dport=%hu ",
			  ntohs(tuple->src.u.udp.port),
			  ntohs(tuple->dst.u.udp.port));
}
static bool udplite_new(struct nf_conn *ct, const struct sk_buff *skb,
			unsigned int dataoff)
{
	return true;
}
int
print_tuple(struct seq_file *s, const struct nf_conntrack_tuple *tuple,
            const struct nf_conntrack_l3proto *l3proto,
            const struct nf_conntrack_l4proto *l4proto)
{
	return l3proto->print_tuple(s, tuple) || l4proto->print_tuple(s, tuple);
}
static void ct_seq_stop(struct seq_file *s, void *v)
{
	rcu_read_unlock();
}
static int ct_open(struct inode *inode, struct file *file)
{
	return seq_open_net(inode, file, &ct_seq_ops,
			sizeof(struct ct_iter_state));
}
static int ct_cpu_seq_open(struct inode *inode, struct file *file)
{
	return seq_open_net(inode, file, &ct_cpu_seq_ops,
			    sizeof(struct seq_net_private));
}
static int nf_conntrack_standalone_init_proc(struct net *net)
{
	return 0;
}
static int nf_conntrack_standalone_init_sysctl(struct net *net)
{
	return 0;
}
static int __init nf_conntrack_standalone_init(void)
{
	return register_pernet_subsys(&nf_conntrack_net_ops);
}
static void __exit nf_conntrack_standalone_fini(void)
{
	unregister_pernet_subsys(&nf_conntrack_net_ops);
}
static void seq_stop(struct seq_file *s, void *v)
{
	rcu_read_unlock();
}
static int nflog_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &nflog_seq_ops);
}
static int nfqueue_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &nfqueue_seq_ops);
}
static inline int overlap(int min1, int max1, int min2, int max2)
{
	return max1 > min2 && min1 < max2;
}
int nf_setsockopt(struct sock *sk, u_int8_t pf, int val, char __user *opt,
		  int len)
{
	return nf_sockopt(sk, pf, val, opt, &len, 0);
}
int nf_getsockopt(struct sock *sk, u_int8_t pf, int val, char __user *opt,
		  int *len)
{
	return nf_sockopt(sk, pf, val, opt, len, 1);
}
int compat_nf_setsockopt(struct sock *sk, u_int8_t pf,
		int val, char __user *opt, int len)
{
	return compat_nf_sockopt(sk, pf, val, opt, &len, 0);
}
int compat_nf_getsockopt(struct sock *sk, u_int8_t pf,
		int val, char __user *opt, int *len)
{
	return compat_nf_sockopt(sk, pf, val, opt, len, 1);
}
void nfnl_lock(void)
{
	mutex_lock(&nfnl_mutex);
}
void nfnl_unlock(void)
{
	mutex_unlock(&nfnl_mutex);
}
int nfnetlink_has_listeners(unsigned int group)
{
	return netlink_has_listeners(nfnl, group);
}
int nfnetlink_send(struct sk_buff *skb, u32 pid, unsigned group, int echo)
{
	return nlmsg_notify(nfnl, skb, pid, group, echo, gfp_any());
}
int nfnetlink_unicast(struct sk_buff *skb, u_int32_t pid, int flags)
{
	return netlink_unicast(nfnl, skb, pid, flags);
}
static inline u_int8_t instance_hashfn(u_int16_t group_num)
{
	return ((group_num & 0xff) % INSTANCE_BUCKETS);
}
static inline void
instance_get(struct nfulnl_instance *inst)
{
	atomic_inc(&inst->use);
}
static int
nfulnl_recv_unsupp(struct sock *ctnl, struct sk_buff *skb,
		  struct nlmsghdr *nlh, struct nlattr *nfqa[])
{
	return -ENOTSUPP;
}
static void seq_stop(struct seq_file *s, void *v)
{
	read_unlock_bh(&instances_lock);
}
static int nful_open(struct inode *inode, struct file *file)
{
	return seq_open_private(file, &nful_seq_ops,
			sizeof(struct iter_state));
}
static inline u_int8_t instance_hashfn(u_int16_t queue_num)
{
	return ((queue_num >> 8) | queue_num) % INSTANCE_BUCKETS;
}
static int
nfqnl_recv_unsupp(struct sock *ctnl, struct sk_buff *skb,
		  struct nlmsghdr *nlh, struct nlattr *nfqa[])
{
	return -ENOTSUPP;
}
static void seq_stop(struct seq_file *s, void *v)
{
	spin_unlock(&instances_lock);
}
static int nfqnl_open(struct inode *inode, struct file *file)
{
	return seq_open_private(file, &nfqnl_seq_ops,
			sizeof(struct iter_state));
}
void xt_table_unlock(struct xt_table *table)
{
	mutex_unlock(&xt[table->af].mutex);
}
void xt_compat_lock(u_int8_t af)
{
	mutex_lock(&xt[af].compat_mutex);
}
void xt_compat_unlock(u_int8_t af)
{
	mutex_unlock(&xt[af].compat_mutex);
}
static int __init classify_tg_init(void)
{
	return xt_register_target(&classify_tg_reg);
}
static void __exit classify_tg_exit(void)
{
	xt_unregister_target(&classify_tg_reg);
}
static void connmark_tg_destroy(const struct xt_tgdtor_param *par)
{
	nf_ct_l3proto_module_put(par->family);
}
static int __init connmark_tg_init(void)
{
	return xt_register_targets(connmark_tg_reg,
	       ARRAY_SIZE(connmark_tg_reg));
}
static void __exit connmark_tg_exit(void)
{
	xt_unregister_targets(connmark_tg_reg, ARRAY_SIZE(connmark_tg_reg));
}
static void connsecmark_tg_destroy(const struct xt_tgdtor_param *par)
{
	nf_ct_l3proto_module_put(par->family);
}
static int __init connsecmark_tg_init(void)
{
	return xt_register_target(&connsecmark_tg_reg);
}
static void __exit connsecmark_tg_exit(void)
{
	xt_unregister_target(&connsecmark_tg_reg);
}
static int __init dscp_tg_init(void)
{
	return xt_register_targets(dscp_tg_reg, ARRAY_SIZE(dscp_tg_reg));
}
static void __exit dscp_tg_exit(void)
{
	xt_unregister_targets(dscp_tg_reg, ARRAY_SIZE(dscp_tg_reg));
}
static int __init mark_tg_init(void)
{
	return xt_register_targets(mark_tg_reg, ARRAY_SIZE(mark_tg_reg));
}
static void __exit mark_tg_exit(void)
{
	xt_unregister_targets(mark_tg_reg, ARRAY_SIZE(mark_tg_reg));
}
static int __init nflog_tg_init(void)
{
	return xt_register_target(&nflog_tg_reg);
}
static void __exit nflog_tg_exit(void)
{
	xt_unregister_target(&nflog_tg_reg);
}
static int __init nfqueue_tg_init(void)
{
	return xt_register_targets(nfqueue_tg_reg, ARRAY_SIZE(nfqueue_tg_reg));
}
static void __exit nfqueue_tg_exit(void)
{
	xt_unregister_targets(nfqueue_tg_reg, ARRAY_SIZE(nfqueue_tg_reg));
}
static int __init notrack_tg_init(void)
{
	return xt_register_target(&notrack_tg_reg);
}
static void __exit notrack_tg_exit(void)
{
	xt_unregister_target(&notrack_tg_reg);
}
static unsigned int xt_rateest_hash(const char *name)
{
	return jhash(name, FIELD_SIZEOF(struct xt_rateest, name), jhash_rnd) &
	       (RATEEST_HSIZE - 1);
}
static void __exit xt_rateest_tg_fini(void)
{
	xt_unregister_target(&xt_rateest_tg_reg);
}
static int __init secmark_tg_init(void)
{
	return xt_register_target(&secmark_tg_reg);
}
static void __exit secmark_tg_exit(void)
{
	xt_unregister_target(&secmark_tg_reg);
}
static inline unsigned int
optlen(const u_int8_t *opt, unsigned int offset)
{
	if (opt[offset] <= TCPOPT_NOP || opt[offset+1] == 0)
		return 1;
	else
		return opt[offset+1];
}
static int __init tcpmss_tg_init(void)
{
	return xt_register_targets(tcpmss_tg_reg, ARRAY_SIZE(tcpmss_tg_reg));
}
static void __exit tcpmss_tg_exit(void)
{
	xt_unregister_targets(tcpmss_tg_reg, ARRAY_SIZE(tcpmss_tg_reg));
}
static inline unsigned int optlen(const u_int8_t *opt, unsigned int offset)
{
	if (opt[offset] <= TCPOPT_NOP || opt[offset+1] == 0)
		return 1;
	else
		return opt[offset+1];
}
static unsigned int
tcpoptstrip_tg4(struct sk_buff *skb, const struct xt_target_param *par)
{
	return tcpoptstrip_mangle_packet(skb, par->targinfo, ip_hdrlen(skb),
	       sizeof(struct iphdr) + sizeof(struct tcphdr));
}
static int __init tcpoptstrip_tg_init(void)
{
	return xt_register_targets(tcpoptstrip_tg_reg,
				   ARRAY_SIZE(tcpoptstrip_tg_reg));
}
static void __exit tcpoptstrip_tg_exit(void)
{
	xt_unregister_targets(tcpoptstrip_tg_reg,
			      ARRAY_SIZE(tcpoptstrip_tg_reg));
}
static void __exit tproxy_tg_exit(void)
{
	xt_unregister_target(&tproxy_tg_reg);
}
static int __init trace_tg_init(void)
{
	return xt_register_target(&trace_tg_reg);
}
static void __exit trace_tg_exit(void)
{
	xt_unregister_target(&trace_tg_reg);
}
static bool
comment_mt(const struct sk_buff *skb, const struct xt_match_param *par)
{
	return true;
}
static int __init comment_mt_init(void)
{
	return xt_register_match(&comment_mt_reg);
}
static void __exit comment_mt_exit(void)
{
	xt_unregister_match(&comment_mt_reg);
}
static void connbytes_mt_destroy(const struct xt_mtdtor_param *par)
{
	nf_ct_l3proto_module_put(par->family);
}
static int __init connbytes_mt_init(void)
{
	return xt_register_match(&connbytes_mt_reg);
}
static void __exit connbytes_mt_exit(void)
{
	xt_unregister_match(&connbytes_mt_reg);
}
static inline bool already_closed(const struct nf_conn *conn)
{
	if (nf_ct_protonum(conn) == IPPROTO_TCP)
		return conn->proto.tcp.state == TCP_CONNTRACK_TIME_WAIT ||
		       conn->proto.tcp.state == TCP_CONNTRACK_CLOSE;
	else
		return 0;
}
static int __init connlimit_mt_init(void)
{
	return xt_register_match(&connlimit_mt_reg);
}
static void __exit connlimit_mt_exit(void)
{
	xt_unregister_match(&connlimit_mt_reg);
}
static void connmark_mt_destroy(const struct xt_mtdtor_param *par)
{
	nf_ct_l3proto_module_put(par->family);
}
static int __init connmark_mt_init(void)
{
	return xt_register_matches(connmark_mt_reg,
	       ARRAY_SIZE(connmark_mt_reg));
}
static void __exit connmark_mt_exit(void)
{
	xt_unregister_matches(connmark_mt_reg, ARRAY_SIZE(connmark_mt_reg));
}
static bool
conntrack_addrcmp(const union nf_inet_addr *kaddr,
                  const union nf_inet_addr *uaddr,
                  const union nf_inet_addr *umask, unsigned int l3proto)
{
	if (l3proto == NFPROTO_IPV4)
		return ((kaddr->ip ^ uaddr->ip) & umask->ip) == 0;
	else if (l3proto == NFPROTO_IPV6)
		return ipv6_masked_addr_cmp(&kaddr->in6, &umask->in6,
		       &uaddr->in6) == 0;
	else
		return false;
}
static inline bool
conntrack_mt_origsrc(const struct nf_conn *ct,
                     const struct xt_conntrack_mtinfo1 *info,
		     u_int8_t family)
{
	return conntrack_addrcmp(&ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3,
	       &info->origsrc_addr, &info->origsrc_mask, family);
}
static inline bool
conntrack_mt_origdst(const struct nf_conn *ct,
                     const struct xt_conntrack_mtinfo1 *info,
		     u_int8_t family)
{
	return conntrack_addrcmp(&ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3,
	       &info->origdst_addr, &info->origdst_mask, family);
}
static inline bool
conntrack_mt_replsrc(const struct nf_conn *ct,
                     const struct xt_conntrack_mtinfo1 *info,
		     u_int8_t family)
{
	return conntrack_addrcmp(&ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u3,
	       &info->replsrc_addr, &info->replsrc_mask, family);
}
static inline bool
conntrack_mt_repldst(const struct nf_conn *ct,
                     const struct xt_conntrack_mtinfo1 *info,
		     u_int8_t family)
{
	return conntrack_addrcmp(&ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3,
	       &info->repldst_addr, &info->repldst_mask, family);
}
static void conntrack_mt_destroy(const struct xt_mtdtor_param *par)
{
	nf_ct_l3proto_module_put(par->family);
}
static int __init conntrack_mt_init(void)
{
	return xt_register_matches(conntrack_mt_reg,
	       ARRAY_SIZE(conntrack_mt_reg));
}
static void __exit conntrack_mt_exit(void)
{
	xt_unregister_matches(conntrack_mt_reg, ARRAY_SIZE(conntrack_mt_reg));
}
static inline bool
match_types(const struct dccp_hdr *dh, u_int16_t typemask)
{
	return typemask & (1 << dh->dccph_type);
}
static inline bool
match_option(u_int8_t option, const struct sk_buff *skb, unsigned int protoff,
	     const struct dccp_hdr *dh, bool *hotdrop)
{
	return dccp_find_option(option, skb, protoff, dh, hotdrop);
}
static int __init dscp_mt_init(void)
{
	return xt_register_matches(dscp_mt_reg, ARRAY_SIZE(dscp_mt_reg));
}
static void __exit dscp_mt_exit(void)
{
	xt_unregister_matches(dscp_mt_reg, ARRAY_SIZE(dscp_mt_reg));
}
static int __init esp_mt_init(void)
{
	return xt_register_matches(esp_mt_reg, ARRAY_SIZE(esp_mt_reg));
}
static void __exit esp_mt_exit(void)
{
	xt_unregister_matches(esp_mt_reg, ARRAY_SIZE(esp_mt_reg));
}
static inline bool dst_cmp(const struct dsthash_ent *ent,
			   const struct dsthash_dst *b)
{
	return !memcmp(&ent->dst, b, sizeof(ent->dst));
}
static bool select_all(const struct xt_hashlimit_htable *ht,
		       const struct dsthash_ent *he)
{
	return 1;
}
static bool select_gc(const struct xt_hashlimit_htable *ht,
		      const struct dsthash_ent *he)
{
	return time_after_eq(jiffies, he->expires);
}
static inline __be32 maskl(__be32 a, unsigned int l)
{
	return l ? htonl(ntohl(a) & ~0 << (32 - l)) : 0;
}
static void helper_mt_destroy(const struct xt_mtdtor_param *par)
{
	nf_ct_l3proto_module_put(par->family);
}
static int __init helper_mt_init(void)
{
	return xt_register_match(&helper_mt_reg);
}
static void __exit helper_mt_exit(void)
{
	xt_unregister_match(&helper_mt_reg);
}
static int __init iprange_mt_init(void)
{
	return xt_register_matches(iprange_mt_reg, ARRAY_SIZE(iprange_mt_reg));
}
static void __exit iprange_mt_exit(void)
{
	xt_unregister_matches(iprange_mt_reg, ARRAY_SIZE(iprange_mt_reg));
}
static int __init length_mt_init(void)
{
	return xt_register_matches(length_mt_reg, ARRAY_SIZE(length_mt_reg));
}
static void __exit length_mt_exit(void)
{
	xt_unregister_matches(length_mt_reg, ARRAY_SIZE(length_mt_reg));
}
static int __init limit_mt_init(void)
{
	return xt_register_match(&limit_mt_reg);
}
static void __exit limit_mt_exit(void)
{
	xt_unregister_match(&limit_mt_reg);
}
static int __init mac_mt_init(void)
{
	return xt_register_match(&mac_mt_reg);
}
static void __exit mac_mt_exit(void)
{
	xt_unregister_match(&mac_mt_reg);
}
static int __init mark_mt_init(void)
{
	return xt_register_matches(mark_mt_reg, ARRAY_SIZE(mark_mt_reg));
}
static void __exit mark_mt_exit(void)
{
	xt_unregister_matches(mark_mt_reg, ARRAY_SIZE(mark_mt_reg));
}
static inline bool
check(u_int16_t proto,
      u_int8_t ip_invflags,
      u_int8_t match_flags,
      u_int8_t count)
{
	return (proto == IPPROTO_TCP || proto == IPPROTO_UDP
		|| proto == IPPROTO_UDPLITE
		|| proto == IPPROTO_SCTP || proto == IPPROTO_DCCP)
		&& !(ip_invflags & XT_INV_PROTO)
		&& (match_flags == XT_MULTIPORT_SOURCE
		    || match_flags == XT_MULTIPORT_DESTINATION
		    || match_flags == XT_MULTIPORT_EITHER)
		&& count <= XT_MULTI_PORTS;
}
static int __init multiport_mt_init(void)
{
	return xt_register_matches(multiport_mt_reg,
	       ARRAY_SIZE(multiport_mt_reg));
}
static void __exit multiport_mt_exit(void)
{
	xt_unregister_matches(multiport_mt_reg, ARRAY_SIZE(multiport_mt_reg));
}
static int __init owner_mt_init(void)
{
	return xt_register_matches(owner_mt_reg, ARRAY_SIZE(owner_mt_reg));
}
static void __exit owner_mt_exit(void)
{
	xt_unregister_matches(owner_mt_reg, ARRAY_SIZE(owner_mt_reg));
}
static int __init physdev_mt_init(void)
{
	return xt_register_match(&physdev_mt_reg);
}
static void __exit physdev_mt_exit(void)
{
	xt_unregister_match(&physdev_mt_reg);
}
static int __init pkttype_mt_init(void)
{
	return xt_register_match(&pkttype_mt_reg);
}
static void __exit pkttype_mt_exit(void)
{
	xt_unregister_match(&pkttype_mt_reg);
}
static bool
match_xfrm_state(const struct xfrm_state *x, const struct xt_policy_elem *e,
		 unsigned short family)
{
	return MATCH_ADDR(saddr, smask, &x->props.saddr) &&
	       MATCH_ADDR(daddr, dmask, &x->id.daddr) &&
	       MATCH(proto, x->id.proto) &&
	       MATCH(mode, x->props.mode) &&
	       MATCH(spi, x->id.spi) &&
	       MATCH(reqid, x->props.reqid);
}
static int __init policy_mt_init(void)
{
	return xt_register_matches(policy_mt_reg, ARRAY_SIZE(policy_mt_reg));
}
static void __exit policy_mt_exit(void)
{
	xt_unregister_matches(policy_mt_reg, ARRAY_SIZE(policy_mt_reg));
}
static int __init quota_mt_init(void)
{
	return xt_register_match(&quota_mt_reg);
}
static void __exit quota_mt_exit(void)
{
	xt_unregister_match(&quota_mt_reg);
}
static int __init xt_rateest_mt_init(void)
{
	return xt_register_match(&xt_rateest_mt_reg);
}
static void __exit xt_rateest_mt_fini(void)
{
	xt_unregister_match(&xt_rateest_mt_reg);
}
static int __init realm_mt_init(void)
{
	return xt_register_match(&realm_mt_reg);
}
static void __exit realm_mt_exit(void)
{
	xt_unregister_match(&realm_mt_reg);
}
static void recent_seq_stop(struct seq_file *s, void *v)
{
	spin_unlock_bh(&recent_lock);
}
static int __init sctp_mt_init(void)
{
	return xt_register_matches(sctp_mt_reg, ARRAY_SIZE(sctp_mt_reg));
}
static void __exit sctp_mt_exit(void)
{
	xt_unregister_matches(sctp_mt_reg, ARRAY_SIZE(sctp_mt_reg));
}
static void __exit socket_mt_exit(void)
{
	xt_unregister_match(&socket_mt_reg);
}
static void state_mt_destroy(const struct xt_mtdtor_param *par)
{
	nf_ct_l3proto_module_put(par->match->family);
}
static int __init state_mt_init(void)
{
	return xt_register_matches(state_mt_reg, ARRAY_SIZE(state_mt_reg));
}
static void __exit state_mt_exit(void)
{
	xt_unregister_matches(state_mt_reg, ARRAY_SIZE(state_mt_reg));
}
static int __init statistic_mt_init(void)
{
	return xt_register_match(&xt_statistic_mt_reg);
}
static void __exit statistic_mt_exit(void)
{
	xt_unregister_match(&xt_statistic_mt_reg);
}
static void string_mt_destroy(const struct xt_mtdtor_param *par)
{
	textsearch_destroy(STRING_TEXT_PRIV(par->matchinfo)->config);
}
static int __init string_mt_init(void)
{
	return xt_register_matches(xt_string_mt_reg,
				   ARRAY_SIZE(xt_string_mt_reg));
}
static void __exit string_mt_exit(void)
{
	xt_unregister_matches(xt_string_mt_reg, ARRAY_SIZE(xt_string_mt_reg));
}
static int __init tcpmss_mt_init(void)
{
	return xt_register_matches(tcpmss_mt_reg, ARRAY_SIZE(tcpmss_mt_reg));
}
static void __exit tcpmss_mt_exit(void)
{
	xt_unregister_matches(tcpmss_mt_reg, ARRAY_SIZE(tcpmss_mt_reg));
}
static inline bool
port_match(u_int16_t min, u_int16_t max, u_int16_t port, bool invert)
{
	return (port >= min && port <= max) ^ invert;
}
static int __init tcpudp_mt_init(void)
{
	return xt_register_matches(tcpudp_mt_reg, ARRAY_SIZE(tcpudp_mt_reg));
}
static void __exit tcpudp_mt_exit(void)
{
	xt_unregister_matches(tcpudp_mt_reg, ARRAY_SIZE(tcpudp_mt_reg));
}
static inline bool is_leap(unsigned int y)
{
	return y % 4 == 0 && (y % 100 != 0 || y % 400 == 0);
}
static void __exit time_mt_exit(void)
{
	xt_unregister_match(&xt_time_mt_reg);
}
static int __init u32_mt_init(void)
{
	return xt_register_match(&xt_u32_mt_reg);
}
static void __exit u32_mt_exit(void)
{
	xt_unregister_match(&xt_u32_mt_reg);
}
int netlbl_domhsh_add_default(struct netlbl_dom_map *entry,
			      struct netlbl_audit *audit_info)
{
	return netlbl_domhsh_add(entry, audit_info);
}
int netlbl_domhsh_remove_default(struct netlbl_audit *audit_info)
{
	return netlbl_domhsh_remove(NULL, audit_info);
}
struct netlbl_dom_map *netlbl_domhsh_getentry(const char *domain)
{
	return netlbl_domhsh_search_def(domain);
}
int netlbl_cfg_cipsov4_add(struct cipso_v4_doi *doi_def,
			   struct netlbl_audit *audit_info)
{
	return cipso_v4_doi_add(doi_def, audit_info);
}
void netlbl_cfg_cipsov4_del(u32 doi, struct netlbl_audit *audit_info)
{
	cipso_v4_doi_remove(doi, audit_info);
}
int netlbl_enabled(void)
{
	return (atomic_read(&netlabel_mgmt_protocount) > 0);
}
void netlbl_sock_delattr(struct sock *sk)
{
	cipso_v4_sock_delattr(sk);
}
int netlbl_sock_getattr(struct sock *sk, struct netlbl_lsm_secattr *secattr)
{
	return cipso_v4_sock_getattr(sk, secattr);
}
void netlbl_cache_invalidate(void)
{
	cipso_v4_cache_invalidate();
}
struct audit_buffer *netlbl_audit_start(int type,
					struct netlbl_audit *audit_info)
{
	return netlbl_audit_start_common(type, audit_info);
}
static u32 netlbl_unlhsh_hash(int ifindex)
{
	return ifindex & (rcu_dereference(netlbl_unlhsh)->size - 1);
}
static inline struct netlink_sock *nlk_sk(struct sock *sk)
{
	return container_of(sk, struct netlink_sock, sk);
}
static inline int netlink_is_kernel(struct sock *sk)
{
	return nlk_sk(sk)->flags & NETLINK_KERNEL_SOCKET;
}
static u32 netlink_group_mask(u32 group)
{
	return group ? 1 << (group - 1) : 0;
}
static struct hlist_head *nl_pid_hashfn(struct nl_pid_hash *hash, u32 pid)
{
	return &hash->table[jhash_1word(pid, hash->rnd) & hash->mask];
}
static inline struct hlist_head *nl_pid_hash_zalloc(size_t size)
{
	if (size <= PAGE_SIZE)
		return kzalloc(size, GFP_ATOMIC);
	else
		return (struct hlist_head *)
			__get_free_pages(GFP_ATOMIC | __GFP_ZERO,
					 get_order(size));
}
static inline int netlink_capable(struct socket *sock, unsigned int flag)
{
	return (nl_table[sock->sk->sk_protocol].nl_nonroot & flag) ||
	       capable(CAP_NET_ADMIN);
}
static void netlink_data_ready(struct sock *sk, int len)
{
	BUG();
}
void
netlink_kernel_release(struct sock *sk)
{
	sk_release_kernel(sk);
}
static void netlink_seq_stop(struct seq_file *seq, void *v)
{
	read_unlock(&nl_table_lock);
}
static int netlink_seq_open(struct inode *inode, struct file *file)
{
	return seq_open_net(inode, file, &netlink_seq_ops,
				sizeof(struct nl_seq_iter));
}
int netlink_register_notifier(struct notifier_block *nb)
{
	return atomic_notifier_chain_register(&netlink_chain, nb);
}
int netlink_unregister_notifier(struct notifier_block *nb)
{
	return atomic_notifier_chain_unregister(&netlink_chain, nb);
}
static inline void genl_lock(void)
{
	mutex_lock(&genl_mutex);
}
static inline void genl_unlock(void)
{
	mutex_unlock(&genl_mutex);
}
static inline unsigned int genl_family_hash(unsigned int id)
{
	return id & GENL_FAM_TAB_MASK;
}
static inline struct list_head *genl_family_chain(unsigned int id)
{
	return &family_ht[genl_family_hash(id)];
}
static void nr_set_lockdep_one(struct net_device *dev,
			       struct netdev_queue *txq,
			       void *_unused)
{
	lockdep_set_class(&txq->_xmit_lock, &nr_netdev_xmit_lock_key);
}
static void nr_info_stop(struct seq_file *seq, void *v)
{
	spin_unlock_bh(&nr_list_lock);
}
static int nr_info_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &nr_info_seqops);
}
static int nr_rebuild_header(struct sk_buff *skb)
{
	return 1;
}
void __init nr_loopback_init(void)
{
	skb_queue_head_init(&loopback_queue);
}
static inline int nr_loopback_running(void)
{
	return timer_pending(&loopback_timer);
}
static void nr_node_stop(struct seq_file *seq, void *v)
{
	spin_unlock_bh(&nr_node_list_lock);
}
static int nr_node_info_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &nr_node_seqops);
}
static void nr_neigh_stop(struct seq_file *seq, void *v)
{
	spin_unlock_bh(&nr_neigh_list_lock);
}
static int nr_neigh_info_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &nr_neigh_seqops);
}
void nr_start_heartbeat(struct sock *sk)
{
	mod_timer(&sk->sk_timer, jiffies + 5 * HZ);
}
void nr_stop_t1timer(struct sock *sk)
{
	del_timer(&nr_sk(sk)->t1timer);
}
void nr_stop_t2timer(struct sock *sk)
{
	del_timer(&nr_sk(sk)->t2timer);
}
void nr_stop_t4timer(struct sock *sk)
{
	del_timer(&nr_sk(sk)->t4timer);
}
void nr_stop_idletimer(struct sock *sk)
{
	del_timer(&nr_sk(sk)->idletimer);
}
void nr_stop_heartbeat(struct sock *sk)
{
	del_timer(&sk->sk_timer);
}
int nr_t1timer_running(struct sock *sk)
{
	return timer_pending(&nr_sk(sk)->t1timer);
}
void __init nr_register_sysctl(void)
{
	nr_table_header = register_sysctl_paths(nr_path, nr_table);
}
void nr_unregister_sysctl(void)
{
	unregister_sysctl_table(nr_table_header);
}
static int sock_no_open(struct inode *irrelevant, struct file *dontcare)
{
	return -ENXIO;
}
static inline struct packet_sock *pkt_sk(struct sock *sk)
{
	return (struct packet_sock *)sk;
}
static inline char *alloc_one_pg_vec_page(unsigned long order)
{
	return (char *) __get_free_pages(GFP_KERNEL | __GFP_COMP | __GFP_ZERO,
					 order);
}
static int packet_seq_open(struct inode *inode, struct file *file)
{
	return seq_open_net(inode, file, &packet_seq_ops,
			    sizeof(struct seq_net_private));
}
static void packet_net_exit(struct net *net)
{
	proc_net_remove(net, "packet");
}
static inline void phonet_proto_put(struct phonet_protocol *pp)
{
	module_put(pp->prot->owner);
}
static void pn_sock_close(struct sock *sk, long timeout)
{
	sk_common_release(sk);
}
static void pn_destruct(struct sock *sk)
{
	skb_queue_purge(&sk->sk_receive_queue);
}
int __init isi_register(void)
{
	return phonet_proto_register(PN_PROTO_PHONET, &pn_dgram_proto);
}
void __exit isi_unregister(void)
{
	phonet_proto_unregister(PN_PROTO_PHONET, &pn_dgram_proto);
}
static int __init pep_register(void)
{
	return phonet_proto_register(PN_PROTO_PIPE, &pep_pn_proto);
}
static void __exit pep_unregister(void)
{
	phonet_proto_unregister(PN_PROTO_PIPE, &pep_pn_proto);
}
void phonet_sysctl_exit(void)
{
	unregister_sysctl_table(phonet_table_hrd);
}
static void rfkill_uevent(struct rfkill *rfkill)
{
	kobject_uevent(&rfkill->dev.kobj, KOBJ_CHANGE);
}
bool rfkill_is_epo_lock_active(void)
{
	return rfkill_epo_lock_active;
}
enum rfkill_state rfkill_get_global_state(const enum rfkill_type type)
{
	return rfkill_global_states[type].current_state;
}
static void __exit rfkill_exit(void)
{
	class_unregister(&rfkill_class);
}
static void rose_set_lockdep_one(struct net_device *dev,
				 struct netdev_queue *txq,
				 void *_unused)
{
	lockdep_set_class(&txq->_xmit_lock, &rose_netdev_xmit_lock_key);
}
static void rose_destroy_timer(unsigned long data)
{
	rose_destroy_socket((struct sock *)data);
}
static void rose_info_stop(struct seq_file *seq, void *v)
{
	spin_unlock_bh(&rose_list_lock);
}
static int rose_info_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &rose_info_seqops);
}
void rose_stop_ftimer(struct rose_neigh *neigh)
{
	del_timer(&neigh->ftimer);
}
void rose_stop_t0timer(struct rose_neigh *neigh)
{
	del_timer(&neigh->t0timer);
}
int rose_ftimer_running(struct rose_neigh *neigh)
{
	return timer_pending(&neigh->ftimer);
}
static int rose_t0timer_running(struct rose_neigh *neigh)
{
	return timer_pending(&neigh->t0timer);
}
static int rose_loopback_running(void)
{
	return timer_pending(&loopback_timer);
}
static void rose_node_stop(struct seq_file *seq, void *v)
{
	spin_unlock_bh(&rose_node_list_lock);
}
static int rose_nodes_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &rose_node_seqops);
}
static void rose_neigh_stop(struct seq_file *seq, void *v)
{
	spin_unlock_bh(&rose_neigh_list_lock);
}
static int rose_neigh_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &rose_neigh_seqops);
}
static void rose_route_stop(struct seq_file *seq, void *v)
{
	spin_unlock_bh(&rose_route_list_lock);
}
static int rose_route_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &rose_route_seqops);
}
void rose_stop_heartbeat(struct sock *sk)
{
	del_timer(&sk->sk_timer);
}
void rose_stop_timer(struct sock *sk)
{
	del_timer(&rose_sk(sk)->timer);
}
void rose_stop_idletimer(struct sock *sk)
{
	del_timer(&rose_sk(sk)->idletimer);
}
void __init rose_register_sysctl(void)
{
	rose_table_header = register_sysctl_paths(rose_path, rose_table);
}
void rose_unregister_sysctl(void)
{
	unregister_sysctl_table(rose_table_header);
}
static inline int rxrpc_writable(struct sock *sk)
{
	return atomic_read(&sk->sk_wmem_alloc) < (size_t) sk->sk_sndbuf;
}
static void rxrpc_clear_tx_window(struct rxrpc_call *call)
{
	rxrpc_rotate_tx_window(call, atomic_read(&call->sequence));
}
static inline
int rxrpc_cmp_bundle(const struct rxrpc_conn_bundle *bundle,
		     struct key *key, __be16 service_id)
{
	return (bundle->service_id - service_id) ?:
		((unsigned long) bundle->key - (unsigned long) key);
}
static void rxrpc_destroy(struct key *key)
{
	kfree(key->payload.data);
}
static void rxrpc_describe(const struct key *key, struct seq_file *m)
{
	seq_puts(m, key->description);
}
static void *rxrpc_call_seq_next(struct seq_file *seq, void *v, loff_t *pos)
{
	return seq_list_next(v, &rxrpc_calls, pos);
}
static void rxrpc_call_seq_stop(struct seq_file *seq, void *v)
{
	read_unlock(&rxrpc_call_lock);
}
static int rxrpc_call_seq_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &rxrpc_call_seq_ops);
}
static void *rxrpc_connection_seq_next(struct seq_file *seq, void *v,
				       loff_t *pos)
{
	return seq_list_next(v, &rxrpc_connections, pos);
}
static void rxrpc_connection_seq_stop(struct seq_file *seq, void *v)
{
	read_unlock(&rxrpc_connection_lock);
}
static int rxrpc_connection_seq_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &rxrpc_connection_seq_ops);
}
static struct rxrpc_security *rxrpc_security_get(struct rxrpc_security *sec)
{
	return try_module_get(sec->owner) ? sec : NULL;
}
static void rxrpc_security_put(struct rxrpc_security *sec)
{
	module_put(sec->owner);
}
void rxrpc_kernel_free_skb(struct sk_buff *skb)
{
	rxrpc_free_skb(skb);
}
static void __exit gact_cleanup_module(void)
{
	tcf_unregister_action(&act_gact_ops);
}
static int __init ipt_init_module(void)
{
	return tcf_register_action(&act_ipt_ops);
}
static void __exit ipt_cleanup_module(void)
{
	tcf_unregister_action(&act_ipt_ops);
}
static void __exit mirred_cleanup_module(void)
{
	tcf_unregister_action(&act_mirred_ops);
}
static int __init nat_init_module(void)
{
	return tcf_register_action(&act_nat_ops);
}
static void __exit nat_cleanup_module(void)
{
	tcf_unregister_action(&act_nat_ops);
}
static int __init pedit_init_module(void)
{
	return tcf_register_action(&act_pedit_ops);
}
static void __exit pedit_cleanup_module(void)
{
	tcf_unregister_action(&act_pedit_ops);
}
static int __init
police_init_module(void)
{
	return tcf_register_action(&act_police_ops);
}
static void __exit
police_cleanup_module(void)
{
	tcf_unregister_action(&act_police_ops);
}
static void __exit simp_cleanup_module(void)
{
	tcf_unregister_action(&act_simp_ops);
}
static int __init skbedit_init_module(void)
{
	return tcf_register_action(&act_skbedit_ops);
}
static void __exit skbedit_cleanup_module(void)
{
	tcf_unregister_action(&act_skbedit_ops);
}
static int __init init_basic(void)
{
	return register_tcf_proto_ops(&cls_basic_ops);
}
static void __exit exit_basic(void)
{
	unregister_tcf_proto_ops(&cls_basic_ops);
}
static inline struct cgroup_cls_state *cgrp_cls_state(struct cgroup *cgrp)
{
	return container_of(cgroup_subsys_state(cgrp, net_cls_subsys_id),
			    struct cgroup_cls_state, css);
}
static inline struct cgroup_cls_state *task_cls_state(struct task_struct *p)
{
	return container_of(task_subsys_state(p, net_cls_subsys_id),
			    struct cgroup_cls_state, css);
}
static void cgrp_destroy(struct cgroup_subsys *ss, struct cgroup *cgrp)
{
	kfree(cgrp_cls_state(cgrp));
}
static u64 read_classid(struct cgroup *cgrp, struct cftype *cft)
{
	return cgrp_cls_state(cgrp)->classid;
}
static int cgrp_populate(struct cgroup_subsys *ss, struct cgroup *cgrp)
{
	return cgroup_add_files(cgrp, ss, ss_files, ARRAY_SIZE(ss_files));
}
static unsigned long cls_cgroup_get(struct tcf_proto *tp, u32 handle)
{
	return 0UL;
}
static int cls_cgroup_init(struct tcf_proto *tp)
{
	return 0;
}
static int cls_cgroup_delete(struct tcf_proto *tp, unsigned long arg)
{
	return -EOPNOTSUPP;
}
static int __init init_cgroup_cls(void)
{
	return register_tcf_proto_ops(&cls_cgroup_ops);
}
static void __exit exit_cgroup_cls(void)
{
	unregister_tcf_proto_ops(&cls_cgroup_ops);
}
static u32 flow_get_iif(const struct sk_buff *skb)
{
	return skb->iif;
}
static u32 flow_get_priority(const struct sk_buff *skb)
{
	return skb->priority;
}
static u32 flow_get_mark(const struct sk_buff *skb)
{
	return skb->mark;
}
static u32 flow_get_nfct(const struct sk_buff *skb)
{
	return addr_fold(skb->nfct);
}
static u32 flow_get_nfct_proto_src(const struct sk_buff *skb)
{
	return ntohs(CTTUPLE(skb, src.u.all));
}
static u32 flow_get_nfct_proto_dst(const struct sk_buff *skb)
{
	return ntohs(CTTUPLE(skb, dst.u.all));
}
static void flow_put(struct tcf_proto *tp, unsigned long f)
{
	return;
}
static int __init cls_flow_init(void)
{
	return register_tcf_proto_ops(&cls_flow_ops);
}
static void __exit cls_flow_exit(void)
{
	unregister_tcf_proto_ops(&cls_flow_ops);
}
static __inline__ int fw_hash(u32 handle)
{
	if (HTSIZE == 4096)
		return ((handle >> 24) & 0xFFF) ^
		       ((handle >> 12) & 0xFFF) ^
		       (handle & 0xFFF);
	else if (HTSIZE == 2048)
		return ((handle >> 22) & 0x7FF) ^
		       ((handle >> 11) & 0x7FF) ^
		       (handle & 0x7FF);
	else if (HTSIZE == 1024)
		return ((handle >> 20) & 0x3FF) ^
		       ((handle >> 10) & 0x3FF) ^
		       (handle & 0x3FF);
	else if (HTSIZE == 512)
		return (handle >> 27) ^
		       ((handle >> 18) & 0x1FF) ^
		       ((handle >> 9) & 0x1FF) ^
		       (handle & 0x1FF);
	else if (HTSIZE == 256) {
	} else
		return handle & (HTSIZE - 1);
}
static int fw_init(struct tcf_proto *tp)
{
	return 0;
}
static int __init init_fw(void)
{
	return register_tcf_proto_ops(&cls_fw_ops);
}
static void __exit exit_fw(void)
{
	unregister_tcf_proto_ops(&cls_fw_ops);
}
static __inline__ int route4_fastmap_hash(u32 id, int iif)
{
	return id&0xF;
}
static __inline__ int route4_hash_to(u32 id)
{
	return id&0xFF;
}
static __inline__ int route4_hash_from(u32 id)
{
	return (id>>16)&0xF;
}
static __inline__ int route4_hash_iif(int iif)
{
	return 16 + ((iif>>16)&0xF);
}
static __inline__ int route4_hash_wild(void)
{
	return 32;
}
static int route4_init(struct tcf_proto *tp)
{
	return 0;
}
static int __init init_route4(void)
{
	return register_tcf_proto_ops(&cls_route4_ops);
}
static void __exit exit_route4(void)
{
	unregister_tcf_proto_ops(&cls_route4_ops);
}
static inline int
tcindex_filter_is_set(struct tcindex_filter_result *r)
{
	return tcf_exts_is_predicative(&r->exts) || r->res.classid;
}
static void tcindex_put(struct tcf_proto *tp, unsigned long f)
{
	pr_debug("tcindex_put(tp %p,f 0x%lx)\n", tp, f);
}
static int tcindex_delete(struct tcf_proto *tp, unsigned long arg)
{
	return __tcindex_delete(tp, arg, 1);
}
static inline int
valid_perfect_hash(struct tcindex_data *p)
{
	return  p->hash > (p->mask >> p->shift);
}
static int tcindex_destroy_element(struct tcf_proto *tp,
    unsigned long arg, struct tcf_walker *walker)
{
	return __tcindex_delete(tp, arg, 0);
}
static int __init init_tcindex(void)
{
	return register_tcf_proto_ops(&cls_tcindex_ops);
}
static void __exit exit_tcindex(void)
{
	unregister_tcf_proto_ops(&cls_tcindex_ops);
}
static void __exit exit_u32(void)
{
	unregister_tcf_proto_ops(&cls_u32_ops);
}
static int __init init_em_nbyte(void)
{
	return tcf_em_register(&em_nbyte_ops);
}
static void __exit exit_em_nbyte(void)
{
	tcf_em_unregister(&em_nbyte_ops);
}
static void em_text_destroy(struct tcf_proto *tp, struct tcf_ematch *m)
{
	textsearch_destroy(EM_TEXT_PRIV(m)->config);
}
static int __init init_em_text(void)
{
	return tcf_em_register(&em_text_ops);
}
static void __exit exit_em_text(void)
{
	tcf_em_unregister(&em_text_ops);
}
static int __init init_em_u32(void)
{
	return tcf_em_register(&em_u32_ops);
}
static void __exit exit_em_u32(void)
{
	tcf_em_unregister(&em_u32_ops);
}
static inline struct tcf_ematch * tcf_em_get_match(struct tcf_ematch_tree *tree,
						   int index)
{
	return &tree->matches[index];
}
void qdisc_class_hash_destroy(struct Qdisc_class_hash *clhash)
{
	qdisc_class_hash_free(clhash->hash, clhash->hashsize);
}
static bool tc_qdisc_dump_ignore(struct Qdisc *q)
{
	return (q->flags & TCQ_F_BUILTIN) ? true : false;
}
static int psched_open(struct inode *inode, struct file *file)
{
	return single_open(file, psched_show, PDE(inode)->data);
}
static unsigned long atm_tc_bind_filter(struct Qdisc *sch,
					unsigned long parent, u32 classid)
{
	return atm_tc_get(sch, classid);
}
static int atm_tc_dump(struct Qdisc *sch, struct sk_buff *skb)
{
	return 0;
}
static int __init atm_init(void)
{
	return register_qdisc(&atm_qdisc_ops);
}
static void __exit atm_exit(void)
{
	unregister_qdisc(&atm_qdisc_ops);
}
static struct sk_buff *blackhole_dequeue(struct Qdisc *sch)
{
	return NULL;
}
static int __init blackhole_module_init(void)
{
	return register_qdisc(&blackhole_qdisc_ops);
}
static void __exit blackhole_module_exit(void)
{
	unregister_qdisc(&blackhole_qdisc_ops);
}
static int __init cbq_module_init(void)
{
	return register_qdisc(&cbq_qdisc_ops);
}
static void __exit cbq_module_exit(void)
{
	unregister_qdisc(&cbq_qdisc_ops);
}
static int __init drr_init(void)
{
	return register_qdisc(&drr_qdisc_ops);
}
static void __exit drr_exit(void)
{
	unregister_qdisc(&drr_qdisc_ops);
}
static inline int dsmark_valid_index(struct dsmark_qdisc_data *p, u16 index)
{
	return (index <= p->indices && index > 0);
}
static unsigned long dsmark_bind_filter(struct Qdisc *sch,
					unsigned long parent, u32 classid)
{
	return dsmark_get(sch, classid);
}
static int __init dsmark_module_init(void)
{
	return register_qdisc(&dsmark_qdisc_ops);
}
static void __exit dsmark_module_exit(void)
{
	unregister_qdisc(&dsmark_qdisc_ops);
}
static inline int qdisc_qlen(struct Qdisc *q)
{
	return q->q.qlen;
}
static void dev_watchdog_up(struct net_device *dev)
{
	__netdev_watchdog_up(dev);
}
static struct sk_buff *noop_dequeue(struct Qdisc * qdisc)
{
	return NULL;
}
static inline int gred_wred_mode(struct gred_sched *table)
{
	return test_bit(GRED_WRED_MODE, &table->flags);
}
static inline void gred_enable_wred_mode(struct gred_sched *table)
{
	__set_bit(GRED_WRED_MODE, &table->flags);
}
static inline void gred_disable_wred_mode(struct gred_sched *table)
{
	__clear_bit(GRED_WRED_MODE, &table->flags);
}
static inline int gred_rio_mode(struct gred_sched *table)
{
	return test_bit(GRED_RIO_MODE, &table->flags);
}
static inline void gred_enable_rio_mode(struct gred_sched *table)
{
	__set_bit(GRED_RIO_MODE, &table->flags);
}
static inline void gred_disable_rio_mode(struct gred_sched *table)
{
	__clear_bit(GRED_RIO_MODE, &table->flags);
}
static inline unsigned int gred_backlog(struct gred_sched *table,
					struct gred_sched_data *q,
					struct Qdisc *sch)
{
	if (gred_wred_mode(table))
		return sch->qstats.backlog;
	else
		return q->backlog;
}
static inline u16 tc_index_to_dp(struct sk_buff *skb)
{
	return skb->tc_index & GRED_VQ_MASK;
}
static inline void gred_store_wred_set(struct gred_sched *table,
				       struct gred_sched_data *q)
{
	table->wred_set.qavg = q->parms.qavg;
}
static inline int gred_use_ecn(struct gred_sched *t)
{
	return t->red_flags & TC_RED_ECN;
}
static inline int gred_use_harddrop(struct gred_sched *t)
{
	return t->red_flags & TC_RED_HARDDROP;
}
static inline void gred_destroy_vq(struct gred_sched_data *q)
{
	kfree(q);
}
static int __init gred_module_init(void)
{
	return register_qdisc(&gred_qdisc_ops);
}
static void __exit gred_module_exit(void)
{
	unregister_qdisc(&gred_qdisc_ops);
}
static inline void
eltree_remove(struct hfsc_class *cl)
{
	rb_erase(&cl->el_node, &cl->sched->eligible);
}
static inline void
vttree_remove(struct hfsc_class *cl)
{
	rb_erase(&cl->vt_node, &cl->cl_parent->vt_tree);
}
static inline void
cftree_remove(struct hfsc_class *cl)
{
	rb_erase(&cl->cf_node, &cl->cl_parent->cf_tree);
}
static inline void
update_d(struct hfsc_class *cl, unsigned int next_len)
{
	cl->cl_d = rtsc_y2x(&cl->cl_deadline, cl->cl_cumul + next_len);
}
static int __init
hfsc_init(void)
{
	return register_qdisc(&hfsc_qdisc_ops);
}
static void __exit
hfsc_cleanup(void)
{
	unregister_qdisc(&hfsc_qdisc_ops);
}
static inline void htb_next_rb_node(struct rb_node **n)
{
	*n = rb_next(*n);
}
static inline long htb_lowater(const struct htb_class *cl)
{
	if (htb_hysteresis)
		return cl->cmode != HTB_CANT_SEND ? -cl->cbuffer : 0;
	else
		return 0;
}
static inline long htb_hiwater(const struct htb_class *cl)
{
	if (htb_hysteresis)
		return cl->cmode == HTB_CAN_SEND ? -cl->buffer : 0;
	else
		return 0;
}
static int __init htb_module_init(void)
{
	return register_qdisc(&htb_qdisc_ops);
}
static void __exit htb_module_exit(void)
{
	unregister_qdisc(&htb_qdisc_ops);
}
static int ingress_graft(struct Qdisc *sch, unsigned long arg,
			 struct Qdisc *new, struct Qdisc **old)
{
	return -EOPNOTSUPP;
}
static struct Qdisc *ingress_leaf(struct Qdisc *sch, unsigned long arg)
{
	return NULL;
}
static unsigned long ingress_get(struct Qdisc *sch, u32 classid)
{
	return TC_H_MIN(classid) + 1;
}
static unsigned long ingress_bind_filter(struct Qdisc *sch,
					 unsigned long parent, u32 classid)
{
	return ingress_get(sch, classid);
}
static int ingress_change(struct Qdisc *sch, u32 classid, u32 parent,
			  struct nlattr **tca, unsigned long *arg)
{
	return 0;
}
static void ingress_walk(struct Qdisc *sch, struct qdisc_walker *walker)
{
	return;
}
static int __init ingress_module_init(void)
{
	return register_qdisc(&ingress_qdisc_ops);
}
static void __exit ingress_module_exit(void)
{
	unregister_qdisc(&ingress_qdisc_ops);
}
static unsigned long multiq_bind(struct Qdisc *sch, unsigned long parent,
				 u32 classid)
{
	return multiq_get(sch, classid);
}
static void multiq_put(struct Qdisc *q, unsigned long cl)
{
	return;
}
static int __init multiq_module_init(void)
{
	return register_qdisc(&multiq_qdisc_ops);
}
static void __exit multiq_module_exit(void)
{
	unregister_qdisc(&multiq_qdisc_ops);
}
static void __exit netem_module_exit(void)
{
	unregister_qdisc(&netem_qdisc_ops);
}
static unsigned long prio_bind(struct Qdisc *sch, unsigned long parent, u32 classid)
{
	return prio_get(sch, classid);
}
static void prio_put(struct Qdisc *q, unsigned long cl)
{
	return;
}
static int __init prio_module_init(void)
{
	return register_qdisc(&prio_qdisc_ops);
}
static void __exit prio_module_exit(void)
{
	unregister_qdisc(&prio_qdisc_ops);
}
static inline int red_use_ecn(struct red_sched_data *q)
{
	return q->flags & TC_RED_ECN;
}
static inline int red_use_harddrop(struct red_sched_data *q)
{
	return q->flags & TC_RED_HARDDROP;
}
static unsigned long red_get(struct Qdisc *sch, u32 classid)
{
	return 1;
}
static void red_put(struct Qdisc *sch, unsigned long arg)
{
	return;
}
static int red_change_class(struct Qdisc *sch, u32 classid, u32 parentid,
			    struct nlattr **tca, unsigned long *arg)
{
	return -ENOSYS;
}
static int red_delete(struct Qdisc *sch, unsigned long cl)
{
	return -ENOSYS;
}
static struct tcf_proto **red_find_tcf(struct Qdisc *sch, unsigned long cl)
{
	return NULL;
}
static int __init red_module_init(void)
{
	return register_qdisc(&red_qdisc_ops);
}
static void __exit red_module_exit(void)
{
	unregister_qdisc(&red_qdisc_ops);
}
static __inline__ unsigned sfq_fold_hash(struct sfq_sched_data *q, u32 h, u32 h1)
{
	return jhash_2words(h, h1, q->perturbation) & (SFQ_HASH_DIVISOR - 1);
}
static int sfq_change_class(struct Qdisc *sch, u32 classid, u32 parentid,
			    struct nlattr **tca, unsigned long *arg)
{
	return -EOPNOTSUPP;
}
static unsigned long sfq_get(struct Qdisc *sch, u32 classid)
{
	return 0;
}
static int __init sfq_module_init(void)
{
	return register_qdisc(&sfq_qdisc_ops);
}
static void __exit sfq_module_exit(void)
{
	unregister_qdisc(&sfq_qdisc_ops);
}
static unsigned long tbf_get(struct Qdisc *sch, u32 classid)
{
	return 1;
}
static int tbf_change_class(struct Qdisc *sch, u32 classid, u32 parentid,
			    struct nlattr **tca, unsigned long *arg)
{
	return -ENOSYS;
}
static int tbf_delete(struct Qdisc *sch, unsigned long arg)
{
	return -ENOSYS;
}
static struct tcf_proto **tbf_find_tcf(struct Qdisc *sch, unsigned long cl)
{
	return NULL;
}
static int __init tbf_module_init(void)
{
	return register_qdisc(&tbf_qdisc_ops);
}
static void __exit tbf_module_exit(void)
{
	unregister_qdisc(&tbf_qdisc_ops);
}
static struct sk_buff *
teql_peek(struct Qdisc* sch)
{
	return NULL;
}
void sctp_association_hold(struct sctp_association *asoc)
{
	atomic_inc(&asoc->base.refcnt);
}
static struct sctp_auth_bytes *sctp_auth_make_local_vector(
				    const struct sctp_association *asoc,
				    gfp_t gfp)
{
	return sctp_auth_make_key_vector(
				    (sctp_random_param_t*)asoc->c.auth_random,
				    (sctp_chunks_param_t*)asoc->c.auth_chunks,
				    (sctp_hmac_algo_param_t*)asoc->c.auth_hmacs,
				    gfp);
}
static struct sctp_auth_bytes *sctp_auth_make_peer_vector(
				    const struct sctp_association *asoc,
				    gfp_t gfp)
{
	return sctp_auth_make_key_vector(asoc->peer.peer_random,
					 asoc->peer.peer_chunks,
					 asoc->peer.peer_hmacs,
					 gfp);
}
struct sctp_hmac *sctp_auth_get_hmac(__u16 hmac_id)
{
	return &sctp_hmac_list[hmac_id];
}
static void sctp_datamsg_hold(struct sctp_datamsg *msg)
{
	atomic_inc(&msg->refcnt);
}
void sctp_endpoint_hold(struct sctp_endpoint *ep)
{
	atomic_inc(&ep->base.refcnt);
}
void sctp_inq_set_th_handler(struct sctp_inq *q, work_func_t callback)
{
	INIT_WORK(&q->immediate, callback);
}
static int sctp_v6_is_any(const union sctp_addr *addr)
{
	return ipv6_addr_any(&addr->v6.sin6_addr);
}
static int sctp_v6_is_ce(const struct sk_buff *skb)
{
	return *((__u32 *)(ipv6_hdr(skb))) & htonl(1 << 20);
}
static void sctp_v6_seq_dump_addr(struct seq_file *seq, union sctp_addr *addr)
{
	seq_printf(seq, "%pI6 ", &addr->v6.sin6_addr);
}
static void sctp_v6_ecn_capable(struct sock *sk)
{
	inet6_sk(sk)->tclass |= INET_ECN_ECT_0;
}
static int sctp6_rcv(struct sk_buff *skb)
{
	return sctp_rcv(skb) ? -1 : 0;
}
void sctp_v6_pf_exit(void)
{
	list_del(&sctp_af_inet6.list);
}
static void *sctp_objcnt_seq_start(struct seq_file *seq, loff_t *pos)
{
	return (*pos >= ARRAY_SIZE(sctp_dbg_objcnt)) ? NULL : (void *)pos;
}
static int sctp_objcnt_seq_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &sctp_objcnt_seq_ops);
}
void sctp_dbg_objcnt_exit(void)
{
	remove_proc_entry("sctp_dbg_objcnt", proc_net_sctp);
}
int sctp_outq_is_empty(const struct sctp_outq *q)
{
	return q->empty;
}
static int sctp_snmp_seq_open(struct inode *inode, struct file *file)
{
	return single_open(file, sctp_snmp_seq_show, NULL);
}
void sctp_snmp_proc_exit(void)
{
	remove_proc_entry("snmp", proc_net_sctp);
}
static void sctp_eps_seq_stop(struct seq_file *seq, void *v)
{
	return;
}
static int sctp_eps_seq_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &sctp_eps_ops);
}
void sctp_eps_proc_exit(void)
{
	remove_proc_entry("eps", proc_net_sctp);
}
static void sctp_assocs_seq_stop(struct seq_file *seq, void *v)
{
	return;
}
static int sctp_assocs_seq_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &sctp_assoc_ops);
}
void sctp_assocs_proc_exit(void)
{
	remove_proc_entry("assocs", proc_net_sctp);
}
static void sctp_remaddr_seq_stop(struct seq_file *seq, void *v)
{
	return;
}
void sctp_remaddr_proc_exit(void)
{
	remove_proc_entry("remaddr", proc_net_sctp);
}
static int sctp_remaddr_seq_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &sctp_remaddr_ops);
}
struct sock *sctp_get_ctl_sock(void)
{
	return sctp_ctl_sock;
}
static void sctp_v4_to_sk_saddr(union sctp_addr *addr, struct sock *sk)
{
	inet_sk(sk)->rcv_saddr = addr->v4.sin_addr.s_addr;
}
static void sctp_v4_to_sk_daddr(union sctp_addr *addr, struct sock *sk)
{
	inet_sk(sk)->daddr = addr->v4.sin_addr.s_addr;
}
static int sctp_v4_is_any(const union sctp_addr *addr)
{
	return htonl(INADDR_ANY) == addr->v4.sin_addr.s_addr;
}
static int sctp_v4_skb_iif(const struct sk_buff *skb)
{
	return skb->rtable->rt_iif;
}
static int sctp_v4_is_ce(const struct sk_buff *skb)
{
	return INET_ECN_is_ce(ip_hdr(skb)->tos);
}
static void sctp_v4_seq_dump_addr(struct seq_file *seq, union sctp_addr *addr)
{
	seq_printf(seq, "%pI4 ", &addr->v4.sin_addr);
}
static void sctp_v4_ecn_capable(struct sock *sk)
{
	INET_ECN_xmit(sk);
}
static int sctp_inet_af_supported(sa_family_t family, struct sctp_sock *sp)
{
	return (AF_INET == family);
}
static int sctp_inet_bind_verify(struct sctp_sock *opt, union sctp_addr *addr)
{
	return sctp_v4_available(addr, opt);
}
static int sctp_inet_send_verify(struct sctp_sock *opt, union sctp_addr *addr)
{
	return 1;
}
static inline int init_sctp_mibs(void)
{
	return snmp_mib_init((void**)sctp_statistics, sizeof(struct sctp_mib));
}
static inline void cleanup_sctp_mibs(void)
{
	snmp_mib_free((void**)sctp_statistics);
}
static void sctp_v4_pf_exit(void)
{
	list_del(&sctp_af_inet.list);
}
void sctp_chunk_hold(struct sctp_chunk *ch)
{
	atomic_inc(&ch->refcnt);
}
static void sctp_do_ecn_cwr_work(struct sctp_association *asoc,
				 __u32 lowest_tsn)
{
	asoc->need_ecne = 0;
}
sctp_disposition_t sctp_sf_do_5_2_1_siminit(const struct sctp_endpoint *ep,
				    const struct sctp_association *asoc,
				    const sctp_subtype_t type,
				    void *arg,
				    sctp_cmd_seq_t *commands)
{
	return sctp_sf_do_unexpected_init(ep, asoc, type, arg, commands);
}
sctp_disposition_t sctp_sf_do_5_2_2_dupinit(const struct sctp_endpoint *ep,
					const struct sctp_association *asoc,
					const sctp_subtype_t type,
					void *arg,
					sctp_cmd_seq_t *commands)
{
	return sctp_sf_do_unexpected_init(ep, asoc, type, arg, commands);
}
sctp_disposition_t sctp_sf_do_5_2_3_initack(const struct sctp_endpoint *ep,
					    const struct sctp_association *asoc,
					    const sctp_subtype_t type,
					    void *arg, sctp_cmd_seq_t *commands)
{
	if (ep == sctp_sk((sctp_get_ctl_sock()))->ep)
		return sctp_sf_ootb(ep, asoc, type, arg, commands);
	else
		return sctp_sf_discard_chunk(ep, asoc, type, arg, commands);
}
static sctp_disposition_t sctp_sf_do_dupcook_c(const struct sctp_endpoint *ep,
					const struct sctp_association *asoc,
					struct sctp_chunk *chunk,
					sctp_cmd_seq_t *commands,
					struct sctp_association *new_asoc)
{
	return SCTP_DISPOSITION_DISCARD;
}
sctp_disposition_t sctp_sf_shutdown_ack_sent_abort(
	const struct sctp_endpoint *ep,
	const struct sctp_association *asoc,
	const sctp_subtype_t type,
	void *arg,
	sctp_cmd_seq_t *commands)
{
	return sctp_sf_shutdown_sent_abort(ep, asoc, type, arg, commands);
}
sctp_disposition_t sctp_sf_cookie_wait_icmp_abort(const struct sctp_endpoint *ep,
					const struct sctp_association *asoc,
					const sctp_subtype_t type,
					void *arg,
					sctp_cmd_seq_t *commands)
{
	return sctp_stop_t1_and_abort(commands, SCTP_ERROR_NO_ERROR,
				      ENOPROTOOPT, asoc,
				      (struct sctp_transport *)arg);
}
sctp_disposition_t sctp_sf_cookie_echoed_abort(const struct sctp_endpoint *ep,
					       const struct sctp_association *asoc,
					       const sctp_subtype_t type,
					       void *arg,
					       sctp_cmd_seq_t *commands)
{
	return sctp_sf_cookie_wait_abort(ep, asoc, type, arg, commands);
}
sctp_disposition_t sctp_sf_cookie_echoed_prm_shutdown(
	const struct sctp_endpoint *ep,
	const struct sctp_association *asoc,
	const sctp_subtype_t type,
	void *arg, sctp_cmd_seq_t *commands)
{
	return sctp_sf_cookie_wait_prm_shutdown(ep, asoc, type, arg, commands);
}
sctp_disposition_t sctp_sf_cookie_echoed_prm_abort(
	const struct sctp_endpoint *ep,
	const struct sctp_association *asoc,
	const sctp_subtype_t type,
	void *arg,
	sctp_cmd_seq_t *commands)
{
	return sctp_sf_cookie_wait_prm_abort(ep, asoc, type, arg, commands);
}
sctp_disposition_t sctp_sf_shutdown_ack_sent_prm_abort(
	const struct sctp_endpoint *ep,
	const struct sctp_association *asoc,
	const sctp_subtype_t type,
	void *arg,
	sctp_cmd_seq_t *commands)
{
	return sctp_sf_shutdown_sent_prm_abort(ep, asoc, type, arg, commands);
}
sctp_disposition_t sctp_sf_not_impl(const struct sctp_endpoint *ep,
				    const struct sctp_association *asoc,
				    const sctp_subtype_t type,
				    void *arg,
				    sctp_cmd_seq_t *commands)
{
	return SCTP_DISPOSITION_NOT_IMPL;
}
sctp_disposition_t sctp_sf_bug(const struct sctp_endpoint *ep,
			       const struct sctp_association *asoc,
			       const sctp_subtype_t type,
			       void *arg,
			       sctp_cmd_seq_t *commands)
{
	return SCTP_DISPOSITION_BUG;
}
void sctp_ootb_pkt_free(struct sctp_packet *packet)
{
	sctp_transport_free(packet->transport);
}
static void sctp_enter_memory_pressure(struct sock *sk)
{
	sctp_memory_pressure = 1;
}
SCTP_STATIC int sctp_setsockopt_connectx_old(struct sock* sk,
				      struct sockaddr __user *addrs,
				      int addrs_size)
{
	return __sctp_setsockopt_connectx(sk, addrs, addrs_size, NULL);
}
SCTP_STATIC int sctp_disconnect(struct sock *sk, int flags)
{
	return -EOPNOTSUPP; /* STUB */
}
SCTP_STATIC int sctp_ioctl(struct sock *sk, int cmd, unsigned long arg)
{
	return -ENOIOCTLCMD;
}
static inline size_t sctp_ssnmap_size(__u16 in, __u16 out)
{
	return sizeof(struct sctp_ssnmap) + (in + out) * sizeof(__u16);
}
void sctp_sysctl_register(void)
{
	sctp_sysctl_header = register_sysctl_paths(sctp_path, sctp_table);
}
void sctp_sysctl_unregister(void)
{
	unregister_sysctl_table(sctp_sysctl_header);
}
void sctp_transport_hold(struct sctp_transport *transport)
{
	atomic_inc(&transport->refcnt);
}
SCTP_STATIC void sctp_tsnmap_iter_init(const struct sctp_tsnmap *map,
				       struct sctp_tsnmap_iter *iter)
{
	iter->start = map->cumulative_tsn_ack_point + 1;
}
int sctp_ulpevent_is_notification(const struct sctp_ulpevent *event)
{
	return MSG_NOTIFICATION == (event->msg_flags & MSG_NOTIFICATION);
}
static __u16 sctp_ulpq_renege_order(struct sctp_ulpq *ulpq, __u16 needed)
{
	return sctp_ulpq_renege_list(ulpq, &ulpq->lobby, needed);
}
static __u16 sctp_ulpq_renege_frags(struct sctp_ulpq *ulpq, __u16 needed)
{
	return sctp_ulpq_renege_list(ulpq, &ulpq->reasm, needed);
}
static void sock_destroy_inode(struct inode *inode)
{
	kmem_cache_free(sock_inode_cachep,
			container_of(inode, struct socket_alloc, vfs_inode));
}
static int sockfs_get_sb(struct file_system_type *fs_type,
			 int flags, const char *dev_name, void *data,
			 struct vfsmount *mnt)
{
	return get_sb_pseudo(fs_type, "socket:", &sockfs_ops, SOCKFS_MAGIC,
			     mnt);
}
static char *sockfs_dname(struct dentry *dentry, char *buffer, int buflen)
{
	return dynamic_dname(dentry, buffer, buflen, "socket:[%lu]",
				dentry->d_inode->i_ino);
}
static int sock_no_open(struct inode *irrelevant, struct file *dontcare)
{
	return -ENXIO;
}
static void sock_aio_dtor(struct kiocb *iocb)
{
	kfree(iocb->private);
}
int sock_create(int family, int type, int protocol, struct socket **res)
{
	return __sock_create(current->nsproxy->net_ns, family, type, protocol, res, 0);
}
int sock_create_kern(int family, int type, int protocol, struct socket **res)
{
	return __sock_create(&init_net, family, type, protocol, res, 1);
}
asmlinkage long sys_recv(int fd, void __user *ubuf, size_t size,
			 unsigned flags)
{
	return sys_recvfrom(fd, ubuf, size, flags, NULL, NULL);
}
int kernel_bind(struct socket *sock, struct sockaddr *addr, int addrlen)
{
	return sock->ops->bind(sock, addr, addrlen);
}
int kernel_listen(struct socket *sock, int backlog)
{
	return sock->ops->listen(sock, backlog);
}
int kernel_connect(struct socket *sock, struct sockaddr *addr, int addrlen,
		   int flags)
{
	return sock->ops->connect(sock, addr, addrlen, flags);
}
int kernel_getsockname(struct socket *sock, struct sockaddr *addr,
			 int *addrlen)
{
	return sock->ops->getname(sock, addr, addrlen, 0);
}
int kernel_getpeername(struct socket *sock, struct sockaddr *addr,
			 int *addrlen)
{
	return sock->ops->getname(sock, addr, addrlen, 1);
}
int kernel_sock_shutdown(struct socket *sock, enum sock_shutdown_cmd how)
{
	return sock->ops->shutdown(sock, how);
}
void __exit rpcauth_remove_module(void)
{
	unregister_shrinker(&rpc_cred_shrinker);
}
struct rpc_cred *rpc_lookup_cred(void)
{
	return rpcauth_lookupcred(&generic_auth, 0);
}
static struct rpc_cred *
generic_lookup_cred(struct rpc_auth *auth, struct auth_cred *acred, int flags)
{
	return rpcauth_lookup_credcache(&generic_auth, acred, flags);
}
static void
generic_destroy_cred(struct rpc_cred *cred)
{
	call_rcu(&cred->cr_rcu, generic_free_cred_callback);
}
void __init rpc_init_generic_auth(void)
{
	spin_lock_init(&generic_cred_cache.lock);
}
void __exit rpc_destroy_generic_auth(void)
{
	rpcauth_clear_credcache(&generic_cred_cache);
}
static int gss_pipe_open_v0(struct inode *inode)
{
	return gss_pipe_open(inode, 0);
}
static int gss_pipe_open_v1(struct inode *inode)
{
	return gss_pipe_open(inode, 1);
}
static struct rpc_cred *
gss_lookup_cred(struct rpc_auth *auth, struct auth_cred *acred, int flags)
{
	return rpcauth_lookup_credcache(auth, acred, flags);
}
static int
gss_refresh_null(struct rpc_task *task)
{
	return -EACCES;
}
static void __exit cleanup_kerberos_module(void)
{
	gss_mech_unregister(&gss_kerberos_mech);
}
u32
gss_get_mic(struct gss_ctx	*context_handle,
	    struct xdr_buf	*message,
	    struct xdr_netobj	*mic_token)
{
	 return context_handle->mech_type->gm_ops
		->gss_get_mic(context_handle,
			      message,
			      mic_token);
}
u32
gss_verify_mic(struct gss_ctx		*context_handle,
	       struct xdr_buf		*message,
	       struct xdr_netobj	*mic_token)
{
	return context_handle->mech_type->gm_ops
		->gss_verify_mic(context_handle,
				 message,
				 mic_token);
}
u32
gss_wrap(struct gss_ctx	*ctx_id,
	 int		offset,
	 struct xdr_buf	*buf,
	 struct page	**inpages)
{
	return ctx_id->mech_type->gm_ops
		->gss_wrap(ctx_id, offset, buf, inpages);
}
u32
gss_unwrap(struct gss_ctx	*ctx_id,
	   int			offset,
	   struct xdr_buf	*buf)
{
	return ctx_id->mech_type->gm_ops
		->gss_unwrap(ctx_id, offset, buf);
}
static void __exit cleanup_spkm3_module(void)
{
	gss_mech_unregister(&gss_spkm3_mech);
}
static int netobj_equal(struct xdr_netobj *a, struct xdr_netobj *b)
{
	return a->len == b->len && 0 == memcmp(a->data, b->data, a->len);
}
static inline int rsi_hash(struct rsi *item)
{
	return hash_mem(item->in_handle.data, item->in_handle.len, RSI_HASHBITS)
	     ^ hash_mem(item->in_token.data, item->in_token.len, RSI_HASHBITS);
}
static inline int dup_netobj(struct xdr_netobj *dst, struct xdr_netobj *src)
{
	return dup_to_netobj(dst, src->data, src->len);
}
static inline int
rsc_hash(struct rsc *rsci)
{
	return hash_mem(rsci->handle.data, rsci->handle.len, RSC_HASHBITS);
}
static inline u32 round_up_to_quad(u32 i)
{
	return (i + 3 ) & ~3;
}
static inline int
total_buf_len(struct xdr_buf *buf)
{
	return buf->head[0].iov_len + buf->page_len + buf->tail[0].iov_len;
}
static struct rpc_cred *
nul_lookup_cred(struct rpc_auth *auth, struct auth_cred *acred, int flags)
{
	return get_rpccred(&null_cred);
}
static int
nul_match(struct auth_cred *acred, struct rpc_cred *cred, int taskflags)
{
	return 1;
}
static struct rpc_cred *
unx_lookup_cred(struct rpc_auth *auth, struct auth_cred *acred, int flags)
{
	return rpcauth_lookup_credcache(auth, acred, flags);
}
static void
unx_destroy_cred(struct rpc_cred *cred)
{
	call_rcu(&cred->cr_rcu, unx_free_cred_callback);
}
void __init rpc_init_authunix(void)
{
	spin_lock_init(&unix_cred_cache.lock);
}
static int create_cache_proc_entries(struct cache_detail *cd)
{
	return 0;
}
void
rpc_call_start(struct rpc_task *task)
{
	task->tk_action = call_start;
}
size_t rpc_max_payload(struct rpc_clnt *clnt)
{
	return clnt->cl_xprt->max_payload;
}
static inline int
rpc_task_need_encode(struct rpc_task *task)
{
	return task->tk_rqstp->rq_snd_buf.len == 0;
}
static inline void
rpc_task_force_reencode(struct rpc_task *task)
{
	task->tk_rqstp->rq_snd_buf.len = 0;
}
static int rpcproc_encode_null(void *rqstp, __be32 *data, void *obj)
{
	return 0;
}
static int rpcproc_decode_null(void *rqstp, __be32 *data, void *obj)
{
	return 0;
}
static void rpc_show_header(void)
{
	printk(KERN_INFO "-pid- flgs status -client- --rqstp- "
		"-timeout ---ops--\n");
}
static inline void
rpc_inode_setowner(struct inode *inode, void *private)
{
	RPC_I(inode)->private = private;
}
static void
rpc_destroy_inode(struct inode *inode)
{
	kmem_cache_free(rpc_inode_cachep, RPC_I(inode));
}
void rpc_put_mount(void)
{
	simple_release_fs(&rpc_mount, &rpc_mount_count);
}
static int rpc_delete_dentry(struct dentry *dentry)
{
	return 1;
}
static int
rpc_get_sb(struct file_system_type *fs_type,
		int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
	return get_sb_single(fs_type, flags, data, rpc_fill_super, mnt);
}
void rpc_init_priority_wait_queue(struct rpc_wait_queue *queue, const char *qname)
{
	__rpc_init_priority_wait_queue(queue, qname, RPC_NR_PRIORITY);
}
void rpc_init_wait_queue(struct rpc_wait_queue *queue, const char *qname)
{
	__rpc_init_priority_wait_queue(queue, qname, 1);
}
void rpc_destroy_wait_queue(struct rpc_wait_queue *queue)
{
	del_timer_sync(&queue->timer_list.timer);
}
static void rpc_wake_up_task(struct rpc_task *task)
{
	rpc_wake_up_queued_task(task->tk_waitqueue, task);
}
static void __rpc_atrun(struct rpc_task *task)
{
	task->tk_status = 0;
}
static void rpc_prepare_task(struct rpc_task *task)
{
	task->tk_ops->rpc_call_prepare(task, task->tk_calldata);
}
static void rpc_async_schedule(struct work_struct *work)
{
	__rpc_execute(container_of(work, struct rpc_task, u.tk_work));
}
static struct rpc_task *
rpc_alloc_task(void)
{
	return (struct rpc_task *)mempool_alloc(rpc_task_mempool, GFP_NOFS);
}
static void rpc_async_release(struct work_struct *work)
{
	rpc_free_task(container_of(work, struct rpc_task, u.tk_work));
}
int rpciod_up(void)
{
	return try_module_get(THIS_MODULE) ? 0 : -EINVAL;
}
void rpciod_down(void)
{
	module_put(THIS_MODULE);
}
static int rpc_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, rpc_proc_show, PDE(inode)->data);
}
void rpc_free_iostats(struct rpc_iostats *stats)
{
	kfree(stats);
}
struct proc_dir_entry *
rpc_proc_register(struct rpc_stat *statp)
{
	return do_register(statp->program->name, statp, &rpc_proc_fops);
}
void
rpc_proc_unregister(const char *name)
{
	remove_proc_entry(name, proc_net_rpc);
}
struct proc_dir_entry *
svc_proc_register(struct svc_stat *statp, const struct file_operations *fops)
{
	return do_register(statp->program->pg_name, statp, fops);
}
void
svc_proc_unregister(const char *name)
{
	remove_proc_entry(name, proc_net_rpc);
}
struct svc_serv *
svc_create(struct svc_program *prog, unsigned int bufsize,
		sa_family_t family, void (*shutdown)(struct svc_serv *serv))
{
	return __svc_create(prog, bufsize, /*npools*/1, family, shutdown);
}
void svc_xprt_put(struct svc_xprt *xprt)
{
	kref_put(&xprt->xpt_ref, svc_xprt_free);
}
char *svc_print_addr(struct svc_rqst *rqstp, char *buf, size_t len)
{
	return __svc_print_addr(svc_addr(rqstp), buf, len);
}
static void svc_thread_enqueue(struct svc_pool *pool, struct svc_rqst *rqstp)
{
	list_add(&rqstp->rq_list, &pool->sp_threads);
}
static void svc_thread_dequeue(struct svc_pool *pool, struct svc_rqst *rqstp)
{
	list_del(&rqstp->rq_list);
}
int svc_set_client(struct svc_rqst *rqstp)
{
	return rqstp->rq_authop->set_client(rqstp);
}
struct auth_domain *auth_domain_find(char *name)
{
	return auth_domain_lookup(name, NULL);
}
static inline int hash_ip6(struct in6_addr ip)
{
	return (hash_ip(ip.s6_addr32[0]) ^
		hash_ip(ip.s6_addr32[1]) ^
		hash_ip(ip.s6_addr32[2]) ^
		hash_ip(ip.s6_addr32[3]));
}
void svcauth_unix_purge(void)
{
	cache_purge(&ip_map_cache);
}
static struct svc_xprt *svc_udp_create(struct svc_serv *serv,
				       struct sockaddr *sa, int salen,
				       int flags)
{
	return svc_create_socket(serv, IPPROTO_UDP, sa, salen, flags);
}
static struct svc_xprt *svc_tcp_create(struct svc_serv *serv,
				       struct sockaddr *sa, int salen,
				       int flags)
{
	return svc_create_socket(serv, IPPROTO_TCP, sa, salen, flags);
}
__be32 *
xdr_encode_string(__be32 *p, const char *string)
{
	return xdr_encode_array(p, string, strlen(string));
}
void
xdr_shift_buf(struct xdr_buf *buf, size_t len)
{
	xdr_shrink_bufhead(buf, len);
}
void xprt_release_rqst_cong(struct rpc_task *task)
{
	__xprt_put_cong(task->tk_xprt, task->tk_rqstp);
}
void xprt_set_retrans_timeout_def(struct rpc_task *task)
{
	task->tk_timeout = task->tk_rqstp->rq_timeout;
}
void xprt_end_transmit(struct rpc_task *task)
{
	xprt_release_write(task->tk_xprt, task);
}
static inline __be32 xprt_alloc_xid(struct rpc_xprt *xprt)
{
	return xprt->xid++;
}
static inline void xprt_init_xid(struct rpc_xprt *xprt)
{
	xprt->xid = net_random();
}
void xprt_put(struct rpc_xprt *xprt)
{
	kref_put(&xprt->kref, xprt_destroy);
}
static void
rpcrdma_unbind_func(struct rpcrdma_rep *rep)
{
	wake_up(&rep->rr_unbind);
}
static int rdma_read_max_sge(struct svcxprt_rdma *xprt, int sge_count)
{
	if ((RDMA_TRANSPORT_IWARP ==
	     rdma_node_get_transport(xprt->sc_cm_id->
				     device->node_type))
	    && sge_count > 1)
		return 1;
	else
		return min_t(int, sge_count, xprt->sc_max_sge);
}
static void *xdr_start(struct xdr_buf *xdr)
{
	return xdr->head[0].iov_base -
		(xdr->len -
		 xdr->page_len -
		 xdr->tail[0].iov_len -
		 xdr->head[0].iov_len);
}
void svc_rdma_put_req_map(struct svc_rdma_req_map *map)
{
	kmem_cache_free(svc_rdma_map_cachep, map);
}
static inline struct sockaddr *xs_addr(struct rpc_xprt *xprt)
{
	return (struct sockaddr *) &xprt->addr;
}
static inline struct sockaddr_in *xs_addr_in(struct rpc_xprt *xprt)
{
	return (struct sockaddr_in *) &xprt->addr;
}
static inline struct sockaddr_in6 *xs_addr_in6(struct rpc_xprt *xprt)
{
	return (struct sockaddr_in6 *) &xprt->addr;
}
static inline struct rpc_xprt *xprt_from_sock(struct sock *sk)
{
	return (struct rpc_xprt *) sk->sk_user_data;
}
static void xs_udp_timer(struct rpc_task *task)
{
	xprt_adjust_cwnd(task, -ETIMEDOUT);
}
static struct ctl_table_set *
net_ctl_header_lookup(struct ctl_table_root *root, struct nsproxy *namespaces)
{
	return &namespaces->net_ns->sysctls;
}
static int is_seen(struct ctl_table_set *set)
{
	return &current->nsproxy->net_ns->sysctls == set;
}
static int net_ctl_ro_header_perms(struct ctl_table_root *root,
		struct nsproxy *namespaces, struct ctl_table *table)
{
	if (namespaces->net_ns == &init_net)
		return table->mode;
	else
		return table->mode & ~0222;
}
struct ctl_table_header *register_net_sysctl_rotable(const
		struct ctl_path *path, struct ctl_table *table)
{
	return __register_sysctl_paths(&net_sysctl_ro_root,
			&init_nsproxy, path, table);
}
void unregister_net_sysctl_table(struct ctl_table_header *header)
{
	unregister_sysctl_table(header);
}
u32 tipc_get_addr(void)
{
	return tipc_own_addr;
}
int tipc_addr_node_valid(u32 addr)
{
	return (tipc_addr_domain_valid(addr) && tipc_node(addr));
}
static u32 buf_seqno(struct sk_buff *buf)
{
	return msg_seqno(buf_msg(buf));
}
static u32 bcbuf_acks(struct sk_buff *buf)
{
	return (u32)(unsigned long)TIPC_SKB_CB(buf)->handle;
}
static void bcbuf_set_acks(struct sk_buff *buf, u32 acks)
{
	TIPC_SKB_CB(buf)->handle = (void *)(unsigned long)acks;
}
static void bcbuf_decr_acks(struct sk_buff *buf)
{
	bcbuf_set_acks(buf, bcbuf_acks(buf) - 1);
}
static int bclink_ack_allowed(u32 n)
{
	return((n % TIPC_MIN_LINK_WIN) == tipc_own_tag);
}
u32 tipc_bclink_acks_missing(struct tipc_node *n_ptr)
{
	return (n_ptr->bclink.supported &&
		(tipc_bclink_get_last_sent() != n_ptr->bclink.acked));
}
static void tipc_bearer_schedule_unlocked(struct bearer *b_ptr, struct link *l_ptr)
{
	list_move_tail(&l_ptr->link_list, &b_ptr->cong_links);
}
int tipc_get_mode(void)
{
	return tipc_mode;
}
int tipc_printbuf_empty(struct print_buf *pb)
{
	return (!pb->buf || (pb->crs == pb->buf));
}
static void disable_bearer(struct tipc_bearer *tb_ptr)
{
	((struct eth_bearer *)tb_ptr->usr_handle)->bearer = NULL;
}
static unsigned int align(unsigned int i)
{
	return (i + 3) & ~3u;
}
static int link_working_working(struct link *l_ptr)
{
	return (l_ptr->state == WORKING_WORKING);
}
static int link_working_unknown(struct link *l_ptr)
{
	return (l_ptr->state == WORKING_UNKNOWN);
}
static int link_reset_unknown(struct link *l_ptr)
{
	return (l_ptr->state == RESET_UNKNOWN);
}
static int link_reset_reset(struct link *l_ptr)
{
	return (l_ptr->state == RESET_RESET);
}
static int link_blocked(struct link *l_ptr)
{
	return (l_ptr->exp_msg_count || l_ptr->blocked);
}
static int link_congested(struct link *l_ptr)
{
	return (l_ptr->out_queue_size >= l_ptr->queue_limit[0]);
}
static u32 link_max_pkt(struct link *l_ptr)
{
	return l_ptr->max_pkt;
}
static u32 link_last_sent(struct link *l_ptr)
{
	return mod(link_next_sent(l_ptr) - 1);
}
int tipc_link_is_active(struct link *l_ptr)
{
	return ((l_ptr->owner->active_links[0] == l_ptr) ||
		(l_ptr->owner->active_links[1] == l_ptr));
}
static void link_set_timer(struct link *l_ptr, u32 time)
{
	k_start_timer(&l_ptr->timer, time);
}
static void set_long_msg_seqno(struct sk_buff *buf, u32 seqno)
{
	msg_set_seqno(buf_msg(buf), seqno);
}
static u32 get_fragm_size(struct sk_buff *buf)
{
	return msg_ack(buf_msg(buf));
}
static void set_fragm_size(struct sk_buff *buf, u32 sz)
{
	msg_set_ack(buf_msg(buf), sz);
}
static u32 get_expected_frags(struct sk_buff *buf)
{
	return msg_bcast_ack(buf_msg(buf));
}
static void set_expected_frags(struct sk_buff *buf, u32 exp)
{
	msg_set_bcast_ack(buf_msg(buf), exp);
}
static u32 get_timer_cnt(struct sk_buff *buf)
{
	return msg_reroute_cnt(buf_msg(buf));
}
static void incr_timer_cnt(struct sk_buff *buf)
{
	msg_incr_reroute_cnt(buf_msg(buf));
}
static u32 percent(u32 count, u32 total)
{
	return (count * 100 + (total / 2)) / total;
}
static int hash(int x)
{
	return(x & (tipc_nametbl_size - 1));
}
struct tipc_node *tipc_net_select_remote_node(u32 addr, u32 ref)
{
	return tipc_zone_select_remote_node(tipc_net.zones[tipc_zone(addr)], addr, ref);
}
u32 tipc_net_select_router(u32 addr, u32 ref)
{
	return tipc_zone_select_router(tipc_net.zones[tipc_zone(addr)], addr, ref);
}
int tipc_node_has_active_links(struct tipc_node *n_ptr)
{
	return (n_ptr &&
		((n_ptr->active_links[0]) || (n_ptr->active_links[1])));
}
int tipc_node_has_redundant_links(struct tipc_node *n_ptr)
{
	return (n_ptr->working_links > 1);
}
static int tipc_node_has_active_routes(struct tipc_node *n_ptr)
{
	return (n_ptr && (n_ptr->last_router >= 0));
}
int tipc_node_is_up(struct tipc_node *n_ptr)
{
	return (tipc_node_has_active_links(n_ptr) || tipc_node_has_active_routes(n_ptr));
}
static u32 port_peernode(struct port *p_ptr)
{
	return msg_destnode(&p_ptr->publ.phdr);
}
static u32 port_peerport(struct port *p_ptr)
{
	return msg_destport(&p_ptr->publ.phdr);
}
static u32 port_out_seqno(struct port *p_ptr)
{
	return msg_transp_seqno(&p_ptr->publ.phdr);
}
struct tipc_port *tipc_get_port(const u32 ref)
{
	return (struct tipc_port *)tipc_ref_deref(ref);
}
static int port_unreliable(struct port *p_ptr)
{
	return msg_src_droppable(&p_ptr->publ.phdr);
}
static int port_unreturnable(struct port *p_ptr)
{
	return msg_dest_droppable(&p_ptr->publ.phdr);
}
static void port_wakeup(struct tipc_port *p_ptr)
{
	tipc_k_signal((Handler)port_wakeup_sh, p_ptr->ref);
}
int tipc_ref_valid(u32 ref)
{
	return !!tipc_ref_deref(ref);
}
static u32 htohl(u32 in, int swap)
{
	return swap ? swab32(in) : in;
}
static void unix_get_secdata(struct scm_cookie *scm, struct sk_buff *skb)
{
	memcpy(UNIXSID(skb), &scm->secid, sizeof(u32));
}
static inline void unix_set_secdata(struct scm_cookie *scm, struct sk_buff *skb)
{
	scm->secid = *UNIXSID(skb);
}
static inline int unix_our_peer(struct sock *sk, struct sock *osk)
{
	return unix_peer(osk) == sk;
}
static inline int unix_may_send(struct sock *sk, struct sock *osk)
{
	return unix_peer(osk) == NULL || unix_our_peer(sk, osk);
}
static inline int unix_recvq_full(struct sock const *sk)
{
	return skb_queue_len(&sk->sk_receive_queue) > sk->sk_max_ack_backlog;
}
static void __unix_remove_socket(struct sock *sk)
{
	sk_del_node_init(sk);
}
static inline int unix_writable(struct sock *sk)
{
	return (atomic_read(&sk->sk_wmem_alloc) << 2) <= sk->sk_sndbuf;
}
static void unix_seq_stop(struct seq_file *seq, void *v)
{
	spin_unlock(&unix_table_lock);
}
static int unix_seq_open(struct inode *inode, struct file *file)
{
	return seq_open_net(inode, file, &unix_seq_ops,
			    sizeof(struct unix_iter_state));
}
static inline struct sk_buff *sock_queue_head(struct sock *sk)
{
	return (struct sk_buff *)&sk->sk_receive_queue;
}
static void dec_inflight(struct unix_sock *usk)
{
	atomic_long_dec(&usk->inflight);
}
static void inc_inflight(struct unix_sock *usk)
{
	atomic_long_inc(&usk->inflight);
}
void wait_for_unix_gc(void)
{
	wait_event(unix_gc_wait, gc_in_progress == false);
}
static void __exit wanrouter_cleanup (void)
{
	wanrouter_proc_cleanup();
}
static void lock_adapter_irq(spinlock_t *lock, unsigned long *smp_flags)
{
	spin_lock_irqsave(lock, *smp_flags);
}
static void unlock_adapter_irq(spinlock_t *lock, unsigned long *smp_flags)
{
	spin_unlock_irqrestore(lock, *smp_flags);
}
static void r_stop(struct seq_file *m, void *v)
{
	unlock_kernel();
}
static int config_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &config_op);
}
static int status_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &status_op);
}
static int wandev_open(struct inode *inode, struct file *file)
{
	return single_open(file, wandev_show, PDE(inode)->data);
}
int __init wanrouter_proc_init(void)
{
	return 0;
}
int wanrouter_proc_add(struct wan_device *wandev)
{
	return 0;
}
int wanrouter_proc_delete(struct wan_device *wandev)
{
	return 0;
}
void wimax_debugfs_rm(struct wimax_dev *wimax_dev)
{
	debugfs_remove_recursive(wimax_dev->debugfs_dentry);
}
int wimax_rfkill(struct wimax_dev *wimax_dev,
		 enum wimax_rf_state state)
{
	return WIMAX_RF_ON << 1 | WIMAX_RF_ON;
}
int wimax_rfkill_add(struct wimax_dev *wimax_dev)
{
	return 0;
}
void wiphy_free(struct wiphy *wiphy)
{
	put_device(&wiphy->dev);
}
static void *lib80211_crypt_null_init(int keyidx)
{
	return (void *)1;
}
static inline void lib80211_ccmp_aes_encrypt(struct crypto_cipher *tfm,
					      const u8 pt[16], u8 ct[16])
{
	crypto_cipher_encrypt_one(tfm, ct, pt);
}
static int __init lib80211_crypto_ccmp_init(void)
{
	return lib80211_register_crypto_ops(&lib80211_crypt_ccmp);
}
static void __exit lib80211_crypto_ccmp_exit(void)
{
	lib80211_unregister_crypto_ops(&lib80211_crypt_ccmp);
}
static inline u16 RotR1(u16 val)
{
	return (val >> 1) | (val << 15);
}
static inline u8 Lo8(u16 val)
{
	return val & 0xff;
}
static inline u8 Hi8(u16 val)
{
	return val >> 8;
}
static inline u16 Lo16(u32 val)
{
	return val & 0xffff;
}
static inline u16 Hi16(u32 val)
{
	return val >> 16;
}
static inline u16 Mk16(u8 hi, u8 lo)
{
	return lo | (((u16) hi) << 8);
}
static inline u16 Mk16_le(__le16 * v)
{
	return le16_to_cpu(*v);
}
static int __init lib80211_crypto_tkip_init(void)
{
	return lib80211_register_crypto_ops(&lib80211_crypt_tkip);
}
static void __exit lib80211_crypto_tkip_exit(void)
{
	lib80211_unregister_crypto_ops(&lib80211_crypt_tkip);
}
static int __init lib80211_crypto_wep_init(void)
{
	return lib80211_register_crypto_ops(&lib80211_crypt_wep);
}
static void __exit lib80211_crypto_wep_exit(void)
{
	lib80211_unregister_crypto_ops(&lib80211_crypt_wep);
}
static inline void *nl80211hdr_put(struct sk_buff *skb, u32 pid, u32 seq,
				   int flags, u8 cmd)
{
	return genlmsg_put(skb, pid, seq, &nl80211_fam, flags, cmd);
}
void nl80211_exit(void)
{
	genl_unregister_family(&nl80211_fam);
}
static inline bool is_old_static_regdom(const struct ieee80211_regdomain *rd)
{
	return false;
}
int freq_reg_info(struct wiphy *wiphy, u32 center_freq, u32 *bandwidth,
			 const struct ieee80211_reg_rule **reg_rule)
{
	return freq_reg_info_regd(wiphy, center_freq,
		bandwidth, reg_rule, NULL);
}
static inline struct cfg80211_registered_device *dev_to_rdev(
	struct device *dev)
{
	return container_of(dev, struct cfg80211_registered_device, wiphy.dev);
}
static ssize_t name ## _show(struct device *dev,			\
			      struct device_attribute *attr,		\
			      char *buf)				\
{									\
	return sprintf(buf, fmt "\n", dev_to_rdev(dev)->member);	\
}
static int wiphy_uevent(struct device *dev, struct kobj_uevent_env *env)
{
	return 0;
}
int wiphy_sysfs_init(void)
{
	return class_register(&ieee80211_class);
}
void wiphy_sysfs_exit(void)
{
	class_unregister(&ieee80211_class);
}
static int call_commit_handler(struct net_device *dev)
{
	if ((netif_running(dev)) &&
	   (dev->wireless_handlers->standard[0] != NULL))
		return dev->wireless_handlers->standard[0](dev, NULL,
							   NULL, NULL);
	else
		return 0;		/* Command completed successfully */
}
static int wireless_seq_open(struct inode *inode, struct file *file)
{
	return seq_open_net(inode, file, &wireless_seq_ops,
			    sizeof(struct seq_net_private));
}
void wext_proc_exit(struct net *net)
{
	proc_net_remove(net, "wireless");
}
static void x25_destroy_timer(unsigned long data)
{
	x25_destroy_socket((struct sock *)data);
}
void __init x25_register_sysctl(void)
{
	x25_table_header = register_sysctl_paths(x25_path, x25_table);
}
void x25_unregister_sysctl(void)
{
	unregister_sysctl_table(x25_table_header);
}
static inline void x25_start_t20timer(struct x25_neigh *nb)
{
	mod_timer(&nb->t20timer, jiffies + nb->t20);
}
static inline void x25_stop_t20timer(struct x25_neigh *nb)
{
	del_timer(&nb->t20timer);
}
static inline int x25_t20timer_pending(struct x25_neigh *nb)
{
	return timer_pending(&nb->t20timer);
}
static void x25_seq_route_stop(struct seq_file *seq, void *v)
{
	read_unlock_bh(&x25_route_list_lock);
}
static void x25_seq_socket_stop(struct seq_file *seq, void *v)
{
	read_unlock_bh(&x25_list_lock);
}
static void x25_seq_forward_stop(struct seq_file *seq, void *v)
{
	read_unlock_bh(&x25_forward_list_lock);
}
static int x25_seq_socket_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &x25_seq_socket_ops);
}
static int x25_seq_route_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &x25_seq_route_ops);
}
static int x25_seq_forward_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &x25_seq_forward_ops);
}
int __init x25_proc_init(void)
{
	return 0;
}
void x25_start_heartbeat(struct sock *sk)
{
	mod_timer(&sk->sk_timer, jiffies + 5 * HZ);
}
void x25_stop_heartbeat(struct sock *sk)
{
	del_timer(&sk->sk_timer);
}
void x25_stop_timer(struct sock *sk)
{
	del_timer(&x25_sk(sk)->timer);
}
static inline int aead_entries(void)
{
	return ARRAY_SIZE(aead_list);
}
static inline int aalg_entries(void)
{
	return ARRAY_SIZE(aalg_list);
}
static inline int ealg_entries(void)
{
	return ARRAY_SIZE(ealg_list);
}
static inline int calg_entries(void)
{
	return ARRAY_SIZE(calg_list);
}
static int xfrm_alg_id_match(const struct xfrm_algo_desc *entry,
			     const void *data)
{
	return entry->desc.sadb_alg_id == (unsigned long)data;
}
struct xfrm_algo_desc *xfrm_aalg_get_byid(int alg_id)
{
	return xfrm_find_algo(&xfrm_aalg_list, xfrm_alg_id_match,
			      (void *)(unsigned long)alg_id, 1);
}
struct xfrm_algo_desc *xfrm_ealg_get_byid(int alg_id)
{
	return xfrm_find_algo(&xfrm_ealg_list, xfrm_alg_id_match,
			      (void *)(unsigned long)alg_id, 1);
}
struct xfrm_algo_desc *xfrm_calg_get_byid(int alg_id)
{
	return xfrm_find_algo(&xfrm_calg_list, xfrm_alg_id_match,
			      (void *)(unsigned long)alg_id, 1);
}
struct xfrm_algo_desc *xfrm_aalg_get_byname(char *name, int probe)
{
	return xfrm_find_algo(&xfrm_aalg_list, xfrm_alg_name_match, name,
			      probe);
}
struct xfrm_algo_desc *xfrm_ealg_get_byname(char *name, int probe)
{
	return xfrm_find_algo(&xfrm_ealg_list, xfrm_alg_name_match, name,
			      probe);
}
struct xfrm_algo_desc *xfrm_calg_get_byname(char *name, int probe)
{
	return xfrm_find_algo(&xfrm_calg_list, xfrm_alg_name_match, name,
			      probe);
}
int xfrm_input_resume(struct sk_buff *skb, int nexthdr)
{
	return xfrm_input(skb, nexthdr, 0, -1);
}
void __init xfrm_input_init(void)
{
	secpath_cachep = kmem_cache_create("secpath_cache",
					   sizeof(struct sec_path),
					   0, SLAB_HWCACHE_ALIGN|SLAB_PANIC,
					   NULL);
}
static int xfrm_output2(struct sk_buff *skb)
{
	return xfrm_output_resume(skb, 1);
}
static inline int
__xfrm4_selector_match(struct xfrm_selector *sel, struct flowi *fl)
{
	return  addr_match(&fl->fl4_dst, &sel->daddr, sel->prefixlen_d) &&
		addr_match(&fl->fl4_src, &sel->saddr, sel->prefixlen_s) &&
		!((xfrm_flowi_dport(fl) ^ sel->dport) & sel->dport_mask) &&
		!((xfrm_flowi_sport(fl) ^ sel->sport) & sel->sport_mask) &&
		(fl->proto == sel->proto || !sel->proto) &&
		(fl->oif == sel->ifindex || !sel->ifindex);
}
static inline int
__xfrm6_selector_match(struct xfrm_selector *sel, struct flowi *fl)
{
	return  addr_match(&fl->fl6_dst, &sel->daddr, sel->prefixlen_d) &&
		addr_match(&fl->fl6_src, &sel->saddr, sel->prefixlen_s) &&
		!((xfrm_flowi_dport(fl) ^ sel->dport) & sel->dport_mask) &&
		!((xfrm_flowi_sport(fl) ^ sel->sport) & sel->sport_mask) &&
		(fl->proto == sel->proto || !sel->proto) &&
		(fl->oif == sel->ifindex || !sel->ifindex);
}
static inline unsigned long make_jiffies(long secs)
{
	if (secs >= (MAX_SCHEDULE_TIMEOUT-1)/HZ)
		return MAX_SCHEDULE_TIMEOUT-1;
	else
		return secs*HZ;
}
static inline unsigned int idx_hash(struct net *net, u32 index)
{
	return __idx_hash(index, net->xfrm.policy_idx_hmask);
}
static unsigned long xfrm_new_hash_mask(unsigned int old_hmask)
{
	return ((old_hmask + 1) << 1) - 1;
}
static inline int
xfrm_policy_flush_secctx_check(struct net *net, u8 type, struct xfrm_audit *audit_info)
{
	return 0;
}
static int stale_bundle(struct dst_entry *dst)
{
	return !xfrm_bundle_ok(NULL, (struct xfrm_dst *)dst, NULL, AF_UNSPEC, 0);
}
static void xfrm_link_failure(struct sk_buff *skb)
{
	return;
}
static int unused_bundle(struct dst_entry *dst)
{
	return !atomic_read(&dst->__refcnt);
}
static void __xfrm_garbage_collect(struct net *net)
{
	xfrm_prune_bundles(net, unused_bundle);
}
static void xfrm_policy_put_afinfo(struct xfrm_policy_afinfo *afinfo)
{
	read_unlock(&xfrm_policy_afinfo_lock);
}
static int xfrm_statistics_seq_open(struct inode *inode, struct file *file)
{
	return single_open_net(inode, file, xfrm_statistics_seq_show);
}
void xfrm_proc_fini(struct net *net)
{
	proc_net_remove(net, "xfrm_stat");
}
static inline unsigned int xfrm_dst_hash(struct net *net,
					 xfrm_address_t *daddr,
					 xfrm_address_t *saddr,
					 u32 reqid,
					 unsigned short family)
{
	return __xfrm_dst_hash(daddr, saddr, reqid, family, net->xfrm.state_hmask);
}
static inline unsigned int xfrm_src_hash(struct net *net,
					 xfrm_address_t *daddr,
					 xfrm_address_t *saddr,
					 unsigned short family)
{
	return __xfrm_src_hash(daddr, saddr, family, net->xfrm.state_hmask);
}
static inline unsigned int
xfrm_spi_hash(struct net *net, xfrm_address_t *daddr, __be32 spi, u8 proto, unsigned short family)
{
	return __xfrm_spi_hash(daddr, spi, proto, family, net->xfrm.state_hmask);
}
static unsigned long xfrm_hash_new_size(unsigned int state_hmask)
{
	return ((state_hmask + 1) << 1) * sizeof(struct hlist_head);
}
static void xfrm_state_unlock_afinfo(struct xfrm_state_afinfo *afinfo)
{
	write_unlock_bh(&xfrm_state_afinfo_lock);
}
static void xfrm_put_type(const struct xfrm_type *type)
{
	module_put(type->owner);
}
static void xfrm_put_mode(struct xfrm_mode *mode)
{
	module_put(mode->owner);
}
static inline unsigned long make_jiffies(long secs)
{
	if (secs >= (MAX_SCHEDULE_TIMEOUT-1)/HZ)
		return MAX_SCHEDULE_TIMEOUT-1;
	else
		return secs*HZ;
}
static inline int
xfrm_state_flush_secctx_check(struct net *net, u8 proto, struct xfrm_audit *audit_info)
{
	return 0;
}
static void xfrm_state_put_afinfo(struct xfrm_state_afinfo *afinfo)
{
	read_unlock(&xfrm_state_afinfo_lock);
}
static inline int aead_len(struct xfrm_algo_aead *alg)
{
	return sizeof(*alg) + ((alg->alg_key_len + 7) / 8);
}
static inline size_t xfrm_spdinfo_msgsize(void)
{
	return NLMSG_ALIGN(4)
	       + nla_total_size(sizeof(struct xfrmu_spdinfo))
	       + nla_total_size(sizeof(struct xfrmu_spdhinfo));
}
static inline size_t xfrm_sadinfo_msgsize(void)
{
	return NLMSG_ALIGN(4)
	       + nla_total_size(sizeof(struct xfrmu_sadhinfo))
	       + nla_total_size(4); /* XFRMA_SAD_CNT */
}
static inline size_t userpolicy_type_attrsize(void)
{
	return nla_total_size(sizeof(struct xfrm_userpolicy_type));
}
static inline int copy_to_user_policy_type(u8 type, struct sk_buff *skb)
{
	return 0;
}
static inline size_t xfrm_aevent_msgsize(void)
{
	return NLMSG_ALIGN(sizeof(struct xfrm_aevent_id))
	       + nla_total_size(sizeof(struct xfrm_replay_state))
	       + nla_total_size(sizeof(struct xfrm_lifetime_cur))
	       + nla_total_size(4) /* XFRM_AE_RTHR */
	       + nla_total_size(4); /* XFRM_AE_ETHR */
}
static int xfrm_do_migrate(struct sk_buff *skb, struct nlmsghdr *nlh,
			   struct nlattr **attrs)
{
	return -ENOPROTOOPT;
}
static inline size_t xfrm_migrate_msgsize(int num_migrate, int with_kma)
{
	return NLMSG_ALIGN(sizeof(struct xfrm_userpolicy_id))
	      + (with_kma ? nla_total_size(sizeof(struct xfrm_kmaddress)) : 0)
	      + nla_total_size(sizeof(struct xfrm_user_migrate) * num_migrate)
	      + userpolicy_type_attrsize();
}
static int xfrm_send_migrate(struct xfrm_selector *sel, u8 dir, u8 type,
			     struct xfrm_migrate *m, int num_migrate,
			     struct xfrm_kmaddress *k)
{
	return -ENOPROTOOPT;
}
static inline size_t xfrm_expire_msgsize(void)
{
	return NLMSG_ALIGN(sizeof(struct xfrm_user_expire));
}
static inline size_t xfrm_acquire_msgsize(struct xfrm_state *x,
					  struct xfrm_policy *xp)
{
	return NLMSG_ALIGN(sizeof(struct xfrm_user_acquire))
	       + nla_total_size(sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr)
	       + nla_total_size(xfrm_user_sec_ctx_size(x->security))
	       + userpolicy_type_attrsize();
}
static inline size_t xfrm_polexpire_msgsize(struct xfrm_policy *xp)
{
	return NLMSG_ALIGN(sizeof(struct xfrm_user_polexpire))
	       + nla_total_size(sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr)
	       + nla_total_size(xfrm_user_sec_ctx_size(xp->security))
	       + userpolicy_type_attrsize();
}
static inline size_t xfrm_report_msgsize(void)
{
	return NLMSG_ALIGN(sizeof(struct xfrm_user_report));
}
static inline size_t xfrm_mapping_msgsize(void)
{
	return NLMSG_ALIGN(sizeof(struct xfrm_user_mapping));
}
static inline struct class_device *to_class_dev(struct kobject *obj)
{
	return container_of(obj, struct class_device, kobj);
}
static inline
struct class_device_attribute *to_class_dev_attr(struct attribute *_attr)
{
	return container_of(_attr, struct class_device_attribute, attr);
}
static ssize_t foo_show(struct kobject *kobj, struct kobj_attribute *attr,
			char *buf)
{
	return sprintf(buf, "%d\n", foo);
}
static void __exit example_exit(void)
{
	kobject_put(example_kobj);
}
static ssize_t foo_show(struct foo_obj *foo_obj, struct foo_attribute *attr,
			char *buf)
{
	return sprintf(buf, "%d\n", foo_obj->foo);
}
static void destroy_foo_obj(struct foo_obj *foo)
{
	kobject_put(&foo->kobj);
}
void probe_subsystem_eventb(void *probe_data, void *call_data,
	const char *format, va_list *args)
{
	atomic_inc(&eventb_count);
}
static void probe_subsys_eventb(void)
{
	printk(KERN_INFO "Event B is encountered\n");
}
static void probe_subsys_event(struct inode *inode, struct file *file)
{
	printk(KERN_INFO "Event is encountered with inode number %lu\n",
		inode->i_ino);
}
void adddep(char * file)		   { printf("\t%s", file); }
void noaction(char * line)		   { line = line; }
void printline(char * line)               { printf("%s", line); }
void intfunc(char * filename) {	docfunctions(filename, NOFUNCTION); }
void extfunc(char * filename) { docfunctions(filename, FUNCTION);   }
void print_cmdline(void)
{
	printf("cmd_%s := %s\n\n", target, cmdline);
}
YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
{
	return yy_scan_bytes(yystr,strlen(yystr) );
}
int yyget_lineno  (void)
{
    return yylineno;
}
FILE *yyget_in  (void)
{
        return yyin;
}
FILE *yyget_out  (void)
{
        return yyout;
}
int yyget_leng  (void)
{
        return yyleng;
}
char *yyget_text  (void)
{
        return yytext;
}
void yyset_lineno (int  line_number )
{
    yylineno = line_number;
}
void yyset_in (FILE *  in_str )
{
        yyin = in_str ;
}
void yyset_out (FILE *  out_str )
{
        yyout = out_str ;
}
int yyget_debug  (void)
{
        return yy_flex_debug;
}
void yyset_debug (int  bdebug )
{
        yy_flex_debug = bdebug ;
}
void *yyalloc (yy_size_t  size )
{
	return (void *) malloc( size );
}
void *yyrealloc  (void * ptr, yy_size_t  size )
{
	return (void *) realloc( (char *) ptr, size );
}
void yyfree (void * ptr )
{
	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
}
static int
YYID (int i)
{
  return i;
}
static void
yyerror(const char *e)
{
  error_with_pos("%s", e);
}
static const char *get_help(struct menu *menu)
{
	if (menu_has_help(menu))
		return _(menu_get_help(menu));
	else
		return nohelp_text;
}
void sym_add_change_count(int count)
{
	sym_set_change_count(count + sym_change_count);
}
bool conf_get_changed(void)
{
	return sym_change_count;
}
void conf_set_changed_callback(void (*fn)(void))
{
	conf_changed_callback = fn;
}
static void expr_print_file_helper(void *data, struct symbol *sym, const char *str)
{
	fwrite(str, strlen(str), 1, data);
}
void expr_fprint(struct expr *e, FILE *out)
{
	expr_print(e, expr_print_file_helper, out, E_NONE);
}
static void expr_print_gstr_helper(void *data, struct symbol *sym, const char *str)
{
	str_append((struct gstr*)data, str);
}
void expr_gstr_print(struct expr *e, struct gstr *gs)
{
	expr_print(e, expr_print_gstr_helper, gs, E_NONE);
}
void on_window1_destroy(GtkObject * object, gpointer user_data)
{
	gtk_main_quit();
}
void on_load_clicked(GtkButton * button, gpointer user_data)
{
	on_load1_activate(NULL, user_data);
}
void on_collapse_clicked(GtkButton * button, gpointer user_data)
{
	gtk_tree_view_collapse_all(GTK_TREE_VIEW(tree2_w));
}
void on_expand_clicked(GtkButton * button, gpointer user_data)
{
	gtk_tree_view_expand_all(GTK_TREE_VIEW(tree2_w));
}
YY_BUFFER_STATE zconf_scan_string (yyconst char * yystr )
{
	return zconf_scan_bytes(yystr,strlen(yystr) );
}
int zconfget_lineno  (void)
{
    return zconflineno;
}
FILE *zconfget_in  (void)
{
        return zconfin;
}
FILE *zconfget_out  (void)
{
        return zconfout;
}
int zconfget_leng  (void)
{
        return zconfleng;
}
char *zconfget_text  (void)
{
        return zconftext;
}
void zconfset_lineno (int  line_number )
{
    zconflineno = line_number;
}
void zconfset_in (FILE *  in_str )
{
        zconfin = in_str ;
}
void zconfset_out (FILE *  out_str )
{
        zconfout = out_str ;
}
int zconfget_debug  (void)
{
        return zconf_flex_debug;
}
void zconfset_debug (int  bdebug )
{
        zconf_flex_debug = bdebug ;
}
void *zconfalloc (yy_size_t  size )
{
	return (void *) malloc( size );
}
void *zconfrealloc  (void * ptr, yy_size_t  size )
{
	return (void *) realloc( (char *) ptr, size );
}
void zconffree (void * ptr )
{
	free( (char *) ptr );	/* see zconfrealloc() for (char *) cast */
}
int zconf_lineno(void)
{
	return current_pos.lineno;
}
char *zconf_curname(void)
{
	return current_pos.file ? current_pos.file->name : "<none>";
}
void set_dialog_backtitle(const char *backtitle)
{
	dlg.backtitle = backtitle;
}
void item_set_tag(char tag)
{
	item_cur->node.tag = tag;
}
void item_set_data(void *ptr)
{
	item_cur->node.data = ptr;
}
void item_set_selected(int val)
{
	item_cur->node.selected = val;
}
void *item_data(void)
{
	return item_cur->node.data;
}
char item_tag(void)
{
	return item_cur->node.tag;
}
const char *item_str(void)
{
	return item_cur->node.str;
}
int item_is_selected(void)
{
	return (item_cur->node.selected != 0);
}
int item_is_tag(char tag)
{
	return (item_cur->node.tag == tag);
}
static void show_helptext(const char *title, const char *text)
{
	show_textbox(title, text, 0, 0);
}
void menu_add_dep(struct expr *dep)
{
	current_entry->dep = expr_alloc_and(current_entry->dep, menu_check_dep(dep));
}
struct property *menu_add_prompt(enum prop_type type, char *prompt, struct expr *dep)
{
	return menu_add_prop(type, prompt, NULL, dep);
}
void menu_add_expr(enum prop_type type, struct expr *expr, struct expr *dep)
{
	menu_add_prop(type, NULL, expr, dep);
}
void menu_add_symbol(enum prop_type type, struct symbol *sym, struct expr *dep)
{
	menu_add_prop(type, NULL, expr_alloc_symbol(sym), dep);
}
static int menu_range_valid_sym(struct symbol *sym, struct symbol *sym2)
{
	return sym2->type == S_INT || sym2->type == S_HEX ||
	       (sym2->type == S_UNKNOWN && sym_string_valid(sym, sym2->name));
}
struct menu *menu_get_root_menu(struct menu *menu)
{
	return &rootmenu;
}
bool menu_has_help(struct menu *menu)
{
	return menu->help != NULL;
}
const char *menu_get_help(struct menu *menu)
{
	if (menu->help)
		return menu->help;
	else
		return "";
}
bool sym_is_changable(struct symbol *sym)
{
	return sym->visible > sym->rev_dep.tri;
}
const char *str_get(struct gstr *gs)
{
	return gs->s;
}
static int
YYID (int i)
{
  return i;
}
static void zconferror(const char *err)
{
	fprintf(stderr, "%s:%d: %s\n", zconf_curname(), zconf_lineno() + 1, err);
}
static const char *export_str(enum export ex)
{
	return export_list[ex].str;
}
static enum export export_from_sec(struct elf_info *elf, Elf_Section sec)
{
	if (sec == elf->export_sec)
		return export_plain;
	else if (sec == elf->export_unused_sec)
		return export_unused;
	else if (sec == elf->export_gpl_sec)
		return export_gpl;
	else if (sec == elf->export_unused_gpl_sec)
		return export_unused_gpl;
	else if (sec == elf->export_gpl_future_sec)
		return export_gpl_future;
	else
		return export_unknown;
}
void release_file(void *file, unsigned long size)
{
	munmap(file, size);
}
static void parse_elf_finish(struct elf_info *info)
{
	release_file(info->hdr, info->size);
}
static char *get_modinfo(void *modinfo, unsigned long modinfo_len,
			 const char *tag)
{
	return get_next_modinfo(modinfo, modinfo_len, tag, NULL);
}
static const char *sym_name(struct elf_info *elf, Elf_Sym *sym)
{
	if (sym)
		return elf->strtab + sym->st_name;
	else
		return "(unknown)";
}
static const char *sech_name(struct elf_info *elf, Elf_Shdr *sechdr)
{
	return (void *)elf->hdr +
	        elf->sechdrs[elf->hdr->e_shstrndx].sh_offset +
	        sechdr->sh_name;
}
static inline int is_arm_mapping_symbol(const char *str)
{
	return str[0] == '$' && strchr("atd", str[1])
	       && (str[2] == '\0' || str[2] == '.');
}
static int is_function(Elf_Sym *sym)
{
	if (sym)
		return ELF_ST_TYPE(sym->st_info) == STT_FUNC;
	else
		return -1;
}
static int compare_strings(const void *a, const void *b)
{
	return strcmp(*(const char **) a, *(const char **) b);
}
static inline uint32_t F(uint32_t x, uint32_t y, uint32_t z)
{
	return (x & y) | ((~x) & z);
}
static inline uint32_t G(uint32_t x, uint32_t y, uint32_t z)
{
	return (x & y) | (x & z) | (y & z);
}
static inline uint32_t H(uint32_t x, uint32_t y, uint32_t z)
{
	return x ^ y ^ z;
}
static inline void add_char(unsigned char c, struct md4_ctx *md)
{
	md4_update(md, &c, 1);
}
static inline int is_black(struct color c)
{
    return c.red == 0 && c.green == 0 && c.blue == 0;
}
static inline int is_white(struct color c)
{
    return c.red == 255 && c.green == 255 && c.blue == 255;
}
static inline int is_gray(struct color c)
{
    return c.red == c.green && c.red == c.blue;
}
static inline int is_equal(struct color c1, struct color c2)
{
    return c1.red == c2.red && c1.green == c2.green && c1.blue == c2.blue;
}
static void usage(void)
{
    die("\n"
	"Usage: %s [options] <filename>\n"
	"\n"
	"Valid options:\n"
	"    -h          : display this usage information\n"
	"    -n <name>   : specify logo name (default: linux_logo)\n"
	"    -o <output> : output to file <output> instead of stdout\n"
	"    -t <type>   : specify logo type, one of\n"
	"                      mono    : monochrome black/white\n"
	"                      vga16   : 16 colors VGA text palette\n"
	"                      clut224 : 224 colors (default)\n"
	"                      gray256 : 256 levels grayscale\n"
	"\n", programname);
}
static void Eelif (void) { error("Inappropriate #elif"); }
static void Eelse (void) { error("Inappropriate #else"); }
static void Eendif(void) { error("Inappropriate #endif"); }
static void Eeof  (void) { error("Premature EOF"); }
static void Eioccc(void) { error("Obfuscated preprocessor control line"); }
static void print (void) { flushline(true); }
static void drop  (void) { flushline(false); }
int ignoreon(void)
{
	ignoring[depth] = true;
}

static void
state(Ifstate is)
{
	ifstate[depth] = is;
}
static int op_lt(int a, int b) { return (a < b); }
static int op_gt(int a, int b) { return (a > b); }
static int op_le(int a, int b) { return (a <= b); }
static int op_ge(int a, int b) { return (a >= b); }
static int op_eq(int a, int b) { return (a == b); }
static int op_ne(int a, int b) { return (a != b); }
static int op_or(int a, int b) { return (a || b); }
static int op_and(int a, int b) { return (a && b); }
static int cap_acct(struct file *file)
{
	return 0;
}
static int cap_sysctl(ctl_table *table, int op)
{
	return 0;
}
static int cap_quotactl(int cmds, int type, int id, struct super_block *sb)
{
	return 0;
}
static int cap_quota_on(struct dentry *dentry)
{
	return 0;
}
static int cap_bprm_check_security (struct linux_binprm *bprm)
{
	return 0;
}
static int cap_sb_alloc_security(struct super_block *sb)
{
	return 0;
}
static int cap_sb_copy_data(char *orig, char *copy)
{
	return 0;
}
static int cap_sb_kern_mount(struct super_block *sb, int flags, void *data)
{
	return 0;
}
static int cap_sb_show_options(struct seq_file *m, struct super_block *sb)
{
	return 0;
}
static int cap_sb_statfs(struct dentry *dentry)
{
	return 0;
}
static int cap_sb_mount(char *dev_name, struct path *path, char *type,
			unsigned long flags, void *data)
{
	return 0;
}
static int cap_sb_check_sb(struct vfsmount *mnt, struct path *path)
{
	return 0;
}
static int cap_sb_umount(struct vfsmount *mnt, int flags)
{
	return 0;
}
static int cap_sb_pivotroot(struct path *old_path, struct path *new_path)
{
	return 0;
}
static int cap_sb_parse_opts_str(char *options, struct security_mnt_opts *opts)
{
	return 0;
}
static int cap_inode_alloc_security(struct inode *inode)
{
	return 0;
}
static int cap_inode_init_security(struct inode *inode, struct inode *dir,
				   char **name, void **value, size_t *len)
{
	return -EOPNOTSUPP;
}
static int cap_inode_create(struct inode *inode, struct dentry *dentry,
			    int mask)
{
	return 0;
}
static int cap_inode_link(struct dentry *old_dentry, struct inode *inode,
			  struct dentry *new_dentry)
{
	return 0;
}
static int cap_inode_unlink(struct inode *inode, struct dentry *dentry)
{
	return 0;
}
static int cap_inode_symlink(struct inode *inode, struct dentry *dentry,
			     const char *name)
{
	return 0;
}
static int cap_inode_mkdir(struct inode *inode, struct dentry *dentry,
			   int mask)
{
	return 0;
}
static int cap_inode_rmdir(struct inode *inode, struct dentry *dentry)
{
	return 0;
}
static int cap_inode_mknod(struct inode *inode, struct dentry *dentry,
			   int mode, dev_t dev)
{
	return 0;
}
static int cap_inode_rename(struct inode *old_inode, struct dentry *old_dentry,
			    struct inode *new_inode, struct dentry *new_dentry)
{
	return 0;
}
static int cap_inode_readlink(struct dentry *dentry)
{
	return 0;
}
static int cap_inode_follow_link(struct dentry *dentry,
				 struct nameidata *nameidata)
{
	return 0;
}
static int cap_inode_permission(struct inode *inode, int mask)
{
	return 0;
}
static int cap_inode_setattr(struct dentry *dentry, struct iattr *iattr)
{
	return 0;
}
static int cap_inode_getattr(struct vfsmount *mnt, struct dentry *dentry)
{
	return 0;
}
static int cap_inode_getxattr(struct dentry *dentry, const char *name)
{
	return 0;
}
static int cap_inode_listxattr(struct dentry *dentry)
{
	return 0;
}
static int cap_inode_getsecurity(const struct inode *inode, const char *name,
				 void **buffer, bool alloc)
{
	return -EOPNOTSUPP;
}
static int cap_inode_setsecurity(struct inode *inode, const char *name,
				 const void *value, size_t size, int flags)
{
	return -EOPNOTSUPP;
}
static int cap_inode_listsecurity(struct inode *inode, char *buffer,
				  size_t buffer_size)
{
	return 0;
}
static void cap_inode_getsecid(const struct inode *inode, u32 *secid)
{
	*secid = 0;
}
static int cap_path_mknod(struct path *dir, struct dentry *dentry, int mode,
			  unsigned int dev)
{
	return 0;
}
static int cap_path_mkdir(struct path *dir, struct dentry *dentry, int mode)
{
	return 0;
}
static int cap_path_rmdir(struct path *dir, struct dentry *dentry)
{
	return 0;
}
static int cap_path_unlink(struct path *dir, struct dentry *dentry)
{
	return 0;
}
static int cap_path_symlink(struct path *dir, struct dentry *dentry,
			    const char *old_name)
{
	return 0;
}
static int cap_path_link(struct dentry *old_dentry, struct path *new_dir,
			 struct dentry *new_dentry)
{
	return 0;
}
static int cap_path_rename(struct path *old_path, struct dentry *old_dentry,
			   struct path *new_path, struct dentry *new_dentry)
{
	return 0;
}
static int cap_path_truncate(struct path *path, loff_t length,
			     unsigned int time_attrs)
{
	return 0;
}
static int cap_file_permission(struct file *file, int mask)
{
	return 0;
}
static int cap_file_alloc_security(struct file *file)
{
	return 0;
}
static int cap_file_ioctl(struct file *file, unsigned int command,
			  unsigned long arg)
{
	return 0;
}
static int cap_file_mprotect(struct vm_area_struct *vma, unsigned long reqprot,
			     unsigned long prot)
{
	return 0;
}
static int cap_file_lock(struct file *file, unsigned int cmd)
{
	return 0;
}
static int cap_file_fcntl(struct file *file, unsigned int cmd,
			  unsigned long arg)
{
	return 0;
}
static int cap_file_set_fowner(struct file *file)
{
	return 0;
}
static int cap_file_send_sigiotask(struct task_struct *tsk,
				   struct fown_struct *fown, int sig)
{
	return 0;
}
static int cap_file_receive(struct file *file)
{
	return 0;
}
static int cap_dentry_open(struct file *file, const struct cred *cred)
{
	return 0;
}
static int cap_task_create(unsigned long clone_flags)
{
	return 0;
}
static int cap_cred_prepare(struct cred *new, const struct cred *old, gfp_t gfp)
{
	return 0;
}
static int cap_kernel_act_as(struct cred *new, u32 secid)
{
	return 0;
}
static int cap_kernel_create_files_as(struct cred *new, struct inode *inode)
{
	return 0;
}
static int cap_task_setuid(uid_t id0, uid_t id1, uid_t id2, int flags)
{
	return 0;
}
static int cap_task_setgid(gid_t id0, gid_t id1, gid_t id2, int flags)
{
	return 0;
}
static int cap_task_setpgid(struct task_struct *p, pid_t pgid)
{
	return 0;
}
static int cap_task_getpgid(struct task_struct *p)
{
	return 0;
}
static int cap_task_getsid(struct task_struct *p)
{
	return 0;
}
static void cap_task_getsecid(struct task_struct *p, u32 *secid)
{
	*secid = 0;
}
static int cap_task_setgroups(struct group_info *group_info)
{
	return 0;
}
static int cap_task_getioprio(struct task_struct *p)
{
	return 0;
}
static int cap_task_setrlimit(unsigned int resource, struct rlimit *new_rlim)
{
	return 0;
}
static int cap_task_getscheduler(struct task_struct *p)
{
	return 0;
}
static int cap_task_movememory(struct task_struct *p)
{
	return 0;
}
static int cap_task_wait(struct task_struct *p)
{
	return 0;
}
static int cap_task_kill(struct task_struct *p, struct siginfo *info,
			 int sig, u32 secid)
{
	return 0;
}
static int cap_ipc_permission(struct kern_ipc_perm *ipcp, short flag)
{
	return 0;
}
static void cap_ipc_getsecid(struct kern_ipc_perm *ipcp, u32 *secid)
{
	*secid = 0;
}
static int cap_msg_msg_alloc_security(struct msg_msg *msg)
{
	return 0;
}
static int cap_msg_queue_alloc_security(struct msg_queue *msq)
{
	return 0;
}
static int cap_msg_queue_associate(struct msg_queue *msq, int msqflg)
{
	return 0;
}
static int cap_msg_queue_msgctl(struct msg_queue *msq, int cmd)
{
	return 0;
}
static int cap_msg_queue_msgsnd(struct msg_queue *msq, struct msg_msg *msg,
				int msgflg)
{
	return 0;
}
static int cap_msg_queue_msgrcv(struct msg_queue *msq, struct msg_msg *msg,
				struct task_struct *target, long type, int mode)
{
	return 0;
}
static int cap_shm_alloc_security(struct shmid_kernel *shp)
{
	return 0;
}
static int cap_shm_associate(struct shmid_kernel *shp, int shmflg)
{
	return 0;
}
static int cap_shm_shmctl(struct shmid_kernel *shp, int cmd)
{
	return 0;
}
static int cap_shm_shmat(struct shmid_kernel *shp, char __user *shmaddr,
			 int shmflg)
{
	return 0;
}
static int cap_sem_alloc_security(struct sem_array *sma)
{
	return 0;
}
static int cap_sem_associate(struct sem_array *sma, int semflg)
{
	return 0;
}
static int cap_sem_semctl(struct sem_array *sma, int cmd)
{
	return 0;
}
static int cap_sem_semop(struct sem_array *sma, struct sembuf *sops,
			 unsigned nsops, int alter)
{
	return 0;
}
static int cap_unix_stream_connect(struct socket *sock, struct socket *other,
				   struct sock *newsk)
{
	return 0;
}
static int cap_unix_may_send(struct socket *sock, struct socket *other)
{
	return 0;
}
static int cap_socket_create(int family, int type, int protocol, int kern)
{
	return 0;
}
static int cap_socket_post_create(struct socket *sock, int family, int type,
				  int protocol, int kern)
{
	return 0;
}
static int cap_socket_bind(struct socket *sock, struct sockaddr *address,
			   int addrlen)
{
	return 0;
}
static int cap_socket_connect(struct socket *sock, struct sockaddr *address,
			      int addrlen)
{
	return 0;
}
static int cap_socket_listen(struct socket *sock, int backlog)
{
	return 0;
}
static int cap_socket_accept(struct socket *sock, struct socket *newsock)
{
	return 0;
}
static int cap_socket_sendmsg(struct socket *sock, struct msghdr *msg, int size)
{
	return 0;
}
static int cap_socket_recvmsg(struct socket *sock, struct msghdr *msg,
			      int size, int flags)
{
	return 0;
}
static int cap_socket_getsockname(struct socket *sock)
{
	return 0;
}
static int cap_socket_getpeername(struct socket *sock)
{
	return 0;
}
static int cap_socket_setsockopt(struct socket *sock, int level, int optname)
{
	return 0;
}
static int cap_socket_getsockopt(struct socket *sock, int level, int optname)
{
	return 0;
}
static int cap_socket_shutdown(struct socket *sock, int how)
{
	return 0;
}
static int cap_socket_sock_rcv_skb(struct sock *sk, struct sk_buff *skb)
{
	return 0;
}
static int cap_socket_getpeersec_stream(struct socket *sock,
					char __user *optval,
					int __user *optlen, unsigned len)
{
	return -ENOPROTOOPT;
}
static int cap_socket_getpeersec_dgram(struct socket *sock,
				       struct sk_buff *skb, u32 *secid)
{
	return -ENOPROTOOPT;
}
static int cap_sk_alloc_security(struct sock *sk, int family, gfp_t priority)
{
	return 0;
}
static int cap_inet_conn_request(struct sock *sk, struct sk_buff *skb,
				 struct request_sock *req)
{
	return 0;
}
static int cap_xfrm_policy_alloc_security(struct xfrm_sec_ctx **ctxp,
					  struct xfrm_user_sec_ctx *sec_ctx)
{
	return 0;
}
static int cap_xfrm_policy_clone_security(struct xfrm_sec_ctx *old_ctx,
					  struct xfrm_sec_ctx **new_ctxp)
{
	return 0;
}
static int cap_xfrm_policy_delete_security(struct xfrm_sec_ctx *ctx)
{
	return 0;
}
static int cap_xfrm_state_alloc_security(struct xfrm_state *x,
					 struct xfrm_user_sec_ctx *sec_ctx,
					 u32 secid)
{
	return 0;
}
static int cap_xfrm_state_delete_security(struct xfrm_state *x)
{
	return 0;
}
static int cap_xfrm_policy_lookup(struct xfrm_sec_ctx *ctx, u32 sk_sid, u8 dir)
{
	return 0;
}
static int cap_xfrm_state_pol_flow_match(struct xfrm_state *x,
					 struct xfrm_policy *xp,
					 struct flowi *fl)
{
	return 1;
}
static int cap_xfrm_decode_session(struct sk_buff *skb, u32 *fl, int ckall)
{
	return 0;
}
static int cap_getprocattr(struct task_struct *p, char *name, char **value)
{
	return -EINVAL;
}
static int cap_setprocattr(struct task_struct *p, char *name, void *value,
			   size_t size)
{
	return -EINVAL;
}
static int cap_secid_to_secctx(u32 secid, char **secdata, u32 *seclen)
{
	return -EOPNOTSUPP;
}
static int cap_secctx_to_secid(const char *secdata, u32 seclen, u32 *secid)
{
	return -EOPNOTSUPP;
}
static int cap_key_alloc(struct key *key, const struct cred *cred,
			 unsigned long flags)
{
	return 0;
}
static int cap_key_permission(key_ref_t key_ref, const struct cred *cred,
			      key_perm_t perm)
{
	return 0;
}
static int cap_audit_rule_init(u32 field, u32 op, char *rulestr, void **lsmrule)
{
	return 0;
}
static int cap_audit_rule_known(struct audit_krule *krule)
{
	return 0;
}
static int cap_audit_rule_match(u32 secid, u32 field, u32 op, void *lsmrule,
				struct audit_context *actx)
{
	return 0;
}
int cap_capable(struct task_struct *tsk, const struct cred *cred, int cap,
		int audit)
{
	return cap_raised(cred->cap_effective, cap) ? 0 : -EPERM;
}
int cap_inode_need_killpriv(struct dentry *dentry)
{
	return 0;
}
int cap_inode_killpriv(struct dentry *dentry)
{
	return 0;
}
int cap_task_setscheduler(struct task_struct *p, int policy,
			   struct sched_param *lp)
{
	return cap_safe_nice(p);
}
int cap_task_setioprio(struct task_struct *p, int ioprio)
{
	return cap_safe_nice(p);
}
int cap_task_setnice(struct task_struct *p, int nice)
{
	return cap_safe_nice(p);
}
int cap_task_setscheduler (struct task_struct *p, int policy,
			   struct sched_param *lp)
{
	return 0;
}
int cap_task_setioprio (struct task_struct *p, int ioprio)
{
	return 0;
}
int cap_task_setnice (struct task_struct *p, int nice)
{
	return 0;
}
static inline struct dev_cgroup *css_to_devcgroup(struct cgroup_subsys_state *s)
{
	return container_of(s, struct dev_cgroup, css);
}
static inline struct dev_cgroup *cgroup_to_devcgroup(struct cgroup *cgroup)
{
	return css_to_devcgroup(cgroup_subsys_state(cgroup, devices_subsys_id));
}
static inline struct dev_cgroup *task_devcgroup(struct task_struct *task)
{
	return css_to_devcgroup(task_subsys_state(task, devices_subsys_id));
}
static int devcgroup_populate(struct cgroup_subsys *ss,
				struct cgroup *cgroup)
{
	return cgroup_add_files(cgroup, ss, dev_cgroup_files,
					ARRAY_SIZE(dev_cgroup_files));
}
static ssize_t default_read_file(struct file *file, char __user *buf,
				 size_t count, loff_t *ppos)
{
	return 0;
}
static ssize_t default_write_file(struct file *file, const char __user *buf,
				   size_t count, loff_t *ppos)
{
	return count;
}
static inline int positive(struct dentry *dentry)
{
	return dentry->d_inode && !d_unhashed(dentry);
}
static int get_sb(struct file_system_type *fs_type,
		  int flags, const char *dev_name,
		  void *data, struct vfsmount *mnt)
{
	return get_sb_single(fs_type, flags, data, fill_super, mnt);
}
struct dentry *securityfs_create_dir(const char *name, struct dentry *parent)
{
	return securityfs_create_file(name,
				      S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO,
				      parent, NULL, NULL);
}
static ssize_t ima_show_htable_violations(struct file *filp,
					  char __user *buf,
					  size_t count, loff_t *ppos)
{
	return ima_show_htable_value(buf, count, ppos, &ima_htable.violations);
}
static ssize_t ima_show_measurements_count(struct file *filp,
					   char __user *buf,
					   size_t count, loff_t *ppos)
{
	return ima_show_htable_value(buf, count, ppos, &ima_htable.len);
}
static int ima_measurements_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &ima_measurments_seqops);
}
static int ima_ascii_measurements_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &ima_ascii_measurements_seqops);
}
void ima_iintcache_init(void)
{
	iint_cache =
	    kmem_cache_create("iint_cache", sizeof(struct ima_iint_cache), 0,
			      SLAB_PANIC, init_once);
}
void __exit ima_cleanup(void)
{
	ima_fs_cleanup();
}
static void __exit cleanup_ima(void)
{
	ima_cleanup();
}
void key_type_put(struct key_type *ktype)
{
	up_read(&key_types_sem);

} /* end key_type_put() */
static int keyring_match(const struct key *keyring, const void *description)
{
	return keyring->description &&
		strcmp(keyring->description, description) == 0;

} /* end keyring_match() */
static int proc_keys_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &proc_keys_ops);
}
static void proc_keys_stop(struct seq_file *p, void *v)
{
	spin_unlock(&key_serial_lock);
}
static int proc_key_users_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &proc_key_users_ops);
}
static void proc_key_users_stop(struct seq_file *p, void *v)
{
	spin_unlock(&key_user_lock);
}
static int lookup_user_key_possessed(const struct key *key, const void *target)
{
	return key == target;

} /* end lookup_user_key_possessed() */
struct key *request_key_async(struct key_type *type,
			      const char *description,
			      const void *callout_info,
			      size_t callout_len)
{
	return request_key_and_link(type, description, callout_info,
				    callout_len, NULL, NULL,
				    KEY_ALLOC_IN_QUOTA);
}
struct key *request_key_async_with_auxdata(struct key_type *type,
					   const char *description,
					   const void *callout_info,
					   size_t callout_len,
					   void *aux)
{
	return request_key_and_link(type, description, callout_info,
				    callout_len, aux, NULL, KEY_ALLOC_IN_QUOTA);
}
int user_match(const struct key *key, const void *description)
{
	return strcmp(key->description, description) == 0;

} /* end user_match() */
int security_ptrace_may_access(struct task_struct *child, unsigned int mode)
{
	return security_ops->ptrace_may_access(child, mode);
}
int security_ptrace_traceme(struct task_struct *parent)
{
	return security_ops->ptrace_traceme(parent);
}
int security_capget(struct task_struct *target,
		     kernel_cap_t *effective,
		     kernel_cap_t *inheritable,
		     kernel_cap_t *permitted)
{
	return security_ops->capget(target, effective, inheritable, permitted);
}
int security_capset(struct cred *new, const struct cred *old,
		    const kernel_cap_t *effective,
		    const kernel_cap_t *inheritable,
		    const kernel_cap_t *permitted)
{
	return security_ops->capset(new, old,
				    effective, inheritable, permitted);
}
int security_capable(int cap)
{
	return security_ops->capable(current, current_cred(), cap,
				     SECURITY_CAP_AUDIT);
}
int security_acct(struct file *file)
{
	return security_ops->acct(file);
}
int security_sysctl(struct ctl_table *table, int op)
{
	return security_ops->sysctl(table, op);
}
int security_quotactl(int cmds, int type, int id, struct super_block *sb)
{
	return security_ops->quotactl(cmds, type, id, sb);
}
int security_quota_on(struct dentry *dentry)
{
	return security_ops->quota_on(dentry);
}
int security_syslog(int type)
{
	return security_ops->syslog(type);
}
int security_settime(struct timespec *ts, struct timezone *tz)
{
	return security_ops->settime(ts, tz);
}
int security_vm_enough_memory_kern(long pages)
{
	return security_ops->vm_enough_memory(current->mm, pages);
}
int security_bprm_set_creds(struct linux_binprm *bprm)
{
	return security_ops->bprm_set_creds(bprm);
}
int security_bprm_check(struct linux_binprm *bprm)
{
	return security_ops->bprm_check_security(bprm);
}
void security_bprm_committing_creds(struct linux_binprm *bprm)
{
	security_ops->bprm_committing_creds(bprm);
}
void security_bprm_committed_creds(struct linux_binprm *bprm)
{
	security_ops->bprm_committed_creds(bprm);
}
int security_bprm_secureexec(struct linux_binprm *bprm)
{
	return security_ops->bprm_secureexec(bprm);
}
int security_sb_alloc(struct super_block *sb)
{
	return security_ops->sb_alloc_security(sb);
}
void security_sb_free(struct super_block *sb)
{
	security_ops->sb_free_security(sb);
}
int security_sb_copy_data(char *orig, char *copy)
{
	return security_ops->sb_copy_data(orig, copy);
}
int security_sb_kern_mount(struct super_block *sb, int flags, void *data)
{
	return security_ops->sb_kern_mount(sb, flags, data);
}
int security_sb_show_options(struct seq_file *m, struct super_block *sb)
{
	return security_ops->sb_show_options(m, sb);
}
int security_sb_statfs(struct dentry *dentry)
{
	return security_ops->sb_statfs(dentry);
}
int security_sb_mount(char *dev_name, struct path *path,
                       char *type, unsigned long flags, void *data)
{
	return security_ops->sb_mount(dev_name, path, type, flags, data);
}
int security_sb_check_sb(struct vfsmount *mnt, struct path *path)
{
	return security_ops->sb_check_sb(mnt, path);
}
int security_sb_umount(struct vfsmount *mnt, int flags)
{
	return security_ops->sb_umount(mnt, flags);
}
void security_sb_umount_close(struct vfsmount *mnt)
{
	security_ops->sb_umount_close(mnt);
}
void security_sb_umount_busy(struct vfsmount *mnt)
{
	security_ops->sb_umount_busy(mnt);
}
void security_sb_post_remount(struct vfsmount *mnt, unsigned long flags, void *data)
{
	security_ops->sb_post_remount(mnt, flags, data);
}
void security_sb_post_addmount(struct vfsmount *mnt, struct path *mountpoint)
{
	security_ops->sb_post_addmount(mnt, mountpoint);
}
int security_sb_pivotroot(struct path *old_path, struct path *new_path)
{
	return security_ops->sb_pivotroot(old_path, new_path);
}
void security_sb_post_pivotroot(struct path *old_path, struct path *new_path)
{
	security_ops->sb_post_pivotroot(old_path, new_path);
}
int security_sb_set_mnt_opts(struct super_block *sb,
				struct security_mnt_opts *opts)
{
	return security_ops->sb_set_mnt_opts(sb, opts);
}
void security_sb_clone_mnt_opts(const struct super_block *oldsb,
				struct super_block *newsb)
{
	security_ops->sb_clone_mnt_opts(oldsb, newsb);
}
int security_sb_parse_opts_str(char *options, struct security_mnt_opts *opts)
{
	return security_ops->sb_parse_opts_str(options, opts);
}
void security_inode_free(struct inode *inode)
{
	security_ops->inode_free_security(inode);
}
int security_inode_need_killpriv(struct dentry *dentry)
{
	return security_ops->inode_need_killpriv(dentry);
}
int security_inode_killpriv(struct dentry *dentry)
{
	return security_ops->inode_killpriv(dentry);
}
void security_inode_getsecid(const struct inode *inode, u32 *secid)
{
	security_ops->inode_getsecid(inode, secid);
}
int security_file_permission(struct file *file, int mask)
{
	return security_ops->file_permission(file, mask);
}
int security_file_alloc(struct file *file)
{
	return security_ops->file_alloc_security(file);
}
void security_file_free(struct file *file)
{
	security_ops->file_free_security(file);
}
int security_file_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
	return security_ops->file_ioctl(file, cmd, arg);
}
int security_file_mmap(struct file *file, unsigned long reqprot,
			unsigned long prot, unsigned long flags,
			unsigned long addr, unsigned long addr_only)
{
	return security_ops->file_mmap(file, reqprot, prot, flags, addr, addr_only);
}
int security_file_mprotect(struct vm_area_struct *vma, unsigned long reqprot,
			    unsigned long prot)
{
	return security_ops->file_mprotect(vma, reqprot, prot);
}
int security_file_lock(struct file *file, unsigned int cmd)
{
	return security_ops->file_lock(file, cmd);
}
int security_file_fcntl(struct file *file, unsigned int cmd, unsigned long arg)
{
	return security_ops->file_fcntl(file, cmd, arg);
}
int security_file_set_fowner(struct file *file)
{
	return security_ops->file_set_fowner(file);
}
int security_file_send_sigiotask(struct task_struct *tsk,
				  struct fown_struct *fown, int sig)
{
	return security_ops->file_send_sigiotask(tsk, fown, sig);
}
int security_file_receive(struct file *file)
{
	return security_ops->file_receive(file);
}
int security_dentry_open(struct file *file, const struct cred *cred)
{
	return security_ops->dentry_open(file, cred);
}
int security_task_create(unsigned long clone_flags)
{
	return security_ops->task_create(clone_flags);
}
void security_cred_free(struct cred *cred)
{
	security_ops->cred_free(cred);
}
int security_prepare_creds(struct cred *new, const struct cred *old, gfp_t gfp)
{
	return security_ops->cred_prepare(new, old, gfp);
}
void security_commit_creds(struct cred *new, const struct cred *old)
{
	security_ops->cred_commit(new, old);
}
int security_kernel_act_as(struct cred *new, u32 secid)
{
	return security_ops->kernel_act_as(new, secid);
}
int security_kernel_create_files_as(struct cred *new, struct inode *inode)
{
	return security_ops->kernel_create_files_as(new, inode);
}
int security_task_setuid(uid_t id0, uid_t id1, uid_t id2, int flags)
{
	return security_ops->task_setuid(id0, id1, id2, flags);
}
int security_task_fix_setuid(struct cred *new, const struct cred *old,
			     int flags)
{
	return security_ops->task_fix_setuid(new, old, flags);
}
int security_task_setgid(gid_t id0, gid_t id1, gid_t id2, int flags)
{
	return security_ops->task_setgid(id0, id1, id2, flags);
}
int security_task_setpgid(struct task_struct *p, pid_t pgid)
{
	return security_ops->task_setpgid(p, pgid);
}
int security_task_getpgid(struct task_struct *p)
{
	return security_ops->task_getpgid(p);
}
int security_task_getsid(struct task_struct *p)
{
	return security_ops->task_getsid(p);
}
void security_task_getsecid(struct task_struct *p, u32 *secid)
{
	security_ops->task_getsecid(p, secid);
}
int security_task_setgroups(struct group_info *group_info)
{
	return security_ops->task_setgroups(group_info);
}
int security_task_setnice(struct task_struct *p, int nice)
{
	return security_ops->task_setnice(p, nice);
}
int security_task_setioprio(struct task_struct *p, int ioprio)
{
	return security_ops->task_setioprio(p, ioprio);
}
int security_task_getioprio(struct task_struct *p)
{
	return security_ops->task_getioprio(p);
}
int security_task_setrlimit(unsigned int resource, struct rlimit *new_rlim)
{
	return security_ops->task_setrlimit(resource, new_rlim);
}
int security_task_setscheduler(struct task_struct *p,
				int policy, struct sched_param *lp)
{
	return security_ops->task_setscheduler(p, policy, lp);
}
int security_task_getscheduler(struct task_struct *p)
{
	return security_ops->task_getscheduler(p);
}
int security_task_movememory(struct task_struct *p)
{
	return security_ops->task_movememory(p);
}
int security_task_kill(struct task_struct *p, struct siginfo *info,
			int sig, u32 secid)
{
	return security_ops->task_kill(p, info, sig, secid);
}
int security_task_wait(struct task_struct *p)
{
	return security_ops->task_wait(p);
}
int security_task_prctl(int option, unsigned long arg2, unsigned long arg3,
			 unsigned long arg4, unsigned long arg5)
{
	return security_ops->task_prctl(option, arg2, arg3, arg4, arg5);
}
void security_task_to_inode(struct task_struct *p, struct inode *inode)
{
	security_ops->task_to_inode(p, inode);
}
int security_ipc_permission(struct kern_ipc_perm *ipcp, short flag)
{
	return security_ops->ipc_permission(ipcp, flag);
}
void security_ipc_getsecid(struct kern_ipc_perm *ipcp, u32 *secid)
{
	security_ops->ipc_getsecid(ipcp, secid);
}
int security_msg_msg_alloc(struct msg_msg *msg)
{
	return security_ops->msg_msg_alloc_security(msg);
}
void security_msg_msg_free(struct msg_msg *msg)
{
	security_ops->msg_msg_free_security(msg);
}
int security_msg_queue_alloc(struct msg_queue *msq)
{
	return security_ops->msg_queue_alloc_security(msq);
}
void security_msg_queue_free(struct msg_queue *msq)
{
	security_ops->msg_queue_free_security(msq);
}
int security_msg_queue_associate(struct msg_queue *msq, int msqflg)
{
	return security_ops->msg_queue_associate(msq, msqflg);
}
int security_msg_queue_msgctl(struct msg_queue *msq, int cmd)
{
	return security_ops->msg_queue_msgctl(msq, cmd);
}
int security_msg_queue_msgsnd(struct msg_queue *msq,
			       struct msg_msg *msg, int msqflg)
{
	return security_ops->msg_queue_msgsnd(msq, msg, msqflg);
}
int security_msg_queue_msgrcv(struct msg_queue *msq, struct msg_msg *msg,
			       struct task_struct *target, long type, int mode)
{
	return security_ops->msg_queue_msgrcv(msq, msg, target, type, mode);
}
int security_shm_alloc(struct shmid_kernel *shp)
{
	return security_ops->shm_alloc_security(shp);
}
void security_shm_free(struct shmid_kernel *shp)
{
	security_ops->shm_free_security(shp);
}
int security_shm_associate(struct shmid_kernel *shp, int shmflg)
{
	return security_ops->shm_associate(shp, shmflg);
}
int security_shm_shmctl(struct shmid_kernel *shp, int cmd)
{
	return security_ops->shm_shmctl(shp, cmd);
}
int security_shm_shmat(struct shmid_kernel *shp, char __user *shmaddr, int shmflg)
{
	return security_ops->shm_shmat(shp, shmaddr, shmflg);
}
int security_sem_alloc(struct sem_array *sma)
{
	return security_ops->sem_alloc_security(sma);
}
void security_sem_free(struct sem_array *sma)
{
	security_ops->sem_free_security(sma);
}
int security_sem_associate(struct sem_array *sma, int semflg)
{
	return security_ops->sem_associate(sma, semflg);
}
int security_sem_semctl(struct sem_array *sma, int cmd)
{
	return security_ops->sem_semctl(sma, cmd);
}
int security_sem_semop(struct sem_array *sma, struct sembuf *sops,
			unsigned nsops, int alter)
{
	return security_ops->sem_semop(sma, sops, nsops, alter);
}
int security_getprocattr(struct task_struct *p, char *name, char **value)
{
	return security_ops->getprocattr(p, name, value);
}
int security_setprocattr(struct task_struct *p, char *name, void *value, size_t size)
{
	return security_ops->setprocattr(p, name, value, size);
}
int security_netlink_send(struct sock *sk, struct sk_buff *skb)
{
	return security_ops->netlink_send(sk, skb);
}
int security_netlink_recv(struct sk_buff *skb, int cap)
{
	return security_ops->netlink_recv(skb, cap);
}
int security_secid_to_secctx(u32 secid, char **secdata, u32 *seclen)
{
	return security_ops->secid_to_secctx(secid, secdata, seclen);
}
int security_secctx_to_secid(const char *secdata, u32 seclen, u32 *secid)
{
	return security_ops->secctx_to_secid(secdata, seclen, secid);
}
void security_release_secctx(char *secdata, u32 seclen)
{
	security_ops->release_secctx(secdata, seclen);
}
int security_unix_stream_connect(struct socket *sock, struct socket *other,
				 struct sock *newsk)
{
	return security_ops->unix_stream_connect(sock, other, newsk);
}
int security_unix_may_send(struct socket *sock,  struct socket *other)
{
	return security_ops->unix_may_send(sock, other);
}
int security_socket_create(int family, int type, int protocol, int kern)
{
	return security_ops->socket_create(family, type, protocol, kern);
}
int security_socket_post_create(struct socket *sock, int family,
				int type, int protocol, int kern)
{
	return security_ops->socket_post_create(sock, family, type,
						protocol, kern);
}
int security_socket_bind(struct socket *sock, struct sockaddr *address, int addrlen)
{
	return security_ops->socket_bind(sock, address, addrlen);
}
int security_socket_connect(struct socket *sock, struct sockaddr *address, int addrlen)
{
	return security_ops->socket_connect(sock, address, addrlen);
}
int security_socket_listen(struct socket *sock, int backlog)
{
	return security_ops->socket_listen(sock, backlog);
}
int security_socket_accept(struct socket *sock, struct socket *newsock)
{
	return security_ops->socket_accept(sock, newsock);
}
void security_socket_post_accept(struct socket *sock, struct socket *newsock)
{
	security_ops->socket_post_accept(sock, newsock);
}
int security_socket_sendmsg(struct socket *sock, struct msghdr *msg, int size)
{
	return security_ops->socket_sendmsg(sock, msg, size);
}
int security_socket_recvmsg(struct socket *sock, struct msghdr *msg,
			    int size, int flags)
{
	return security_ops->socket_recvmsg(sock, msg, size, flags);
}
int security_socket_getsockname(struct socket *sock)
{
	return security_ops->socket_getsockname(sock);
}
int security_socket_getpeername(struct socket *sock)
{
	return security_ops->socket_getpeername(sock);
}
int security_socket_getsockopt(struct socket *sock, int level, int optname)
{
	return security_ops->socket_getsockopt(sock, level, optname);
}
int security_socket_setsockopt(struct socket *sock, int level, int optname)
{
	return security_ops->socket_setsockopt(sock, level, optname);
}
int security_socket_shutdown(struct socket *sock, int how)
{
	return security_ops->socket_shutdown(sock, how);
}
int security_sock_rcv_skb(struct sock *sk, struct sk_buff *skb)
{
	return security_ops->socket_sock_rcv_skb(sk, skb);
}
int security_socket_getpeersec_stream(struct socket *sock, char __user *optval,
				      int __user *optlen, unsigned len)
{
	return security_ops->socket_getpeersec_stream(sock, optval, optlen, len);
}
int security_socket_getpeersec_dgram(struct socket *sock, struct sk_buff *skb, u32 *secid)
{
	return security_ops->socket_getpeersec_dgram(sock, skb, secid);
}
int security_sk_alloc(struct sock *sk, int family, gfp_t priority)
{
	return security_ops->sk_alloc_security(sk, family, priority);
}
void security_sk_free(struct sock *sk)
{
	security_ops->sk_free_security(sk);
}
void security_sk_clone(const struct sock *sk, struct sock *newsk)
{
	security_ops->sk_clone_security(sk, newsk);
}
void security_sk_classify_flow(struct sock *sk, struct flowi *fl)
{
	security_ops->sk_getsecid(sk, &fl->secid);
}
void security_req_classify_flow(const struct request_sock *req, struct flowi *fl)
{
	security_ops->req_classify_flow(req, fl);
}
void security_sock_graft(struct sock *sk, struct socket *parent)
{
	security_ops->sock_graft(sk, parent);
}
int security_inet_conn_request(struct sock *sk,
			struct sk_buff *skb, struct request_sock *req)
{
	return security_ops->inet_conn_request(sk, skb, req);
}
void security_inet_csk_clone(struct sock *newsk,
			const struct request_sock *req)
{
	security_ops->inet_csk_clone(newsk, req);
}
void security_inet_conn_established(struct sock *sk,
			struct sk_buff *skb)
{
	security_ops->inet_conn_established(sk, skb);
}
int security_xfrm_policy_alloc(struct xfrm_sec_ctx **ctxp, struct xfrm_user_sec_ctx *sec_ctx)
{
	return security_ops->xfrm_policy_alloc_security(ctxp, sec_ctx);
}
int security_xfrm_policy_clone(struct xfrm_sec_ctx *old_ctx,
			      struct xfrm_sec_ctx **new_ctxp)
{
	return security_ops->xfrm_policy_clone_security(old_ctx, new_ctxp);
}
void security_xfrm_policy_free(struct xfrm_sec_ctx *ctx)
{
	security_ops->xfrm_policy_free_security(ctx);
}
int security_xfrm_policy_delete(struct xfrm_sec_ctx *ctx)
{
	return security_ops->xfrm_policy_delete_security(ctx);
}
int security_xfrm_state_alloc(struct xfrm_state *x, struct xfrm_user_sec_ctx *sec_ctx)
{
	return security_ops->xfrm_state_alloc_security(x, sec_ctx, 0);
}
int security_xfrm_state_delete(struct xfrm_state *x)
{
	return security_ops->xfrm_state_delete_security(x);
}
void security_xfrm_state_free(struct xfrm_state *x)
{
	security_ops->xfrm_state_free_security(x);
}
int security_xfrm_policy_lookup(struct xfrm_sec_ctx *ctx, u32 fl_secid, u8 dir)
{
	return security_ops->xfrm_policy_lookup(ctx, fl_secid, dir);
}
int security_xfrm_state_pol_flow_match(struct xfrm_state *x,
				       struct xfrm_policy *xp, struct flowi *fl)
{
	return security_ops->xfrm_state_pol_flow_match(x, xp, fl);
}
int security_xfrm_decode_session(struct sk_buff *skb, u32 *secid)
{
	return security_ops->xfrm_decode_session(skb, secid, 1);
}
int security_key_alloc(struct key *key, const struct cred *cred,
		       unsigned long flags)
{
	return security_ops->key_alloc(key, cred, flags);
}
void security_key_free(struct key *key)
{
	security_ops->key_free(key);
}
int security_key_permission(key_ref_t key_ref,
			    const struct cred *cred, key_perm_t perm)
{
	return security_ops->key_permission(key_ref, cred, perm);
}
int security_key_getsecurity(struct key *key, char **_buffer)
{
	return security_ops->key_getsecurity(key, _buffer);
}
int security_audit_rule_init(u32 field, u32 op, char *rulestr, void **lsmrule)
{
	return security_ops->audit_rule_init(field, op, rulestr, lsmrule);
}
int security_audit_rule_known(struct audit_krule *krule)
{
	return security_ops->audit_rule_known(krule);
}
void security_audit_rule_free(void *lsmrule)
{
	security_ops->audit_rule_free(lsmrule);
}
int security_audit_rule_match(u32 secid, u32 field, u32 op, void *lsmrule,
			      struct audit_context *actx)
{
	return security_ops->audit_rule_match(secid, field, op, lsmrule, actx);
}
static inline int avc_hash(u32 ssid, u32 tsid, u16 tclass)
{
	return (ssid ^ (tsid<<2) ^ (tclass<<4)) & (AVC_CACHE_SLOTS - 1);
}
static inline int avc_sidcmp(u32 x, u32 y)
{
	return (x == y || x == SECSID_WILD || y == SECSID_WILD);
}
u32 avc_policy_seqno(void)
{
	return avc_cache.latest_notif;
}
void selinux_secmark_refcount_inc(void)
{
	atomic_inc(&selinux_secmark_refcount);
}
void selinux_secmark_refcount_dec(void)
{
	atomic_dec(&selinux_secmark_refcount);
}
static int selinux_secmark_enabled(void)
{
	return (atomic_read(&selinux_secmark_refcount) > 0);
}
static inline int inode_doinit(struct inode *inode)
{
	return inode_doinit_with_dentry(inode, NULL);
}
static inline int default_protocol_stream(int protocol)
{
	return (protocol == IPPROTO_IP || protocol == IPPROTO_TCP);
}
static inline int default_protocol_dgram(int protocol)
{
	return (protocol == IPPROTO_IP || protocol == IPPROTO_UDP);
}
static int selinux_proc_get_sid(struct super_block *sb,
				struct proc_dir_entry *de,
				u16 tclass,
				u32 *sid)
{
	return -EINVAL;
}
static int selinux_sb_alloc_security(struct super_block *sb)
{
	return superblock_alloc_security(sb);
}
static void selinux_sb_free_security(struct super_block *sb)
{
	superblock_free_security(sb);
}
static inline int selinux_option(char *option, int len)
{
	return (match_prefix(CONTEXT_STR, sizeof(CONTEXT_STR)-1, option, len) ||
		match_prefix(FSCONTEXT_STR, sizeof(FSCONTEXT_STR)-1, option, len) ||
		match_prefix(DEFCONTEXT_STR, sizeof(DEFCONTEXT_STR)-1, option, len) ||
		match_prefix(ROOTCONTEXT_STR, sizeof(ROOTCONTEXT_STR)-1, option, len) ||
		match_prefix(LABELSUPP_STR, sizeof(LABELSUPP_STR)-1, option, len));
}
static int selinux_inode_alloc_security(struct inode *inode)
{
	return inode_alloc_security(inode);
}
static void selinux_inode_free_security(struct inode *inode)
{
	inode_free_security(inode);
}
static int selinux_inode_create(struct inode *dir, struct dentry *dentry, int mask)
{
	return may_create(dir, dentry, SECCLASS_FILE);
}
static int selinux_inode_link(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry)
{
	return may_link(dir, old_dentry, MAY_LINK);
}
static int selinux_inode_unlink(struct inode *dir, struct dentry *dentry)
{
	return may_link(dir, dentry, MAY_UNLINK);
}
static int selinux_inode_symlink(struct inode *dir, struct dentry *dentry, const char *name)
{
	return may_create(dir, dentry, SECCLASS_LNK_FILE);
}
static int selinux_inode_mkdir(struct inode *dir, struct dentry *dentry, int mask)
{
	return may_create(dir, dentry, SECCLASS_DIR);
}
static int selinux_inode_rmdir(struct inode *dir, struct dentry *dentry)
{
	return may_link(dir, dentry, MAY_RMDIR);
}
static int selinux_inode_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev)
{
	return may_create(dir, dentry, inode_mode_to_security_class(mode));
}
static int selinux_inode_rename(struct inode *old_inode, struct dentry *old_dentry,
				struct inode *new_inode, struct dentry *new_dentry)
{
	return may_rename(old_inode, old_dentry, new_inode, new_dentry);
}
static int selinux_file_alloc_security(struct file *file)
{
	return file_alloc_security(file);
}
static void selinux_file_free_security(struct file *file)
{
	file_free_security(file);
}
static int selinux_task_create(unsigned long clone_flags)
{
	return current_has_perm(current, PROCESS__FORK);
}
static int selinux_task_setpgid(struct task_struct *p, pid_t pgid)
{
	return current_has_perm(p, PROCESS__SETPGID);
}
static int selinux_task_getpgid(struct task_struct *p)
{
	return current_has_perm(p, PROCESS__GETPGID);
}
static int selinux_task_getsid(struct task_struct *p)
{
	return current_has_perm(p, PROCESS__GETSESSION);
}
static void selinux_task_getsecid(struct task_struct *p, u32 *secid)
{
	*secid = task_sid(p);
}
static int selinux_task_getioprio(struct task_struct *p)
{
	return current_has_perm(p, PROCESS__GETSCHED);
}
static int selinux_task_getscheduler(struct task_struct *p)
{
	return current_has_perm(p, PROCESS__GETSCHED);
}
static int selinux_task_movememory(struct task_struct *p)
{
	return current_has_perm(p, PROCESS__SETSCHED);
}
static int selinux_task_wait(struct task_struct *p)
{
	return task_has_perm(p, current, PROCESS__SIGCHLD);
}
static int selinux_socket_listen(struct socket *sock, int backlog)
{
	return socket_has_perm(current, sock, SOCKET__LISTEN);
}
static int selinux_socket_recvmsg(struct socket *sock, struct msghdr *msg,
				  int size, int flags)
{
	return socket_has_perm(current, sock, SOCKET__READ);
}
static int selinux_socket_getsockname(struct socket *sock)
{
	return socket_has_perm(current, sock, SOCKET__GETATTR);
}
static int selinux_socket_getpeername(struct socket *sock)
{
	return socket_has_perm(current, sock, SOCKET__GETATTR);
}
static int selinux_socket_getsockopt(struct socket *sock, int level,
				     int optname)
{
	return socket_has_perm(current, sock, SOCKET__GETOPT);
}
static int selinux_socket_shutdown(struct socket *sock, int how)
{
	return socket_has_perm(current, sock, SOCKET__SHUTDOWN);
}
static int selinux_sk_alloc_security(struct sock *sk, int family, gfp_t priority)
{
	return sk_alloc_security(sk, family, priority);
}
static void selinux_sk_free_security(struct sock *sk)
{
	sk_free_security(sk);
}
static void selinux_req_classify_flow(const struct request_sock *req,
				      struct flowi *fl)
{
	fl->secid = req->secid;
}
static unsigned int selinux_ipv4_forward(unsigned int hooknum,
					 struct sk_buff *skb,
					 const struct net_device *in,
					 const struct net_device *out,
					 int (*okfn)(struct sk_buff *))
{
	return selinux_ip_forward(skb, in->ifindex, PF_INET);
}
static unsigned int selinux_ipv6_forward(unsigned int hooknum,
					 struct sk_buff *skb,
					 const struct net_device *in,
					 const struct net_device *out,
					 int (*okfn)(struct sk_buff *))
{
	return selinux_ip_forward(skb, in->ifindex, PF_INET6);
}
static unsigned int selinux_ipv4_output(unsigned int hooknum,
					struct sk_buff *skb,
					const struct net_device *in,
					const struct net_device *out,
					int (*okfn)(struct sk_buff *))
{
	return selinux_ip_output(skb, PF_INET);
}
static unsigned int selinux_ipv4_postroute(unsigned int hooknum,
					   struct sk_buff *skb,
					   const struct net_device *in,
					   const struct net_device *out,
					   int (*okfn)(struct sk_buff *))
{
	return selinux_ip_postroute(skb, out->ifindex, PF_INET);
}
static unsigned int selinux_ipv6_postroute(unsigned int hooknum,
					   struct sk_buff *skb,
					   const struct net_device *in,
					   const struct net_device *out,
					   int (*okfn)(struct sk_buff *))
{
	return selinux_ip_postroute(skb, out->ifindex, PF_INET6);
}
static int selinux_msg_msg_alloc_security(struct msg_msg *msg)
{
	return msg_msg_alloc_security(msg);
}
static void selinux_msg_msg_free_security(struct msg_msg *msg)
{
	msg_msg_free_security(msg);
}
static void selinux_msg_queue_free_security(struct msg_queue *msq)
{
	ipc_free_security(&msq->q_perm);
}
static void selinux_shm_free_security(struct shmid_kernel *shp)
{
	ipc_free_security(&shp->shm_perm);
}
static void selinux_sem_free_security(struct sem_array *sma)
{
	ipc_free_security(&sma->sem_perm);
}
static int selinux_secid_to_secctx(u32 secid, char **secdata, u32 *seclen)
{
	return security_sid_to_context(secid, secdata, seclen);
}
static int selinux_secctx_to_secid(const char *secdata, u32 seclen, u32 *secid)
{
	return security_context_to_sid(secdata, seclen, secid);
}
static void selinux_release_secctx(char *secdata, u32 seclen)
{
	kfree(secdata);
}
static inline u32 sel_netif_hashfn(int ifindex)
{
	return (ifindex & (SEL_NETIF_HASH_SIZE - 1));
}
void selinux_netlbl_cache_invalidate(void)
{
	netlbl_cache_invalidate();
}
void selinux_netlbl_err(struct sk_buff *skb, int error, int gateway)
{
	netlbl_skbuff_err(skb, error, gateway);
}
int selinux_netlbl_socket_post_create(struct socket *sock)
{
	return selinux_netlbl_sock_setsid(sock->sk);
}
void selnl_notify_setenforce(int val)
{
	selnl_notify(SELNL_MSG_SETENFORCE, &val);
}
void selnl_notify_policyload(u32 seqno)
{
	selnl_notify(SELNL_MSG_POLICYLOAD, &seqno);
}
static unsigned int sel_netnode_hashfn_ipv4(__be32 addr)
{
	return (addr & (SEL_NETNODE_HASH_SIZE - 1));
}
static unsigned int sel_netnode_hashfn_ipv6(const struct in6_addr *addr)
{
	return (addr->s6_addr32[3] & (SEL_NETNODE_HASH_SIZE - 1));
}
static unsigned int sel_netport_hashfn(u16 pnum)
{
	return (pnum & (SEL_NETPORT_HASH_SIZE - 1));
}
static void *sel_avc_stats_seq_next(struct seq_file *seq, void *v, loff_t *pos)
{
	return sel_avc_get_stat_idx(pos);
}
static int sel_open_avc_cache_stats(struct inode *inode, struct file *file)
{
	return seq_open(file, &sel_avc_cache_stats_seq_ops);
}
static inline unsigned int sel_div(unsigned long a, unsigned long b)
{
	return a / b - (a % b < 0);
}
static inline unsigned long sel_class_to_ino(u16 class)
{
	return (class * (SEL_VEC_MAX + 1)) | SEL_CLASS_INO_OFFSET;
}
static inline u16 sel_ino_to_class(unsigned long ino)
{
	return sel_div(ino & SEL_INO_MASK, SEL_VEC_MAX + 1);
}
static inline unsigned long sel_perm_to_ino(u16 class, u32 perm)
{
	return (class * (SEL_VEC_MAX + 1) + perm) | SEL_CLASS_INO_OFFSET;
}
static inline u32 sel_ino_to_perm(unsigned long ino)
{
	return (ino & SEL_INO_MASK) % (SEL_VEC_MAX + 1);
}
static int sel_get_sb(struct file_system_type *fs_type,
		      int flags, const char *dev_name, void *data,
		      struct vfsmount *mnt)
{
	return get_sb_single(fs_type, flags, data, sel_fill_super, mnt);
}
void exit_sel_fs(void)
{
	unregister_filesystem(&sel_fs_type);
}
static inline int avtab_hash(struct avtab_key *keyp, u16 mask)
{
	return ((keyp->target_class + (keyp->target_type << 2) +
		 (keyp->source_type << 9)) & mask);
}
static int avtab_insertf(struct avtab *a, struct avtab_key *k,
			 struct avtab_datum *d, void *p)
{
	return avtab_insert(a, k, d);
}
void avtab_cache_init(void)
{
	avtab_node_cachep = kmem_cache_create("avtab_node",
					      sizeof(struct avtab_node),
					      0, SLAB_PANIC, NULL);
}
void avtab_cache_destroy(void)
{
	kmem_cache_destroy(avtab_node_cachep);
}
int mls_range_isvalid(struct policydb *p, struct mls_range *r)
{
	return (mls_level_isvalid(p, &r->level[0]) &&
		mls_level_isvalid(p, &r->level[1]) &&
		mls_level_dom(&r->level[1], &r->level[0]));
}
int security_sid_to_context(u32 sid, char **scontext, u32 *scontext_len)
{
	return security_sid_to_context_core(sid, scontext, scontext_len, 0);
}
int security_sid_to_context_force(u32 sid, char **scontext, u32 *scontext_len)
{
	return security_sid_to_context_core(sid, scontext, scontext_len, 1);
}
int security_context_to_sid(const char *scontext, u32 scontext_len, u32 *sid)
{
	return security_context_to_sid_core(scontext, scontext_len,
					    sid, SECSID_NULL, GFP_KERNEL, 0);
}
int security_context_to_sid_default(const char *scontext, u32 scontext_len,
				    u32 *sid, u32 def_sid, gfp_t gfp_flags)
{
	return security_context_to_sid_core(scontext, scontext_len,
					    sid, def_sid, gfp_flags, 1);
}
int security_context_to_sid_force(const char *scontext, u32 scontext_len,
				  u32 *sid)
{
	return security_context_to_sid_core(scontext, scontext_len,
					    sid, SECSID_NULL, GFP_KERNEL, 1);
}
int security_transition_sid(u32 ssid,
			    u32 tsid,
			    u16 tclass,
			    u32 *out_sid)
{
	return security_compute_sid(ssid, tsid, tclass, AVTAB_TRANSITION, out_sid);
}
int security_member_sid(u32 ssid,
			u32 tsid,
			u16 tclass,
			u32 *out_sid)
{
	return security_compute_sid(ssid, tsid, tclass, AVTAB_MEMBER, out_sid);
}
int security_change_sid(u32 ssid,
			u32 tsid,
			u16 tclass,
			u32 *out_sid)
{
	return security_compute_sid(ssid, tsid, tclass, AVTAB_CHANGE, out_sid);
}
int security_get_reject_unknown(void)
{
	return policydb.reject_unknown;
}
int security_get_allow_unknown(void)
{
	return policydb.allow_unknown;
}
struct context *sidtab_search(struct sidtab *s, u32 sid)
{
	return sidtab_search_core(s, sid, 0);
}
struct context *sidtab_search_force(struct sidtab *s, u32 sid)
{
	return sidtab_search_core(s, sid, 1);
}
static inline int selinux_authorizable_ctx(struct xfrm_sec_ctx *ctx)
{
	return (ctx &&
		(ctx->ctx_doi == XFRM_SC_DOI_LSM) &&
		(ctx->ctx_alg == XFRM_SC_ALG_SELINUX));
}
static inline int selinux_authorizable_xfrm(struct xfrm_state *x)
{
	return selinux_authorizable_ctx(x->security);
}
void selinux_xfrm_policy_free(struct xfrm_sec_ctx *ctx)
{
	kfree(ctx);
}
static int smack_inode_getattr(struct vfsmount *mnt, struct dentry *dentry)
{
	return smk_curacc(smk_of_inode(dentry->d_inode), MAY_READ);
}
static int smack_inode_getxattr(struct dentry *dentry, const char *name)
{
	return smk_curacc(smk_of_inode(dentry->d_inode), MAY_READ);
}
static int smack_file_permission(struct file *file, int mask)
{
	return 0;
}
static void smack_file_free_security(struct file *file)
{
	file->f_security = NULL;
}
static int smack_file_lock(struct file *file, unsigned int cmd)
{
	return smk_curacc(file->f_security, MAY_WRITE);
}
static void smack_cred_free(struct cred *cred)
{
	cred->security = NULL;
}
static int smack_task_setpgid(struct task_struct *p, pid_t pgid)
{
	return smk_curacc(task_security(p), MAY_WRITE);
}
static int smack_task_getpgid(struct task_struct *p)
{
	return smk_curacc(task_security(p), MAY_READ);
}
static int smack_task_getsid(struct task_struct *p)
{
	return smk_curacc(task_security(p), MAY_READ);
}
static void smack_task_getsecid(struct task_struct *p, u32 *secid)
{
	*secid = smack_to_secid(task_security(p));
}
static int smack_task_getioprio(struct task_struct *p)
{
	return smk_curacc(task_security(p), MAY_READ);
}
static int smack_task_getscheduler(struct task_struct *p)
{
	return smk_curacc(task_security(p), MAY_READ);
}
static int smack_task_movememory(struct task_struct *p)
{
	return smk_curacc(task_security(p), MAY_WRITE);
}
static void smack_sk_free_security(struct sock *sk)
{
	kfree(sk->sk_security);
}
static void smack_msg_msg_free_security(struct msg_msg *msg)
{
	msg->security = NULL;
}
static char *smack_of_shm(struct shmid_kernel *shp)
{
	return (char *)shp->shm_perm.security;
}
static char *smack_of_sem(struct sem_array *sma)
{
	return (char *)sma->sem_perm.security;
}
static char *smack_of_msq(struct msg_queue *msq)
{
	return (char *)msq->q_perm.security;
}
static void smack_key_free(struct key *key)
{
	key->security = NULL;
}
static int smk_open_load(struct inode *inode, struct file *file)
{
	return seq_open(file, &load_seq_ops);
}
static int smk_open_cipso(struct inode *inode, struct file *file)
{
	return seq_open(file, &cipso_seq_ops);
}
static int smk_open_netlbladdr(struct inode *inode, struct file *file)
{
	return seq_open(file, &netlbladdr_seq_ops);
}
static int smk_get_sb(struct file_system_type *fs_type,
		      int flags, const char *dev_name, void *data,
		      struct vfsmount *mnt)
{
	return get_sb_single(fs_type, flags, data, smk_fill_super, mnt);
}
static inline bool tomoyo_is_byte_range(const char *str)
{
	return *str >= '0' && *str++ <= '3' &&
		*str >= '0' && *str++ <= '7' &&
		*str >= '0' && *str <= '7';
}
static inline bool tomoyo_is_alphabet_char(const char c)
{
	return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');
}
static inline u8 tomoyo_make_byte(const u8 c1, const u8 c2, const u8 c3)
{
	return ((c1 - '0') << 6) + ((c2 - '0') << 3) + (c3 - '0');
}
bool tomoyo_is_domain_def(const unsigned char *buffer)
{
	return !strncmp(buffer, TOMOYO_ROOT_NAME, TOMOYO_ROOT_NAME_LEN);
}
const char *tomoyo_get_msg(const bool is_enforce)
{
	if (is_enforce)
		return "ERROR";
	else
		return "WARNING";
}
bool tomoyo_verbose_mode(const struct tomoyo_domain_info *domain)
{
	return tomoyo_check_flags(domain, TOMOYO_VERBOSE) != 0;
}
static int tomoyo_release(struct inode *inode, struct file *file)
{
	return tomoyo_close_control(file);
}
static ssize_t tomoyo_read(struct file *file, char __user *buf, size_t count,
			   loff_t *ppos)
{
	return tomoyo_read_control(file, buf, count);
}
static ssize_t tomoyo_write(struct file *file, const char __user *buf,
			    size_t count, loff_t *ppos)
{
	return tomoyo_write_control(file, buf, count);
}
static void __init tomoyo_create_entry(const char *name, const mode_t mode,
				       struct dentry *parent, const u8 key)
{
	securityfs_create_file(name, mode, parent, ((u8 *) NULL) + key,
			       &tomoyo_operations);
}
const char *tomoyo_sp2keyword(const u8 operation)
{
	return (operation < TOMOYO_MAX_SINGLE_PATH_OPERATION)
		? tomoyo_sp_keyword[operation] : NULL;
}
const char *tomoyo_dp2keyword(const u8 operation)
{
	return (operation < TOMOYO_MAX_DOUBLE_PATH_OPERATION)
		? tomoyo_dp_keyword[operation] : NULL;
}
int tomoyo_write_globally_readable_policy(char *data, const bool is_delete)
{
	return tomoyo_update_globally_readable_entry(data, is_delete);
}
int tomoyo_write_pattern_policy(char *data, const bool is_delete)
{
	return tomoyo_update_file_pattern_entry(data, is_delete);
}
int tomoyo_write_no_rewrite_policy(char *data, const bool is_delete)
{
	return tomoyo_update_no_rewrite_entry(data, is_delete);
}
static int tomoyo_path_truncate(struct path *path, loff_t length,
				unsigned int time_attrs)
{
	return tomoyo_check_1path_perm(tomoyo_domain(),
				       TOMOYO_TYPE_TRUNCATE_ACL,
				       path);
}
static int ac97_bus_match(struct device *dev, struct device_driver *drv)
{
	return 1;
}
static int __init ac97_bus_init(void)
{
	return bus_register(&ac97_bus_type);
}
static void __exit ac97_bus_exit(void)
{
	bus_unregister(&ac97_bus_type);
}
static int onyx_dev_register(struct snd_device *dev)
{
	return 0;
}
static int __init onyx_init(void)
{
	return i2c_add_driver(&onyx_driver);
}
static void __exit onyx_exit(void)
{
	i2c_del_driver(&onyx_driver);
}
static struct tas *codec_to_tas(struct aoa_codec *codec)
{
	return container_of(codec, struct tas, codec);
}
static inline int tas_write_reg(struct tas *tas, u8 reg, u8 len, u8 *data)
{
	if (len == 1)
		return i2c_smbus_write_byte_data(&tas->i2c, reg, *data);
	else
		return i2c_smbus_write_i2c_block_data(&tas->i2c, reg, len, data);
}
static int tas_dev_register(struct snd_device *dev)
{
	return 0;
}
static int tas_usable(struct codec_info_item *cii,
		      struct transfer_info *ti,
		      struct transfer_info *out)
{
	return 1;
}
static int _tas_suspend(struct codec_info_item *cii, pm_message_t state)
{
	return tas_suspend(cii->codec_data);
}
static int _tas_resume(struct codec_info_item *cii)
{
	return tas_resume(cii->codec_data);
}
static int __init tas_init(void)
{
	return i2c_add_driver(&tas_driver);
}
static void __exit tas_exit(void)
{
	i2c_del_driver(&tas_driver);
}
static int toonie_dev_register(struct snd_device *dev)
{
	return 0;
}
static int toonie_usable(struct codec_info_item *cii,
			 struct transfer_info *ti,
			 struct transfer_info *out)
{
	return 1;
}
static int toonie_suspend(struct codec_info_item *cii, pm_message_t state)
{
	return 0;
}
static int toonie_resume(struct codec_info_item *cii)
{
	return 0;
}
static int __init aoa_init(void)
{
	return 0;
}
static void __exit aoa_exit(void)
{
	aoa_alsa_cleanup();
}
void soundbus_remove_one(struct soundbus_dev *dev)
{
	of_device_unregister(&dev->ofdev);
}
void soundbus_unregister_driver(struct soundbus_driver *drv)
{
	driver_unregister(&drv->driver);
}
static int __init soundbus_init(void)
{
	return bus_register(&soundbus_bus_type);
}
static void __exit soundbus_exit(void)
{
	bus_unregister(&soundbus_bus_type);
}
void i2sbus_control_destroy(struct i2sbus_control *c)
{
	kfree(c);
}
static int i2sbus_shutdown(struct macio_dev* dev)
{
	return 0;
}
static int __init soundbus_i2sbus_init(void)
{
	return macio_register_driver(&i2sbus_drv);
}
static void __exit soundbus_i2sbus_exit(void)
{
	macio_unregister_driver(&i2sbus_drv);
}
static int i2sbus_hw_params(struct snd_pcm_substream *substream,
			    struct snd_pcm_hw_params *params)
{
	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
}
static int i2sbus_playback_hw_free(struct snd_pcm_substream *substream)
{
	return i2sbus_hw_free(substream, 0);
}
static int i2sbus_record_hw_free(struct snd_pcm_substream *substream)
{
	return i2sbus_hw_free(substream, 1);
}
static int aaci_pcm_mmap(struct snd_pcm_substream *substream, struct vm_area_struct *vma)
{
	return devdma_mmap(NULL, substream, vma);
}
static int __init aaci_init(void)
{
	return amba_driver_register(&aaci_driver);
}
static void __exit aaci_exit(void)
{
	amba_driver_unregister(&aaci_driver);
}
static int __init pxa2xx_ac97_init(void)
{
	return platform_driver_register(&pxa2xx_ac97_driver);
}
static void __exit pxa2xx_ac97_exit(void)
{
	platform_driver_unregister(&pxa2xx_ac97_driver);
}
static int snd_sa11xx_uda1341_hw_params(struct snd_pcm_substream *substream,
					struct snd_pcm_hw_params *hw_params)
{
	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
}
static int snd_sa11xx_uda1341_hw_free(struct snd_pcm_substream *substream)
{
	return snd_pcm_lib_free_pages(substream);
}
static int __init atmel_abdac_init(void)
{
	return platform_driver_probe(&atmel_abdac_driver,
			atmel_abdac_probe);
}
static void __exit atmel_abdac_exit(void)
{
	platform_driver_unregister(&atmel_abdac_driver);
}
static int __init atmel_ac97c_init(void)
{
	return platform_driver_probe(&atmel_ac97c_driver,
			atmel_ac97c_probe);
}
static void __exit atmel_ac97c_exit(void)
{
	platform_driver_unregister(&atmel_ac97c_driver);
}
int snd_ctl_register_ioctl(snd_kctl_ioctl_func_t fcn)
{
	return _snd_ctl_register_ioctl(fcn, &snd_control_ioctls);
}
int snd_ctl_register_ioctl_compat(snd_kctl_ioctl_func_t fcn)
{
	return _snd_ctl_register_ioctl(fcn, &snd_control_compat_ioctls);
}
int snd_ctl_unregister_ioctl(snd_kctl_ioctl_func_t fcn)
{
	return _snd_ctl_unregister_ioctl(fcn, &snd_control_ioctls);
}
int snd_ctl_unregister_ioctl_compat(snd_kctl_ioctl_func_t fcn)
{
	return _snd_ctl_unregister_ioctl(fcn, &snd_control_compat_ioctls);
}
static void __exit snd_hwdep_proc_done(void)
{
	snd_info_free_entry(snd_hwdep_proc_entry);
}
static void snd_info_version_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)
{
	snd_iprintf(buffer,
		    "Advanced Linux Sound Architecture Driver Version "
		    CONFIG_SND_VERSION CONFIG_SND_DATE ".\n"
		   );
}
static void snd_card_id_read(struct snd_info_entry *entry,
			     struct snd_info_buffer *buffer)
{
	snd_iprintf(buffer, "%s\n", entry->card->id);
}
static loff_t snd_disconnect_llseek(struct file *file, loff_t offset, int orig)
{
	return -ENODEV;
}
static ssize_t snd_disconnect_read(struct file *file, char __user *buf,
				   size_t count, loff_t *offset)
{
	return -ENODEV;
}
static ssize_t snd_disconnect_write(struct file *file, const char __user *buf,
				    size_t count, loff_t *offset)
{
	return -ENODEV;
}
static unsigned int snd_disconnect_poll(struct file * file, poll_table * wait)
{
	return POLLERR | POLLNVAL;
}
static long snd_disconnect_ioctl(struct file *file,
				 unsigned int cmd, unsigned long arg)
{
	return -ENODEV;
}
static int snd_disconnect_mmap(struct file *file, struct vm_area_struct *vma)
{
	return -ENODEV;
}
static int snd_disconnect_fasync(int fd, struct file *file, int on)
{
	return -ENODEV;
}
static inline void inc_snd_pages(int order)
{
	snd_allocated_pages += 1 << order;
}
static inline void dec_snd_pages(int order)
{
	snd_allocated_pages -= 1 << order;
}
static int snd_mem_proc_open(struct inode *inode, struct file *file)
{
	return single_open(file, snd_mem_proc_read, NULL);
}
int copy_to_user_fromio(void __user *dst, const volatile void __iomem *src, size_t count)
{
	return copy_to_user(dst, (const void __force*)src, count) ? -EFAULT : 0;
}
int copy_from_user_toio(volatile void __iomem *dst, const void __user *src, size_t count)
{
	return copy_from_user((void __force *)dst, src, count) ? -EFAULT : 0;
}
static long snd_mixer_oss_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
	return snd_mixer_oss_ioctl1((struct snd_mixer_oss_file *) file->private_data, cmd, arg);
}
static long snd_mixer_oss_conv2(long val, long min, long max)
{
	return snd_mixer_oss_conv(val, 0, 100, min, max);
}
static inline void snd_leave_user(mm_segment_t fs)
{
	set_fs(fs);
}
static int snd_pcm_oss_get_mapbuf(struct snd_pcm_oss_file *pcm_oss_file, int stream, struct buffmem_desc __user * _info)
{
	return -EINVAL;
}
static void __exit alsa_pcm_oss_exit(void)
{
	snd_pcm_notify(&snd_pcm_oss_notify, 1);
}
static const char *snd_pcm_format_name(snd_pcm_format_t format)
{
	return snd_pcm_format_names[format];
}
static const char *snd_pcm_stream_name(int stream)
{
	return snd_pcm_stream_names[stream];
}
static const char *snd_pcm_access_name(snd_pcm_access_t access)
{
	return snd_pcm_access_names[access];
}
static const char *snd_pcm_subformat_name(snd_pcm_subformat_t subformat)
{
	return snd_pcm_subformat_names[subformat];
}
static const char *snd_pcm_tstamp_mode_name(int mode)
{
	return snd_pcm_tstamp_mode_names[mode];
}
static const char *snd_pcm_state_name(snd_pcm_state_t state)
{
	return snd_pcm_state_names[state];
}
static void snd_pcm_stream_proc_info_read(struct snd_info_entry *entry,
					  struct snd_info_buffer *buffer)
{
	snd_pcm_proc_info_read(((struct snd_pcm_str *)entry->private_data)->substream,
			       buffer);
}
static void snd_pcm_substream_proc_info_read(struct snd_info_entry *entry,
					     struct snd_info_buffer *buffer)
{
	snd_pcm_proc_info_read((struct snd_pcm_substream *)entry->private_data,
			       buffer);
}
static inline int snd_pcm_stream_proc_init(struct snd_pcm_str *pstr) { return 0; }
static inline int snd_pcm_stream_proc_done(struct snd_pcm_str *pstr) { return 0; }
static inline int snd_pcm_substream_proc_init(struct snd_pcm_substream *substream) { return 0; }
static inline int snd_pcm_substream_proc_done(struct snd_pcm_substream *substream) { return 0; }
static void snd_pcm_proc_done(void)
{
	snd_info_free_entry(snd_pcm_proc_entry);
}
int snd_pcm_hw_constraint_list(struct snd_pcm_runtime *runtime,
			       unsigned int cond,
			       snd_pcm_hw_param_t var,
			       struct snd_pcm_hw_constraint_list *l)
{
	return snd_pcm_hw_rule_add(runtime, cond, var,
				   snd_pcm_hw_rule_list, l,
				   var, -1);
}
int snd_pcm_hw_constraint_ratnums(struct snd_pcm_runtime *runtime, 
				  unsigned int cond,
				  snd_pcm_hw_param_t var,
				  struct snd_pcm_hw_constraint_ratnums *r)
{
	return snd_pcm_hw_rule_add(runtime, cond, var,
				   snd_pcm_hw_rule_ratnums, r,
				   var, -1);
}
int snd_pcm_hw_constraint_ratdens(struct snd_pcm_runtime *runtime, 
				  unsigned int cond,
				  snd_pcm_hw_param_t var,
				  struct snd_pcm_hw_constraint_ratdens *r)
{
	return snd_pcm_hw_rule_add(runtime, cond, var,
				   snd_pcm_hw_rule_ratdens, r,
				   var, -1);
}
int snd_pcm_hw_constraint_step(struct snd_pcm_runtime *runtime,
			       unsigned int cond,
			       snd_pcm_hw_param_t var,
			       unsigned long step)
{
	return snd_pcm_hw_rule_add(runtime, cond, var, 
				   snd_pcm_hw_rule_step, (void *) step,
				   var, -1);
}
int snd_pcm_hw_constraint_pow2(struct snd_pcm_runtime *runtime,
			       unsigned int cond,
			       snd_pcm_hw_param_t var)
{
	return snd_pcm_hw_rule_add(runtime, cond, var, 
				   snd_pcm_hw_rule_pow2, NULL,
				   var, -1);
}
int snd_pcm_format_linear(snd_pcm_format_t format)
{
	return snd_pcm_format_signed(format) >= 0;
}
static inline void snd_leave_user(mm_segment_t fs)
{
	set_fs(fs);
}
int snd_pcm_start(struct snd_pcm_substream *substream)
{
	return snd_pcm_action(&snd_pcm_action_start, substream,
			      SNDRV_PCM_STATE_RUNNING);
}
int snd_pcm_stop(struct snd_pcm_substream *substream, int state)
{
	return snd_pcm_action(&snd_pcm_action_stop, substream, state);
}
int snd_pcm_drain_done(struct snd_pcm_substream *substream)
{
	return snd_pcm_action_single(&snd_pcm_action_stop, substream,
				     SNDRV_PCM_STATE_SETUP);
}
static int snd_pcm_pause(struct snd_pcm_substream *substream, int push)
{
	return snd_pcm_action(&snd_pcm_action_pause, substream, push);
}
static int snd_pcm_resume(struct snd_pcm_substream *substream)
{
	return -ENOSYS;
}
static int snd_pcm_reset(struct snd_pcm_substream *substream)
{
	return snd_pcm_action_nonatomic(&snd_pcm_action_reset, substream, 0);
}
static void pcm_release_private(struct snd_pcm_substream *substream)
{
	snd_pcm_unlink(substream);
}
static int snd_pcm_mmap_status(struct snd_pcm_substream *substream, struct file *file,
			       struct vm_area_struct *area)
{
	return -ENXIO;
}
static int snd_pcm_mmap_control(struct snd_pcm_substream *substream, struct file *file,
				struct vm_area_struct *area)
{
	return -ENXIO;
}
unsigned long dummy_get_unmapped_area(struct file *file, unsigned long addr,
				      unsigned long len, unsigned long pgoff,
				      unsigned long flags)
{
	return 0;
}
long snd_rawmidi_kernel_write(struct snd_rawmidi_substream *substream,
			      const unsigned char *buf, long count)
{
	return snd_rawmidi_kernel_write1(substream, NULL, buf, count);
}
static void rtctimer_tasklet(unsigned long data)
{
	snd_timer_interrupt((struct snd_timer *)data, 1);
}
static void rtctimer_interrupt(void *private_data)
{
	tasklet_schedule(private_data);
}
static inline int register_proc(void) { return 0; }
static int
local_event(struct seq_oss_devinfo *dp, union evrec *q, struct snd_seq_event *ev)
{
	return -EINVAL;
}
char *
enabled_str(int bool)
{
	return bool ? "enabled" : "disabled";
}
void
snd_seq_oss_midi_setup(struct seq_oss_devinfo *dp)
{
	dp->max_mididev = max_midi_devs;
}
void
snd_seq_oss_readq_wait(struct seq_oss_readq *q)
{
	wait_event_interruptible_timeout(q->midi_sleep,
					 (q->qlen > 0 || q->head == q->tail),
					 q->pre_event_timeout);
}
void
snd_seq_oss_readq_info_read(struct seq_oss_readq *q, struct snd_info_buffer *buf)
{
	snd_iprintf(buf, "  read queue [%s] length = %d : tick = %ld\n",
		    (waitqueue_active(&q->midi_sleep) ? "sleeping":"running"),
		    q->qlen, q->input_time);
}
void __init
snd_seq_oss_synth_init(void)
{
	snd_use_lock_init(&midi_synth_dev.use_lock);
}
static inline void snd_leave_user(mm_segment_t fs)
{
	set_fs(fs);
}
static inline int snd_seq_write_pool_allocated(struct snd_seq_client *client)
{
	return snd_seq_total_cells(client->pool) > 0;
}
static void usage_free(struct snd_seq_usage *res, int num)
{
	res->cur -= num;
}
int snd_seq_kernel_client_enqueue(int client, struct snd_seq_event * ev,
				  int atomic, int hop)
{
	return kernel_client_enqueue(client, ev, NULL, 0, atomic, hop);
}
int snd_seq_kernel_client_enqueue_blocking(int client, struct snd_seq_event * ev,
					   struct file *file,
					   int atomic, int hop)
{
	return kernel_client_enqueue(client, ev, file, 1, atomic, hop);
}
void __exit snd_sequencer_device_done(void)
{
	snd_unregister_device(SNDRV_DEVICE_TYPE_SEQUENCER, NULL, 0);
}
void snd_seq_autoload_lock(void)
{
	snd_seq_in_init++;
}
void snd_seq_autoload_unlock(void)
{
	snd_seq_in_init--;
}
static void
dummy_free(void *private_data)
{
	kfree(private_data);
}
static void __exit alsa_seq_dummy_exit(void)
{
	delete_client();
}
static inline int snd_seq_pool_available(struct snd_seq_pool *pool)
{
	return pool->total_elements - atomic_read(&pool->counter);
}
static inline int snd_seq_output_ok(struct snd_seq_pool *pool)
{
	return snd_seq_pool_available(pool) >= pool->room;
}
int __init snd_sequencer_memory_init(void)
{
	return 0;
}
static void __exit alsa_seq_midi_exit(void)
{
	snd_seq_device_unregister_driver(SNDRV_SEQ_DEV_ID_MIDISYNTH);
}
static int __init alsa_seq_midi_emul_init(void)
{
	return 0;
}
void snd_midi_event_no_status(struct snd_midi_event *dev, int on)
{
	dev->nostat = on ? 1 : 0;
}
static void one_param_event(struct snd_midi_event *dev, struct snd_seq_event *ev)
{
	ev->data.control.value = dev->buf[1];
}
static void songpos_event(struct snd_midi_event *dev, struct snd_seq_event *ev)
{
	ev->data.control.value = (int)dev->buf[2] * 128 + (int)dev->buf[1];
}
static void one_param_decode(struct snd_seq_event *ev, unsigned char *buf)
{
	buf[0] = ev->data.control.value & 0x7f;
}
static int __init alsa_seq_midi_event_init(void)
{
	return 0;
}
static inline int addr_match(struct snd_seq_addr *r, struct snd_seq_addr *s)
{
	return (r->client == s->client) && (r->port == s->port);
}
int snd_seq_queue_get_cur_queues(void)
{
	return num_queues;
}
int __init snd_seq_queues_init(void)
{
	return 0;
}
static inline int check_access(struct snd_seq_queue *q, int client)
{
	return (q->owner == client) || (!q->locked && !q->klocked);
}
static int event_input_timer(struct snd_seq_event * ev, int direct, void *private_data, int atomic, int hop)
{
	return snd_seq_control_queue(ev, atomic, hop);
}
snd_seq_tick_time_t snd_seq_timer_get_cur_tick(struct snd_seq_timer *tmr)
{
	return tmr->tick.cur_tick;
}
static int __init alsa_virmidi_init(void)
{
	return 0;
}
int snd_timer_pause(struct snd_timer_instance * timeri)
{
	return _snd_timer_stop(timeri, 0, SNDRV_TIMER_EVENT_PAUSE);
}
int snd_timer_global_free(struct snd_timer *timer)
{
	return snd_timer_free(timer);
}
static void snd_timer_free_system(struct snd_timer *timer)
{
	kfree(timer->private_data);
}
static void __exit snd_timer_proc_done(void)
{
	snd_info_free_entry(snd_timer_proc_entry);
}
static inline void snd_card_dummy_pcm_timer_stop(struct snd_dummy_pcm *dpcm)
{
	del_timer(&dpcm->timer);
}
static void snd_card_dummy_runtime_free(struct snd_pcm_runtime *runtime)
{
	kfree(runtime->private_data);
}
static int snd_card_dummy_hw_params(struct snd_pcm_substream *substream,
				    struct snd_pcm_hw_params *hw_params)
{
	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
}
static int snd_card_dummy_hw_free(struct snd_pcm_substream *substream)
{
	return snd_pcm_lib_free_pages(substream);
}
static int snd_card_dummy_playback_close(struct snd_pcm_substream *substream)
{
	return 0;
}
static int snd_card_dummy_capture_close(struct snd_pcm_substream *substream)
{
	return 0;
}
static void __exit alsa_card_dummy_exit(void)
{
	snd_dummy_unregister_all();
}
static int __init alsa_card_ml403_ac97cr_init(void)
{
	return platform_driver_register(&snd_ml403_ac97cr_driver);
}
static void __exit alsa_card_ml403_ac97cr_exit(void)
{
	platform_driver_unregister(&snd_ml403_ac97cr_driver);
}
static void __exit alsa_card_mpu401_exit(void)
{
	snd_mpu401_unregister_all();
}
static void mpu401_write_port(struct snd_mpu401 *mpu, unsigned char data,
			      unsigned long addr)
{
	outb(data, addr);
}
static unsigned char mpu401_read_port(struct snd_mpu401 *mpu,
				      unsigned long addr)
{
	return inb(addr);
}
static void mpu401_write_mmio(struct snd_mpu401 *mpu, unsigned char data,
			      unsigned long addr)
{
	writeb(data, (void __iomem *)addr);
}
static unsigned char mpu401_read_mmio(struct snd_mpu401 *mpu,
				      unsigned long addr)
{
	return readb((void __iomem *)addr);
}
static int __init alsa_mpu401_uart_init(void)
{
	return 0;
}
static void snd_mtpav_remove_output_timer(struct mtpav *chip)
{
	del_timer(&chip->timer);
}
static void mts64_smpte_stop(struct parport *p)
{
	mts64_write_command(p, MTS64_CMD_SMPTE_STOP);
}
static void __exit snd_mts64_module_exit(void)
{
	snd_mts64_unregister_all();
}
static int __init alsa_opl3_init(void)
{
	return 0;
}
static inline void snd_leave_user(mm_segment_t fs)
{
	set_fs(fs);
}
void snd_opl3_synth_use_dec(struct snd_opl3 * opl3)
{
	module_put(opl3->card->module);
}
static void __exit alsa_opl3_seq_exit(void)
{
	snd_seq_device_unregister_driver(SNDRV_SEQ_DEV_ID_OPL3);
}
int snd_opl3_open(struct snd_hwdep * hw, struct file *file)
{
	return 0;
}
static int __init alsa_opl4_init(void)
{
	return 0;
}
void snd_opl4_free_proc(struct snd_opl4 *opl4)
{
	snd_info_free_entry(opl4->proc_entry);
}
static void snd_opl4_seq_use_dec(struct snd_opl4 *opl4)
{
	module_put(opl4->card->module);
}
static void __exit alsa_opl4_synth_exit(void)
{
	snd_seq_device_unregister_driver(SNDRV_SEQ_DEV_ID_OPL4);
}
static void __devexit alsa_card_pcsp_exit(struct snd_pcsp *chip)
{
	snd_card_free(chip->card);
}
static void __exit pcsp_exit(void)
{
	platform_driver_unregister(&pcsp_platform_driver);
}
void pcspkr_stop_sound(void)
{
	pcspkr_do_sound(0);
}
static inline void portman_write_command(struct portman *pm, u8 value)
{
	parport_write_control(pm->pardev->port, value);
}
static inline u8 portman_read_command(struct portman *pm)
{
	return parport_read_control(pm->pardev->port);
}
static inline u8 portman_read_status(struct portman *pm)
{
	return parport_read_status(pm->pardev->port);
}
static inline u8 portman_read_data(struct portman *pm)
{
	return parport_read_data(pm->pardev->port);
}
static inline void portman_write_data(struct portman *pm, u8 value)
{
	parport_write_data(pm->pardev->port, value);
}
static int snd_portman_midi_open(struct snd_rawmidi_substream *substream)
{
	return 0;
}
static int snd_portman_midi_close(struct snd_rawmidi_substream *substream)
{
	return 0;
}
static void __exit snd_portman_module_exit(void)
{
	snd_portman_unregister_all();
}
static inline int snd_uart16550_buffer_can_write(struct snd_uart16550 *uart,
						 int Num)
{
	if (uart->buff_in_count + Num < TX_BUFF_SIZE)
		return 1;
	else
		return 0;
}
static void __exit alsa_card_serial_exit(void)
{
	snd_serial_unregister_all();
}
static void __exit alsa_card_virmidi_exit(void)
{
	snd_virmidi_unregister_all();
}
static int __init alsa_vx_core_init(void)
{
	return 0;
}
static int vx_pcm_hw_params(struct snd_pcm_substream *subs,
				     struct snd_pcm_hw_params *hw_params)
{
	return snd_pcm_alloc_vmalloc_buffer(subs, params_buffer_bytes(hw_params));
}
static int vx_pcm_hw_free(struct snd_pcm_substream *subs)
{
	return snd_pcm_free_vmalloc_buffer(subs);
}
static void snd_cs8427_free(struct snd_i2c_device *device)
{
	kfree(device->private_data);
}
static int __init alsa_cs8427_module_init(void)
{
	return 0;
}
int snd_i2c_sendbytes(struct snd_i2c_device *device, unsigned char *bytes, int count)
{
	return device->bus->ops->sendbytes(device, bytes, count);
}
int snd_i2c_readbytes(struct snd_i2c_device *device, unsigned char *bytes, int count)
{
	return device->bus->ops->readbytes(device, bytes, count);
}
int snd_i2c_probeaddr(struct snd_i2c_bus *bus, unsigned short addr)
{
	return bus->ops->probeaddr(bus, addr);
}
static void snd_i2c_bit_set(struct snd_i2c_bus *bus, int clock, int data)
{
	bus->hw_ops.bit->setlines(bus, clock, data);
}
static int snd_i2c_bit_data(struct snd_i2c_bus *bus, int ack)
{
	return bus->hw_ops.bit->getdata(bus, ack);
}
static int __init alsa_i2c_init(void)
{
	return 0;
}
static inline int snd_uda1341_valid_reg(struct l3_client *clnt, unsigned short reg)
{
	return reg < uda1341_reg_last;
}
static void uda1341_detach(struct l3_client *clnt)
{
	kfree(clnt->driver_data);
}
static int __init uda1341_init(void)
{
	return l3_add_driver(&uda1341_driver);
}
static void __exit uda1341_exit(void)
{
	l3_del_driver(&uda1341_driver);
}
static inline unsigned char reg_read(struct ak4114 *ak4114, unsigned char reg)
{
	return ak4114->read(ak4114->private_data, reg);
}
static inline unsigned char reg_read(struct ak4117 *ak4117, unsigned char reg)
{
	return ak4117->read(ak4117->private_data, reg);
}
static int __init alsa_akm4xxx_module_init(void)
{
	return 0;
}
static int __init alsa_tea575x_module_init(void)
{
	return 0;
}
static void snd_tea6330_free(struct snd_i2c_device *device)
{
	kfree(device->private_data);
}
static int __init alsa_tea6330t_init(void)
{
	return 0;
}
static void __exit alsa_card_ad1816a_exit(void)
{
	pnp_unregister_card_driver(&ad1816a_pnpc_driver);
}
static inline void snd_ad1816a_out_mask(struct snd_ad1816a *chip, unsigned char reg,
				 unsigned char mask, unsigned char value)
{
	snd_ad1816a_out(chip, reg,
		(value & mask) | (snd_ad1816a_in(chip, reg) & ~mask));
}
static void snd_ad1816a_write_mask(struct snd_ad1816a *chip, unsigned char reg,
				   unsigned short mask, unsigned short value)
{
	snd_ad1816a_write(chip, reg,
		(value & mask) | (snd_ad1816a_read(chip, reg) & ~mask));
}
static int snd_ad1816a_hw_params(struct snd_pcm_substream *substream,
				 struct snd_pcm_hw_params *hw_params)
{
	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
}
static int snd_ad1816a_hw_free(struct snd_pcm_substream *substream)
{
	return snd_pcm_lib_free_pages(substream);
}
static int __init alsa_card_ad1848_init(void)
{
	return isa_register_driver(&snd_ad1848_driver, SNDRV_CARDS);
}
static void __exit alsa_card_ad1848_exit(void)
{
	isa_unregister_driver(&snd_ad1848_driver);
}
static void snd_adlib_free(struct snd_card *card)
{
	release_and_free_resource(card->private_data);
}
static int __init alsa_card_adlib_init(void)
{
	return isa_register_driver(&snd_adlib_driver, SNDRV_CARDS);
}
static void __exit alsa_card_adlib_exit(void)
{
	isa_unregister_driver(&snd_adlib_driver);
}
static void __exit alsa_card_als100_exit(void)
{
	pnp_unregister_card_driver(&als100_pnpc_driver);
}
static void __exit alsa_card_azt2320_exit(void)
{
	pnp_unregister_card_driver(&azt2320_pnpc_driver);
}
static int snd_cmi8330_isa_suspend(struct device *dev, unsigned int n,
				   pm_message_t state)
{
	return snd_cmi8330_suspend(dev_get_drvdata(dev));
}
static int snd_cmi8330_isa_resume(struct device *dev, unsigned int n)
{
	return snd_cmi8330_resume(dev_get_drvdata(dev));
}
static int snd_cmi8330_pnp_suspend(struct pnp_card_link *pcard, pm_message_t state)
{
	return snd_cmi8330_suspend(pnp_get_card_drvdata(pcard));
}
static int snd_cmi8330_pnp_resume(struct pnp_card_link *pcard)
{
	return snd_cmi8330_resume(pnp_get_card_drvdata(pcard));
}
static int __init alsa_card_cs4231_init(void)
{
	return isa_register_driver(&snd_cs4231_driver, SNDRV_CARDS);
}
static void __exit alsa_card_cs4231_exit(void)
{
	isa_unregister_driver(&snd_cs4231_driver);
}
static int snd_cs423x_isa_suspend(struct device *dev, unsigned int n,
				  pm_message_t state)
{
	return snd_cs423x_suspend(dev_get_drvdata(dev));
}
static int snd_cs423x_isa_resume(struct device *dev, unsigned int n)
{
	return snd_cs423x_resume(dev_get_drvdata(dev));
}
static int snd_cs4232_pnp_suspend(struct pnp_dev *pdev, pm_message_t state)
{
	return snd_cs423x_suspend(pnp_get_drvdata(pdev));
}
static int snd_cs4232_pnp_resume(struct pnp_dev *pdev)
{
	return snd_cs423x_resume(pnp_get_drvdata(pdev));
}
static int snd_cs423x_pnpc_suspend(struct pnp_card_link *pcard, pm_message_t state)
{
	return snd_cs423x_suspend(pnp_get_card_drvdata(pcard));
}
static int snd_cs423x_pnpc_resume(struct pnp_card_link *pcard)
{
	return snd_cs423x_resume(pnp_get_card_drvdata(pcard));
}
static int snd_cs4236_xrate(struct snd_pcm_runtime *runtime)
{
	return snd_pcm_hw_constraint_ratnums(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
					     &hw_constraints_clocks);
}

static inline int snd_cs4236_mixer_master_digital_invert_volume(int vol)
{
	return (vol < 64) ? 63 - vol : 64 + (71 - vol);
}        
static int __init alsa_cs4236_init(void)
{
	return 0;
}
static void __exit alsa_card_dt019x_exit(void)
{
	pnp_unregister_card_driver(&dt019x_pnpc_driver);
}
static int __devinit snd_es1688_match(struct device *dev, unsigned int n)
{
	return enable[n];
}
static int __init alsa_card_es1688_init(void)
{
	return isa_register_driver(&snd_es1688_driver, SNDRV_CARDS);
}
static void __exit alsa_card_es1688_exit(void)
{
	isa_unregister_driver(&snd_es1688_driver);
}
static int snd_es1688_ioctl(struct snd_pcm_substream *substream,
			    unsigned int cmd, void *arg)
{
	return snd_pcm_lib_ioctl(substream, cmd, arg);
}
static int snd_es1688_hw_params(struct snd_pcm_substream *substream,
				struct snd_pcm_hw_params *hw_params)
{
	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
}
static int snd_es1688_hw_free(struct snd_pcm_substream *substream)
{
	return snd_pcm_lib_free_pages(substream);
}
static int __init alsa_es1688_init(void)
{
	return 0;
}
static int snd_es18xx_pcm_hw_free(struct snd_pcm_substream *substream)
{
	return snd_pcm_lib_free_pages(substream);
}
static int snd_es18xx_reg_bits(struct snd_es18xx *chip, unsigned char reg,
			       unsigned char mask, unsigned char val)
{
	if (reg < 0xa0)
		return snd_es18xx_mixer_bits(chip, reg, mask, val);
	else
		return snd_es18xx_bits(chip, reg, mask, val);
}
static int snd_es18xx_reg_read(struct snd_es18xx *chip, unsigned char reg)
{
	if (reg < 0xa0)
		return snd_es18xx_mixer_read(chip, reg);
	else
		return snd_es18xx_read(chip, reg);
}
static int snd_es18xx_card_new(int dev, struct snd_card **cardp)
{
	return snd_card_create(index[dev], id[dev], THIS_MODULE,
			       sizeof(struct snd_audiodrive), cardp);
}
static int __devinit snd_es18xx_isa_match(struct device *pdev, unsigned int dev)
{
	return enable[dev] && !is_isapnp_selected(dev);
}
static int snd_es18xx_isa_suspend(struct device *dev, unsigned int n,
				  pm_message_t state)
{
	return snd_es18xx_suspend(dev_get_drvdata(dev), state);
}
static int snd_es18xx_isa_resume(struct device *dev, unsigned int n)
{
	return snd_es18xx_resume(dev_get_drvdata(dev));
}
static int snd_audiodrive_pnp_suspend(struct pnp_dev *pdev, pm_message_t state)
{
	return snd_es18xx_suspend(pnp_get_drvdata(pdev), state);
}
static int snd_audiodrive_pnp_resume(struct pnp_dev *pdev)
{
	return snd_es18xx_resume(pnp_get_drvdata(pdev));
}
static int snd_audiodrive_pnpc_suspend(struct pnp_card_link *pcard, pm_message_t state)
{
	return snd_es18xx_suspend(pnp_get_card_drvdata(pcard), state);
}
static int snd_audiodrive_pnpc_resume(struct pnp_card_link *pcard)
{
	return snd_es18xx_resume(pnp_get_card_drvdata(pcard));
}
int snd_gus_dram_write(struct snd_gus_card *gus, char __user *buffer,
		       unsigned int address, unsigned int size)
{
	return snd_gus_dram_poke(gus, buffer, address, size);
}
int snd_gus_dram_read(struct snd_gus_card *gus, char __user *buffer,
		      unsigned int address, unsigned int size,
		      int rom)
{
	return snd_gus_dram_peek(gus, buffer, address, size, rom);
}
void snd_gf1_ctrl_stop(struct snd_gus_card * gus, unsigned char reg)
{
	__snd_gf1_ctrl_stop(gus, reg);
}
void snd_gf1_write8(struct snd_gus_card * gus,
		    unsigned char reg,
		    unsigned char data)
{
	__snd_gf1_write8(gus, reg, data);
}
unsigned char snd_gf1_look8(struct snd_gus_card * gus, unsigned char reg)
{
	return __snd_gf1_look8(gus, reg);
}
void snd_gf1_write16(struct snd_gus_card * gus,
		     unsigned char reg,
		     unsigned int data)
{
	__snd_gf1_write16(gus, reg, data);
}
unsigned short snd_gf1_look16(struct snd_gus_card * gus, unsigned char reg)
{
	return __snd_gf1_look16(gus, reg);
}
void snd_gf1_adlib_write(struct snd_gus_card * gus,
                         unsigned char reg,
                         unsigned char data)
{
	__snd_gf1_adlib_write(gus, reg, data);
}
void snd_gf1_write_addr(struct snd_gus_card * gus, unsigned char reg,
                        unsigned int addr, short w_16bit)
{
	__snd_gf1_write_addr(gus, reg, addr, w_16bit);
}
unsigned int snd_gf1_read_addr(struct snd_gus_card * gus,
                               unsigned char reg,
                               short w_16bit)
{
	return __snd_gf1_read_addr(gus, reg, w_16bit);
}
void snd_gus_use_dec(struct snd_gus_card * gus)
{
	module_put(gus->card->module);
}
static int __init alsa_gus_init(void)
{
	return 0;
}
static int snd_gf1_pcm_capture_hw_free(struct snd_pcm_substream *substream)
{
	return snd_pcm_lib_free_pages(substream);
}
static void snd_gf1_pcm_playback_free(struct snd_pcm_runtime *runtime)
{
	kfree(runtime->private_data);
}
static void snd_gf1_default_interrupt_handler_midi_out(struct snd_gus_card * gus)
{
	snd_gf1_uart_cmd(gus, gus->gf1.uart_cmd &= ~0x20);
}
static void snd_gf1_default_interrupt_handler_midi_in(struct snd_gus_card * gus)
{
	snd_gf1_uart_cmd(gus, gus->gf1.uart_cmd &= ~0x80);
}
static void snd_gf1_default_interrupt_handler_timer1(struct snd_gus_card * gus)
{
	snd_gf1_i_write8(gus, SNDRV_GF1_GB_SOUND_BLASTER_CONTROL, gus->gf1.timer_enabled &= ~4);
}
static void snd_gf1_default_interrupt_handler_timer2(struct snd_gus_card * gus)
{
	snd_gf1_i_write8(gus, SNDRV_GF1_GB_SOUND_BLASTER_CONTROL, gus->gf1.timer_enabled &= ~8);
}
static void snd_gf1_default_interrupt_handler_dma_write(struct snd_gus_card * gus)
{
	snd_gf1_i_write8(gus, 0x41, 0x00);
}
static void snd_gf1_default_interrupt_handler_dma_read(struct snd_gus_card * gus)
{
	snd_gf1_i_write8(gus, 0x49, 0x00);
}
static int __devinit snd_gusclassic_match(struct device *dev, unsigned int n)
{
	return enable[n];
}
static int __init alsa_card_gusclassic_init(void)
{
	return isa_register_driver(&snd_gusclassic_driver, SNDRV_CARDS);
}
static void __exit alsa_card_gusclassic_exit(void)
{
	isa_unregister_driver(&snd_gusclassic_driver);
}
static int __devinit snd_gusextreme_match(struct device *dev, unsigned int n)
{
	return enable[n];
}
static int __init alsa_card_gusextreme_init(void)
{
	return isa_register_driver(&snd_gusextreme_driver, SNDRV_CARDS);
}
static void __exit alsa_card_gusextreme_exit(void)
{
	isa_unregister_driver(&snd_gusextreme_driver);
}
static int __devinit snd_gusmax_match(struct device *pdev, unsigned int dev)
{
	return enable[dev];
}
static int __init alsa_card_gusmax_init(void)
{
	return isa_register_driver(&snd_gusmax_driver, SNDRV_CARDS);
}
static void __exit alsa_card_gusmax_exit(void)
{
	isa_unregister_driver(&snd_gusmax_driver);
}
static int snd_opl3sa2_pnp_suspend(struct pnp_dev *pdev, pm_message_t state)
{
	return snd_opl3sa2_suspend(pnp_get_drvdata(pdev), state);
}
static int snd_opl3sa2_pnp_resume(struct pnp_dev *pdev)
{
	return snd_opl3sa2_resume(pnp_get_drvdata(pdev));
}
static int snd_opl3sa2_pnp_csuspend(struct pnp_card_link *pcard, pm_message_t state)
{
	return snd_opl3sa2_suspend(pnp_get_card_drvdata(pcard), state);
}
static int snd_opl3sa2_pnp_cresume(struct pnp_card_link *pcard)
{
	return snd_opl3sa2_resume(pnp_get_card_drvdata(pcard));
}
static int snd_opl3sa2_isa_suspend(struct device *dev, unsigned int n,
				   pm_message_t state)
{
	return snd_opl3sa2_suspend(dev_get_drvdata(dev), state);
}
static int snd_opl3sa2_isa_resume(struct device *dev, unsigned int n)
{
	return snd_opl3sa2_resume(dev_get_drvdata(dev));
}
static int aci_getvalue(struct snd_miro * miro, unsigned char index)
{
	return aci_cmd(miro, ACI_STATUS, index, -1);
}
static int aci_setvalue(struct snd_miro * miro, unsigned char index, int value)
{
	return aci_cmd(miro, index, value, -1);
}
static int __devinit snd_miro_match(struct device *devptr, unsigned int n)
{
	return 1;
}
static int __init alsa_card_miro_init(void)
{
	return isa_register_driver(&snd_miro_driver, 1);
}
static void __exit alsa_card_miro_exit(void)
{
	isa_unregister_driver(&snd_miro_driver);
}
void
snd_emu8000_ops_setup(struct snd_emu8000 *hw)
{
	hw->emu->ops = emu8000_ops;
}
static void
set_pitch(struct snd_emu8000 *hw, struct snd_emux_voice *vp)
{
	EMU8000_IP_WRITE(hw, vp->ch, vp->apitch);
}
static void
set_tremfreq(struct snd_emu8000 *hw, struct snd_emux_voice *vp)
{
	EMU8000_TREMFRQ_WRITE(hw, vp->ch, vp->reg.parm.tremfrq);
}
void
snd_emu8000_sample_reset(struct snd_emux *rec)
{
	snd_emux_terminate_all(rec);
}
static int calc_rate_offset(int hz)
{
	return snd_sf_linear_to_log(hz, OFFSET_SAMPLERATE, SAMPLERATE_RATIO);
}
static void __exit alsa_emu8000_exit(void)
{
	snd_seq_device_unregister_driver(SNDRV_SEQ_DEV_ID_EMU8000);
}
static void __exit alsa_card_es968_exit(void)
{
	pnp_unregister_card_driver(&es968_pnpc_driver);
}
static int __devinit snd_sb16_isa_match(struct device *pdev, unsigned int dev)
{
	return enable[dev] && !is_isapnp_selected(dev);
}
static int snd_sb16_isa_suspend(struct device *dev, unsigned int n,
				pm_message_t state)
{
	return snd_sb16_suspend(dev_get_drvdata(dev), state);
}
static int snd_sb16_isa_resume(struct device *dev, unsigned int n)
{
	return snd_sb16_resume(dev_get_drvdata(dev));
}
static int snd_sb16_pnp_suspend(struct pnp_card_link *pcard, pm_message_t state)
{
	return snd_sb16_suspend(pnp_get_card_drvdata(pcard), state);
}
static int snd_sb16_pnp_resume(struct pnp_card_link *pcard)
{
	return snd_sb16_resume(pnp_get_card_drvdata(pcard));
}
static int __init alsa_sb_csp_init(void)
{
	return 0;
}
static int snd_sb16_hw_params(struct snd_pcm_substream *substream,
			      struct snd_pcm_hw_params *hw_params)
{
	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
}
const struct snd_pcm_ops *snd_sb16dsp_get_pcm_ops(int direction)
{
	return direction == SNDRV_PCM_STREAM_PLAYBACK ?
		&snd_sb16_playback_ops : &snd_sb16_capture_ops;
}
static int __init alsa_sb16_init(void)
{
	return 0;
}
static int __init alsa_card_sb8_init(void)
{
	return isa_register_driver(&snd_sb8_driver, SNDRV_CARDS);
}
static void __exit alsa_card_sb8_exit(void)
{
	isa_unregister_driver(&snd_sb8_driver);
}
static int snd_sb8_hw_params(struct snd_pcm_substream *substream,
			     struct snd_pcm_hw_params *hw_params)
{
	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
}
static int __init alsa_sb8_init(void)
{
	return 0;
}
static int __init alsa_sb_common_init(void)
{
	return 0;
}
static int __init alsa_card_sc6000_init(void)
{
	return isa_register_driver(&snd_sc6000_driver, SNDRV_CARDS);
}
static void __exit alsa_card_sc6000_exit(void)
{
	isa_unregister_driver(&snd_sc6000_driver);
}
static irqreturn_t snd_sgalaxy_dummy_interrupt(int irq, void *dev_id)
{
	return IRQ_NONE;
}
static int __init alsa_card_sgalaxy_init(void)
{
	return isa_register_driver(&snd_sgalaxy_driver, SNDRV_CARDS);
}
static void __exit alsa_card_sgalaxy_exit(void)
{
	isa_unregister_driver(&snd_sgalaxy_driver);
}
static inline struct soundscape *get_card_soundscape(struct snd_card *c)
{
	return (struct soundscape *) (c->private_data);
}
static inline struct soundscape *get_mpu401_soundscape(struct snd_mpu401 * mpu)
{
	return (struct soundscape *) (mpu->private_data);
}
static inline struct soundscape *get_hwdep_soundscape(struct snd_hwdep * hw)
{
	return (struct soundscape *) (hw->private_data);
}
static inline void set_host_mode_unsafe(unsigned io_base)
{
	outb(0x0, HOST_CTRL_IO(io_base));
}
static inline void set_midi_mode_unsafe(unsigned io_base)
{
	outb(0x3, HOST_CTRL_IO(io_base));
}
static inline int verify_mpu401(const struct snd_mpu401 * mpu)
{
	return ((inb(MPU401C(mpu)) & 0xc0) == 0x80);
}
static inline void initialise_mpu401(const struct snd_mpu401 * mpu)
{
	outb(0, MPU401D(mpu));
}
static inline int 
wf_mpu_status (snd_wavefront_midi_t *midi)
{
	return inb (midi->mpu_status_port);
}
static inline int 
input_avail (snd_wavefront_midi_t *midi)
{
	return !(wf_mpu_status(midi) & INPUT_AVAIL);
}
static inline int
output_ready (snd_wavefront_midi_t *midi)
{
	return !(wf_mpu_status(midi) & OUTPUT_READY);
}
static inline int 
read_data (snd_wavefront_midi_t *midi)
{
	return inb (midi->mpu_data_port);
}
static inline void 
write_data (snd_wavefront_midi_t *midi, unsigned char byte)
{
	outb (byte, midi->mpu_data_port);
}
static inline int
wavefront_status (snd_wavefront_t *dev) 

{
	return inb (dev->status_port);
}
static int snd_wss_xrate(struct snd_pcm_runtime *runtime)
{
	return snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
					  &hw_constraints_rates);
}
static inline void wss_outb(struct snd_wss *chip, u8 offset, u8 val)
{
	outb(val, chip->port + offset);
}
static inline u8 wss_inb(struct snd_wss *chip, u8 offset)
{
	return inb(chip->port + offset);
}
static int snd_wss_playback_hw_free(struct snd_pcm_substream *substream)
{
	return snd_pcm_lib_free_pages(substream);
}
static int snd_wss_capture_hw_free(struct snd_pcm_substream *substream)
{
	return snd_pcm_lib_free_pages(substream);
}
const struct snd_pcm_ops *snd_wss_get_pcm_ops(int direction)
{
	return direction == SNDRV_PCM_STREAM_PLAYBACK ?
		&snd_wss_playback_ops : &snd_wss_capture_ops;
}
static int __init alsa_wss_init(void)
{
	return 0;
}
static void __exit au1000_exit(void)
{
	snd_card_free(au1000_card);
}
static inline u32 hal2_read(u32 *reg)
{
	return __raw_readl(reg);
}
static inline void hal2_write(u32 val, u32 *reg)
{
	__raw_writel(val, reg);
}
static inline void hal2_stop_dac(struct snd_hal2 *hal2)
{
	hal2->dac.pbus.pbus->pbdma_ctrl = HPC3_PDMACTRL_LD;
}
static inline void hal2_stop_adc(struct snd_hal2 *hal2)
{
	hal2->adc.pbus.pbus->pbdma_ctrl = HPC3_PDMACTRL_LD;
}
static int hal2_pcm_hw_free(struct snd_pcm_substream *substream)
{
	return snd_pcm_lib_free_pages(substream);
}
static int __init alsa_card_hal2_init(void)
{
	return platform_driver_register(&hal2_driver);
}
static void __exit alsa_card_hal2_exit(void)
{
	platform_driver_unregister(&hal2_driver);
}
static struct page *snd_sgio2audio_page(struct snd_pcm_substream *substream,
					unsigned long offset)
{
	return vmalloc_to_page(substream->runtime->dma_area + offset);
}
static int __init alsa_card_sgio2audio_init(void)
{
	return platform_driver_register(&sgio2audio_driver);
}
static void __exit alsa_card_sgio2audio_exit(void)
{
	platform_driver_unregister(&sgio2audio_driver);
}
static int __init aedsp16_test_dsp(int port)
{
	return ((aedsp16_read(port) == 0xaa) ? TRUE : FALSE);
}
static void __exit cleanup_aedsp16(void) {
	uninit_aedsp16();
}
static loff_t
au1550_llseek(struct file *file, loff_t offset, int origin)
{
	return -ESPIPE;
}
static int
au1550_release_mixdev(struct inode *inode, struct file *file)
{
	return 0;
}
static int
mixdev_ioctl(struct ac97_codec *codec, unsigned int cmd,
                        unsigned long arg)
{
	return codec->mixer_ioctl(codec, cmd, arg);
}
static inline u8 S16_TO_U8(s16 ch)
{
	return (u8) (ch >> 8) + 0x80;
}
static inline s16 U8_TO_S16(u8 ch)
{
	return (s16) (ch - 0x80) << 8;
}
static int __init
init_au1550(void)
{
	return au1550_probe();
}
static void __exit
cleanup_au1550(void)
{
	au1550_remove();
}
static void *AtaAlloc(unsigned int size, gfp_t flags)
{
	return atari_stram_alloc(size, "dmasound");
}
static void AtaFree(void *obj, unsigned int size)
{
	atari_stram_free( obj );
}
static void __exit dmasound_atari_cleanup(void)
{
	dmasound_deinit();
}
static inline void sound_silence(void)
{
	dmasound.mach.silence(); /* _MUST_ stop DMA */
}
static inline int sound_set_format(int format)
{
	return dmasound.mach.setFormat(format);
}
static inline void sq_play(void)
{
	dmasound.mach.play();
}
static void *AmiAlloc(unsigned int size, gfp_t flags)
{
	return amiga_chip_alloc((long)size, "dmasound [Paula]");
}
static void AmiFree(void *obj, unsigned int size)
{
	amiga_chip_free (obj);
}
static void AmiSilence(void)
{
	StopDMA();
}
static void *Q40Alloc(unsigned int size, gfp_t flags)
{
         return kmalloc(size, flags); /* change to vmalloc */
}
static void Q40Free(void *ptr, unsigned int size)
{
	kfree(ptr);
}
static int Q40SetVolume(int volume)
{
    return 0;
}
static void __exit dmasound_q40_cleanup(void)
{
	dmasound_deinit();
}
static void __devexit kahlua_cleanup_module(void)
{
	pci_unregister_driver(&kahlua_driver);
}
void
midi_synth_reset(int dev)
{
	leave_sysex(dev);
}
static inline int mpu401_status(struct mpu_config *devc)
{
	return inb(STATPORT(devc->base));
}
static inline void write_command(struct mpu_config *devc, unsigned char cmd)
{
	outb(cmd, COMDPORT(devc->base));
}
static inline int read_data(struct mpu_config *devc)
{
	return inb(DATAPORT(devc->base));
}
static inline void write_data(struct mpu_config *devc, unsigned char byte)
{
	outb(byte, DATAPORT(devc->base));
}
static int mpu401_start_read(int dev)
{
	return 0;
}
static int mpu401_end_read(int dev)
{
	return 0;
}
static int mpu401_buffer_status(int dev)
{
	return 0;		/*
				 * No data in buffers
				 */
}
static unsigned long clocks2ticks(unsigned long clocks)
{
	return ((clocks * curr_timebase) + (hw_timebase / 2)) / hw_timebase;
}
static void stop_metronome(int midi_dev)
{
	mpu_cmd(midi_dev, 0x84, 0);	/* Disable metronome */
}
void msnd_fifo_init(msnd_fifo *f)
{
	f->data = NULL;
}
void msnd_fifo_make_empty(msnd_fifo *f)
{
	f->len = f->tail = f->head = 0;
}
int init_module(void)
{
	return 0;
}
static void opl3_panning(int dev, int voice, int value)
{
	devc->voc[voice].panning = value;
}
unsigned char pas_read(int ioaddr)
{
	return inb(ioaddr + pas_translate_code);
}
void pas_write(unsigned char data, int ioaddr)
{
	outb((data), ioaddr + pas_translate_code);
}
static inline int __init probe_pas(struct address_info *hw_config)
{
	return detect_pas_hw(hw_config);
}
static void __exit cleanup_pas2(void)
{
	unload_pas(&cfg);
}
static int pas_midi_start_read(int dev)
{
	return 0;
}
static int pas_midi_end_read(int dev)
{
	return 0;
}
static int pas_buffer_status(int dev)
{
	return qlen;
}
static int ret_vol_mono(int left)
{
	return ((left << 8) | left);
}
static int ret_vol_stereo(int left, int right)
{
	return ((right << 8) | left);
}
static int call_ad_mixer(pss_confdata *devc,unsigned int cmd, void __user *arg)
{
	if (devc->ad_mixer_dev != NO_WSS_MIXER) 
		return mixer_devs[devc->ad_mixer_dev]->ioctl(devc->ad_mixer_dev, cmd, arg);
	else 
		return -EINVAL;
}
static void pss_coproc_close(void *dev_info, int sub_device)
{
	return;
}
static inline void __exit unload_pss_mpu(struct address_info *hw_config)
{
	unload_mpu401(hw_config);
}
static inline void __exit unload_pss_mss(struct address_info *hw_config)
{
	unload_ms_sound(hw_config);
}
static void ess_extended (sb_devc * devc)
{
	sb_dsp_command(devc, 0xc6);
}
static int sb_midi_start_read(int dev)
{
	return 0;
}
static int sb_midi_ioctl(int dev, unsigned cmd, void __user *arg)
{
        return -EINVAL;
}
void sb_mixer_set_stereo(sb_devc * devc, int mode)
{
	sb_chgmixer(devc, OUT_FILTER, STEREO_DAC, (mode ? STEREO_DAC : MONO_DAC));
}
static int detect_mixer(sb_devc * devc)
{
	return 1;
}
static void set_recsrc(sb_devc * devc, int src)
{
	sb_setmixer(devc, RECORD_SRC, (sb_getmixer(devc, RECORD_SRC) & ~7) | (src & 0x7));
}
static void seq_panic(void)
{
	seq_reset();
}
void sequencer_timer(unsigned long dummy)
{
	seq_startplay();
}
static ssize_t dac_audio_read(struct file *file, char *buf, size_t count,
			      loff_t * ppos)
{
	return -EINVAL;
}
static void do_sequencer_timer(unsigned long dummy)
{
	sequencer_timer(0);
}
void sound_stop_timer(void)
{
	del_timer(&seq_timer);
}
void conf_printf(char *name, struct address_info *hw_config)
{
	return;
}
void conf_printf2(char *name, int base, int irq, int dma, int dma2)
{
	return;
}
static void host_open(struct sscape_info *devc)
{
	outb((0x00), PORT(HOST_CTRL));	/* Put the board to the host mode */
}
static void host_close(struct sscape_info *devc)
{
	outb((0x03), PORT(HOST_CTRL));	/* Put the board to the MIDI mode */
}
static	int sscape_read_host_ctrl(sscape_info* devc)
{
	return host_read(devc);
}
static	void sscape_write_host_ctrl2(sscape_info *devc, int a, int b)
{
	host_command2(devc, a, b);
}
static int cs4297a_ioctl_mixdev(struct inode *inode, struct file *file,
			       unsigned int cmd, unsigned long arg)
{
	return mixer_ioctl((struct cs4297a_state *) file->private_data, cmd,
			   arg);
}
static int drain_adc(struct cs4297a_state *s, int nonblock)
{
	return 0;
}
static int cs4297a_mmap(struct file *file, struct vm_area_struct *vma)
{
        return -EINVAL;
}
static void __exit cs4297a_cleanup(void)
{
	CS_DBGOUT(CS_INIT | CS_FUNCTION, 2,
		  printk(KERN_INFO "cs4297a: cleanup_cs4297a() finished\n"));
}
static inline void __exit unload_trix_mpu(struct address_info *hw_config)
{
	unload_uart401(hw_config);
}
static inline void __exit unload_trix_sb(struct address_info *hw_config)
{
	sb_dsp_unload(hw_config, mpu);
}
static int uart401_status(uart401_devc * devc)
{
	return inb(STATPORT);
}
static void uart401_cmd(uart401_devc * devc, unsigned char cmd)
{
	outb((cmd), COMDPORT);
}
static int uart401_read(uart401_devc * devc)
{
	return inb(DATAPORT);
}
static void uart401_write(uart401_devc * devc, unsigned char byte)
{
	outb((byte), DATAPORT);
}
static inline int uart401_start_read(int dev)
{
	return 0;
}
static inline int uart401_end_read(int dev)
{
	return 0;
}
static inline int uart401_buffer_status(int dev)
{
	return 0;
}
static int uart6850_status(void)
{
	return inb(STATPORT);
}
static void uart6850_cmd(unsigned char cmd)
{
	outb(cmd, COMDPORT);
}
static int uart6850_read(void)
{
	return inb(DATAPORT);
}
static void uart6850_write(unsigned char byte)
{
	outb(byte, DATAPORT);
}
static inline int uart6850_command(int dev, unsigned char *midi_byte)
{
	return 1;
}
static inline int uart6850_start_read(int dev)
{
	return 0;
}
static inline int uart6850_end_read(int dev)
{
	return 0;
}
static inline int uart6850_buffer_status(int dev)
{
	return 0;		/*
				 * No data in buffers
				 */
}
static void __exit cleanup_uart6850(void)
{
	unload_uart6850(&cfg_mpu);
}
static inline int v_midi_start_read (int dev)
{
	return 0;
}
static inline int v_midi_ioctl (int dev, unsigned cmd, void __user *arg)
{
	return -EPERM;
}
static inline int __init probe_v_midi(struct address_info *hw_config)
{
	return(1);	/* always OK */
}
static void __exit cleanup_vmidi(void)
{
	unload_v_midi(&cfg);
}
static void vidc_audio_close(int dev)
{
	vidc_busy = 0;
}
static int vidc_audio_prepare_for_input(int dev, int bsize, int bcount)
{
	return -EINVAL;
}
static void vidc_audio_reset(int dev)
{
	dma_interrupt = NULL;
}
static int vidc_audio_local_qlen(int dev)
{
	return /*dma_count !=*/ 0;
}
static void __exit cleanup_vidc(void)
{
	unload_vidc(&cfg);
}
static __inline__ unsigned long li_readl(lithium_t *lith, int off)
{
	return * (volatile unsigned long *) (lith->page0 + off);
}
static __inline__ unsigned char li_readb(lithium_t *lith, int off)
{
	return * (volatile unsigned char *) (lith->page0 + off);
}
static __inline__ void li_writel(lithium_t *lith, int off, unsigned long val)
{
	* (volatile unsigned long *) (lith->page0 + off) = val;
}
static __inline__ void li_writeb(lithium_t *lith, int off, unsigned char val)
{
	* (volatile unsigned char *) (lith->page0 + off) = val;
}
static __inline__ int li_read_hwptr(dma_chan_t *chan)
{
	return CHUNKS_TO_BYTES(li_readb(chan->lith, chan->desc->hwptrreg));
}
static void ad1843_shutdown_dac(lithium_t *lith)
{
	ad1843_write_bits(lith, &ad1843_DA1F, 1);
}
static inline int
waveartist_cmd1(wavnc_info *devc, unsigned int cmd)
{
	return waveartist_cmd(devc, 1, &cmd, 0, NULL);
}
static int
waveartist_ioctl(int dev, unsigned int cmd, void __user * arg)
{
	return -EINVAL;
}
static int waveartist_get_mixer(wavnc_info *devc, int dev)
{
	return devc->levels[dev];
}
static inline unsigned long
harmony_read(struct snd_harmony *h, unsigned r)
{
	return __raw_readl(h->iobase + r);
}
static inline void
harmony_write(struct snd_harmony *h, unsigned r, unsigned long v)
{
	__raw_writel(v, h->iobase + r);
}
static int 
snd_harmony_hw_free(struct snd_pcm_substream *ss) 
{
	return snd_pcm_lib_free_pages(ss);
}
static int __init 
alsa_harmony_init(void)
{
	return register_parisc_driver(&snd_harmony_driver);
}
static void __exit
alsa_harmony_fini(void)
{
	unregister_parisc_driver(&snd_harmony_driver);
}
static void do_update_power(struct work_struct *work)
{
	update_power_regs(
		container_of(work, struct snd_ac97, power_work.work));
}
static int __init alsa_ac97_init(void)
{
	return 0;
}
static inline int is_surround_on(struct snd_ac97 *ac97)
{
	return ac97->channel_mode >= 1;
}
static inline int is_clfe_on(struct snd_ac97 *ac97)
{
	return ac97->channel_mode >= 2;
}
static inline int is_shared_surrout(struct snd_ac97 *ac97)
{
	return !ac97->indep_surround && is_surround_on(ac97);
}
static inline int is_shared_clfeout(struct snd_ac97 *ac97)
{
	return !ac97->indep_surround && is_clfe_on(ac97);
}
static inline int is_shared_linein(struct snd_ac97 *ac97)
{
	return !ac97->indep_surround && !is_surround_on(ac97);
}
static inline int is_shared_micin(struct snd_ac97 *ac97)
{
	return !ac97->indep_surround && !is_clfe_on(ac97);
}
static inline int alc850_is_aux_back_surround(struct snd_ac97 *ac97)
{
	return is_surround_on(ac97);
}
static int patch_ad198x_post_spdif(struct snd_ac97 * ac97)
{
 	return patch_build_controls(ac97, &snd_ac97_ad198x_spdif_source, 1);
}
static void cm9738_update_jacks(struct snd_ac97 *ac97)
{
	snd_ac97_update_bits(ac97, AC97_CM9738_VENDOR_CTRL, 1 << 10,
			     is_shared_surrout(ac97) ? (1 << 10) : 0);
}
static int patch_cm9738_specific(struct snd_ac97 * ac97)
{
	return patch_build_controls(ac97, snd_ac97_cm9738_controls, ARRAY_SIZE(snd_ac97_cm9738_controls));
}
static int patch_cm9739_specific(struct snd_ac97 * ac97)
{
	return patch_build_controls(ac97, snd_ac97_cm9739_controls, ARRAY_SIZE(snd_ac97_cm9739_controls));
}
static int patch_cm9739_post_spdif(struct snd_ac97 * ac97)
{
	return patch_build_controls(ac97, snd_ac97_cm9739_controls_spdif, ARRAY_SIZE(snd_ac97_cm9739_controls_spdif));
}
static int patch_cm9761_post_spdif(struct snd_ac97 * ac97)
{
	return patch_build_controls(ac97, snd_ac97_cm9761_controls_spdif, ARRAY_SIZE(snd_ac97_cm9761_controls_spdif));
}
static int patch_cm9761_specific(struct snd_ac97 * ac97)
{
	return patch_build_controls(ac97, snd_ac97_cm9761_controls, ARRAY_SIZE(snd_ac97_cm9761_controls));
}
static int patch_cm9780_specific(struct snd_ac97 *ac97)
{
	return patch_build_controls(ac97, cm9780_controls, ARRAY_SIZE(cm9780_controls));
}
static int snd_ac97_vt1618_UAJ_info(struct snd_kcontrol *kcontrol,
				    struct snd_ctl_elem_info *uinfo)
{
	return ac97_enum_text_info(kcontrol, uinfo,
				   vt1618_uaj[kcontrol->private_value].items,
				   4);
}
static int snd_ac97_vt1618_UAJ_put(struct snd_kcontrol *kcontrol,
				   struct snd_ctl_elem_value *ucontrol)
{
	return ac97_update_bits_page(snd_kcontrol_chip(kcontrol), 0x60,
				     vt1618_uaj[kcontrol->private_value].mask,
				     ucontrol->value.enumerated.item[0]<<
				     vt1618_uaj[kcontrol->private_value].shift,
				     0);
}
static int patch_vt1618(struct snd_ac97 *ac97)
{
	return patch_build_controls(ac97, snd_ac97_controls_vt1618,
				    ARRAY_SIZE(snd_ac97_controls_vt1618));
}
static inline u16
ad1889_readw(struct snd_ad1889 *chip, unsigned reg)
{
	return readw(chip->iobase + reg);
}
static inline void
ad1889_writew(struct snd_ad1889 *chip, unsigned reg, u16 val)
{
	writew(val, chip->iobase + reg);
}
static inline u32
ad1889_readl(struct snd_ad1889 *chip, unsigned reg)
{
	return readl(chip->iobase + reg);
}
static inline void
ad1889_writel(struct snd_ad1889 *chip, unsigned reg, u32 val)
{
	writel(val, chip->iobase + reg);
}
static int 
snd_ad1889_hw_params(struct snd_pcm_substream *substream,
			struct snd_pcm_hw_params *hw_params)
{
	return snd_pcm_lib_malloc_pages(substream, 
					params_buffer_bytes(hw_params));
}
static int
snd_ad1889_hw_free(struct snd_pcm_substream *substream)
{
	return snd_pcm_lib_free_pages(substream);
}
static int __init
alsa_ad1889_init(void)
{
	return pci_register_driver(&ad1889_pci_driver);
}
static void __exit
alsa_ad1889_fini(void)
{
	pci_unregister_driver(&ad1889_pci_driver);
}
static inline unsigned int snd_ali_5451_peek(struct snd_ali *codec,
					     unsigned int port)
{
	return (unsigned int)inl(ALI_REG(codec, port)); 
}
static inline void snd_ali_5451_poke(struct snd_ali *codec,
				     unsigned int port,
				     unsigned int val)
{
	outl((unsigned int)val, ALI_REG(codec, port));
}
static int snd_ali_hw_params(struct snd_pcm_substream *substream,
			     struct snd_pcm_hw_params *hw_params)
{
	return snd_pcm_lib_malloc_pages(substream,
					params_buffer_bytes(hw_params));
}
static int snd_ali_hw_free(struct snd_pcm_substream *substream)
{
	return snd_pcm_lib_free_pages(substream);
}
static int snd_ali_playback_open(struct snd_pcm_substream *substream)
{
	return snd_ali_open(substream, 0, -1, &snd_ali_playback);
}
static int snd_ali_capture_open(struct snd_pcm_substream *substream)
{
	return snd_ali_open(substream, 1, -1, &snd_ali_capture);
}
static int snd_ali_playback_close(struct snd_pcm_substream *substream)
{
	return 0;
}
static int snd_ali_modem_playback_open(struct snd_pcm_substream *substream)
{
	return snd_ali_modem_open(substream, 0, ALI_MODEM_OUT_CHANNEL);
}
static int snd_ali_modem_capture_open(struct snd_pcm_substream *substream)
{
	return snd_ali_modem_open(substream, 1, ALI_MODEM_IN_CHANNEL);
}
static int __init alsa_card_ali_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_ali_exit(void)
{
	pci_unregister_driver(&driver);
}
static int snd_als300_pcm_hw_params(struct snd_pcm_substream *substream,
				    struct snd_pcm_hw_params *hw_params)
{
	return snd_pcm_lib_malloc_pages(substream,
					params_buffer_bytes(hw_params));
}
static int snd_als300_pcm_hw_free(struct snd_pcm_substream *substream)
{
	return snd_pcm_lib_free_pages(substream);
}
static int __init alsa_card_als300_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_als300_exit(void)
{
	pci_unregister_driver(&driver);
}
static inline void snd_als4k_iobase_writeb(unsigned long iobase,
						enum als4k_iobase_t reg,
						u8 val)
{
	outb(val, iobase + reg);
}
static inline void snd_als4k_iobase_writel(unsigned long iobase,
						enum als4k_iobase_t reg,
						u32 val)
{
	outl(val, iobase + reg);
}
static inline u8 snd_als4k_iobase_readb(unsigned long iobase,
						enum als4k_iobase_t reg)
{
	return inb(iobase + reg);
}
static inline u32 snd_als4k_iobase_readl(unsigned long iobase,
						enum als4k_iobase_t reg)
{
	return inl(iobase + reg);
}

static inline void snd_als4k_gcr_write(struct snd_sb *sb,
					 enum als4k_gcr_t reg,
					 u32 val)
{
	snd_als4k_gcr_write_addr(sb->alt_port, reg, val);
}	
static inline u32 snd_als4k_gcr_read(struct snd_sb *sb, enum als4k_gcr_t reg)
{
	return snd_als4k_gcr_read_addr(sb->alt_port, reg);
}
static inline void snd_als4_cr_write(struct snd_sb *chip,
					enum als4k_cr_t reg,
					u8 data)
{
	snd_sbmixer_write(chip, reg | 0xc0, data);
}
static inline u8 snd_als4_cr_read(struct snd_sb *chip,
					enum als4k_cr_t reg)
{
	return snd_sbmixer_read(chip, reg | 0xc0);
}
static int snd_als4000_hw_params(struct snd_pcm_substream *substream,
				 struct snd_pcm_hw_params *hw_params)
{
	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
}
static inline int snd_als4000_create_gameport(struct snd_card_als4000 *acard, int dev) { return -ENOSYS; }
static int __init alsa_card_als4000_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_als4000_exit(void)
{
	pci_unregister_driver(&driver);
}
static void atiixp_out_flush_dma(struct atiixp *chip)
{
	atiixp_write(chip, FIFO_FLUSH, ATI_REG_FIFO_OUT_FLUSH);
}
static void atiixp_out_enable_transfer(struct atiixp *chip, int on)
{
	atiixp_update(chip, CMD, ATI_REG_CMD_SEND_EN,
		      on ? ATI_REG_CMD_SEND_EN : 0);
}
static void atiixp_in_enable_dma(struct atiixp *chip, int on)
{
	atiixp_update(chip, CMD, ATI_REG_CMD_IN_DMA_EN,
		      on ? ATI_REG_CMD_IN_DMA_EN : 0);
}
static void atiixp_in_flush_dma(struct atiixp *chip)
{
	atiixp_write(chip, FIFO_FLUSH, ATI_REG_FIFO_IN_FLUSH);
}
static void atiixp_spdif_enable_dma(struct atiixp *chip, int on)
{
	atiixp_update(chip, CMD, ATI_REG_CMD_SPDF_DMA_EN,
		      on ? ATI_REG_CMD_SPDF_DMA_EN : 0);
}
static int __init alsa_card_atiixp_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_atiixp_exit(void)
{
	pci_unregister_driver(&driver);
}
static void atiixp_out_flush_dma(struct atiixp_modem *chip)
{
	atiixp_write(chip, MODEM_FIFO_FLUSH, ATI_REG_MODEM_FIFO_OUT1_FLUSH);
}
static void atiixp_out_enable_transfer(struct atiixp_modem *chip, int on)
{
	atiixp_update(chip, CMD, ATI_REG_CMD_MODEM_SEND1_EN,
		      on ? ATI_REG_CMD_MODEM_SEND1_EN : 0);
}
static void atiixp_in_enable_dma(struct atiixp_modem *chip, int on)
{
	atiixp_update(chip, CMD, ATI_REG_CMD_MODEM_IN_DMA_EN,
		      on ? ATI_REG_CMD_MODEM_IN_DMA_EN : 0);
}
static void atiixp_in_flush_dma(struct atiixp_modem *chip)
{
	atiixp_write(chip, MODEM_FIFO_FLUSH, ATI_REG_MODEM_FIFO_IN_FLUSH);
}
static int snd_atiixp_capture_prepare(struct snd_pcm_substream *substream)
{
	return 0;
}
static int __init alsa_card_atiixp_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_atiixp_exit(void)
{
	pci_unregister_driver(&driver);
}
static int __init alsa_card_vortex_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_vortex_exit(void)
{
	pci_unregister_driver(&driver);
}
static int
snd_vortex_a3d_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
{
	return 0;
}
static void vortex_mixer_en_sr(vortex_t * vortex, int channel)
{
	hwwrite(vortex->mmio, VORTEX_MIXER_SR,
		hwread(vortex->mmio, VORTEX_MIXER_SR) | (0x1 << channel));
}
static void vortex_mixer_dis_sr(vortex_t * vortex, int channel)
{
	hwwrite(vortex->mmio, VORTEX_MIXER_SR,
		hwread(vortex->mmio, VORTEX_MIXER_SR) & ~(0x1 << channel));
}
static void vortex_src_en_sr(vortex_t * vortex, int channel)
{
	hwwrite(vortex->mmio, VORTEX_SRCBLOCK_SR,
		hwread(vortex->mmio, VORTEX_SRCBLOCK_SR) | (0x1 << channel));
}
static void vortex_src_dis_sr(vortex_t * vortex, int channel)
{
	hwwrite(vortex->mmio, VORTEX_SRCBLOCK_SR,
		hwread(vortex->mmio, VORTEX_SRCBLOCK_SR) & ~(0x1 << channel));
}
static void vortex_fifo_setadbvalid(vortex_t * vortex, int fifo, int en)
{
	hwwrite(vortex->mmio, VORTEX_FIFO_ADBCTRL + (fifo << 2),
		(hwread(vortex->mmio, VORTEX_FIFO_ADBCTRL + (fifo << 2)) &
		 0xffffffef) | ((1 & en) << 4) | FIFO_U1);
}
static void vortex_fifo_setwtvalid(vortex_t * vortex, int fifo, int en)
{
	hwwrite(vortex->mmio, VORTEX_FIFO_WTCTRL + (fifo << 2),
		(hwread(vortex->mmio, VORTEX_FIFO_WTCTRL + (fifo << 2)) &
		 0xffffffef) | ((en & 1) << 4) | FIFO_U1);
}
static void vortex_adb_en_sr(vortex_t * vortex, int channel)
{
	hwwrite(vortex->mmio, VORTEX_ADB_SR,
		hwread(vortex->mmio, VORTEX_ADB_SR) | (0x1 << channel));
}
static void vortex_adb_dis_sr(vortex_t * vortex, int channel)
{
	hwwrite(vortex->mmio, VORTEX_ADB_SR,
		hwread(vortex->mmio, VORTEX_ADB_SR) & ~(0x1 << channel));
}
static void
vortex_connection_adbdma_src(vortex_t * vortex, int en, unsigned char ch,
			     unsigned char adbdma, unsigned char src)
{
	vortex_route(vortex, en, ch, ADB_DMA(adbdma), ADB_SRCIN(src));
}
static void
vortex_connection_src_mixin(vortex_t * vortex, int en,
			    unsigned char channel, unsigned char src,
			    unsigned char mixin)
{
	vortex_route(vortex, en, channel, ADB_SRCOUT(src), ADB_MIXIN(mixin));
}
static void
vortex_connection_adb_mixin(vortex_t * vortex, int en,
			    unsigned char channel, unsigned char source,
			    unsigned char mixin)
{
	vortex_route(vortex, en, channel, source, ADB_MIXIN(mixin));
}
static void
vortex_connection_src_adbdma(vortex_t * vortex, int en, unsigned char ch,
			     unsigned char src, unsigned char adbdma)
{
	vortex_route(vortex, en, ch, ADB_SRCOUT(src), ADB_DMA(adbdma));
}
static void
vortex_connection_src_src_adbdma(vortex_t * vortex, int en,
				 unsigned char ch, unsigned char src0,
				 unsigned char src1, unsigned char adbdma)
{
	vortex_routeLRT(vortex, en, ch, ADB_SRCOUT(src0), ADB_SRCOUT(src1),
			ADB_DMA(adbdma));
}
static void vortex_settimer(vortex_t * vortex, int period)
{
	hwwrite(vortex->mmio, VORTEX_IRQ_STAT, period);
}
static void vortex_disable_int(vortex_t * card)
{
	hwwrite(card->mmio, VORTEX_CTRL,
		hwread(card->mmio, VORTEX_CTRL) & ~CTRL_IRQ_ENABLE);
}
static inline u16 sign_invert(u16 a)
{
	if (a == (u16)-32768)
		return 32767;
	else
		return -a;
}
static void
vortex_EqHw_SetLeftGainsSingleTarget(vortex_t * vortex, u16 index, u16 b)
{
	hwwrite(vortex->mmio, 0x2b02c + (index * 0x30), b);
}
static void
vortex_EqHw_SetRightGainsSingleTarget(vortex_t * vortex, u16 index, u16 b)
{
	hwwrite(vortex->mmio, 0x2b20c + (index * 0x30), b);
}
static void vortex_EqHw_SetControlReg(vortex_t * vortex, u32 reg)
{
	hwwrite(vortex->mmio, 0x2b440, reg);
}
static void vortex_EqHw_SetSampleRate(vortex_t * vortex, u32 sr)
{
	hwwrite(vortex->mmio, 0x2b440, ((sr & 0x1f) << 3) | 0xb800);
}
static void vortex_EqHw_Enable(vortex_t * vortex)
{
	hwwrite(vortex->mmio, VORTEX_EQ_CTRL, 0xf001);
}
static void vortex_EqHw_Disable(vortex_t * vortex)
{
	hwwrite(vortex->mmio, VORTEX_EQ_CTRL, 0xf000);
}
static inline int vortex_gameport_register(vortex_t * vortex) { return -ENOSYS; }
static void
vortex_XtalkHw_SetGainsAllChan(vortex_t * vortex)
{
	vortex_XtalkHw_SetGains(vortex, asXtalkGainsAllChan);
}
static void vortex_XtalkHw_init(vortex_t * vortex)
{
	vortex_XtalkHw_ZeroState(vortex);
}
static int snd_aw2_pcm_playback_close(struct snd_pcm_substream *substream)
{
	return 0;
}
static int snd_aw2_pcm_capture_close(struct snd_pcm_substream *substream)
{
	return 0;
}
static int snd_aw2_pcm_hw_params(struct snd_pcm_substream *substream,
				 struct snd_pcm_hw_params *hw_params)
{
	return snd_pcm_lib_malloc_pages(substream,
					params_buffer_bytes(hw_params));
}
static int snd_aw2_pcm_hw_free(struct snd_pcm_substream *substream)
{
	return snd_pcm_lib_free_pages(substream);
}
static inline void
snd_azf3328_codec_outb(const struct snd_azf3328 *chip, unsigned reg, u8 value)
{
	outb(value, chip->codec_io + reg);
}
static inline u8
snd_azf3328_codec_inb(const struct snd_azf3328 *chip, unsigned reg)
{
	return inb(chip->codec_io + reg);
}
static inline void
snd_azf3328_codec_outw(const struct snd_azf3328 *chip, unsigned reg, u16 value)
{
	outw(value, chip->codec_io + reg);
}
static inline u16
snd_azf3328_codec_inw(const struct snd_azf3328 *chip, unsigned reg)
{
	return inw(chip->codec_io + reg);
}
static inline void
snd_azf3328_codec_outl(const struct snd_azf3328 *chip, unsigned reg, u32 value)
{
	outl(value, chip->codec_io + reg);
}
static inline u32
snd_azf3328_codec_inl(const struct snd_azf3328 *chip, unsigned reg)
{
	return inl(chip->codec_io + reg);
}
static inline void
snd_azf3328_game_outb(const struct snd_azf3328 *chip, unsigned reg, u8 value)
{
	outb(value, chip->game_io + reg);
}
static inline void
snd_azf3328_game_outw(const struct snd_azf3328 *chip, unsigned reg, u16 value)
{
	outw(value, chip->game_io + reg);
}
static inline u8
snd_azf3328_game_inb(const struct snd_azf3328 *chip, unsigned reg)
{
	return inb(chip->game_io + reg);
}
static inline u16
snd_azf3328_game_inw(const struct snd_azf3328 *chip, unsigned reg)
{
	return inw(chip->game_io + reg);
}
static inline void
snd_azf3328_mixer_outw(const struct snd_azf3328 *chip, unsigned reg, u16 value)
{
	outw(value, chip->mixer_io + reg);
}
static inline u16
snd_azf3328_mixer_inw(const struct snd_azf3328 *chip, unsigned reg)
{
	return inw(chip->mixer_io + reg);
}
static inline void
snd_azf3328_codec_setfmt_lowpower(struct snd_azf3328 *chip,
			    unsigned reg
)
{
	snd_azf3328_codec_setfmt(chip, reg, AZF_FREQ_4000, 8, 1);
}
static inline void
snd_azf3328_gameport_irq_enable(struct snd_azf3328 *chip, int enable)
{
	snd_azf3328_io_reg_setb(
		chip->game_io+IDX_GAME_HWCONFIG,
		GAME_HWCFG_IRQ_ENABLE,
		enable
	);
}
static inline void
snd_azf3328_gameport_legacy_address_enable(struct snd_azf3328 *chip, int enable)
{
	snd_azf3328_io_reg_setb(
		chip->game_io+IDX_GAME_HWCONFIG,
		GAME_HWCFG_LEGACY_ADDRESS_ENABLE,
		enable
	);
}
static inline void
snd_azf3328_gameport_axis_circuit_enable(struct snd_azf3328 *chip, int enable)
{
	snd_azf3328_codec_reg_6AH_update(
		chip, IO_6A_SOMETHING2_GAMEPORT, enable
	);
}
static inline int
snd_azf3328_gameport(struct snd_azf3328 *chip, int dev) { return -ENOSYS; }
static inline void
snd_azf3328_gameport_interrupt(struct snd_azf3328 *chip)
{
	printk(KERN_WARNING "huh, game port IRQ occurred!?\n");
}
static inline void
snd_azf3328_irq_log_unknown_type(u8 which)
{
	snd_azf3328_dbgplay(
	"azt3328: unknown IRQ type (%x) occurred, please report!\n",
		which
	);
}
static inline u32 snd_bt87x_readl(struct snd_bt87x *chip, u32 reg)
{
	return readl(chip->mmio + reg);
}
static inline void snd_bt87x_writel(struct snd_bt87x *chip, u32 reg, u32 value)
{
	writel(value, chip->mmio + reg);
}
static void __exit alsa_card_bt87x_exit(void)
{
	pci_unregister_driver(&driver);
}
static void snd_ca0106_pcm_free_substream(struct snd_pcm_runtime *runtime)
{
	kfree(runtime->private_data);
}
static int snd_ca0106_pcm_open_playback_front(struct snd_pcm_substream *substream)
{
	return snd_ca0106_pcm_open_playback_channel(substream, PCM_FRONT_CHANNEL);
}
static int snd_ca0106_pcm_open_playback_center_lfe(struct snd_pcm_substream *substream)
{
	return snd_ca0106_pcm_open_playback_channel(substream, PCM_CENTER_LFE_CHANNEL);
}
static int snd_ca0106_pcm_open_playback_unknown(struct snd_pcm_substream *substream)
{
	return snd_ca0106_pcm_open_playback_channel(substream, PCM_UNKNOWN_CHANNEL);
}
static int snd_ca0106_pcm_open_playback_rear(struct snd_pcm_substream *substream)
{
	return snd_ca0106_pcm_open_playback_channel(substream, PCM_REAR_CHANNEL);
}
static int snd_ca0106_pcm_open_0_capture(struct snd_pcm_substream *substream)
{
	return snd_ca0106_pcm_open_capture_channel(substream, 0);
}
static int snd_ca0106_pcm_open_1_capture(struct snd_pcm_substream *substream)
{
	return snd_ca0106_pcm_open_capture_channel(substream, 1);
}
static int snd_ca0106_pcm_open_2_capture(struct snd_pcm_substream *substream)
{
	return snd_ca0106_pcm_open_capture_channel(substream, 2);
}
static int snd_ca0106_pcm_open_3_capture(struct snd_pcm_substream *substream)
{
	return snd_ca0106_pcm_open_capture_channel(substream, 3);
}
static int snd_ca0106_pcm_hw_params_playback(struct snd_pcm_substream *substream,
				      struct snd_pcm_hw_params *hw_params)
{
	return snd_pcm_lib_malloc_pages(substream,
					params_buffer_bytes(hw_params));
}
static int snd_ca0106_pcm_hw_free_playback(struct snd_pcm_substream *substream)
{
	return snd_pcm_lib_free_pages(substream);
}
static int snd_ca0106_pcm_hw_params_capture(struct snd_pcm_substream *substream,
				      struct snd_pcm_hw_params *hw_params)
{
	return snd_pcm_lib_malloc_pages(substream,
					params_buffer_bytes(hw_params));
}
static int snd_ca0106_pcm_hw_free_capture(struct snd_pcm_substream *substream)
{
	return snd_pcm_lib_free_pages(substream);
}
static void ca0106_midi_interrupt_enable(struct snd_ca_midi *midi, int intr)
{
	snd_ca0106_intr_enable((struct snd_ca0106 *)(midi->dev_id), intr);
}
static void ca0106_midi_interrupt_disable(struct snd_ca_midi *midi, int intr)
{
	snd_ca0106_intr_disable((struct snd_ca0106 *)(midi->dev_id), intr);
}
static unsigned char ca0106_midi_read(struct snd_ca_midi *midi, int idx)
{
	return (unsigned char)snd_ca0106_ptr_read((struct snd_ca0106 *)(midi->dev_id),
						  midi->port + idx, 0);
}
static void ca0106_midi_write(struct snd_ca_midi *midi, int data, int idx)
{
	snd_ca0106_ptr_write((struct snd_ca0106 *)(midi->dev_id), midi->port + idx, 0, data);
}
static struct snd_card *ca0106_dev_id_card(void *dev_id)
{
	return ((struct snd_ca0106 *)dev_id)->card;
}
static int ca0106_dev_id_port(void *dev_id)
{
	return ((struct snd_ca0106 *)dev_id)->port;
}
static int __init alsa_card_ca0106_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_ca0106_exit(void)
{
	pci_unregister_driver(&driver);
}
static void ca0106_set_spdif_bits(struct snd_ca0106 *emu, int idx)
{
	snd_ca0106_ptr_write(emu, SPCS0 + idx, 0, emu->spdif_str_bits[idx]);
}
static unsigned int encode_spdif_bits(unsigned char *status)
{
	return ((unsigned int)status[0] << 0) |
		((unsigned int)status[1] << 8) |
		((unsigned int)status[2] << 16) |
		((unsigned int)status[3] << 24);
}
static void ca_rmidi_free(struct snd_rawmidi *rmidi)
{
	ca_midi_free(rmidi->private_data);
}
static inline void snd_cmipci_write(struct cmipci *cm, unsigned int cmd, unsigned int data)
{
	outl(data, cm->iobase + cmd);
}
static inline unsigned int snd_cmipci_read(struct cmipci *cm, unsigned int cmd)
{
	return inl(cm->iobase + cmd);
}
static inline void snd_cmipci_write_w(struct cmipci *cm, unsigned int cmd, unsigned short data)
{
	outw(data, cm->iobase + cmd);
}
static inline unsigned short snd_cmipci_read_w(struct cmipci *cm, unsigned int cmd)
{
	return inw(cm->iobase + cmd);
}
static inline void snd_cmipci_write_b(struct cmipci *cm, unsigned int cmd, unsigned char data)
{
	outb(data, cm->iobase + cmd);
}
static inline unsigned char snd_cmipci_read_b(struct cmipci *cm, unsigned int cmd)
{
	return inb(cm->iobase + cmd);
}
static int snd_cmipci_hw_params(struct snd_pcm_substream *substream,
				struct snd_pcm_hw_params *hw_params)
{
	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
}
static int snd_cmipci_hw_free(struct snd_pcm_substream *substream)
{
	return snd_pcm_lib_free_pages(substream);
}
static int snd_cmipci_get_native_mixer_sensitive(struct snd_kcontrol *kcontrol,
						 struct snd_ctl_elem_value *ucontrol)
{
	return snd_cmipci_get_native_mixer(kcontrol, ucontrol);
}
static inline int snd_cmipci_create_gameport(struct cmipci *cm, int dev) { return -ENOSYS; }
static int __init alsa_card_cmipci_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_cmipci_exit(void)
{
	pci_unregister_driver(&driver);
}
static inline void snd_cs4281_pokeBA0(struct cs4281 *chip, unsigned long offset,
				      unsigned int val)
{
        writel(val, chip->ba0 + offset);
}
static inline unsigned int snd_cs4281_peekBA0(struct cs4281 *chip, unsigned long offset)
{
        return readl(chip->ba0 + offset);
}
static int snd_cs4281_hw_params(struct snd_pcm_substream *substream,
				struct snd_pcm_hw_params *hw_params)
{
	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
}
static int snd_cs4281_hw_free(struct snd_pcm_substream *substream)
{
	return snd_pcm_lib_free_pages(substream);
}
static inline int snd_cs4281_create_gameport(struct cs4281 *chip) { return -ENOSYS; }
static int __init alsa_card_cs4281_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_cs4281_exit(void)
{
	pci_unregister_driver(&driver);
}
static int __init alsa_card_cs46xx_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_cs46xx_exit(void)
{
	pci_unregister_driver(&driver);
}
static void snd_cs46xx_proc_stop(struct snd_cs46xx *chip)
{
	snd_cs46xx_poke(chip, BA1_SPCR, 0);
}
static void snd_cs46xx_pcm_free_substream(struct snd_pcm_runtime *runtime)
{
	kfree(runtime->private_data);
}
int __devinit snd_cs46xx_gameport(struct snd_cs46xx *chip) { return -ENOSYS; }
static int __init alsa_card_cs5530_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_cs5530_exit(void)
{
	pci_unregister_driver(&driver);
}
static int __init alsa_card_cs5535audio_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_cs5535audio_exit(void)
{
	pci_unregister_driver(&driver);
}
static int snd_cs5535audio_playback_close(struct snd_pcm_substream *substream)
{
	return 0;
}
static void cs5535audio_playback_enable_dma(struct cs5535audio *cs5535au)
{
	cs_writeb(cs5535au, ACC_BM0_CMD, BM_CTL_EN);
}
static void cs5535audio_playback_disable_dma(struct cs5535audio *cs5535au)
{
	cs_writeb(cs5535au, ACC_BM0_CMD, 0);
}
static void cs5535audio_playback_pause_dma(struct cs5535audio *cs5535au)
{
	cs_writeb(cs5535au, ACC_BM0_CMD, BM_CTL_PAUSE);
}
static void cs5535audio_playback_setup_prd(struct cs5535audio *cs5535au,
					   u32 prd_addr)
{
	cs_writel(cs5535au, ACC_BM0_PRD, prd_addr);
}
static u32 cs5535audio_playback_read_prd(struct cs5535audio *cs5535au)
{
	return cs_readl(cs5535au, ACC_BM0_PRD);
}
static u32 cs5535audio_playback_read_dma_pntr(struct cs5535audio *cs5535au)
{
	return cs_readl(cs5535au, ACC_BM0_PNTR);
}
static void cs5535audio_capture_enable_dma(struct cs5535audio *cs5535au)
{
	cs_writeb(cs5535au, ACC_BM1_CMD, BM_CTL_EN);
}
static void cs5535audio_capture_disable_dma(struct cs5535audio *cs5535au)
{
	cs_writeb(cs5535au, ACC_BM1_CMD, 0);
}
static void cs5535audio_capture_pause_dma(struct cs5535audio *cs5535au)
{
	cs_writeb(cs5535au, ACC_BM1_CMD, BM_CTL_PAUSE);
}
static void cs5535audio_capture_setup_prd(struct cs5535audio *cs5535au,
					  u32 prd_addr)
{
	cs_writel(cs5535au, ACC_BM1_PRD, prd_addr);
}
static u32 cs5535audio_capture_read_prd(struct cs5535audio *cs5535au)
{
	return cs_readl(cs5535au, ACC_BM1_PRD);
}
static u32 cs5535audio_capture_read_dma_pntr(struct cs5535audio *cs5535au)
{
	return cs_readl(cs5535au, ACC_BM1_PNTR);
}
static void snd_cs5535audio_stop_hardware(struct cs5535audio *cs5535au)
{
	cs_writel(cs5535au, ACC_CODEC_CNTL, ACC_CODEC_CNTL_LNK_SHUTDOWN);
}
static u32 detect_input_clocks(const struct echoaudio *chip)
{
	return ECHO_CLOCK_BIT_INTERNAL;
}
static int load_asic(struct echoaudio *chip)
{
	return 0;
}
static int load_asic(struct echoaudio *chip)
{
	return 0;
}
static int pcm_analog_out_hw_params(struct snd_pcm_substream *substream,
				    struct snd_pcm_hw_params *hw_params)
{
	return init_engine(substream, hw_params, substream->number,
			   params_channels(hw_params));
}
static int __init alsa_card_echo_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_echo_exit(void)
{
	pci_unregister_driver(&driver);
}
static inline u32 get_frq_reg(struct echoaudio *chip)
{
	return le32_to_cpu(chip->comm_page->e3g_frq_register);
}
static inline int is_pipe_allocated(struct echoaudio *chip, u16 pipe_index)
{
	return (chip->pipe_alloc_mask & (1 << pipe_index));
}
static inline int sglist_add_irq(struct echoaudio *chip, struct audiopipe *pipe)
{
	return sglist_add_mapping(chip, pipe, 0, 0);
}
static inline int sglist_wrap(struct echoaudio *chip, struct audiopipe *pipe)
{
	return sglist_add_mapping(chip, pipe, pipe->sgpage.addr, 0);
}
static int load_asic(struct echoaudio *chip)
{
	return 0;
}
static u32 detect_input_clocks(const struct echoaudio *chip)
{
	return ECHO_CLOCK_BIT_INTERNAL;
}
static int load_asic(struct echoaudio *chip)
{
	return 0;
}
static u32 detect_input_clocks(const struct echoaudio *chip)
{
	return ECHO_CLOCK_BIT_INTERNAL;
}
static int load_asic(struct echoaudio *chip)
{
	return 0;
}
static u32 detect_input_clocks(const struct echoaudio *chip)
{
	return ECHO_CLOCK_BIT_INTERNAL;
}
static int load_asic(struct echoaudio *chip)
{
	return 0;
}
static int load_asic(struct echoaudio *chip)
{
	return 0;
}
static int __init alsa_card_emu10k1_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_emu10k1_exit(void)
{
	pci_unregister_driver(&driver);
}
void
snd_emu10k1_ops_setup(struct snd_emux *emux)
{
	emux->ops = emu10k1_ops;
}
static void __exit alsa_emu10k1_synth_exit(void)
{
	snd_seq_device_unregister_driver(SNDRV_SEQ_DEV_ID_EMU10K1_SYNTH);
}
static void snd_emu10k1x_pcm_free_substream(struct snd_pcm_runtime *runtime)
{
	kfree(runtime->private_data);
}
static int snd_emu10k1x_playback_close(struct snd_pcm_substream *substream)
{
	return 0;
}
static int snd_emu10k1x_pcm_close_capture(struct snd_pcm_substream *substream)
{
	return 0;
}
static inline unsigned char mpu401_read(struct emu10k1x *emu, struct emu10k1x_midi *mpu, int idx)
{
	return (unsigned char)snd_emu10k1x_ptr_read(emu, mpu->port + idx, 0);
}
static inline void mpu401_write(struct emu10k1x *emu, struct emu10k1x_midi *mpu, int data, int idx)
{
	snd_emu10k1x_ptr_write(emu, mpu->port + idx, 0, data);
}
static void snd_emu10k1x_midi_interrupt(struct emu10k1x *emu, unsigned int status)
{
	do_emu10k1x_midi_interrupt(emu, &emu->midi, status);
}
static int __init alsa_card_emu10k1x_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_emu10k1x_exit(void)
{
	pci_unregister_driver(&driver);
}
static inline void snd_leave_user(mm_segment_t fs)
{
	set_fs(fs);
}
static int snd_emu10k1_fx8010_open(struct snd_hwdep * hw, struct file *file)
{
	return 0;
}
static int snd_emu10k1_fx8010_release(struct snd_hwdep * hw, struct file *file)
{
	return 0;
}
static inline unsigned char mpu401_read(struct snd_emu10k1 *emu,
					struct snd_emu10k1_midi *mpu, int idx)
{
	if (emu->audigy)
		return (unsigned char)snd_emu10k1_ptr_read(emu, mpu->port + idx, 0);
	else
		return inb(emu->port + mpu->port + idx);
}
static void snd_emu10k1_midi_interrupt(struct snd_emu10k1 *emu, unsigned int status)
{
	do_emu10k1_midi_interrupt(emu, &emu->midi, status);
}
static void snd_emu10k1_midi_interrupt2(struct snd_emu10k1 *emu, unsigned int status)
{
	do_emu10k1_midi_interrupt(emu, &emu->midi2, status);
}
static void snd_emu10k1_pcm_ac97adc_interrupt(struct snd_emu10k1 *emu,
					      unsigned int status)
{
	snd_pcm_period_elapsed(emu->pcm_capture_substream);
}
static void snd_emu10k1_pcm_ac97mic_interrupt(struct snd_emu10k1 *emu,
					      unsigned int status)
{
	snd_pcm_period_elapsed(emu->pcm_capture_mic_substream);
}
static void snd_emu10k1_pcm_efx_interrupt(struct snd_emu10k1 *emu,
					  unsigned int status)
{
#endif
	snd_pcm_period_elapsed(emu->pcm_capture_efx_substream);
}	 
static unsigned int emu10k1_select_interprom(unsigned int pitch_target)
{
	if (pitch_target == PITCH_48000)
		return CCCA_INTERPROM_0;
	else if (pitch_target < PITCH_48000)
		return CCCA_INTERPROM_1;
	else if (pitch_target >= PITCH_96000)
		return CCCA_INTERPROM_0;
	else if (pitch_target >= PITCH_85000)
		return CCCA_INTERPROM_6;
	else if (pitch_target >= PITCH_80726)
		return CCCA_INTERPROM_5;
	else if (pitch_target >= PITCH_67882)
		return CCCA_INTERPROM_4;
	else if (pitch_target >= PITCH_57081)
		return CCCA_INTERPROM_3;
	else  
		return CCCA_INTERPROM_2;
}
static int snd_emu10k1_capture_hw_params(struct snd_pcm_substream *substream,
					 struct snd_pcm_hw_params *hw_params)
{
	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
}
static int snd_emu10k1_capture_hw_free(struct snd_pcm_substream *substream)
{
	return snd_pcm_lib_free_pages(substream);
}
static void snd_emu10k1_pcm_free_substream(struct snd_pcm_runtime *runtime)
{
	kfree(runtime->private_data);
}
static int snd_emu10k1_fx8010_playback_hw_params(struct snd_pcm_substream *substream,
						 struct snd_pcm_hw_params *hw_params)
{
	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
}
static void snd_emu_proc_ptr_reg_write00(struct snd_info_entry *entry,
					 struct snd_info_buffer *buffer)
{
	snd_emu_proc_ptr_reg_write(entry, buffer, 0);
}
static void snd_emu_proc_ptr_reg_write20(struct snd_info_entry *entry,
					 struct snd_info_buffer *buffer)
{
	snd_emu_proc_ptr_reg_write(entry, buffer, 0x20);
}
static void snd_emu_proc_ptr_reg_read00a(struct snd_info_entry *entry,
					 struct snd_info_buffer *buffer)
{
	snd_emu_proc_ptr_reg_read(entry, buffer, 0, 0, 0x40, 64);
}
static void snd_emu_proc_ptr_reg_read00b(struct snd_info_entry *entry,
					 struct snd_info_buffer *buffer)
{
	snd_emu_proc_ptr_reg_read(entry, buffer, 0, 0x40, 0x40, 64);
}
static void snd_emu_proc_ptr_reg_read20a(struct snd_info_entry *entry,
					 struct snd_info_buffer *buffer)
{
	snd_emu_proc_ptr_reg_read(entry, buffer, 0x20, 0, 0x40, 4);
}
static void snd_emu_proc_ptr_reg_read20b(struct snd_info_entry *entry,
					 struct snd_info_buffer *buffer)
{
	snd_emu_proc_ptr_reg_read(entry, buffer, 0x20, 0x40, 0x40, 4);
}
static void snd_emu_proc_ptr_reg_read20c(struct snd_info_entry *entry,
					 struct snd_info_buffer * buffer)
{
	snd_emu_proc_ptr_reg_read(entry, buffer, 0x20, 0x80, 0x20, 4);
}
static int snd_p16v_pcm_open_playback_front(struct snd_pcm_substream *substream)
{
	return snd_p16v_pcm_open_playback_channel(substream, PCM_FRONT_CHANNEL);
}
static int snd_p16v_pcm_open_capture(struct snd_pcm_substream *substream)
{
	return snd_p16v_pcm_open_capture_channel(substream, 0);
}
void snd_p16v_free_pm_buffer(struct snd_emu10k1 *emu)
{
	vfree(emu->p16v_saved);
}
static int snd_ensoniq_hw_params(struct snd_pcm_substream *substream,
				 struct snd_pcm_hw_params *hw_params)
{
	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
}
static int snd_ensoniq_hw_free(struct snd_pcm_substream *substream)
{
	return snd_pcm_lib_free_pages(substream);
}
static inline int snd_ensoniq_get_joystick_port(int dev)
{
	return joystick[dev] ? 0x200 : 0;
}
static inline int snd_ensoniq_create_gameport(struct ensoniq *ensoniq, long port) { return -ENOSYS; }
static int __init alsa_card_ens137x_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_ens137x_exit(void)
{
	pci_unregister_driver(&driver);
}
static int snd_es1938_pcm_hw_free(struct snd_pcm_substream *substream)
{
	return snd_pcm_lib_free_pages(substream);
}
static int snd_es1938_reg_bits(struct es1938 *chip, unsigned char reg,
			       unsigned char mask, unsigned char val)
{
	if (reg < 0xa0)
		return snd_es1938_mixer_bits(chip, reg, mask, val);
	else
		return snd_es1938_bits(chip, reg, mask, val);
}
static int snd_es1938_reg_read(struct es1938 *chip, unsigned char reg)
{
	if (reg < 0xa0)
		return snd_es1938_mixer_read(chip, reg);
	else
		return snd_es1938_read(chip, reg);
}
static inline int snd_es1938_create_gameport(struct es1938 *chip) { return -ENOSYS; }
static int __init alsa_card_es1938_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_es1938_exit(void)
{
	pci_unregister_driver(&driver);
}
static inline void snd_es1968_trigger_apu(struct es1968 *esm, int apu, int mode)
{
	__apu_set_register(esm, apu, 0,
			   (__apu_get_register(esm, apu, 0) & 0xff0f) |
			   (mode << 4));
}
static void snd_es1968_free_apu_pair(struct es1968 *chip, int apu)
{
	chip->apu[apu] = chip->apu[apu + 1] = ESM_APU_FREE;
}
static inline int snd_es1968_create_gameport(struct es1968 *chip, int dev) { return -ENOSYS; }
static int __init alsa_card_es1968_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_es1968_exit(void)
{
	pci_unregister_driver(&driver);
}
static int snd_fm801_hw_params(struct snd_pcm_substream *substream,
			       struct snd_pcm_hw_params *hw_params)
{
	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
}
static int snd_fm801_hw_free(struct snd_pcm_substream *substream)
{
	return snd_pcm_lib_free_pages(substream);
}
static int __init alsa_card_fm801_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_fm801_exit(void)
{
	pci_unregister_driver(&driver);
}
static void free_hda_cache(struct hda_cache_rec *cache)
{
	snd_array_free(&cache->buf);
}
static inline struct hda_amp_info *
get_alloc_amp_hash(struct hda_codec *codec, u32 key)
{
	return (struct hda_amp_info *)get_alloc_hash(&codec->amp_cache, key);
}
struct snd_kcontrol *snd_hda_find_mixer_ctl(struct hda_codec *codec,
					    const char *name)
{
	return _snd_hda_find_mixer_ctl(codec, name, 0);
}
static int hda_pcm_default_open_close(struct hda_pcm_stream *hinfo,
				      struct hda_codec *codec,
				      struct snd_pcm_substream *substream)
{
	return 0;
}
static int hdmi_present_sense(struct hda_codec *codec, hda_nid_t nid)
{
	return snd_hda_codec_read(codec, nid, 0, AC_VERB_GET_PIN_SENSE, 0);
}
int snd_hdmi_get_eld_size(struct hda_codec *codec, hda_nid_t nid)
{
	return snd_hda_codec_read(codec, nid, 0, AC_VERB_GET_HDMI_DIP_SIZE,
						 AC_DIPSIZE_ELD_BUF);
}
static int hda_hwdep_ioctl_compat(struct snd_hwdep *hw, struct file *file,
				  unsigned int cmd, unsigned long arg)
{
	return hda_hwdep_ioctl(hw, file, cmd, (unsigned long)compat_ptr(arg));
}
static void hwdep_free(struct snd_hwdep *hwdep)
{
	clear_hwdep_elements(hwdep->private_data);
}
static void azx_int_enable(struct azx *chip)
{
	azx_writel(chip, INTCTL, azx_readl(chip, INTCTL) |
		   ICH6_INT_CTRL_EN | ICH6_INT_GLOBAL_EN);
}
static inline void azx_release_device(struct azx_dev *azx_dev)
{
	azx_dev->opened = 0;
}
static int azx_pcm_hw_params(struct snd_pcm_substream *substream,
			     struct snd_pcm_hw_params *hw_params)
{
	return snd_pcm_lib_malloc_pages(substream,
					params_buffer_bytes(hw_params));
}
static int __devinit azx_mixer_create(struct azx *chip)
{
	return snd_hda_build_controls(chip->bus);
}
static int azx_resume_early(struct pci_dev *pci)
{
	return pci_restore_state(pci);
}
static int azx_dev_free(struct snd_device *device)
{
	return azx_free(device->device_data);
}
static int __init alsa_card_azx_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_azx_exit(void)
{
	pci_unregister_driver(&driver);
}
static int __init patch_analog_init(void)
{
	return snd_hda_add_codec_preset(&analog_list);
}
static void __exit patch_analog_exit(void)
{
	snd_hda_delete_codec_preset(&analog_list);
}
static void atihdmi_free(struct hda_codec *codec)
{
	kfree(codec->spec);
}
static int __init patch_atihdmi_init(void)
{
	return snd_hda_add_codec_preset(&atihdmi_list);
}
static void __exit patch_atihdmi_exit(void)
{
	snd_hda_delete_codec_preset(&atihdmi_list);
}
static void cmi9880_free(struct hda_codec *codec)
{
	kfree(codec->spec);
}
static int __init patch_cmedia_init(void)
{
	return snd_hda_add_codec_preset(&cmedia_list);
}
static void __exit patch_cmedia_exit(void)
{
	snd_hda_delete_codec_preset(&cmedia_list);
}
static inline int conexant_init_jacks(struct hda_codec *codec)
{
	return 0;
}
static int __init patch_conexant_init(void)
{
	return snd_hda_add_codec_preset(&conexant_list);
}
static void __exit patch_conexant_exit(void)
{
	snd_hda_delete_codec_preset(&conexant_list);
}
static void hdmi_write_dip_byte(struct hda_codec *codec, hda_nid_t nid,
				unsigned char val)
{
	snd_hda_codec_write(codec, nid, 0, AC_VERB_SET_HDMI_DIP_DATA, val);
}
static int hdmi_get_channel_count(struct hda_codec *codec)
{
	return 1 + snd_hda_codec_read(codec, CVT_NID, 0,
					AC_VERB_GET_CVT_CHAN_COUNT, 0);
}
static int __init patch_intelhdmi_init(void)
{
	return snd_hda_add_codec_preset(&intel_list);
}
static void __exit patch_intelhdmi_exit(void)
{
	snd_hda_delete_codec_preset(&intel_list);
}
static void nvhdmi_free(struct hda_codec *codec)
{
	kfree(codec->spec);
}
static int __init patch_nvhdmi_init(void)
{
	return snd_hda_add_codec_preset(&nvhdmi_list);
}
static void __exit patch_nvhdmi_exit(void)
{
	snd_hda_delete_codec_preset(&nvhdmi_list);
}
static int si3054_build_controls(struct hda_codec *codec)
{
	return snd_hda_add_new_ctls(codec, si3054_modem_mixer);
}
static void si3054_free(struct hda_codec *codec)
{
	kfree(codec->spec);
}
static int __init patch_si3054_init(void)
{
	return snd_hda_add_codec_preset(&si3054_list);
}
static void __exit patch_si3054_exit(void)
{
	snd_hda_delete_codec_preset(&si3054_list);
}
static void stac92xx_auto_set_pinctl(struct hda_codec *codec, hda_nid_t nid, int pin_type)
{
	snd_hda_codec_write_cache(codec, nid, 0,
				  AC_VERB_SET_PIN_WIDGET_CONTROL, pin_type);
}
static inline int stac92xx_add_control_idx(struct sigmatel_spec *spec,
					   int type, int idx, const char *name,
					   unsigned long val)
{
	return stac92xx_add_control_temp(spec,
					 &stac92xx_control_templates[type],
					 idx, name, val);
}
static inline int stac92xx_add_control(struct sigmatel_spec *spec, int type,
				       const char *name, unsigned long val)
{
	return stac92xx_add_control_idx(spec, type, 0, name, val);
}
static int stac92xx_beep_switch_ctl(struct hda_codec *codec)
{
	return stac92xx_add_control_temp(codec->spec, &stac92xx_dig_beep_ctrl,
					 0, "PC Beep Playback Switch", 0);
}
static void stac92xx_pin_sense(struct hda_codec *codec, hda_nid_t nid)
{
	stac_toggle_power_map(codec, nid, get_pin_presence(codec, nid));
}
static void analog_loop_proc_hook(struct snd_info_buffer *buffer,
				  struct hda_codec *codec,
				  unsigned int verb)
{
	snd_iprintf(buffer, "Analog Loopback: 0x%02x\n",
		    snd_hda_codec_read(codec, codec->afg, 0, verb, 0));
}
static int __init patch_sigmatel_init(void)
{
	return snd_hda_add_codec_preset(&sigmatel_list);
}
static void __exit patch_sigmatel_exit(void)
{
	snd_hda_delete_codec_preset(&sigmatel_list);
}
static int __init patch_via_init(void)
{
	return snd_hda_add_codec_preset(&via_list);
}
static void __exit patch_via_exit(void)
{
	snd_hda_delete_codec_preset(&via_list);
}
static int __init alsa_ice1712_akm4xxx_module_init(void)
{
	return 0;
}
static void aureon_cs8415_put(struct snd_ice1712 *ice, int reg,
						unsigned char val)
{
	aureon_spi_write(ice, AUREON_CS8415_CS, 0x200000 | (reg << 8) | val, 24);
}
static void wm_put_nocache(struct snd_ice1712 *ice, int reg, unsigned short val)
{
	aureon_spi_write(ice,
			 ((ice->eeprom.subvendor == VT1724_SUBDEVICE_PRODIGY71LT ||
			   ice->eeprom.subvendor == VT1724_SUBDEVICE_PRODIGY71XT) ?
			 PRODIGY_WM_CS : AUREON_WM_CS),
			(reg << 9) | (val & 0x1ff), 16);
}
static void delta_spdif_default_get(struct snd_ice1712 *ice, struct snd_ctl_elem_value *ucontrol)
{
	snd_cs8403_decode_spdif_bits(&ucontrol->value.iec958, ice->spdif.cs8403_bits);
}
static void delta_spdif_stream_get(struct snd_ice1712 *ice, struct snd_ctl_elem_value *ucontrol)
{
	snd_cs8403_decode_spdif_bits(&ucontrol->value.iec958, ice->spdif.cs8403_stream_bits);
}
static void delta_open_spdif(struct snd_ice1712 *ice, struct snd_pcm_substream *substream)
{
	ice->spdif.cs8403_stream_bits = ice->spdif.cs8403_bits;
}
static void ews88_spdif_default_get(struct snd_ice1712 *ice, struct snd_ctl_elem_value *ucontrol)
{
	snd_cs8404_decode_spdif_bits(&ucontrol->value.iec958, ice->spdif.cs8403_bits);
}
static void ews88_spdif_stream_get(struct snd_ice1712 *ice, struct snd_ctl_elem_value *ucontrol)
{
	snd_cs8404_decode_spdif_bits(&ucontrol->value.iec958, ice->spdif.cs8403_stream_bits);
}
static void ews88_open_spdif(struct snd_ice1712 *ice, struct snd_pcm_substream *substream)
{
	ice->spdif.cs8403_stream_bits = ice->spdif.cs8403_bits;
}
static inline int is_spdif_master(struct snd_ice1712 *ice)
{
	return (inb(ICEMT(ice, RATE)) & ICE1712_SPDIF_MASTER) ? 1 : 0;
}
static inline int is_pro_rate_locked(struct snd_ice1712 *ice)
{
	return is_spdif_master(ice) || PRO_RATE_LOCKED;
}
static unsigned int snd_ice1712_get_gpio_data(struct snd_ice1712 *ice)
{
	return snd_ice1712_read(ice, ICE1712_IREG_GPIO_DATA);
}
static void open_cs8427(struct snd_ice1712 *ice, struct snd_pcm_substream *substream)
{
	snd_cs8427_iec958_active(ice->cs8427, 1);
}
static void close_cs8427(struct snd_ice1712 *ice, struct snd_pcm_substream *substream)
{
	snd_cs8427_iec958_active(ice->cs8427, 0);
}
static void setup_cs8427(struct snd_ice1712 *ice, int rate)
{
	snd_cs8427_iec958_pcm(ice->cs8427, rate);
}
static int snd_ice1712_hw_params(struct snd_pcm_substream *substream,
				 struct snd_pcm_hw_params *hw_params)
{
	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
}
static int snd_ice1712_hw_free(struct snd_pcm_substream *substream)
{
	return snd_pcm_lib_free_pages(substream);
}
static inline unsigned int eeprom_double(struct snd_ice1712 *ice, int idx)
{
	return (unsigned int)ice->eeprom.data[idx] | ((unsigned int)ice->eeprom.data[idx + 1] << 8);
}
static int __init alsa_card_ice1712_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_ice1712_exit(void)
{
	pci_unregister_driver(&driver);
}
static inline int stdclock_is_spdif_master(struct snd_ice1712 *ice)
{
	return (inb(ICEMT1724(ice, RATE)) & VT1724_SPDIF_MASTER) ? 1 : 0;
}
static inline int is_pro_rate_locked(struct snd_ice1712 *ice)
{
	return ice->is_spdif_master(ice) || PRO_RATE_LOCKED;
}
static inline struct snd_rawmidi_substream *
get_rawmidi_substream(struct snd_ice1712 *ice, unsigned int stream)
{
	return list_first_entry(&ice->rmidi[0]->streams[stream].substreams,
				struct snd_rawmidi_substream, list);
}
static int vt1724_midi_output_open(struct snd_rawmidi_substream *s)
{
	return 0;
}
static int vt1724_midi_output_close(struct snd_rawmidi_substream *s)
{
	return 0;
}
static inline unsigned int eeprom_triple(struct snd_ice1712 *ice, int idx)
{
	return (unsigned int)ice->eeprom.data[idx] | \
		((unsigned int)ice->eeprom.data[idx + 1] << 8) | \
		((unsigned int)ice->eeprom.data[idx + 2] << 16);
}
static inline int analog_route_shift(int idx)
{
	return (idx % 2) * 12 + ((idx / 2) * 3) + 8;
}
static inline int digital_route_shift(int idx)
{
	return idx * 3;
}
static int __init alsa_card_ice1724_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_ice1724_exit(void)
{
	pci_unregister_driver(&driver);
}
static void juli_ak4114_write(void *private_data, unsigned char reg,
				unsigned char val)
{
	snd_vt1724_write_i2c((struct snd_ice1712 *)private_data, AK4114_ADDR,
				reg, val);
}
static unsigned char juli_ak4114_read(void *private_data, unsigned char reg)
{
	return snd_vt1724_read_i2c((struct snd_ice1712 *)private_data,
					AK4114_ADDR, reg);
}
static inline int juli_is_spdif_master(struct snd_ice1712 *ice)
{
	return (ice->gpio.get_data(ice) & GPIO_INTERNAL_CLOCK) ? 0 : 1;
}
static inline unsigned char juli_set_mclk(struct snd_ice1712 *ice,
					  unsigned int rate)
{
	return 0;
}
static void wm_put_nocache(struct snd_ice1712 *ice, int reg, unsigned short val)
{
	phase28_spi_write(ice, PHASE28_WM_CS, (reg << 9) | (val & 0x1ff), 16);
}
static inline void stac9460_put(struct snd_ice1712 *ice, int reg, unsigned char val)
{
	snd_vt1724_write_i2c(ice, PRODIGY192_STAC9460_ADDR, reg, val);
}
static inline unsigned char stac9460_get(struct snd_ice1712 *ice, int reg)
{
	return snd_vt1724_read_i2c(ice, PRODIGY192_STAC9460_ADDR, reg);
}
static int __devinit k8x800_add_controls(struct snd_ice1712 *ice)
{
	return 0;
}
static inline void stac9460_put(struct snd_ice1712 *ice, int reg,
						unsigned char val)
{
	snd_vt1724_write_i2c(ice, STAC9460_I2C_ADDR, reg, val);
}
static inline unsigned char stac9460_get(struct snd_ice1712 *ice, int reg)
{
	return snd_vt1724_read_i2c(ice, STAC9460_I2C_ADDR, reg);
}
static inline void stac9460_2_put(struct snd_ice1712 *ice, int reg,
						unsigned char val)
{
	snd_vt1724_write_i2c(ice, STAC9460_2_I2C_ADDR, reg, val);
}
static inline unsigned char stac9460_2_get(struct snd_ice1712 *ice, int reg)
{
	return snd_vt1724_read_i2c(ice, STAC9460_2_I2C_ADDR, reg);
}
static inline u8 igetbyte(struct intel8x0 *chip, u32 offset)
{
	return ioread8(chip->bmaddr + offset);
}
static inline u16 igetword(struct intel8x0 *chip, u32 offset)
{
	return ioread16(chip->bmaddr + offset);
}
static inline u32 igetdword(struct intel8x0 *chip, u32 offset)
{
	return ioread32(chip->bmaddr + offset);
}
static inline void iputbyte(struct intel8x0 *chip, u32 offset, u8 val)
{
	iowrite8(val, chip->bmaddr + offset);
}
static inline void iputword(struct intel8x0 *chip, u32 offset, u16 val)
{
	iowrite16(val, chip->bmaddr + offset);
}
static inline void iputdword(struct intel8x0 *chip, u32 offset, u32 val)
{
	iowrite32(val, chip->bmaddr + offset);
}
static inline u16 iagetword(struct intel8x0 *chip, u32 offset)
{
	return ioread16(chip->addr + offset);
}
static inline void iaputword(struct intel8x0 *chip, u32 offset, u16 val)
{
	iowrite16(val, chip->addr + offset);
}
static int __init alsa_card_intel8x0_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_intel8x0_exit(void)
{
	pci_unregister_driver(&driver);
}
static inline u8 igetbyte(struct intel8x0m *chip, u32 offset)
{
	return ioread8(chip->bmaddr + offset);
}
static inline u16 igetword(struct intel8x0m *chip, u32 offset)
{
	return ioread16(chip->bmaddr + offset);
}
static inline u32 igetdword(struct intel8x0m *chip, u32 offset)
{
	return ioread32(chip->bmaddr + offset);
}
static inline void iputbyte(struct intel8x0m *chip, u32 offset, u8 val)
{
	iowrite8(val, chip->bmaddr + offset);
}
static inline void iputword(struct intel8x0m *chip, u32 offset, u16 val)
{
	iowrite16(val, chip->bmaddr + offset);
}
static inline void iputdword(struct intel8x0m *chip, u32 offset, u32 val)
{
	iowrite32(val, chip->bmaddr + offset);
}
static inline u16 iagetword(struct intel8x0m *chip, u32 offset)
{
	return ioread16(chip->addr + offset);
}
static inline void iaputword(struct intel8x0m *chip, u32 offset, u16 val)
{
	iowrite16(val, chip->addr + offset);
}
static int snd_intel8x0_hw_params(struct snd_pcm_substream *substream,
				  struct snd_pcm_hw_params *hw_params)
{
	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
}
static int snd_intel8x0_hw_free(struct snd_pcm_substream *substream)
{
	return snd_pcm_lib_free_pages(substream);
}
static int __init alsa_card_intel8x0m_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_intel8x0m_exit(void)
{
	pci_unregister_driver(&driver);
}
static inline void snd_korg1212_setCardState(struct snd_korg1212 * korg1212, enum CardState csState)
{
        korg1212->cardState = csState;
}
static void snd_korg1212_EnableCardInterrupts(struct snd_korg1212 * korg1212)
{
	writel(PCI_INT_ENABLE_BIT            |
	       PCI_DOORBELL_INT_ENABLE_BIT   |
	       LOCAL_INT_ENABLE_BIT          |
	       LOCAL_DOORBELL_INT_ENABLE_BIT |
	       LOCAL_DMA1_INT_ENABLE_BIT,
	       korg1212->statusRegPtr);
}
static void snd_korg1212_DisableCardInterrupts(struct snd_korg1212 *korg1212)
{
	writel(0, korg1212->statusRegPtr);
}
static int __init alsa_card_korg1212_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_korg1212_exit(void)
{
	pci_unregister_driver(&driver);
}
static inline void snd_m3_outw(struct snd_m3 *chip, u16 value, unsigned long reg)
{
	outw(value, chip->iobase + reg);
}
static inline u16 snd_m3_inw(struct snd_m3 *chip, unsigned long reg)
{
	return inw(chip->iobase + reg);
}
static inline void snd_m3_outb(struct snd_m3 *chip, u8 value, unsigned long reg)
{
	outb(value, chip->iobase + reg);
}
static inline u8 snd_m3_inb(struct snd_m3 *chip, unsigned long reg)
{
	return inb(chip->iobase + reg);
}
static void snd_m3_assp_continue(struct snd_m3 *chip)
{
	snd_m3_outb(chip, chip->reset_state | REGB_ENABLE_RESET, DSP_PORT_CONTROL_REG_B);
}
static int __init alsa_card_m3_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_m3_exit(void)
{
	pci_unregister_driver(&driver);
}
static void preallocate_buffers(struct snd_mixart *chip, struct snd_pcm *pcm)
{
	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
					      snd_dma_pci_data(chip->mgr->pci), 32*1024, 32*1024);
}
static int __init alsa_card_mixart_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_mixart_exit(void)
{
	pci_unregister_driver(&driver);
}
static inline u8
snd_nm256_readb(struct nm256 *chip, int offset)
{
	return readb(chip->cport + offset);
}
static inline u16
snd_nm256_readw(struct nm256 *chip, int offset)
{
	return readw(chip->cport + offset);
}
static inline u32
snd_nm256_readl(struct nm256 *chip, int offset)
{
	return readl(chip->cport + offset);
}
static inline void
snd_nm256_writeb(struct nm256 *chip, int offset, u8 val)
{
	writeb(val, chip->cport + offset);
}
static inline void
snd_nm256_writew(struct nm256 *chip, int offset, u16 val)
{
	writew(val, chip->cport + offset);
}
static inline void
snd_nm256_writel(struct nm256 *chip, int offset, u32 val)
{
	writel(val, chip->cport + offset);
}
static void
snd_nm256_capture_stop(struct nm256 *chip)
{
	snd_nm256_writeb(chip, NM_RECORD_ENABLE_REG, 0);
}
static int __init alsa_card_nm256_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_nm256_exit(void)
{
	pci_unregister_driver(&driver);
}
static void ak4396_write(struct oxygen *chip, u8 reg, u8 value)
{
	oxygen_write_spi(chip, OXYGEN_SPI_TRIGGER  |
			 OXYGEN_SPI_DATA_LENGTH_2 |
			 OXYGEN_SPI_CLOCK_160 |
			 (0 << OXYGEN_SPI_CODEC_SHIFT) |
			 OXYGEN_SPI_CEN_LATCH_CLOCK_HI,
			 AK4396_WRITE | (reg << 8) | value);
}
static void hifier_resume(struct oxygen *chip)
{
	hifier_registers_init(chip);
}
static int __init alsa_card_hifier_init(void)
{
	return pci_register_driver(&hifier_driver);
}
static void __exit alsa_card_hifier_exit(void)
{
	pci_unregister_driver(&hifier_driver);
}
static void meridian_resume(struct oxygen *chip)
{
	ak4396_registers_init(chip);
}
static int __init alsa_card_oxygen_init(void)
{
	return pci_register_driver(&oxygen_driver);
}
static void __exit alsa_card_oxygen_exit(void)
{
	pci_unregister_driver(&oxygen_driver);
}
u8 oxygen_read8(struct oxygen *chip, unsigned int reg)
{
	return inb(chip->addr + reg);
}
u16 oxygen_read16(struct oxygen *chip, unsigned int reg)
{
	return inw(chip->addr + reg);
}
u32 oxygen_read32(struct oxygen *chip, unsigned int reg)
{
	return inl(chip->addr + reg);
}
void oxygen_write_uart(struct oxygen *chip, u8 data)
{
	_write_uart(chip, 0, data);
}
static inline int oxygen_uart_input_ready(struct oxygen *chip)
{
	return !(oxygen_read8(chip, OXYGEN_MPU401 + 1) & MPU401_RX_EMPTY);
}
static inline int is_bit_set(const u32 *bitmap, unsigned int bit)
{
	return bitmap[bit / 32] & (1 << (bit & 31));
}
static inline void write_spdif_bits(struct oxygen *chip, u32 bits)
{
	oxygen_write32_masked(chip, OXYGEN_SPDIF_OUTPUT_BITS, bits,
			      OXYGEN_SPDIF_NONAUDIO |
			      OXYGEN_SPDIF_C |
			      OXYGEN_SPDIF_PREEMPHASIS |
			      OXYGEN_SPDIF_CATEGORY_MASK |
			      OXYGEN_SPDIF_ORIGINAL |
			      OXYGEN_SPDIF_V);
}
static inline unsigned int
oxygen_substream_channel(struct snd_pcm_substream *substream)
{
	return (unsigned int)(uintptr_t)substream->runtime->private_data;
}
static int oxygen_rec_a_open(struct snd_pcm_substream *substream)
{
	return oxygen_open(substream, PCM_A);
}
static int oxygen_rec_b_open(struct snd_pcm_substream *substream)
{
	return oxygen_open(substream, PCM_B);
}
static int oxygen_rec_c_open(struct snd_pcm_substream *substream)
{
	return oxygen_open(substream, PCM_C);
}
static int oxygen_spdif_open(struct snd_pcm_substream *substream)
{
	return oxygen_open(substream, PCM_SPDIF);
}
static int oxygen_multich_open(struct snd_pcm_substream *substream)
{
	return oxygen_open(substream, PCM_MULTICH);
}
static int oxygen_ac97_open(struct snd_pcm_substream *substream)
{
	return oxygen_open(substream, PCM_AC97);
}
static unsigned int oxygen_format(struct snd_pcm_hw_params *hw_params)
{
	if (params_format(hw_params) == SNDRV_PCM_FORMAT_S32_LE)
		return OXYGEN_FORMAT_24;
	else
		return OXYGEN_FORMAT_16;
}
static unsigned int oxygen_i2s_mclk(struct snd_pcm_hw_params *hw_params)
{
	if (params_rate(hw_params) <= 96000)
		return OXYGEN_I2S_MCLK_256;
	else
		return OXYGEN_I2S_MCLK_128;
}
static unsigned int oxygen_i2s_bits(struct snd_pcm_hw_params *hw_params)
{
	if (params_format(hw_params) == SNDRV_PCM_FORMAT_S32_LE)
		return OXYGEN_I2S_BITS_24;
	else
		return OXYGEN_I2S_BITS_16;
}
static void oxygen_pcm_free(struct snd_pcm *pcm)
{
	snd_pcm_lib_preallocate_free_for_all(pcm);
}
static inline void pcm1796_write_i2c(struct oxygen *chip, unsigned int codec,
				     u8 reg, u8 value)
{
	oxygen_write_i2c(chip, I2C_DEVICE_PCM1796(codec), reg, value);
}
static void cs4398_write(struct oxygen *chip, u8 reg, u8 value)
{
	oxygen_write_i2c(chip, I2C_DEVICE_CS4398, reg, value);
}
static void cs4362a_write(struct oxygen *chip, u8 reg, u8 value)
{
	oxygen_write_i2c(chip, I2C_DEVICE_CS4362A, reg, value);
}
static void xonar_d2_cleanup(struct oxygen *chip)
{
	xonar_disable_output(chip);
}
static void xonar_d2_suspend(struct oxygen *chip)
{
	xonar_d2_cleanup(chip);
}
static void xonar_d1_suspend(struct oxygen *chip)
{
	xonar_d1_cleanup(chip);
}
static int xonar_d2_mixer_init(struct oxygen *chip)
{
	return snd_ctl_add(chip->card, snd_ctl_new1(&alt_switch, chip));
}
static int xonar_d1_mixer_init(struct oxygen *chip)
{
	return snd_ctl_add(chip->card, snd_ctl_new1(&front_panel_switch, chip));
}
static int __init alsa_card_xonar_init(void)
{
	return pci_register_driver(&xonar_driver);
}
static void __exit alsa_card_xonar_exit(void)
{
	pci_unregister_driver(&xonar_driver);
}
int pcxhr_get_external_clock(struct pcxhr_mgr *mgr,
			     enum pcxhr_clock_type clock_type,
			     int *sample_rate)
{
	if (mgr->is_hr_stereo)
		return hr222_get_external_clock(mgr, clock_type,
						sample_rate);
	else
		return pcxhr_sub_get_external_clock(mgr, clock_type,
						    sample_rate);
}
static int __init pcxhr_module_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit pcxhr_module_exit(void)
{
	pci_unregister_driver(&driver);
}
static inline unsigned int snd_rme32_pcm_byteptr(struct rme32 * rme32)
{
	return (readl(rme32->iobase + RME32_IO_GET_POS)
		& RME32_RCR_AUDIO_ADDR_MASK);
}
static int snd_rme32_getclockmode(struct rme32 * rme32)
{
	return ((rme32->wcreg >> RME32_WCR_BITPOS_FREQ_0) & 1) +
	    (((rme32->wcreg >> RME32_WCR_BITPOS_FREQ_1) & 1) << 1);
}
static int snd_rme32_getinputtype(struct rme32 * rme32)
{
	return ((rme32->wcreg >> RME32_WCR_BITPOS_INP_0) & 1) +
	    (((rme32->wcreg >> RME32_WCR_BITPOS_INP_1) & 1) << 1);
}
static void snd_rme32_card_free(struct snd_card *card)
{
	snd_rme32_free(card->private_data);
}
static int __init alsa_card_rme32_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_rme32_exit(void)
{
	pci_unregister_driver(&driver);
}
static inline unsigned int
snd_rme96_playback_ptr(struct rme96 *rme96)
{
	return (readl(rme96->iobase + RME96_IO_GET_PLAY_POS)
		& RME96_RCR_AUDIO_ADDR_MASK) >> rme96->playback_frlog;
}
static inline unsigned int
snd_rme96_capture_ptr(struct rme96 *rme96)
{
	return (readl(rme96->iobase + RME96_IO_GET_REC_POS)
		& RME96_RCR_AUDIO_ADDR_MASK) >> rme96->capture_frlog;
}
static int
snd_rme96_getmontracks(struct rme96 *rme96)
{
	return ((rme96->wcreg >> RME96_WCR_BITPOS_MONITOR_0) & 1) +
		(((rme96->wcreg >> RME96_WCR_BITPOS_MONITOR_1) & 1) << 1);
}
static int
snd_rme96_getattenuation(struct rme96 *rme96)
{
	return ((rme96->wcreg >> RME96_WCR_BITPOS_GAIN_0) & 1) +
		(((rme96->wcreg >> RME96_WCR_BITPOS_GAIN_1) & 1) << 1);
}
static void snd_rme96_card_free(struct snd_card *card)
{
	snd_rme96_free(card->private_data);
}
static int __init alsa_card_rme96_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_rme96_exit(void)
{
	pci_unregister_driver(&driver);
}
static void hdsp_write(struct hdsp *hdsp, int reg, int val)
{
	writel(val, hdsp->iobase + reg);
}
static unsigned int hdsp_read(struct hdsp *hdsp, int reg)
{
	return readl (hdsp->iobase + reg);
}
static void hdsp_compute_period_size(struct hdsp *hdsp)
{
	hdsp->period_bytes = 1 << ((hdsp_decode_latency(hdsp->control_register) + 8));
}
static void hdsp_silence_playback(struct hdsp *hdsp)
{
	memset(hdsp->playback_buffer, 0, HDSP_DMA_AREA_BYTES);
}
static unsigned char snd_hdsp_midi_read_byte (struct hdsp *hdsp, int id)
{
	if (id)
		return hdsp_read(hdsp, HDSP_midiDataIn1);
	else
		return hdsp_read(hdsp, HDSP_midiDataIn0);
}
static int snd_hdsp_midi_input_available (struct hdsp *hdsp, int id)
{
	if (id)
		return (hdsp_read(hdsp, HDSP_midiStatusIn1) & 0xff);
	else
		return (hdsp_read(hdsp, HDSP_midiStatusIn0) & 0xff);
}
static unsigned int hdsp_spdif_in(struct hdsp *hdsp)
{
	return hdsp_decode_spdif_in(hdsp->control_register & HDSP_SPDIFInputMask);
}
static int hdsp_spdif_out(struct hdsp *hdsp)
{
	return (hdsp->control_register & HDSP_SPDIFOpticalOut) ? 1 : 0;
}
static int hdsp_spdif_professional(struct hdsp *hdsp)
{
	return (hdsp->control_register & HDSP_SPDIFProfessional) ? 1 : 0;
}
static int hdsp_spdif_emphasis(struct hdsp *hdsp)
{
	return (hdsp->control_register & HDSP_SPDIFEmphasis) ? 1 : 0;
}
static int hdsp_spdif_nonaudio(struct hdsp *hdsp)
{
	return (hdsp->control_register & HDSP_SPDIFNonAudio) ? 1 : 0;
}
static int hdsp_line_out(struct hdsp *hdsp)
{
	return (hdsp->control_register & HDSP_LineOut) ? 1 : 0;
}
static int __init alsa_card_hdsp_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_hdsp_exit(void)
{
	pci_unregister_driver(&driver);
}
static inline void hdspm_write(struct hdspm * hdspm, unsigned int reg,
			       unsigned int val)
{
	writel(val, hdspm->iobase + reg);
}
static inline unsigned int hdspm_read(struct hdspm * hdspm, unsigned int reg)
{
	return readl(hdspm->iobase + reg);
}
static inline void snd_hdspm_enable_in(struct hdspm * hdspm, int i, int v)
{
	hdspm_write(hdspm, HDSPM_inputEnableBase + (4 * i), v);
}
static inline void snd_hdspm_enable_out(struct hdspm * hdspm, int i, int v)
{
	hdspm_write(hdspm, HDSPM_outputEnableBase + (4 * i), v);
}
static inline void hdspm_compute_period_size(struct hdspm * hdspm)
{
	hdspm->period_bytes =
	    1 << ((hdspm_decode_latency(hdspm->control_register) + 8));
}
static inline unsigned char snd_hdspm_midi_read_byte (struct hdspm *hdspm,
						      int id)
{
	if (id)
		return hdspm_read(hdspm, HDSPM_midiDataIn1);
	else
		return hdspm_read(hdspm, HDSPM_midiDataIn0);
}
static inline int snd_hdspm_midi_input_available (struct hdspm *hdspm, int id)
{
	if (id)
		return (hdspm_read(hdspm, HDSPM_midiStatusIn1) & 0xff);
	else
		return (hdspm_read(hdspm, HDSPM_midiStatusIn0) & 0xff);
}
static int hdspm_line_out(struct hdspm * hdspm)
{
	return (hdspm->control_register & HDSPM_LineOut) ? 1 : 0;
}
static int hdspm_tx_64(struct hdspm * hdspm)
{
	return (hdspm->control_register & HDSPM_TX_64ch) ? 1 : 0;
}
static int hdspm_c_tms(struct hdspm * hdspm)
{
	return (hdspm->control_register & HDSPM_clr_tms) ? 1 : 0;
}
static int hdspm_safe_mode(struct hdspm * hdspm)
{
	return (hdspm->control_register & HDSPM_AutoInp) ? 1 : 0;
}
static int hdspm_emphasis(struct hdspm * hdspm)
{
	return (hdspm->control_register & HDSPM_Emphasis) ? 1 : 0;
}
static int hdspm_dolby(struct hdspm * hdspm)
{
	return (hdspm->control_register & HDSPM_Dolby) ? 1 : 0;
}
static int hdspm_professional(struct hdspm * hdspm)
{
	return (hdspm->control_register & HDSPM_Professional) ? 1 : 0;
}
static int hdspm_input_select(struct hdspm * hdspm)
{
	return (hdspm->control_register & HDSPM_InputSelect0) ? 1 : 0;
}
static int hdspm_ds_wire(struct hdspm * hdspm)
{
	return (hdspm->control_register & HDSPM_DS_DoubleWire) ? 1 : 0;
}
static int snd_hdspm_prepare(struct snd_pcm_substream *substream)
{
	return 0;
}
static int __init alsa_card_hdspm_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_hdspm_exit(void)
{
	pci_unregister_driver(&driver);
}
static inline void rme9652_write(struct snd_rme9652 *rme9652, int reg, int val)
{
	writel(val, rme9652->iobase + reg);
}
static inline unsigned int rme9652_read(struct snd_rme9652 *rme9652, int reg)
{
	return readl(rme9652->iobase + reg);
}
static unsigned int rme9652_spdif_in(struct snd_rme9652 *rme9652)
{
	return rme9652_decode_spdif_in(rme9652->control_register &
				       RME9652_inp);
}
static int rme9652_spdif_out(struct snd_rme9652 *rme9652)
{
	return (rme9652->control_register & RME9652_opt_out) ? 1 : 0;
}
static void rme9652_silence_playback(struct snd_rme9652 *rme9652)
{
	memset(rme9652->playback_buffer, 0, RME9652_DMA_AREA_BYTES);
}
static int __init alsa_card_hammerfall_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_hammerfall_exit(void)
{
	pci_unregister_driver(&driver);
}
static int sis_playback_hw_params(struct snd_pcm_substream *substream,
					struct snd_pcm_hw_params *hw_params)
{
	return snd_pcm_lib_malloc_pages(substream,
					params_buffer_bytes(hw_params));
}
static int sis_hw_free(struct snd_pcm_substream *substream)
{
	return snd_pcm_lib_free_pages(substream);
}
static int __init sis7019_init(void)
{
	return pci_register_driver(&sis7019_driver);
}
static void __exit sis7019_exit(void)
{
	pci_unregister_driver(&sis7019_driver);
}
static inline unsigned int snd_sonicvibes_getdmaa(struct sonicvibes * sonic)
{
	return (inl(sonic->dmaa_port + SV_DMA_COUNT0) & 0xffffff) + 1;
}
static inline unsigned int snd_sonicvibes_getdmac(struct sonicvibes * sonic)
{
	return ((inl(sonic->dmac_port + SV_DMA_COUNT0) & 0xffffff) + 1) << 1;
}
static int snd_sonicvibes_hw_params(struct snd_pcm_substream *substream,
				    struct snd_pcm_hw_params *hw_params)
{
	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
}
static int snd_sonicvibes_hw_free(struct snd_pcm_substream *substream)
{
	return snd_pcm_lib_free_pages(substream);
}
static inline int snd_sonicvibes_create_gameport(struct sonicvibes *sonic) { return -ENOSYS; }
static int __init alsa_card_sonicvibes_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_sonicvibes_exit(void)
{
	pci_unregister_driver(&driver);
}
static int __init alsa_card_trident_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_trident_exit(void)
{
	pci_unregister_driver(&driver);
}
static int snd_trident_ioctl(struct snd_pcm_substream *substream,
			     unsigned int cmd,
			     void *arg)
{
	return snd_pcm_lib_ioctl(substream, cmd, arg);
}
static int snd_trident_capture_hw_params(struct snd_pcm_substream *substream,
					 struct snd_pcm_hw_params *hw_params)
{
	return snd_trident_allocate_pcm_mem(substream, hw_params);
}
static int snd_trident_capture_close(struct snd_pcm_substream *substream)
{
	return 0;
}
int __devinit snd_trident_create_gameport(struct snd_trident *chip) { return -ENOSYS; }
static inline void do_delay(struct snd_trident *chip)
{
	schedule_timeout_uninterruptible(1);
}
static inline unsigned int snd_via82xx_codec_xread(struct via82xx *chip)
{
	return inl(VIAREG(chip, AC97));
}
static inline void snd_via82xx_codec_xwrite(struct via82xx *chip, unsigned int val)
{
	outl(val, VIAREG(chip, AC97));
}
static inline int snd_via686_create_gameport(struct via82xx *chip, unsigned char *legacy)
{
	return -ENOSYS;
}
static int __init alsa_card_via82xx_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_via82xx_exit(void)
{
	pci_unregister_driver(&driver);
}
static inline unsigned int snd_via82xx_codec_xread(struct via82xx_modem *chip)
{
	return inl(VIAREG(chip, AC97));
}
static inline void snd_via82xx_codec_xwrite(struct via82xx_modem *chip, unsigned int val)
{
	outl(val, VIAREG(chip, AC97));
}
static int __init alsa_card_via82xx_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_via82xx_exit(void)
{
	pci_unregister_driver(&driver);
}
static int __init alsa_card_vx222_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_vx222_exit(void)
{
	pci_unregister_driver(&driver);
}
static unsigned char vx2_inb(struct vx_core *chip, int offset)
{
	return inb(vx2_reg_addr(chip, offset));
}
static void vx2_outb(struct vx_core *chip, int offset, unsigned char val)
{
	outb(val, vx2_reg_addr(chip, offset));
}
static unsigned int vx2_inl(struct vx_core *chip, int offset)
{
	return inl(vx2_reg_addr(chip, offset));
}
static void vx2_outl(struct vx_core *chip, int offset, unsigned int val)
{
	outl(val, vx2_reg_addr(chip, offset));
}
static inline void vx2_release_pseudo_dma(struct vx_core *chip)
{
	vx_outl(chip, ICR, 0);
}
static inline int snd_ymfpci_create_gameport(struct snd_ymfpci *chip, int dev, int l, int l2) { return -ENOSYS; }
static int __init alsa_card_ymfpci_init(void)
{
	return pci_register_driver(&driver);
}
static void __exit alsa_card_ymfpci_exit(void)
{
	pci_unregister_driver(&driver);
}
static inline u8 snd_ymfpci_readb(struct snd_ymfpci *chip, u32 offset)
{
	return readb(chip->reg_area_virt + offset);
}
static inline void snd_ymfpci_writeb(struct snd_ymfpci *chip, u32 offset, u8 val)
{
	writeb(val, chip->reg_area_virt + offset);
}
static inline u16 snd_ymfpci_readw(struct snd_ymfpci *chip, u32 offset)
{
	return readw(chip->reg_area_virt + offset);
}
static inline void snd_ymfpci_writew(struct snd_ymfpci *chip, u32 offset, u16 val)
{
	writew(val, chip->reg_area_virt + offset);
}
static inline u32 snd_ymfpci_readl(struct snd_ymfpci *chip, u32 offset)
{
	return readl(chip->reg_area_virt + offset);
}
static inline void snd_ymfpci_writel(struct snd_ymfpci *chip, u32 offset, u32 val)
{
	writel(val, chip->reg_area_virt + offset);
}
static int snd_ymfpci_capture_hw_params(struct snd_pcm_substream *substream,
					struct snd_pcm_hw_params *hw_params)
{
	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
}
static void snd_ymfpci_pcm_free_substream(struct snd_pcm_runtime *runtime)
{
	kfree(runtime->private_data);
}
static int snd_ymfpci_capture_rec_open(struct snd_pcm_substream *substream)
{
	return snd_ymfpci_capture_open(substream, 0);
}
static int snd_ymfpci_capture_ac97_open(struct snd_pcm_substream *substream)
{
	return snd_ymfpci_capture_open(substream, 1);
}
static int snd_ymfpci_playback_close_1(struct snd_pcm_substream *substream)
{
	return 0;
}
static void snd_ymfpci_enable_dsp(struct snd_ymfpci *chip)
{
	snd_ymfpci_writel(chip, YDSXGR_CONFIG, 0x00000001);
}
static void pdacf_release(struct pcmcia_device *link)
{
	pcmcia_disable_device(link);
}
static int __init init_pdacf(void)
{
	return pcmcia_register_driver(&pdacf_cs_driver);
}
static void __exit exit_pdacf(void)
{
	pcmcia_unregister_driver(&pdacf_cs_driver);
}
static inline int check_signal(struct snd_pdacf *chip)
{
	return (chip->ak4117->rcs0 & AK4117_UNLCK) == 0;
}
static int pdacf_pcm_hw_params(struct snd_pcm_substream *subs,
				     struct snd_pcm_hw_params *hw_params)
{
	return snd_pcm_alloc_vmalloc_buffer(subs, params_buffer_bytes(hw_params));
}
static int pdacf_pcm_hw_free(struct snd_pcm_substream *subs)
{
	return snd_pcm_free_vmalloc_buffer(subs);
}
static unsigned char vxp_inb(struct vx_core *chip, int offset)
{
	return inb(vxp_reg_addr(chip, offset));
}
static void vxp_outb(struct vx_core *chip, int offset, unsigned char val)
{
	outb(val, vxp_reg_addr(chip, offset));
}
static void vxpocket_release(struct pcmcia_device *link)
{
	pcmcia_disable_device(link);
}
static int __init init_vxpocket(void)
{
	return pcmcia_register_driver(&vxp_cs_driver);
}
static void __exit exit_vxpocket(void)
{
	pcmcia_unregister_driver(&vxp_cs_driver);
}
static void
snd_pmac_awacs_write_noreg(struct snd_pmac *chip, int reg, int val)
{
	snd_pmac_awacs_write(chip, val | (reg << 12));
}
static void snd_pmac_awacs_suspend(struct snd_pmac *chip)
{
	snd_pmac_awacs_write_noreg(chip, 1, (chip->awacs_reg[1]
					     | MASK_AMUTE | MASK_CMUTE));
}
static int snd_pmac_awacs_detect_headphone(struct snd_pmac *chip)
{
	return (in_le32(&chip->awacs->codec_stat) & chip->hp_stat_mask) ? 1 : 0;
}
static int snd_pmac_burgundy_detect_headphone(struct snd_pmac *chip)
{
	return (in_le32(&chip->awacs->codec_stat) & chip->hp_stat_mask) ? 1 : 0;
}
static inline int another_stream(int stream)
{
	return (stream == SNDRV_PCM_STREAM_PLAYBACK) ?
		SNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK;
}
static int snd_pmac_pcm_hw_params(struct snd_pcm_substream *subs,
				  struct snd_pcm_hw_params *hw_params)
{
	return snd_pcm_lib_malloc_pages(subs, params_buffer_bytes(hw_params));
}
static inline void snd_pmac_dma_set_command(struct pmac_stream *rec, struct pmac_dbdma *cmd)
{
	out_le32(&rec->dma->cmdptr, cmd->addr);
}
static inline void snd_pmac_dma_run(struct pmac_stream *rec, int status)
{
	out_le32(&rec->dma->control, status | (status << 16));
}
static inline u32 read_reg(unsigned int reg)
{
	return in_be32(the_card.mapped_mmio_vaddr + reg);
}
static inline void write_reg(unsigned int reg, u32 val)
{
	out_be32(the_card.mapped_mmio_vaddr + reg, val);
}

static dma_addr_t v_to_bus(struct snd_ps3_card_info *card,
			   void * paddr,
			   int ch)
{
	return card->dma_start_bus_addr[ch] +
		(paddr - card->dma_start_vaddr[ch]);
}
static int snd_ps3_mute(int mute_on)
{
	return ps3av_audio_mute(mute_on);
}
static int snd_ps3_spdif_pmask_get(struct snd_kcontrol *kcontrol,
				   struct snd_ctl_elem_value *ucontrol)
{
	return 0;
}
static void __exit snd_ps3_exit(void)
{
	ps3_system_bus_driver_unregister(&snd_ps3_bus_driver_info);
}
static int snd_aicapcm_pcm_hw_free(struct snd_pcm_substream
				   *substream)
{
	return snd_pcm_lib_free_pages(substream);
}
static int snd_aicapcm_pcm_hw_params(struct snd_pcm_substream
				     *substream, struct snd_pcm_hw_params
				     *hw_params)
{
	return
	    snd_pcm_lib_malloc_pages(substream,
				     params_buffer_bytes(hw_params));
}
static unsigned long snd_aicapcm_pcm_pointer(struct snd_pcm_substream
					     *substream)
{
	return readl(AICA_CONTROL_CHANNEL_SAMPLE_NUMBER);
}
static int atmel_pcm_mmap(struct snd_pcm_substream *substream,
	struct vm_area_struct *vma)
{
	return remap_pfn_range(vma, vma->vm_start,
		       substream->dma_buffer.addr >> PAGE_SHIFT,
		       vma->vm_end - vma->vm_start, vma->vm_page_prot);
}
static int __init atmel_pcm_modinit(void)
{
	return snd_soc_register_platform(&atmel_soc_platform);
}
static void __exit atmel_pcm_modexit(void)
{
	snd_soc_unregister_platform(&atmel_soc_platform);
}
static int __init atmel_ssc_modinit(void)
{
	return snd_soc_register_dais(atmel_ssc_dai, ARRAY_SIZE(atmel_ssc_dai));
}
static void __exit atmel_ssc_modexit(void)
{
	snd_soc_unregister_dais(atmel_ssc_dai, ARRAY_SIZE(atmel_ssc_dai));
}
static snd_pcm_uframes_t
au1xpsc_pcm_pointer(struct snd_pcm_substream *substream)
{
	return bytes_to_frames(substream->runtime,
		au1xpsc_audio_pcmdma[SUBSTREAM_TYPE(substream)]->pos);
}
static void au1xpsc_pcm_free_dma_buffers(struct snd_pcm *pcm)
{
	snd_pcm_lib_preallocate_free_for_all(pcm);
}
static void __exit au1xpsc_audio_dbdma_exit(void)
{
	snd_soc_unregister_platform(&au1xpsc_soc_platform);
}
static void __exit au1xpsc_ac97_exit(void)
{
	snd_soc_unregister_dai(&au1xpsc_ac97_dai);
}
static void __exit au1xpsc_i2s_exit(void)
{
	snd_soc_unregister_dai(&au1xpsc_i2s_dai);
}
static void __exit au1xpsc_sample_ac97_exit(void)
{
	platform_device_unregister(au1xpsc_sample_ac97_dev);
}
static int __init bfin_ac97_init(void)
{
	return snd_soc_register_platform(&bf5xx_ac97_soc_platform);
}
static void __exit bfin_ac97_exit(void)
{
	snd_soc_unregister_platform(&bf5xx_ac97_soc_platform);
}
static void __exit bf5xx_board_exit(void)
{
	platform_device_unregister(bf5xx_board_snd_device);
}
static int __init bfin_i2s_init(void)
{
	return snd_soc_register_platform(&bf5xx_i2s_soc_platform);
}
static void __exit bfin_i2s_exit(void)
{
	snd_soc_unregister_platform(&bf5xx_i2s_soc_platform);
}
static int __init bfin_i2s_init(void)
{
	return snd_soc_register_dai(&bf5xx_i2s_dai);
}
static void __exit bfin_i2s_exit(void)
{
	snd_soc_unregister_dai(&bf5xx_i2s_dai);
}
static unsigned int ac97_read(struct snd_soc_codec *codec,
	unsigned int reg)
{
	return soc_ac97_ops.read(codec->ac97, reg);
}
static int __init ad73311_init(void)
{
	return snd_soc_register_dai(&ad73311_dai);
}
static void __exit ad73311_exit(void)
{
	snd_soc_unregister_dai(&ad73311_dai);
}
static int __init ak4535_modinit(void)
{
	return snd_soc_register_dai(&ak4535_dai);
}
static void __exit ak4535_exit(void)
{
	snd_soc_unregister_dai(&ak4535_dai);
}
static void __exit cs4270_exit(void)
{
	i2c_del_driver(&cs4270_i2c_driver);
}
static int __init pcm3008_init(void)
{
	return snd_soc_register_dai(&pcm3008_dai);
}
static void __exit pcm3008_exit(void)
{
	snd_soc_unregister_dai(&pcm3008_dai);
}
static int __init ssm2602_modinit(void)
{
	return snd_soc_register_dai(&ssm2602_dai);
}
static void __exit ssm2602_exit(void)
{
	snd_soc_unregister_dai(&ssm2602_dai);
}
static int __init tlv320aic23_modinit(void)
{
	return snd_soc_register_dai(&tlv320aic23_dai);
}
static void __exit tlv320aic23_exit(void)
{
	snd_soc_unregister_dai(&tlv320aic23_dai);
}
static int __init aic26_init(void)
{
	return spi_register_driver(&aic26_spi);
}
static void __exit aic26_exit(void)
{
	spi_unregister_driver(&aic26_spi);
}
static int __init aic3x_modinit(void)
{
	return snd_soc_register_dai(&aic3x_dai);
}
static void __exit aic3x_exit(void)
{
	snd_soc_unregister_dai(&aic3x_dai);
}
static void twl4030_power_down(struct snd_soc_codec *codec)
{
	twl4030_codec_enable(codec, 0);
}
static int __init twl4030_modinit(void)
{
	return snd_soc_register_dai(&twl4030_dai);
}
static void __exit twl4030_exit(void)
{
	snd_soc_unregister_dai(&twl4030_dai);
}
static int __init uda134x_init(void)
{
	return snd_soc_register_dai(&uda134x_dai);
}
static void __exit uda134x_exit(void)
{
	snd_soc_unregister_dai(&uda134x_dai);
}
static int __init uda1380_modinit(void)
{
	return snd_soc_register_dais(uda1380_dai, ARRAY_SIZE(uda1380_dai));
}
static void __exit uda1380_exit(void)
{
	snd_soc_unregister_dais(uda1380_dai, ARRAY_SIZE(uda1380_dai));
}
static __init int wm8350_init(void)
{
	return platform_driver_register(&wm8350_codec_driver);
}
static __exit void wm8350_exit(void)
{
	platform_driver_unregister(&wm8350_codec_driver);
}
static int __devexit wm8510_spi_remove(struct spi_device *spi)
{
	return 0;
}
static int __init wm8510_modinit(void)
{
	return snd_soc_register_dai(&wm8510_dai);
}
static void __exit wm8510_exit(void)
{
	snd_soc_unregister_dai(&wm8510_dai);
}
static int __init wm8580_modinit(void)
{
	return snd_soc_register_dais(wm8580_dai, ARRAY_SIZE(wm8580_dai));
}
static void __exit wm8580_exit(void)
{
	snd_soc_unregister_dais(wm8580_dai, ARRAY_SIZE(wm8580_dai));
}
static int __devexit wm8728_spi_remove(struct spi_device *spi)
{
	return 0;
}
static int __init wm8728_modinit(void)
{
	return snd_soc_register_dai(&wm8728_dai);
}
static void __exit wm8728_exit(void)
{
	snd_soc_unregister_dai(&wm8728_dai);
}
static int __devexit wm8731_spi_remove(struct spi_device *spi)
{
	return 0;
}
static int __init wm8731_modinit(void)
{
	return snd_soc_register_dai(&wm8731_dai);
}
static void __exit wm8731_exit(void)
{
	snd_soc_unregister_dai(&wm8731_dai);
}
static int __devexit wm8750_spi_remove(struct spi_device *spi)
{
	return 0;
}
static int __init wm8750_modinit(void)
{
	return snd_soc_register_dai(&wm8750_dai);
}
static void __exit wm8750_exit(void)
{
	snd_soc_unregister_dai(&wm8750_dai);
}
static int __devexit wm8753_spi_remove(struct spi_device *spi)
{
	return 0;
}
static int __init wm8753_modinit(void)
{
	return snd_soc_register_dais(wm8753_dai, ARRAY_SIZE(wm8753_dai));
}
static void __exit wm8753_exit(void)
{
	snd_soc_unregister_dais(wm8753_dai, ARRAY_SIZE(wm8753_dai));
}
static int wm8900_set_dai_pll(struct snd_soc_dai *codec_dai,
		int pll_id, unsigned int freq_in, unsigned int freq_out)
{
	return wm8900_set_fll(codec_dai->codec, pll_id, freq_in, freq_out);
}
static int __init wm8900_modinit(void)
{
	return i2c_add_driver(&wm8900_i2c_driver);
}
static void __exit wm8900_exit(void)
{
	i2c_del_driver(&wm8900_i2c_driver);
}
static int __init wm8903_modinit(void)
{
	return i2c_add_driver(&wm8903_i2c_driver);
}
static void __exit wm8903_exit(void)
{
	i2c_del_driver(&wm8903_i2c_driver);
}
static int __init wm8971_modinit(void)
{
	return snd_soc_register_dai(&wm8971_dai);
}
static void __exit wm8971_exit(void)
{
	snd_soc_unregister_dai(&wm8971_dai);
}
static int __init wm8990_modinit(void)
{
	return snd_soc_register_dai(&wm8990_dai);
}
static void __exit wm8990_exit(void)
{
	snd_soc_unregister_dai(&wm8990_dai);
}
static void __exit evm_exit(void)
{
	platform_device_unregister(evm_snd_device);
}
static inline void davinci_mcbsp_write_reg(struct davinci_mcbsp_dev *dev,
					   int reg, u32 val)
{
	__raw_writel(val, dev->base + reg);
}
static inline u32 davinci_mcbsp_read_reg(struct davinci_mcbsp_dev *dev, int reg)
{
	return __raw_readl(dev->base + reg);
}
static int __init davinci_i2s_init(void)
{
	return snd_soc_register_dai(&davinci_i2s_dai);
}
static void __exit davinci_i2s_exit(void)
{
	snd_soc_unregister_dai(&davinci_i2s_dai);
}
static int davinci_pcm_hw_params(struct snd_pcm_substream *substream,
				 struct snd_pcm_hw_params *hw_params)
{
	return snd_pcm_lib_malloc_pages(substream,
					params_buffer_bytes(hw_params));
}
static int davinci_pcm_hw_free(struct snd_pcm_substream *substream)
{
	return snd_pcm_lib_free_pages(substream);
}
static int __init davinci_soc_platform_init(void)
{
	return snd_soc_register_platform(&davinci_soc_platform);
}
static void __exit davinci_soc_platform_exit(void)
{
	snd_soc_unregister_platform(&davinci_soc_platform);
}
static void __exit sffsdr_exit(void)
{
	platform_device_unregister(sffsdr_snd_device);
}
static int __init fsl_soc_platform_init(void)
{
	return snd_soc_register_platform(&fsl_soc_platform);
}
static void __exit fsl_soc_platform_exit(void)
{
	snd_soc_unregister_platform(&fsl_soc_platform);
}
static int fsl_ssi_set_sysclk(struct snd_soc_dai *cpu_dai,
			      int clk_id, unsigned int freq, int dir)
{
	return (dir == SND_SOC_CLOCK_IN) ? 0 : -EINVAL;
}
static int fsl_ssi_set_fmt(struct snd_soc_dai *cpu_dai, unsigned int format)
{
	return (format == SND_SOC_DAIFMT_I2S) ? 0 : -EINVAL;
}
static int __init psc_i2s_init(void)
{
	return of_register_platform_driver(&psc_i2s_driver);
}
static void __exit psc_i2s_exit(void)
{
	of_unregister_platform_driver(&psc_i2s_driver);
}
static void __exit mpc8610_hpcd_exit(void)
{
	of_unregister_platform_driver(&mpc8610_hpcd_of_driver);
}
static void n810_shutdown(struct snd_pcm_substream *substream)
{
	clk_disable(sys_clkout2);
}
static int __init snd_omap_mcbsp_init(void)
{
	return snd_soc_register_dais(omap_mcbsp_dai,
				     ARRAY_SIZE(omap_mcbsp_dai));
}
static void __exit snd_omap_mcbsp_exit(void)
{
	snd_soc_unregister_dais(omap_mcbsp_dai, ARRAY_SIZE(omap_mcbsp_dai));
}
static int __init omap_soc_platform_init(void)
{
	return snd_soc_register_platform(&omap_soc_platform);
}
static void __exit omap_soc_platform_exit(void)
{
	snd_soc_unregister_platform(&omap_soc_platform);
}
static void __exit omap2evm_soc_exit(void)
{
	platform_device_unregister(omap2evm_snd_device);
}
static void __exit omap3beagle_soc_exit(void)
{
	platform_device_unregister(omap3beagle_snd_device);
}
static int osk_startup(struct snd_pcm_substream *substream)
{
	return clk_enable(tlv320aic23_mclk);
}
static void osk_shutdown(struct snd_pcm_substream *substream)
{
	clk_disable(tlv320aic23_mclk);
}
static void __exit osk_soc_exit(void)
{
	platform_device_unregister(osk_snd_device);
}
static void __exit overo_soc_exit(void)
{
	platform_device_unregister(overo_snd_device);
}
static void __exit sdp3430_soc_exit(void)
{
	platform_device_unregister(sdp3430_snd_device);
}
static void __exit corgi_exit(void)
{
	platform_device_unregister(corgi_snd_device);
}
static void __exit e740_exit(void)
{
	platform_device_unregister(e740_snd_device);
}
static void __exit em_x270_exit(void)
{
	platform_device_unregister(em_x270_snd_device);
}
static int __init mioa701_asoc_init(void)
{
	return platform_driver_register(&mioa701_wm9713_driver);
}
static void __exit mioa701_asoc_exit(void)
{
	platform_driver_unregister(&mioa701_wm9713_driver);
}
void __init palm27x_asoc_set_pdata(struct palm27x_asoc_info *data)
{
	palm27x_ep_gpio = data->jack_gpio;
}
static void __exit poodle_exit(void)
{
	platform_device_unregister(poodle_snd_device);
}
static int __init pxa_ssp_init(void)
{
	return snd_soc_register_dais(pxa_ssp_dai, ARRAY_SIZE(pxa_ssp_dai));
}
static void __exit pxa_ssp_exit(void)
{
	snd_soc_unregister_dais(pxa_ssp_dai, ARRAY_SIZE(pxa_ssp_dai));
}
static int pxa2xx_ac97_suspend(struct snd_soc_dai *dai)
{
	return pxa2xx_ac97_hw_suspend();
}
static int pxa2xx_ac97_resume(struct snd_soc_dai *dai)
{
	return pxa2xx_ac97_hw_resume();
}
static int pxa2xx_ac97_probe(struct platform_device *pdev,
			     struct snd_soc_dai *dai)
{
	return pxa2xx_ac97_hw_probe(pdev);
}
static void pxa2xx_ac97_remove(struct platform_device *pdev,
			       struct snd_soc_dai *dai)
{
	pxa2xx_ac97_hw_remove(pdev);
}
static int __init pxa_ac97_init(void)
{
	return snd_soc_register_dais(pxa_ac97_dai, ARRAY_SIZE(pxa_ac97_dai));
}
static void __exit pxa_ac97_exit(void)
{
	snd_soc_unregister_dais(pxa_ac97_dai, ARRAY_SIZE(pxa_ac97_dai));
}
static void __exit pxa2xx_i2s_exit(void)
{
	platform_driver_unregister(&pxa2xx_i2s_driver);
}
static int __init pxa2xx_soc_platform_init(void)
{
	return snd_soc_register_platform(&pxa2xx_soc_platform);
}
static void __exit pxa2xx_soc_platform_exit(void)
{
	snd_soc_unregister_platform(&pxa2xx_soc_platform);
}
static void __exit spitz_exit(void)
{
	platform_device_unregister(spitz_snd_device);
}
static void __exit tosa_exit(void)
{
	platform_device_unregister(tosa_snd_device);
}
static void __exit zylonite_exit(void)
{
	platform_device_unregister(zylonite_snd_ac97_device);
}
static void __exit ln2440sbc_exit(void)
{
	platform_device_unregister(ln2440sbc_snd_ac97_device);
}
struct clk *s3c2412_get_iisclk(void)
{
	return s3c2412_i2s.iis_clk;
}
static int __init s3c2412_i2s_init(void)
{
	return snd_soc_register_dai(&s3c2412_i2s_dai);
}
static void __exit s3c2412_i2s_exit(void)
{
	snd_soc_unregister_dai(&s3c2412_i2s_dai);
}
static int __init s3c2443_ac97_init(void)
{
	return snd_soc_register_dais(s3c2443_ac97_dai,
				     ARRAY_SIZE(s3c2443_ac97_dai));
}
static void __exit s3c2443_ac97_exit(void)
{
	snd_soc_unregister_dais(s3c2443_ac97_dai,
				ARRAY_SIZE(s3c2443_ac97_dai));
}
u32 s3c24xx_i2s_get_clockrate(void)
{
	return clk_get_rate(s3c24xx_i2s.iis_clk);
}
static int __init s3c24xx_i2s_init(void)
{
	return snd_soc_register_dai(&s3c24xx_i2s_dai);
}
static void __exit s3c24xx_i2s_exit(void)
{
	snd_soc_unregister_dai(&s3c24xx_i2s_dai);
}
static int __init s3c24xx_soc_platform_init(void)
{
	return snd_soc_register_platform(&s3c24xx_soc_platform);
}
static void __exit s3c24xx_soc_platform_exit(void)
{
	snd_soc_unregister_platform(&s3c24xx_soc_platform);
}
static void setdat(int v)
{
	gpio_set_value(s3c24xx_uda134x_l3_pins->l3_data, v > 0);
}
static void setclk(int v)
{
	gpio_set_value(s3c24xx_uda134x_l3_pins->l3_clk, v > 0);
}
static void setmode(int v)
{
	gpio_set_value(s3c24xx_uda134x_l3_pins->l3_mode, v > 0);
}
static int __init s3c24xx_uda134x_init(void)
{
	return platform_driver_register(&s3c24xx_uda134x_driver);
}
static void __exit s3c24xx_uda134x_exit(void)
{
	platform_driver_unregister(&s3c24xx_uda134x_driver);
}
static void __exit smdk2443_exit(void)
{
	platform_device_unregister(smdk2443_snd_ac97_device);
}
static int camelot_hw_free(struct snd_pcm_substream *substream)
{
	return snd_pcm_lib_free_pages(substream);
}
static void camelot_pcm_free(struct snd_pcm *pcm)
{
	snd_pcm_lib_preallocate_free_for_all(pcm);
}
static int __init sh7760_soc_platform_init(void)
{
	return snd_soc_register_platform(&sh7760_soc_platform);
}
static void __exit sh7760_soc_platform_exit(void)
{
	snd_soc_unregister_platform(&sh7760_soc_platform);
}
static int __init sh4_hac_init(void)
{
	return snd_soc_register_dais(sh4_hac_dai, ARRAY_SIZE(sh4_hac_dai));
}
static void __exit sh4_hac_exit(void)
{
	snd_soc_unregister_dais(sh4_hac_dai, ARRAY_SIZE(sh4_hac_dai));
}
static void __exit sh7760_ac97_exit(void)
{
	platform_device_unregister(sh7760_ac97_snd_device);
}
static int __init sh4_ssi_init(void)
{
	return snd_soc_register_dais(sh4_ssi_dai, ARRAY_SIZE(sh4_ssi_dai));
}
static void __exit sh4_ssi_exit(void)
{
	snd_soc_unregister_dais(sh4_ssi_dai, ARRAY_SIZE(sh4_ssi_dai));
}
int snd_soc_dai_set_sysclk(struct snd_soc_dai *dai, int clk_id,
	unsigned int freq, int dir)
{
	if (dai->ops.set_sysclk)
		return dai->ops.set_sysclk(dai, clk_id, freq, dir);
	else
		return -EINVAL;
}
int snd_soc_dai_set_clkdiv(struct snd_soc_dai *dai,
	int div_id, int div)
{
	if (dai->ops.set_clkdiv)
		return dai->ops.set_clkdiv(dai, div_id, div);
	else
		return -EINVAL;
}
int snd_soc_dai_set_pll(struct snd_soc_dai *dai,
	int pll_id, unsigned int freq_in, unsigned int freq_out)
{
	if (dai->ops.set_pll)
		return dai->ops.set_pll(dai, pll_id, freq_in, freq_out);
	else
		return -EINVAL;
}
int snd_soc_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
{
	if (dai->ops.set_fmt)
		return dai->ops.set_fmt(dai, fmt);
	else
		return -EINVAL;
}
int snd_soc_dai_set_tdm_slot(struct snd_soc_dai *dai,
	unsigned int mask, int slots)
{
	if (dai->ops.set_sysclk)
		return dai->ops.set_tdm_slot(dai, mask, slots);
	else
		return -EINVAL;
}
int snd_soc_dai_set_tristate(struct snd_soc_dai *dai, int tristate)
{
	if (dai->ops.set_sysclk)
		return dai->ops.set_tristate(dai, tristate);
	else
		return -EINVAL;
}
int snd_soc_dai_digital_mute(struct snd_soc_dai *dai, int mute)
{
	if (dai->ops.digital_mute)
		return dai->ops.digital_mute(dai, mute);
	else
		return -EINVAL;
}
static inline struct snd_soc_dapm_widget *dapm_cnew_widget(
	const struct snd_soc_dapm_widget *_widget)
{
	return kmemdup(_widget, sizeof(*_widget), GFP_KERNEL);
}
int snd_soc_dapm_enable_pin(struct snd_soc_codec *codec, const char *pin)
{
	return snd_soc_dapm_set_pin(codec, pin, 1);
}
int snd_soc_dapm_disable_pin(struct snd_soc_codec *codec, const char *pin)
{
	return snd_soc_dapm_set_pin(codec, pin, 0);
}
int snd_soc_dapm_nc_pin(struct snd_soc_codec *codec, const char *pin)
{
	return snd_soc_dapm_set_pin(codec, pin, 0);
}
static inline int init_oss_soundcore(void)	{ return 0; }
int register_sound_special(const struct file_operations *fops, int unit)
{
	return register_sound_special_device(fops, unit, NULL);
}
int register_sound_mixer(const struct file_operations *fops, int dev)
{
	return sound_insert_unit(&chains[0], fops, dev, 0, 128,
				 "mixer", S_IRUSR | S_IWUSR, NULL);
}
int register_sound_midi(const struct file_operations *fops, int dev)
{
	return sound_insert_unit(&chains[2], fops, dev, 2, 130,
				 "midi", S_IRUSR | S_IWUSR, NULL);
}
int register_sound_dsp(const struct file_operations *fops, int dev)
{
	return sound_insert_unit(&chains[3], fops, dev, 3, 131,
				 "dsp", S_IWUSR | S_IRUSR, NULL);
}
void unregister_sound_special(int unit)
{
	sound_remove_unit(&chains[unit % SOUND_STEP], unit);
}
void unregister_sound_mixer(int unit)
{
	sound_remove_unit(&chains[0], unit);
}
void unregister_sound_midi(int unit)
{
	sound_remove_unit(&chains[2], unit);
}
void unregister_sound_dsp(int unit)
{
	sound_remove_unit(&chains[3], unit);
}
static void cleanup_oss_soundcore(void)
{
	unregister_chrdev(SOUND_MAJOR, "sound");
}
static int snd_amd7930_hw_params(struct snd_pcm_substream *substream,
				    struct snd_pcm_hw_params *hw_params)
{
	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
}
static int snd_amd7930_hw_free(struct snd_pcm_substream *substream)
{
	return snd_pcm_lib_free_pages(substream);
}
static int __init amd7930_init(void)
{
	return of_register_driver(&amd7930_sbus_driver, &of_bus_type);
}
static int snd_cs4231_xrate(struct snd_pcm_runtime *runtime)
{
	return snd_pcm_hw_constraint_list(runtime, 0,
					  SNDRV_PCM_HW_PARAM_RATE,
					  &hw_constraints_rates);
}
static u8 __cs4231_readb(struct snd_cs4231 *cp, void __iomem *reg_addr)
{
	if (cp->flags & CS4231_FLAG_EBUS)
		return readb(reg_addr);
	else
		return sbus_readb(reg_addr);
}
static void __cs4231_writeb(struct snd_cs4231 *cp, u8 val,
			    void __iomem *reg_addr)
{
	if (cp->flags & CS4231_FLAG_EBUS)
		return writeb(val, reg_addr);
	else
		return sbus_writeb(val, reg_addr);
}
static int _ebus_dma_request(struct cs4231_dma_control *dma_cont,
			     dma_addr_t bus_addr, size_t len)
{
	return ebus_dma_request(&dma_cont->ebus_info, bus_addr, len);
}
static void _ebus_dma_enable(struct cs4231_dma_control *dma_cont, int on)
{
	ebus_dma_enable(&dma_cont->ebus_info, on);
}
static void _ebus_dma_prepare(struct cs4231_dma_control *dma_cont, int dir)
{
	ebus_dma_prepare(&dma_cont->ebus_info, dir);
}
static unsigned int _ebus_dma_addr(struct cs4231_dma_control *dma_cont)
{
	return ebus_dma_addr(&dma_cont->ebus_info);
}
static int __init cs4231_init(void)
{
	return of_register_driver(&cs4231_driver, &of_bus_type);
}
static void __exit cs4231_exit(void)
{
	of_unregister_driver(&cs4231_driver);
}
static inline int pipe_active(struct snd_dbri *dbri, int pipe)
{
	return ((pipe >= 0) && (dbri->pipes[pipe].desc != -1));
}
static int __init dbri_init(void)
{
	return of_register_driver(&dbri_sbus_driver, &of_bus_type);
}
static void __exit dbri_exit(void)
{
	of_unregister_driver(&dbri_sbus_driver);
}
static int snd_at73c213_pcm_hw_free(struct snd_pcm_substream *substream)
{
	return snd_pcm_lib_free_pages(substream);
}
static int __init at73c213_init(void)
{
	return spi_register_driver(&at73c213_driver);
}
static void __exit at73c213_exit(void)
{
	spi_unregister_driver(&at73c213_driver);
}
static int __init alsa_emux_init(void)
{
	return 0;
}
static int fx_delay(int val)
{
	return (unsigned short)snd_sf_calc_parm_delay(val);
}
static int fx_attack(int val)
{
	return (unsigned short)snd_sf_calc_parm_attack(val);
}
static int fx_hold(int val)
{
	return (unsigned short)snd_sf_calc_parm_hold(val);
}
static int fx_decay(int val)
{
	return (unsigned short)snd_sf_calc_parm_decay(val);
}
static int fx_the_value(int val)
{
	return (unsigned short)(val & 0xff);
}
static int fx_twice_value(int val)
{
	return (unsigned short)((val * 2) & 0xff);
}
static int fx_conv_pitch(int val)
{
	return (short)(val * 4096 / 1200);
}
static int fx_conv_Q(int val)
{
	return (unsigned short)((val / 8) & 0xff);
}
static int gs_cutoff(int val)
{
	return (val - 64) * gs_sense[FX_CUTOFF] / 50;
}
static int gs_filterQ(int val)
{
	return (val - 64) * gs_sense[FX_RESONANCE] / 50;
}
static int gs_attack(int val)
{
	return -(val - 64) * gs_sense[FX_ATTACK] / 50;
}
static int gs_decay(int val)
{
	return -(val - 64) * gs_sense[FX_RELEASE] / 50;
}
static int gs_release(int val)
{
	return -(val - 64) * gs_sense[FX_RELEASE] / 50;
}
static int gs_vib_rate(int val)
{
	return (val - 64) * gs_sense[FX_VIBRATE] / 50;
}
static int gs_vib_depth(int val)
{
	return (val - 64) * gs_sense[FX_VIBDEPTH] / 50;
}
static int gs_vib_delay(int val)
{
	return -(val - 64) * gs_sense[FX_VIBDELAY] / 50;
}
static int xg_cutoff(int val)
{
	return (val - 64) * xg_sense[FX_CUTOFF] / 64;
}
static int xg_filterQ(int val)
{
	return (val - 64) * xg_sense[FX_RESONANCE] / 64;
}
static int xg_attack(int val)
{
	return -(val - 64) * xg_sense[FX_ATTACK] / 64;
}
static int xg_release(int val)
{
	return -(val - 64) * xg_sense[FX_RELEASE] / 64;
}
int
snd_emux_xg_control(struct snd_emux_port *port, struct snd_midi_channel *chan,
		    int param)
{
	return send_converted_effect(xg_effects, ARRAY_SIZE(xg_effects),
				     port, chan, param,
				     chan->control[param],
				     EMUX_FX_FLAG_ADD);
}
static int
is_identical_font(struct snd_soundfont *sf, int type, unsigned char *name)
{
	return ((sf->type & SNDRV_SFNT_PAT_SHARED) &&
		(sf->type & 0x0f) == (type & 0x0f) &&
		(name == NULL ||
		 memcmp(sf->name, name, SNDRV_SFNT_PATCH_NAME_LEN) == 0));
}
static int
freq_to_note(int mhz)
{
	return snd_sf_linear_to_log(mhz, OFFSET_ABSCENT, ABSCENT_RATIO);
}
static int
calc_rate_offset(int hz)
{
	return snd_sf_linear_to_log(hz, OFFSET_SAMPLERATE, SAMPLERATE_RATIO);
}
int
snd_sf_calc_parm_attack(int msec)
{
	return calc_parm_search(msec, attack_time_tbl);
}
int
snd_sf_calc_parm_decay(int msec)
{
	return calc_parm_search(msec, decay_time_tbl);
}
static int __init alsa_util_mem_init(void)
{
	return 0;
}
static int __init snd_module_init(void)
{
	return usb_register(&snd_usb_driver);
}
static void __exit snd_module_exit(void)
{
	usb_deregister(&snd_usb_driver);
}
static int snd_usb_caiaq_midi_input_open(struct snd_rawmidi_substream *substream)
{
	return 0;
}
static int snd_usb_caiaq_midi_input_close(struct snd_rawmidi_substream *substream)
{
	return 0;
}
static int snd_usb_caiaq_midi_output_open(struct snd_rawmidi_substream *substream)
{
	return 0;
}
static inline unsigned get_usb_full_speed_rate(unsigned int rate)
{
	return ((rate << 13) + 62) / 125;
}
static inline unsigned get_usb_high_speed_rate(unsigned int rate)
{
	return ((rate << 10) + 62) / 125;
}
static inline unsigned get_full_speed_hz(unsigned int usb_rate)
{
	return (usb_rate * 125 + (1 << 12)) >> 13;
}
static inline unsigned get_high_speed_hz(unsigned int usb_rate)
{
	return (usb_rate * 125 + (1 << 9)) >> 10;
}
static int retire_capture_sync_urb(struct snd_usb_substream *subs,
				   struct snd_pcm_runtime *runtime,
				   struct urb *urb)
{
	return 0;
}
static int retire_paused_capture_urb(struct snd_usb_substream *subs,
				     struct snd_pcm_runtime *runtime,
				     struct urb *urb)
{
	return 0;
}
static int retire_playback_urb(struct snd_usb_substream *subs,
			       struct snd_pcm_runtime *runtime,
			       struct urb *urb)
{
	return 0;
}
static int snd_usb_playback_open(struct snd_pcm_substream *substream)
{
	return snd_usb_pcm_open(substream, SNDRV_PCM_STREAM_PLAYBACK);
}
static int snd_usb_playback_close(struct snd_pcm_substream *substream)
{
	return snd_usb_pcm_close(substream, SNDRV_PCM_STREAM_PLAYBACK);
}
static int snd_usb_capture_open(struct snd_pcm_substream *substream)
{
	return snd_usb_pcm_open(substream, SNDRV_PCM_STREAM_CAPTURE);
}
static int snd_usb_capture_close(struct snd_pcm_substream *substream)
{
	return snd_usb_pcm_close(substream, SNDRV_PCM_STREAM_CAPTURE);
}
static int ignore_interface_quirk(struct snd_usb_audio *chip,
				  struct usb_interface *iface,
				  const struct snd_usb_audio_quirk *quirk)
{
	return 0;
}
static int snd_usb_cm106_boot_quirk(struct usb_device *dev)
{
	return snd_usb_cm106_write_int_reg(dev, 2, 0x8004);
}
static void usb_audio_disconnect(struct usb_interface *intf)
{
	snd_usb_audio_disconnect(interface_to_usbdev(intf),
				 usb_get_intfdata(intf));
}
static void __exit snd_usb_audio_cleanup(void)
{
	usb_deregister(&usb_audio_driver);
}
static void snd_usbmidi_raw_input(struct snd_usb_midi_in_endpoint* ep,
				  uint8_t* buffer, int buffer_length)
{
	snd_usbmidi_input_data(ep, 0, buffer, buffer_length);
}
static int snd_usbmidi_output_close(struct snd_rawmidi_substream *substream)
{
	return 0;
}
static int snd_usbmidi_input_open(struct snd_rawmidi_substream *substream)
{
	return 0;
}
static int snd_usbmidi_input_close(struct snd_rawmidi_substream *substream)
{
	return 0;
}
static int get_cur_ctl_value(struct usb_mixer_elem_info *cval, int validx, int *value)
{
	return get_ctl_value(cval, GET_CUR, validx, value);
}
static inline int get_cur_mix_raw(struct usb_mixer_elem_info *cval,
				  int channel, int *value)
{
	return get_ctl_value(cval, GET_CUR, (cval->control << 8) | channel, value);
}
static int set_cur_ctl_value(struct usb_mixer_elem_info *cval, int validx, int value)
{
	return set_ctl_value(cval, SET_CUR, validx, value);
}
static int parse_audio_processing_unit(struct mixer_build *state, int unitid, unsigned char *desc)
{
	return build_audio_procunit(state, unitid, desc, procunits, "Processing Unit");
}
static int parse_audio_extension_unit(struct mixer_build *state, int unitid, unsigned char *desc)
{
	return build_audio_procunit(state, unitid, desc, NULL, "Extension Unit");
}
static int __init snd_us122l_module_init(void)
{
	return usb_register(&snd_us122l_usb_driver);
}
static void __exit snd_us122l_module_exit(void)
{
	usb_deregister(&snd_us122l_usb_driver);
}
static inline unsigned get_usb_full_speed_rate(unsigned rate)
{
	return ((rate << 13) + 62) / 125;
}
static inline unsigned get_usb_high_speed_rate(unsigned rate)
{
	return ((rate << 10) + 62) / 125;
}
static void snd_usX2Y_disconnect(struct usb_interface *intf)
{
	usX2Y_usb_disconnect(interface_to_usbdev(intf),
				 usb_get_intfdata(intf));
}
static int __init snd_usX2Y_module_init(void)
{
	return usb_register(&snd_usX2Y_usb_driver);
}
static void __exit snd_usX2Y_module_exit(void)
{
	usb_deregister(&snd_usX2Y_usb_driver);
}
static inline int usX2Y_iso_frames_per_buffer(struct snd_pcm_runtime *runtime,
					      struct usX2Ydev * usX2Y)
{
	return (runtime->buffer_size * 1000) / usX2Y->rate + 1;	//FIXME: so far only correct period_size == 2^x ?
}
int usX2Y_hwdep_pcm_new(struct snd_card *card)
{
	return 0;
}
static int cpio_mkdir_line(const char *line)
{
	return cpio_mkgeneric_line(line, GT_DIR);
}
static int cpio_mkpipe_line(const char *line)
{
	return cpio_mkgeneric_line(line, GT_PIPE);
}
static int cpio_mksock_line(const char *line)
{
	return cpio_mkgeneric_line(line, GT_SOCK);
}
void usage(const char *prog)
{
	fprintf(stderr, "Usage:\n"
		"\t%s <cpio_list>\n"
		"\n"
		"<cpio_list> is a file containing newline separated entries that\n"
		"describe the files to be included in the initramfs archive:\n"
		"\n"
		"# a comment\n"
		"file <name> <location> <mode> <uid> <gid> [<hard links>]\n"
		"dir <name> <mode> <uid> <gid>\n"
		"nod <name> <mode> <uid> <gid> <dev_type> <maj> <min>\n"
		"slink <name> <target> <mode> <uid> <gid>\n"
		"pipe <name> <mode> <uid> <gid>\n"
		"sock <name> <mode> <uid> <gid>\n"
		"\n"
		"<name>       name of the file/dir/nod/etc in the archive\n"
		"<location>   location of the file in the current filesystem\n"
		"             expands shell variables quoted with ${}\n"
		"<target>     link target\n"
		"<mode>       mode/permissions of the file\n"
		"<uid>        user id (0=root)\n"
		"<gid>        group id (0=root)\n"
		"<dev_type>   device type (b=block, c=character)\n"
		"<maj>        major number of nod\n"
		"<min>        minor number of nod\n"
		"<hard links> space separated list of other links to file\n"
		"\n"
		"example:\n"
		"# A simple initramfs\n"
		"dir /dev 0755 0 0\n"
		"nod /dev/console 0600 0 0 c 5 1\n"
		"dir /root 0700 0 0\n"
		"dir /sbin 0755 0 0\n"
		"file /sbin/kinit /usr/src/klibc/kinit/kinit 0755 0 0\n",
		prog);
}
static void coalesced_mmio_destructor(struct kvm_io_device *this)
{
	kfree(this);
}
static void kvm_set_pic_irq(struct kvm_kernel_irq_routing_entry *e,
			    struct kvm *kvm, int level)
{
	kvm_pic_set_irq(pic_irqchip(kvm), e->irqchip.pin, level);
}
static void kvm_set_ioapic_irq(struct kvm_kernel_irq_routing_entry *e,
			       struct kvm *kvm, int level)
{
	kvm_ioapic_set_irq(kvm->arch.vioapic, e->irqchip.pin, level);
}
void kvm_register_irq_ack_notifier(struct kvm *kvm,
				   struct kvm_irq_ack_notifier *kian)
{
	hlist_add_head(&kian->link, &kvm->arch.irq_ack_notifier_list);
}
void kvm_unregister_irq_ack_notifier(struct kvm_irq_ack_notifier *kian)
{
	hlist_del_init(&kian->link);
}
void kvm_unregister_irq_mask_notifier(struct kvm *kvm, int irq,
				      struct kvm_irq_mask_notifier *kimn)
{
	hlist_del(&kimn->link);
}
void kvm_free_irq_routing(struct kvm *kvm)
{
	__kvm_free_irq_routing(&kvm->irq_routing);
}
int kvm_setup_default_irq_routing(struct kvm *kvm)
{
	return kvm_set_irq_routing(kvm, default_routing,
				   ARRAY_SIZE(default_routing), 0);
}
static struct dentry *kvm_create_buf_file_callack(const char *filename,
						 struct dentry *parent,
						 int mode,
						 struct rchan_buf *buf,
						 int *is_global)
{
	return debugfs_create_file(filename, mode, parent, buf,
				   &relay_file_operations);
}

