PB MAYBE: dangerous typedef inference, maybe not a typedef: Config_t
PB MAYBE: dangerous typedef inference, maybe not a typedef: IOCPage4_t
PB MAYBE: dangerous typedef inference, maybe not a typedef: MPT_FRAME_HDR
PB MAYBE: dangerous typedef inference, maybe not a typedef: MpiRaidActionRequest_t
PB MAYBE: dangerous typedef inference, maybe not a typedef: VirtDevice
semantic error two or more data types
 =File "mptspi.c.orig", line 1543, column 0,  charpos = 41587
    around = 'mptspi_init', whole content = mptspi_init(void)
ERROR-RECOV: found sync '}' at line 1565
badcount: 31
bad: };
bad: 
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
bad: /**
bad:  *	mptspi_init - Register MPT adapter(s) as SCSI host(s) with SCSI mid-layer.
bad:  *
bad:  *	Returns 0 for success, non-zero for failure.
bad:  */
bad: static int __init
BAD:!!!!! mptspi_init(void)
bad: {
bad: 	int error;
bad: 
bad: 	show_mptmod_ver(my_NAME, my_VERSION);
bad: 
bad: 	mptspi_transport_template = spi_attach_transport(&mptspi_transport_functions);
bad: 	if (!mptspi_transport_template)
bad: 		return -ENODEV;
bad: 
bad: 	mptspiDoneCtx = mpt_register(mptscsih_io_done, MPTSPI_DRIVER);
bad: 	mptspiTaskCtx = mpt_register(mptscsih_taskmgmt_complete, MPTSPI_DRIVER);
bad: 	mptspiInternalCtx = mpt_register(mptscsih_scandv_complete, MPTSPI_DRIVER);
bad: 
bad: 	mpt_event_register(mptspiDoneCtx, mptspi_event_process);
bad: 	mpt_reset_register(mptspiDoneCtx, mptspi_ioc_reset);
bad: 
bad: 	error = pci_register_driver(&mptspi_driver);
bad: 	if (error)
bad: 		spi_release_transport(mptspi_transport_template);
bad: 
bad: 	return error;
bad: }
semantic error two or more data types
 =File "mptspi.c.orig", line 1573, column 0,  charpos = 42480
    around = 'mptspi_exit', whole content = mptspi_exit(void)
ERROR-RECOV: found sync '}' at line 1584
badcount: 19
bad: }
bad: 
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
bad: /**
bad:  *	mptspi_exit - Unregisters MPT adapter(s)
bad:  */
bad: static void __exit
BAD:!!!!! mptspi_exit(void)
bad: {
bad: 	pci_unregister_driver(&mptspi_driver);
bad: 
bad: 	mpt_reset_deregister(mptspiDoneCtx);
bad: 	mpt_event_deregister(mptspiDoneCtx);
bad: 
bad: 	mpt_deregister(mptspiInternalCtx);
bad: 	mpt_deregister(mptspiTaskCtx);
bad: 	mpt_deregister(mptspiDoneCtx);
bad: 	spi_release_transport(mptspi_transport_template);
bad: }
Type_annoter: not finding type for my_NAME
Type_annoter: not finding type for my_VERSION
Type_annoter: not finding type for scsi_device_wide
Type_annoter: not finding type for scsi_device_sync
Type_annoter: not finding type for scsi_device_dt
Type_annoter: not finding type for scsi_device_ius
Type_annoter: not finding type for scsi_device_qas
Type_annoter: not finding type for ddvprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for max
Type_annoter: not finding type for mpt_get_msg_frame
Type_annoter: not finding type for dfailprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for cpu_to_le32
Type_annoter: not finding type for mpt_add_sge
Type_annoter: not finding type for ddvprintk
Type_annoter: not finding type for mpt_put_msg_frame
Type_annoter: not finding type for dev_to_shost
Type_annoter: not finding type for kzalloc
Type_annoter: not finding type for mptscsih_is_phys_disk
Type_annoter: not finding type for mptscsih_raid_id_to_num
Type_annoter: not finding type for ddvprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for spi_min_period
Type_annoter: not finding type for spi_max_width
Type_annoter: not finding type for spi_max_offset
Type_annoter: not finding type for spi_offset
Type_annoter: not finding type for kfree
Type_annoter: not finding type for ddvprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for ddvprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for dev_to_shost
Type_annoter: not finding type for dma_alloc_coherent
Type_annoter: not finding type for starget_printk
Type_annoter: not finding type for memset
Type_annoter: not finding type for mpt_config
Type_annoter: not finding type for memcpy
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for dma_free_coherent
Type_annoter: not finding type for spi_iu
Type_annoter: not finding type for spi_dt
Type_annoter: not finding type for spi_qas
Type_annoter: not finding type for spi_hold_mcs
Type_annoter: not finding type for spi_wr_flow
Type_annoter: not finding type for spi_rd_strm
Type_annoter: not finding type for spi_rti
Type_annoter: not finding type for spi_pcomp_en
Type_annoter: not finding type for spi_period
Type_annoter: not finding type for spi_offset
Type_annoter: not finding type for spi_width
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for spi_iu
Type_annoter: not finding type for spi_dt
Type_annoter: not finding type for spi_qas
Type_annoter: not finding type for spi_wr_flow
Type_annoter: not finding type for spi_rd_strm
Type_annoter: not finding type for spi_rti
Type_annoter: not finding type for spi_pcomp_en
Type_annoter: not finding type for spi_hold_mcs
Type_annoter: not finding type for spi_period
Type_annoter: not finding type for spi_offset
Type_annoter: not finding type for spi_width
Type_annoter: not finding type for mpt_get_msg_frame
Type_annoter: not finding type for ddvprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for mpt_add_sge
Type_annoter: not finding type for jiffies
Type_annoter: not finding type for add_timer
Type_annoter: not finding type for mpt_put_msg_frame
Type_annoter: not finding type for wait_event
Type_annoter: not finding type for scsi_target
Type_annoter: not finding type for starget_printk
Type_annoter: not finding type for spi_dv_device
Type_annoter: not finding type for spi_display_xfer_agreement
Type_annoter: not finding type for mptscsih_is_phys_disk
Type_annoter: not finding type for kzalloc
Type_annoter: not finding type for printk
Type_annoter: not finding type for scsi_target
Type_annoter: not finding type for scsi_target
Type_annoter: not finding type for mptscsih_slave_configure
Type_annoter: not finding type for ddvprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for spi_min_period
Type_annoter: not finding type for spi_max_offset
Type_annoter: not finding type for spi_max_width
Type_annoter: not finding type for spi_initial_dv
Type_annoter: not finding type for mptscsih_is_phys_disk
Type_annoter: not finding type for spi_dv_pending
Type_annoter: not finding type for scsi_target
Type_annoter: not finding type for ddvprintk
Type_annoter: not finding type for scsi_print_command
Type_annoter: not finding type for mptscsih_qcmd
Type_annoter: not finding type for scsi_target
Type_annoter: not finding type for mptscsih_slave_destroy
Type_annoter: not finding type for mptscsih_proc_info
Type_annoter: not finding type for mptscsih_info
Type_annoter: not finding type for mptscsih_change_queue_depth
Type_annoter: not finding type for mptscsih_abort
Type_annoter: not finding type for mptscsih_dev_reset
Type_annoter: not finding type for mptscsih_bus_reset
Type_annoter: not finding type for mptscsih_host_reset
Type_annoter: not finding type for mptscsih_bios_param
Type_annoter: not finding type for mptscsih_host_attrs
Type_annoter: not finding type for dev_to_shost
Type_annoter: not finding type for dma_alloc_coherent
Type_annoter: not finding type for starget_printk
Type_annoter: not finding type for memset
Type_annoter: not finding type for memcpy
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for mpt_config
Type_annoter: not finding type for dma_free_coherent
Type_annoter: not finding type for spi_offset
Type_annoter: not finding type for cpu_to_le32
Type_annoter: not finding type for spi_period
Type_annoter: not finding type for spi_iu
Type_annoter: not finding type for spi_dt
Type_annoter: not finding type for cpu_to_le32
Type_annoter: not finding type for spi_period
Type_annoter: not finding type for spi_dt
Type_annoter: not finding type for cpu_to_le32
Type_annoter: not finding type for spi_period
Type_annoter: not finding type for spi_iu
Type_annoter: not finding type for cpu_to_le32
Type_annoter: not finding type for spi_##parm
Type_annoter: not finding type for starget
Type_annoter: not finding type for parm
Type_annoter: not finding type for cpu_to_le32
Type_annoter: not finding type for rd_strm
Type_annoter: not finding type for wr_flow
Type_annoter: not finding type for rti
Type_annoter: not finding type for hold_mcs
Type_annoter: not finding type for pcomp_en
Type_annoter: not finding type for dev_to_shost
Type_annoter: not finding type for spi_qas
Type_annoter: not finding type for cpu_to_le32
Type_annoter: not finding type for spi_dt
Type_annoter: not finding type for spi_period
Type_annoter: not finding type for spi_width
Type_annoter: not finding type for cpu_to_le32
Type_annoter: not finding type for container_of
Type_annoter: not finding type for kfree
Type_annoter: not finding type for mpt_findImVolumes
Type_annoter: not finding type for scsi_target
Type_annoter: not finding type for starget_printk
Type_annoter: not finding type for shost_printk
Type_annoter: not finding type for scsi_scan_target
Type_annoter: not finding type for kmalloc
Type_annoter: not finding type for shost_printk
Type_annoter: not finding type for schedule_work
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for mptscsih_event_process
Type_annoter: not finding type for dev_to_shost
Type_annoter: not finding type for mptspi_write_wr_flow
Type_annoter: not finding type for mptspi_write_rd_strm
Type_annoter: not finding type for mptspi_write_rti
Type_annoter: not finding type for mptspi_write_pcomp_en
Type_annoter: not finding type for mptspi_write_hold_mcs
Type_annoter: not finding type for pci
Type_annoter: not finding type for container_of
Type_annoter: not finding type for kfree
Type_annoter: not finding type for scsi_target
Type_annoter: not finding type for cpu_to_le32
Type_annoter: not finding type for kmalloc
Type_annoter: not finding type for schedule_work
Type_annoter: not finding type for mptscsih_ioc_reset
Type_annoter: not finding type for pci_get_drvdata
Type_annoter: not finding type for mptscsih_resume
Type_annoter: not finding type for mpt_attach
Type_annoter: not finding type for pci_get_drvdata
Type_annoter: not finding type for printk
Type_annoter: not finding type for scsi_host_alloc
Type_annoter: not finding type for spin_lock_irqsave
Type_annoter: not finding type for u64
Type_annoter: not finding type for dprintk
Type_annoter: not finding type for spin_unlock_irqrestore
Type_annoter: not finding type for kcalloc
Type_annoter: not finding type for init_timer
Type_annoter: not finding type for mptscsih_timer_expired
Type_annoter: not finding type for ddvprintk
Type_annoter: not finding type for init_waitqueue_head
Type_annoter: not finding type for scsi_add_host
Type_annoter: not finding type for mptscsih_TMHandler
Type_annoter: not finding type for scsi_scan_host
Type_annoter: not finding type for mptscsih_remove
Type_annoter: not finding type for mptscsih_remove
Type_annoter: not finding type for mptscsih_shutdown
Type_annoter: not finding type for mptscsih_suspend
Type_annoter: not finding type for mptspi_init
Type_annoter: not finding type for mptspi_exit
PB MAYBE: dangerous typedef inference, maybe not a typedef: Config_t
PB MAYBE: dangerous typedef inference, maybe not a typedef: IOCPage4_t
PB MAYBE: dangerous typedef inference, maybe not a typedef: MPT_FRAME_HDR
PB MAYBE: dangerous typedef inference, maybe not a typedef: MpiRaidActionRequest_t
PB MAYBE: dangerous typedef inference, maybe not a typedef: VirtDevice
semantic error two or more data types
 =File "mptspi.c.new", line 1542, column 0,  charpos = 41354
    around = 'mptspi_init', whole content = mptspi_init(void)
ERROR-RECOV: found sync '}' at line 1564
badcount: 31
bad: };
bad: 
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
bad: /**
bad:  *	mptspi_init - Register MPT adapter(s) as SCSI host(s) with SCSI mid-layer.
bad:  *
bad:  *	Returns 0 for success, non-zero for failure.
bad:  */
bad: static int __init
BAD:!!!!! mptspi_init(void)
bad: {
bad: 	int error;
bad: 
bad: 	show_mptmod_ver(my_NAME, my_VERSION);
bad: 
bad: 	mptspi_transport_template = spi_attach_transport(&mptspi_transport_functions);
bad: 	if (!mptspi_transport_template)
bad: 		return -ENODEV;
bad: 
bad: 	mptspiDoneCtx = mpt_register(mptscsih_io_done, MPTSPI_DRIVER);
bad: 	mptspiTaskCtx = mpt_register(mptscsih_taskmgmt_complete, MPTSPI_DRIVER);
bad: 	mptspiInternalCtx = mpt_register(mptscsih_scandv_complete, MPTSPI_DRIVER);
bad: 
bad: 	mpt_event_register(mptspiDoneCtx, mptspi_event_process);
bad: 	mpt_reset_register(mptspiDoneCtx, mptspi_ioc_reset);
bad: 
bad: 	error = pci_register_driver(&mptspi_driver);
bad: 	if (error)
bad: 		spi_release_transport(mptspi_transport_template);
bad: 
bad: 	return error;
bad: }
semantic error two or more data types
 =File "mptspi.c.new", line 1572, column 0,  charpos = 42247
    around = 'mptspi_exit', whole content = mptspi_exit(void)
ERROR-RECOV: found sync '}' at line 1583
badcount: 19
bad: }
bad: 
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
bad: /**
bad:  *	mptspi_exit - Unregisters MPT adapter(s)
bad:  */
bad: static void __exit
BAD:!!!!! mptspi_exit(void)
bad: {
bad: 	pci_unregister_driver(&mptspi_driver);
bad: 
bad: 	mpt_reset_deregister(mptspiDoneCtx);
bad: 	mpt_event_deregister(mptspiDoneCtx);
bad: 
bad: 	mpt_deregister(mptspiInternalCtx);
bad: 	mpt_deregister(mptspiTaskCtx);
bad: 	mpt_deregister(mptspiDoneCtx);
bad: 	spi_release_transport(mptspi_transport_template);
bad: }
Type_annoter: not finding type for my_NAME
Type_annoter: not finding type for my_VERSION
Type_annoter: not finding type for scsi_device_wide
Type_annoter: not finding type for scsi_device_sync
Type_annoter: not finding type for scsi_device_dt
Type_annoter: not finding type for scsi_device_ius
Type_annoter: not finding type for scsi_device_qas
Type_annoter: not finding type for ddvprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for max
Type_annoter: not finding type for mpt_get_msg_frame
Type_annoter: not finding type for dfailprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for cpu_to_le32
Type_annoter: not finding type for mpt_add_sge
Type_annoter: not finding type for ddvprintk
Type_annoter: not finding type for mpt_put_msg_frame
Type_annoter: not finding type for dev_to_shost
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for kzalloc
Type_annoter: not finding type for mptscsih_is_phys_disk
Type_annoter: not finding type for mptscsih_raid_id_to_num
Type_annoter: not finding type for ddvprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for spi_min_period
Type_annoter: not finding type for spi_max_width
Type_annoter: not finding type for spi_max_offset
Type_annoter: not finding type for spi_offset
Type_annoter: not finding type for kfree
Type_annoter: not finding type for ddvprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for ddvprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for dev_to_shost
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for dma_alloc_coherent
Type_annoter: not finding type for starget_printk
Type_annoter: not finding type for memset
Type_annoter: not finding type for mpt_config
Type_annoter: not finding type for memcpy
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for dma_free_coherent
Type_annoter: not finding type for spi_iu
Type_annoter: not finding type for spi_dt
Type_annoter: not finding type for spi_qas
Type_annoter: not finding type for spi_hold_mcs
Type_annoter: not finding type for spi_wr_flow
Type_annoter: not finding type for spi_rd_strm
Type_annoter: not finding type for spi_rti
Type_annoter: not finding type for spi_pcomp_en
Type_annoter: not finding type for spi_period
Type_annoter: not finding type for spi_offset
Type_annoter: not finding type for spi_width
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for spi_iu
Type_annoter: not finding type for spi_dt
Type_annoter: not finding type for spi_qas
Type_annoter: not finding type for spi_wr_flow
Type_annoter: not finding type for spi_rd_strm
Type_annoter: not finding type for spi_rti
Type_annoter: not finding type for spi_pcomp_en
Type_annoter: not finding type for spi_hold_mcs
Type_annoter: not finding type for spi_period
Type_annoter: not finding type for spi_offset
Type_annoter: not finding type for spi_width
Type_annoter: not finding type for mpt_get_msg_frame
Type_annoter: not finding type for ddvprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for mpt_add_sge
Type_annoter: not finding type for jiffies
Type_annoter: not finding type for add_timer
Type_annoter: not finding type for mpt_put_msg_frame
Type_annoter: not finding type for wait_event
Type_annoter: not finding type for scsi_target
Type_annoter: not finding type for starget_printk
Type_annoter: not finding type for spi_dv_device
Type_annoter: not finding type for spi_display_xfer_agreement
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for mptscsih_is_phys_disk
Type_annoter: not finding type for kzalloc
Type_annoter: not finding type for printk
Type_annoter: not finding type for scsi_target
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for scsi_target
Type_annoter: not finding type for mptscsih_slave_configure
Type_annoter: not finding type for ddvprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for spi_min_period
Type_annoter: not finding type for spi_max_offset
Type_annoter: not finding type for spi_max_width
Type_annoter: not finding type for spi_initial_dv
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for mptscsih_is_phys_disk
Type_annoter: not finding type for spi_dv_pending
Type_annoter: not finding type for scsi_target
Type_annoter: not finding type for ddvprintk
Type_annoter: not finding type for scsi_print_command
Type_annoter: not finding type for mptscsih_qcmd
Type_annoter: not finding type for scsi_target
Type_annoter: not finding type for mptscsih_slave_destroy
Type_annoter: not finding type for mptscsih_proc_info
Type_annoter: not finding type for mptscsih_info
Type_annoter: not finding type for mptscsih_change_queue_depth
Type_annoter: not finding type for mptscsih_abort
Type_annoter: not finding type for mptscsih_dev_reset
Type_annoter: not finding type for mptscsih_bus_reset
Type_annoter: not finding type for mptscsih_host_reset
Type_annoter: not finding type for mptscsih_bios_param
Type_annoter: not finding type for mptscsih_host_attrs
Type_annoter: not finding type for dev_to_shost
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for dma_alloc_coherent
Type_annoter: not finding type for starget_printk
Type_annoter: not finding type for memset
Type_annoter: not finding type for memcpy
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for mpt_config
Type_annoter: not finding type for dma_free_coherent
Type_annoter: not finding type for spi_offset
Type_annoter: not finding type for cpu_to_le32
Type_annoter: not finding type for spi_period
Type_annoter: not finding type for spi_iu
Type_annoter: not finding type for spi_dt
Type_annoter: not finding type for cpu_to_le32
Type_annoter: not finding type for spi_period
Type_annoter: not finding type for spi_dt
Type_annoter: not finding type for cpu_to_le32
Type_annoter: not finding type for spi_period
Type_annoter: not finding type for spi_iu
Type_annoter: not finding type for cpu_to_le32
Type_annoter: not finding type for spi_##parm
Type_annoter: not finding type for starget
Type_annoter: not finding type for parm
Type_annoter: not finding type for cpu_to_le32
Type_annoter: not finding type for rd_strm
Type_annoter: not finding type for wr_flow
Type_annoter: not finding type for rti
Type_annoter: not finding type for hold_mcs
Type_annoter: not finding type for pcomp_en
Type_annoter: not finding type for dev_to_shost
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for spi_qas
Type_annoter: not finding type for cpu_to_le32
Type_annoter: not finding type for spi_dt
Type_annoter: not finding type for spi_period
Type_annoter: not finding type for spi_width
Type_annoter: not finding type for cpu_to_le32
Type_annoter: not finding type for container_of
Type_annoter: not finding type for kfree
Type_annoter: not finding type for mpt_findImVolumes
Type_annoter: not finding type for scsi_target
Type_annoter: not finding type for starget_printk
Type_annoter: not finding type for shost_printk
Type_annoter: not finding type for scsi_scan_target
Type_annoter: not finding type for kmalloc
Type_annoter: not finding type for shost_printk
Type_annoter: not finding type for schedule_work
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for mptscsih_event_process
Type_annoter: not finding type for dev_to_shost
Type_annoter: not finding type for mptspi_write_wr_flow
Type_annoter: not finding type for mptspi_write_rd_strm
Type_annoter: not finding type for mptspi_write_rti
Type_annoter: not finding type for mptspi_write_pcomp_en
Type_annoter: not finding type for mptspi_write_hold_mcs
Type_annoter: not finding type for pci
Type_annoter: not finding type for container_of
Type_annoter: not finding type for kfree
Type_annoter: not finding type for scsi_target
Type_annoter: not finding type for cpu_to_le32
Type_annoter: not finding type for kmalloc
Type_annoter: not finding type for schedule_work
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for mptscsih_ioc_reset
Type_annoter: not finding type for pci_get_drvdata
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for mptscsih_resume
Type_annoter: not finding type for mpt_attach
Type_annoter: not finding type for pci_get_drvdata
Type_annoter: not finding type for printk
Type_annoter: not finding type for scsi_host_alloc
Type_annoter: not finding type for spin_lock_irqsave
Type_annoter: not finding type for u64
Type_annoter: not finding type for dprintk
Type_annoter: not finding type for spin_unlock_irqrestore
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for kcalloc
Type_annoter: not finding type for init_timer
Type_annoter: not finding type for mptscsih_timer_expired
Type_annoter: not finding type for ddvprintk
Type_annoter: not finding type for init_waitqueue_head
Type_annoter: not finding type for scsi_add_host
Type_annoter: not finding type for mptscsih_TMHandler
Type_annoter: not finding type for scsi_scan_host
Type_annoter: not finding type for mptscsih_remove
Type_annoter: not finding type for mptscsih_remove
Type_annoter: not finding type for mptscsih_shutdown
Type_annoter: not finding type for mptscsih_suspend
Type_annoter: not finding type for mptspi_init
Type_annoter: not finding type for mptspi_exit
PB MAYBE: dangerous typedef inference, maybe not a typedef: SEPRequest_t
PB MAYBE: dangerous typedef inference, maybe not a typedef: SCSITaskMgmt_t
PB MAYBE: dangerous typedef inference, maybe not a typedef: SCSITaskMgmtReply_t
CONFLICT:u64
transforming some ident in typedef
Type_annoter: not finding type for my_NAME
Type_annoter: not finding type for my_VERSION
Type_annoter: not finding type for scp
Type_annoter: not finding type for cpu_to_le32
Type_annoter: not finding type for cpu_to_le16
Type_annoter: not finding type for mpt_addr_size
Type_annoter: not finding type for cpu_to_le32
Type_annoter: not finding type for dsgprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for spin_lock_irqsave
Type_annoter: not finding type for list_empty
Type_annoter: not finding type for list_entry
Type_annoter: not finding type for u
Type_annoter: not finding type for list_del
Type_annoter: not finding type for dfailprintk
Type_annoter: not finding type for spin_unlock_irqrestore
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for scsi_dma_map
Type_annoter: not finding type for scsi_sglist
Type_annoter: not finding type for sg_dma_len
Type_annoter: not finding type for sg_dma_address
Type_annoter: not finding type for dsgprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for cpu_to_le32
Type_annoter: not finding type for dfailprintk
Type_annoter: not finding type for mpt_get_msg_frame
Type_annoter: not finding type for dfailprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for devtverboseprintk
Type_annoter: not finding type for mpt_put_msg_frame
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for scsi_print_command
Type_annoter: not finding type for printk
Type_annoter: not finding type for scsi_bufflen
Type_annoter: not finding type for scsi_get_resid
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for printk
Type_annoter: not finding type for dmfprintk
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for scsi_set_resid
Type_annoter: not finding type for scsi_bufflen
Type_annoter: not finding type for dreplyprintk
Type_annoter: not finding type for scsi_dma_unmap
Type_annoter: not finding type for dprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for dmfprintk
Type_annoter: not finding type for mpt_free_msg_frame
Type_annoter: not finding type for scsi_dma_unmap
Type_annoter: not finding type for dsprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for int_to_scsilun
Type_annoter: not finding type for memcmp
Type_annoter: not finding type for mpt_free_msg_frame
Type_annoter: not finding type for scsi_dma_unmap
Type_annoter: not finding type for sdev_printk
Type_annoter: not finding type for jiffies
Type_annoter: not finding type for dprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for pci_get_drvdata
Type_annoter: not finding type for mpt_detach
Type_annoter: not finding type for scsi_remove_host
Type_annoter: not finding type for kfree
Type_annoter: not finding type for dprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for scsi_host_put
Type_annoter: not finding type for pci_get_drvdata
Type_annoter: not finding type for mpt_suspend
Type_annoter: not finding type for mpt_resume
Type_annoter: not finding type for kmalloc
Type_annoter: not finding type for mpt_print_ioc_summary
Type_annoter: not finding type for memcpy
Type_annoter: not finding type for va_start
Type_annoter: not finding type for vsprintf
Type_annoter: not finding type for va_end
Type_annoter: not finding type for dmfprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for dtmprintk
Type_annoter: not finding type for mpt_get_msg_frame
Type_annoter: not finding type for dprintk
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for scsi_bufflen
Type_annoter: not finding type for mpt_msg_flags
Type_annoter: not finding type for int_to_scsilun
Type_annoter: not finding type for cpu_to_le32
Type_annoter: not finding type for mpt_put_msg_frame
Type_annoter: not finding type for mpt_free_msg_frame
Type_annoter: not finding type for spin_lock_irqsave
Type_annoter: not finding type for list_add_tail
Type_annoter: not finding type for spin_unlock_irqrestore
Type_annoter: not finding type for dmfprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for dtmprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for spin_lock_irqsave
Type_annoter: not finding type for spin_unlock_irqrestore
Type_annoter: not finding type for mpt_GetIocState
Type_annoter: not finding type for mpt_HardResetHandler
Type_annoter: not finding type for mpt_get_msg_frame
Type_annoter: not finding type for dfailprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for dtmprintk
Type_annoter: not finding type for int_to_scsilun
Type_annoter: not finding type for mpt_put_msg_frame_hi_pri
Type_annoter: not finding type for mpt_send_handshake_request
Type_annoter: not finding type for mpt_HardResetHandler
Type_annoter: not finding type for mpt_free_msg_frame
Type_annoter: not finding type for printk
Type_annoter: not finding type for scsi_print_command
Type_annoter: not finding type for dtmprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for scsi_print_command
Type_annoter: not finding type for printk
Type_annoter: not finding type for scsi_print_command
Type_annoter: not finding type for printk
Type_annoter: not finding type for mpt_HardResetHandler
Type_annoter: not finding type for spin_lock_irqsave
Type_annoter: not finding type for spin_unlock_irqrestore
Type_annoter: not finding type for msleep
Type_annoter: not finding type for spin_lock_irqsave
Type_annoter: not finding type for spin_unlock_irqrestore
Type_annoter: not finding type for msleep
Type_annoter: not finding type for printk
Type_annoter: not finding type for dtmprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for mpt_HardResetHandler
Type_annoter: not finding type for spin_lock_irqsave
Type_annoter: not finding type for spin_unlock_irqrestore
Type_annoter: not finding type for sector_div
Type_annoter: not finding type for list_empty
Type_annoter: not finding type for down
Type_annoter: not finding type for list
Type_annoter: not finding type for up
Type_annoter: not finding type for list_empty
Type_annoter: not finding type for down
Type_annoter: not finding type for list
Type_annoter: not finding type for up
Type_annoter: not finding type for scsi_target
Type_annoter: not finding type for kfree
Type_annoter: not finding type for scsi_target
Type_annoter: not finding type for scsi_adjust_queue_depth
Type_annoter: not finding type for scsi_target
Type_annoter: not finding type for dsprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for scsi_adjust_queue_depth
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for memcpy
Type_annoter: not finding type for dprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for dtmprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for del_timer
Type_annoter: not finding type for mpt_free_msg_frame
Type_annoter: not finding type for spin_lock_irqsave
Type_annoter: not finding type for spin_unlock_irqrestore
Type_annoter: not finding type for wake_up
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for devtverboseprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for dprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for del_timer
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for ddvprintk
Type_annoter: not finding type for memcpy
Type_annoter: not finding type for min_t
Type_annoter: not finding type for wake_up
Type_annoter: not finding type for ddvprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for mpt_HardResetHandler
Type_annoter: not finding type for in_interrupt
Type_annoter: not finding type for dprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for mpt_get_msg_frame
Type_annoter: not finding type for dfailprintk
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for mpt_msg_flags
Type_annoter: not finding type for int_to_scsilun
Type_annoter: not finding type for cpu_to_le32
Type_annoter: not finding type for ddvprintk
Type_annoter: not finding type for mpt_add_sge
Type_annoter: not finding type for memcpy
Type_annoter: not finding type for jiffies
Type_annoter: not finding type for add_timer
Type_annoter: not finding type for mpt_put_msg_frame
Type_annoter: not finding type for wait_event
Type_annoter: not finding type for class_to_shost
Type_annoter: not finding type for snprintf
Type_annoter: not finding type for version_fw
Type_annoter: not finding type for class_to_shost
Type_annoter: not finding type for snprintf
Type_annoter: not finding type for version_bios
Type_annoter: not finding type for class_to_shost
Type_annoter: not finding type for snprintf
Type_annoter: not finding type for version_mpi
Type_annoter: not finding type for class_to_shost
Type_annoter: not finding type for snprintf
Type_annoter: not finding type for version_product
Type_annoter: not finding type for class_to_shost
Type_annoter: not finding type for snprintf
Type_annoter: not finding type for version_nvdata_persistent
Type_annoter: not finding type for class_to_shost
Type_annoter: not finding type for snprintf
Type_annoter: not finding type for version_nvdata_default
Type_annoter: not finding type for class_to_shost
Type_annoter: not finding type for snprintf
Type_annoter: not finding type for board_name
Type_annoter: not finding type for class_to_shost
Type_annoter: not finding type for snprintf
Type_annoter: not finding type for board_assembly
Type_annoter: not finding type for class_to_shost
Type_annoter: not finding type for snprintf
Type_annoter: not finding type for board_tracer
Type_annoter: not finding type for class_to_shost
Type_annoter: not finding type for snprintf
Type_annoter: not finding type for io_delay
Type_annoter: not finding type for class_to_shost
Type_annoter: not finding type for snprintf
Type_annoter: not finding type for device_delay
Type_annoter: not finding type for class_to_shost
Type_annoter: not finding type for snprintf
Type_annoter: not finding type for class_to_shost
Type_annoter: not finding type for sscanf
Type_annoter: not finding type for printk
Type_annoter: not finding type for strlen
Type_annoter: not finding type for debug_level
Type_annoter: not finding type for class_device_attr_version_fw
Type_annoter: not finding type for class_device_attr_version_bios
Type_annoter: not finding type for class_device_attr_version_mpi
Type_annoter: not finding type for class_device_attr_version_product
Type_annoter: not finding type for class_device_attr_version_nvdata_persistent
Type_annoter: not finding type for class_device_attr_version_nvdata_default
Type_annoter: not finding type for class_device_attr_board_name
Type_annoter: not finding type for class_device_attr_board_assembly
Type_annoter: not finding type for class_device_attr_board_tracer
Type_annoter: not finding type for class_device_attr_io_delay
Type_annoter: not finding type for class_device_attr_device_delay
Type_annoter: not finding type for class_device_attr_debug_level
PB MAYBE: dangerous typedef inference, maybe not a typedef: SEPRequest_t
PB MAYBE: dangerous typedef inference, maybe not a typedef: SCSITaskMgmt_t
PB MAYBE: dangerous typedef inference, maybe not a typedef: SCSITaskMgmtReply_t
CONFLICT:u64
transforming some ident in typedef
Type_annoter: not finding type for my_NAME
Type_annoter: not finding type for my_VERSION
Type_annoter: not finding type for scp
Type_annoter: not finding type for cpu_to_le32
Type_annoter: not finding type for cpu_to_le16
Type_annoter: not finding type for mpt_addr_size
Type_annoter: not finding type for cpu_to_le32
Type_annoter: not finding type for dsgprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for spin_lock_irqsave
Type_annoter: not finding type for list_empty
Type_annoter: not finding type for list_entry
Type_annoter: not finding type for u
Type_annoter: not finding type for list_del
Type_annoter: not finding type for dfailprintk
Type_annoter: not finding type for spin_unlock_irqrestore
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for scsi_dma_map
Type_annoter: not finding type for scsi_sglist
Type_annoter: not finding type for sg_dma_len
Type_annoter: not finding type for sg_dma_address
Type_annoter: not finding type for dsgprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for cpu_to_le32
Type_annoter: not finding type for dfailprintk
Type_annoter: not finding type for mpt_get_msg_frame
Type_annoter: not finding type for dfailprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for devtverboseprintk
Type_annoter: not finding type for mpt_put_msg_frame
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for scsi_print_command
Type_annoter: not finding type for printk
Type_annoter: not finding type for scsi_bufflen
Type_annoter: not finding type for scsi_get_resid
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for printk
Type_annoter: not finding type for dmfprintk
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for scsi_set_resid
Type_annoter: not finding type for scsi_bufflen
Type_annoter: not finding type for dreplyprintk
Type_annoter: not finding type for scsi_dma_unmap
Type_annoter: not finding type for dprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for dmfprintk
Type_annoter: not finding type for mpt_free_msg_frame
Type_annoter: not finding type for scsi_dma_unmap
Type_annoter: not finding type for dsprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for int_to_scsilun
Type_annoter: not finding type for memcmp
Type_annoter: not finding type for mpt_free_msg_frame
Type_annoter: not finding type for scsi_dma_unmap
Type_annoter: not finding type for sdev_printk
Type_annoter: not finding type for jiffies
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for dprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for pci_get_drvdata
Type_annoter: not finding type for mpt_detach
Type_annoter: not finding type for scsi_remove_host
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for kfree
Type_annoter: not finding type for dprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for scsi_host_put
Type_annoter: not finding type for mpt_suspend
Type_annoter: not finding type for mpt_resume
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for kmalloc
Type_annoter: not finding type for mpt_print_ioc_summary
Type_annoter: not finding type for memcpy
Type_annoter: not finding type for va_start
Type_annoter: not finding type for vsprintf
Type_annoter: not finding type for va_end
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for dmfprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for dtmprintk
Type_annoter: not finding type for mpt_get_msg_frame
Type_annoter: not finding type for dprintk
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for scsi_bufflen
Type_annoter: not finding type for mpt_msg_flags
Type_annoter: not finding type for int_to_scsilun
Type_annoter: not finding type for cpu_to_le32
Type_annoter: not finding type for mpt_put_msg_frame
Type_annoter: not finding type for mpt_free_msg_frame
Type_annoter: not finding type for spin_lock_irqsave
Type_annoter: not finding type for list_add_tail
Type_annoter: not finding type for spin_unlock_irqrestore
Type_annoter: not finding type for dmfprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for dtmprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for spin_lock_irqsave
Type_annoter: not finding type for spin_unlock_irqrestore
Type_annoter: not finding type for mpt_GetIocState
Type_annoter: not finding type for mpt_HardResetHandler
Type_annoter: not finding type for mpt_get_msg_frame
Type_annoter: not finding type for dfailprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for dtmprintk
Type_annoter: not finding type for int_to_scsilun
Type_annoter: not finding type for mpt_put_msg_frame_hi_pri
Type_annoter: not finding type for mpt_send_handshake_request
Type_annoter: not finding type for mpt_HardResetHandler
Type_annoter: not finding type for mpt_free_msg_frame
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for printk
Type_annoter: not finding type for scsi_print_command
Type_annoter: not finding type for dtmprintk
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for printk
Type_annoter: not finding type for scsi_print_command
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for printk
Type_annoter: not finding type for scsi_print_command
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for printk
Type_annoter: not finding type for mpt_HardResetHandler
Type_annoter: not finding type for spin_lock_irqsave
Type_annoter: not finding type for spin_unlock_irqrestore
Type_annoter: not finding type for msleep
Type_annoter: not finding type for spin_lock_irqsave
Type_annoter: not finding type for spin_unlock_irqrestore
Type_annoter: not finding type for msleep
Type_annoter: not finding type for printk
Type_annoter: not finding type for dtmprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for mpt_HardResetHandler
Type_annoter: not finding type for spin_lock_irqsave
Type_annoter: not finding type for spin_unlock_irqrestore
Type_annoter: not finding type for sector_div
Type_annoter: not finding type for list_empty
Type_annoter: not finding type for down
Type_annoter: not finding type for list
Type_annoter: not finding type for up
Type_annoter: not finding type for list_empty
Type_annoter: not finding type for down
Type_annoter: not finding type for list
Type_annoter: not finding type for up
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for scsi_target
Type_annoter: not finding type for kfree
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for scsi_target
Type_annoter: not finding type for scsi_adjust_queue_depth
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for scsi_target
Type_annoter: not finding type for dsprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for scsi_adjust_queue_depth
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for memcpy
Type_annoter: not finding type for dprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for dtmprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for del_timer
Type_annoter: not finding type for mpt_free_msg_frame
Type_annoter: not finding type for spin_lock_irqsave
Type_annoter: not finding type for spin_unlock_irqrestore
Type_annoter: not finding type for wake_up
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for devtverboseprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for dprintk
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for printk
Type_annoter: not finding type for del_timer
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for ddvprintk
Type_annoter: not finding type for memcpy
Type_annoter: not finding type for min_t
Type_annoter: not finding type for wake_up
Type_annoter: not finding type for ddvprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for mpt_HardResetHandler
Type_annoter: not finding type for in_interrupt
Type_annoter: not finding type for dprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for mpt_get_msg_frame
Type_annoter: not finding type for dfailprintk
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for mpt_msg_flags
Type_annoter: not finding type for int_to_scsilun
Type_annoter: not finding type for cpu_to_le32
Type_annoter: not finding type for ddvprintk
Type_annoter: not finding type for mpt_add_sge
Type_annoter: not finding type for memcpy
Type_annoter: not finding type for jiffies
Type_annoter: not finding type for add_timer
Type_annoter: not finding type for mpt_put_msg_frame
Type_annoter: not finding type for wait_event
Type_annoter: not finding type for class_to_shost
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for snprintf
Type_annoter: not finding type for version_fw
Type_annoter: not finding type for class_to_shost
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for snprintf
Type_annoter: not finding type for version_bios
Type_annoter: not finding type for class_to_shost
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for snprintf
Type_annoter: not finding type for version_mpi
Type_annoter: not finding type for class_to_shost
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for snprintf
Type_annoter: not finding type for version_product
Type_annoter: not finding type for class_to_shost
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for snprintf
Type_annoter: not finding type for version_nvdata_persistent
Type_annoter: not finding type for class_to_shost
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for snprintf
Type_annoter: not finding type for version_nvdata_default
Type_annoter: not finding type for class_to_shost
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for snprintf
Type_annoter: not finding type for board_name
Type_annoter: not finding type for class_to_shost
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for snprintf
Type_annoter: not finding type for board_assembly
Type_annoter: not finding type for class_to_shost
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for snprintf
Type_annoter: not finding type for board_tracer
Type_annoter: not finding type for class_to_shost
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for snprintf
Type_annoter: not finding type for io_delay
Type_annoter: not finding type for class_to_shost
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for snprintf
Type_annoter: not finding type for device_delay
Type_annoter: not finding type for class_to_shost
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for snprintf
Type_annoter: not finding type for class_to_shost
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for sscanf
Type_annoter: not finding type for printk
Type_annoter: not finding type for strlen
Type_annoter: not finding type for debug_level
Type_annoter: not finding type for class_device_attr_version_fw
Type_annoter: not finding type for class_device_attr_version_bios
Type_annoter: not finding type for class_device_attr_version_mpi
Type_annoter: not finding type for class_device_attr_version_product
Type_annoter: not finding type for class_device_attr_version_nvdata_persistent
Type_annoter: not finding type for class_device_attr_version_nvdata_default
Type_annoter: not finding type for class_device_attr_board_name
Type_annoter: not finding type for class_device_attr_board_assembly
Type_annoter: not finding type for class_device_attr_board_tracer
Type_annoter: not finding type for class_device_attr_io_delay
Type_annoter: not finding type for class_device_attr_device_delay
Type_annoter: not finding type for class_device_attr_debug_level
PB MAYBE: dangerous typedef inference, maybe not a typedef: VirtDevice
PB MAYBE: dangerous typedef inference, maybe not a typedef: MPT_FRAME_HDR
PB MAYBE: dangerous typedef inference, maybe not a typedef: SCSITaskMgmt_t
PB MAYBE: dangerous typedef inference, maybe not a typedef: SasEnclosurePage0_t
PB MAYBE: dangerous typedef inference, maybe not a typedef: SasIoUnitControlRequest_t
PB MAYBE: dangerous typedef inference, maybe not a typedef: SasIoUnitControlReply_t
PB MAYBE: dangerous typedef inference, maybe not a typedef: MPIHeader_t
PB MAYBE: dangerous typedef inference, maybe not a typedef: SmpPassthroughRequest_t
PB MAYBE: dangerous typedef inference, maybe not a typedef: SmpPassthroughReply_t
PB MAYBE: dangerous typedef inference, maybe not a typedef: SasIOUnitPage0_t
PB MAYBE: dangerous typedef inference, maybe not a typedef: SasIOUnitPage1_t
PB MAYBE: dangerous typedef inference, maybe not a typedef: SasExpanderPage0_t
semantic error two or more data types
 =File "mptsas.c.orig", line 3285, column 22,  charpos = 87174
    around = 'mptsas_remove', whole content = static void __devexit mptsas_remove(struct pci_dev *pdev)
ERROR-RECOV: found sync '}' at line 3305
badcount: 22
bad: }
bad: 
BAD:!!!!! static void __devexit mptsas_remove(struct pci_dev *pdev)
bad: {
bad: 	MPT_ADAPTER *ioc = pci_get_drvdata(pdev);
bad: 	struct mptsas_portinfo *p, *n;
bad: 	int i;
bad: 
bad: 	ioc->sas_discovery_ignore_events = 1;
bad: 	sas_remove_host(ioc->sh);
bad: 
bad: 	mutex_lock(&ioc->sas_topology_mutex);
bad: 	list_for_each_entry_safe(p, n, &ioc->sas_topology, list) {
bad: 		list_del(&p->list);
bad: 		for (i = 0 ; i < p->num_phys ; i++)
bad: 			mptsas_port_delete(ioc, p->phy_info[i].port_details);
bad: 		kfree(p->phy_info);
bad: 		kfree(p);
bad: 	}
bad: 	mutex_unlock(&ioc->sas_topology_mutex);
bad: 
bad: 	mptscsih_remove(pdev);
bad: }
semantic error two or more data types
 =File "mptsas.c.orig", line 3336, column 0,  charpos = 88552
    around = 'mptsas_init', whole content = mptsas_init(void)
ERROR-RECOV: found sync '}' at line 3361
badcount: 28
bad: };
bad: 
bad: static int __init
BAD:!!!!! mptsas_init(void)
bad: {
bad: 	int error;
bad: 
bad: 	show_mptmod_ver(my_NAME, my_VERSION);
bad: 
bad: 	mptsas_transport_template =
bad: 	    sas_attach_transport(&mptsas_transport_functions);
bad: 	if (!mptsas_transport_template)
bad: 		return -ENODEV;
bad: 
bad: 	mptsasDoneCtx = mpt_register(mptscsih_io_done, MPTSAS_DRIVER);
bad: 	mptsasTaskCtx = mpt_register(mptsas_taskmgmt_complete, MPTSAS_DRIVER);
bad: 	mptsasInternalCtx =
bad: 		mpt_register(mptscsih_scandv_complete, MPTSAS_DRIVER);
bad: 	mptsasMgmtCtx = mpt_register(mptsas_mgmt_done, MPTSAS_DRIVER);
bad: 
bad: 	mpt_event_register(mptsasDoneCtx, mptsas_event_process);
bad: 	mpt_reset_register(mptsasDoneCtx, mptsas_ioc_reset);
bad: 
bad: 	error = pci_register_driver(&mptsas_driver);
bad: 	if (error)
bad: 		sas_release_transport(mptsas_transport_template);
bad: 
bad: 	return error;
bad: }
semantic error two or more data types
 =File "mptsas.c.orig", line 3364, column 0,  charpos = 89302
    around = 'mptsas_exit', whole content = mptsas_exit(void)
ERROR-RECOV: found sync '}' at line 3376
badcount: 15
bad: }
bad: 
bad: static void __exit
BAD:!!!!! mptsas_exit(void)
bad: {
bad: 	pci_unregister_driver(&mptsas_driver);
bad: 	sas_release_transport(mptsas_transport_template);
bad: 
bad: 	mpt_reset_deregister(mptsasDoneCtx);
bad: 	mpt_event_deregister(mptsasDoneCtx);
bad: 
bad: 	mpt_deregister(mptsasMgmtCtx);
bad: 	mpt_deregister(mptsasInternalCtx);
bad: 	mpt_deregister(mptsasTaskCtx);
bad: 	mpt_deregister(mptsasDoneCtx);
bad: }
Type_annoter: not finding type for my_NAME
Type_annoter: not finding type for my_VERSION
Type_annoter: not finding type for dsasprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for memcpy
Type_annoter: not finding type for dsasprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for le64_to_cpu
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for dsasprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for memcpy
Type_annoter: not finding type for dsasprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for le64_to_cpu
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for dsasprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for dev_to_shost
Type_annoter: not finding type for dev_to_shost
Type_annoter: not finding type for list
Type_annoter: not finding type for dsaswideprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for memset
Type_annoter: not finding type for kfree
Type_annoter: not finding type for dsaswideprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for dev_printk
Type_annoter: not finding type for dsaswideprintk
Type_annoter: not finding type for dev_printk
Type_annoter: not finding type for printk
Type_annoter: not finding type for mutex_lock
Type_annoter: not finding type for dsaswideprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for memset
Type_annoter: not finding type for sas_port_delete_phy
Type_annoter: not finding type for kzalloc
Type_annoter: not finding type for kfree
Type_annoter: not finding type for mutex_unlock
Type_annoter: not finding type for mpt_get_msg_frame
Type_annoter: not finding type for dfailprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for memset
Type_annoter: not finding type for mpt_put_msg_frame_hi_pri
Type_annoter: not finding type for kzalloc
Type_annoter: not finding type for dfailprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for memcpy
Type_annoter: not finding type for list_add_tail
Type_annoter: not finding type for list_empty
Type_annoter: not finding type for list_entry
Type_annoter: not finding type for list
Type_annoter: not finding type for list_del
Type_annoter: not finding type for kzalloc
Type_annoter: not finding type for dfailprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for memcpy
Type_annoter: not finding type for le64_to_cpu
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for schedule_work
Type_annoter: not finding type for kfree
Type_annoter: not finding type for mptscsih_taskmgmt_complete
Type_annoter: not finding type for mptscsih_ioc_reset
Type_annoter: not finding type for list_empty
Type_annoter: not finding type for list
Type_annoter: not finding type for list_del
Type_annoter: not finding type for kfree
Type_annoter: not finding type for memset
Type_annoter: not finding type for mpt_config
Type_annoter: not finding type for pci_alloc_consistent
Type_annoter: not finding type for memcpy
Type_annoter: not finding type for le64_to_cpu
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for pci_free_consistent
Type_annoter: not finding type for sas_read_port_mode_page
Type_annoter: not finding type for mptscsih_slave_configure
Type_annoter: not finding type for dev_to_shost
Type_annoter: not finding type for kzalloc
Type_annoter: not finding type for dev_to_rphy
Type_annoter: not finding type for mutex_lock
Type_annoter: not finding type for list
Type_annoter: not finding type for mptscsih_is_phys_disk
Type_annoter: not finding type for mptscsih_raid_id_to_num
Type_annoter: not finding type for mutex_unlock
Type_annoter: not finding type for kfree
Type_annoter: not finding type for dev_to_shost
Type_annoter: not finding type for dev_to_rphy
Type_annoter: not finding type for list
Type_annoter: not finding type for kfree
Type_annoter: not finding type for kzalloc
Type_annoter: not finding type for printk
Type_annoter: not finding type for scsi_target
Type_annoter: not finding type for dev_to_rphy
Type_annoter: not finding type for mutex_lock
Type_annoter: not finding type for list
Type_annoter: not finding type for mptscsih_is_phys_disk
Type_annoter: not finding type for mutex_unlock
Type_annoter: not finding type for kfree
Type_annoter: not finding type for mptscsih_qcmd
Type_annoter: not finding type for mptscsih_proc_info
Type_annoter: not finding type for mptscsih_info
Type_annoter: not finding type for mptscsih_slave_destroy
Type_annoter: not finding type for mptscsih_change_queue_depth
Type_annoter: not finding type for mptscsih_abort
Type_annoter: not finding type for mptscsih_dev_reset
Type_annoter: not finding type for mptscsih_bus_reset
Type_annoter: not finding type for mptscsih_host_reset
Type_annoter: not finding type for mptscsih_bios_param
Type_annoter: not finding type for mptscsih_host_attrs
Type_annoter: not finding type for scsi_is_sas_phy_local
Type_annoter: not finding type for mpt_config
Type_annoter: not finding type for pci_alloc_consistent
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for pci_free_consistent
Type_annoter: not finding type for memcpy
Type_annoter: not finding type for min
Type_annoter: not finding type for complete
Type_annoter: not finding type for scsi_is_sas_phy_local
Type_annoter: not finding type for mutex_lock_interruptible
Type_annoter: not finding type for mpt_get_msg_frame
Type_annoter: not finding type for memset
Type_annoter: not finding type for mpt_put_msg_frame
Type_annoter: not finding type for wait_for_completion_timeout
Type_annoter: not finding type for mpt_free_msg_frame
Type_annoter: not finding type for mpt_HardResetHandler
Type_annoter: not finding type for printk
Type_annoter: not finding type for mutex_unlock
Type_annoter: not finding type for mutex_lock
Type_annoter: not finding type for list
Type_annoter: not finding type for mutex_unlock
Type_annoter: not finding type for memset
Type_annoter: not finding type for mutex_lock
Type_annoter: not finding type for list
Type_annoter: not finding type for mutex_unlock
Type_annoter: not finding type for printk
Type_annoter: not finding type for mutex_lock_interruptible
Type_annoter: not finding type for mpt_get_msg_frame
Type_annoter: not finding type for memset
Type_annoter: not finding type for cpu_to_le16
Type_annoter: not finding type for mutex_lock
Type_annoter: not finding type for mutex_unlock
Type_annoter: not finding type for cpu_to_le64
Type_annoter: not finding type for offsetof
Type_annoter: not finding type for mpt_addr_size
Type_annoter: not finding type for pci_map_single
Type_annoter: not finding type for bio_data
Type_annoter: not finding type for mpt_add_sge
Type_annoter: not finding type for mpt_put_msg_frame
Type_annoter: not finding type for wait_for_completion_timeout
Type_annoter: not finding type for mpt_HardResetHandler
Type_annoter: not finding type for memcpy
Type_annoter: not finding type for pci_unmap_single
Type_annoter: not finding type for mpt_free_msg_frame
Type_annoter: not finding type for mpt_config
Type_annoter: not finding type for pci_alloc_consistent
Type_annoter: not finding type for kcalloc
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for pci_free_consistent
Type_annoter: not finding type for memset
Type_annoter: not finding type for mpt_config
Type_annoter: not finding type for pci_alloc_consistent
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for pci_free_consistent
Type_annoter: not finding type for mpt_config
Type_annoter: not finding type for pci_alloc_consistent
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for pci_free_consistent
Type_annoter: not finding type for memset
Type_annoter: not finding type for mpt_config
Type_annoter: not finding type for pci_alloc_consistent
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for memcpy
Type_annoter: not finding type for le64_to_cpu
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for pci_free_consistent
Type_annoter: not finding type for memset
Type_annoter: not finding type for mpt_config
Type_annoter: not finding type for pci_alloc_consistent
Type_annoter: not finding type for kcalloc
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for pci_free_consistent
Type_annoter: not finding type for mpt_config
Type_annoter: not finding type for pci_alloc_consistent
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for pci_free_consistent
Type_annoter: not finding type for sas_phy_alloc
Type_annoter: not finding type for sas_phy_add
Type_annoter: not finding type for sas_phy_free
Type_annoter: not finding type for sas_port_alloc_num
Type_annoter: not finding type for sas_port_add
Type_annoter: not finding type for dfailprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for dsaswideprintk
Type_annoter: not finding type for sas_port_add_phy
Type_annoter: not finding type for scsi_is_host_device
Type_annoter: not finding type for mutex_lock
Type_annoter: not finding type for mutex_unlock
Type_annoter: not finding type for sas_port_mark_backlink
Type_annoter: not finding type for scsi_is_sas_rphy
Type_annoter: not finding type for dev_to_rphy
Type_annoter: not finding type for sas_end_device_alloc
Type_annoter: not finding type for sas_expander_alloc
Type_annoter: not finding type for sas_rphy_add
Type_annoter: not finding type for sas_rphy_free
Type_annoter: not finding type for kzalloc
Type_annoter: not finding type for mutex_lock
Type_annoter: not finding type for list_add_tail
Type_annoter: not finding type for kfree
Type_annoter: not finding type for mutex_unlock
Type_annoter: not finding type for kzalloc
Type_annoter: not finding type for mutex_lock
Type_annoter: not finding type for list_add_tail
Type_annoter: not finding type for kfree
Type_annoter: not finding type for mutex_unlock
Type_annoter: not finding type for list
Type_annoter: not finding type for mutex_lock
Type_annoter: not finding type for list
Type_annoter: not finding type for dsaswideprintk
Type_annoter: not finding type for dev_printk
Type_annoter: not finding type for sas_port_delete
Type_annoter: not finding type for list_del
Type_annoter: not finding type for kfree
Type_annoter: not finding type for mutex_unlock
Type_annoter: not finding type for mutex_lock
Type_annoter: not finding type for scsi_add_device
Type_annoter: not finding type for mutex_unlock
Type_annoter: not finding type for container_of
Type_annoter: not finding type for mutex_lock
Type_annoter: not finding type for mutex_unlock
Type_annoter: not finding type for kfree
Type_annoter: not finding type for mutex_lock
Type_annoter: not finding type for list
Type_annoter: not finding type for mutex_unlock
Type_annoter: not finding type for mutex_lock
Type_annoter: not finding type for list
Type_annoter: not finding type for mutex_unlock
Type_annoter: not finding type for mutex_lock
Type_annoter: not finding type for list
Type_annoter: not finding type for mutex_unlock
Type_annoter: not finding type for container_of
Type_annoter: not finding type for sas_persist_task
Type_annoter: not finding type for mptbase_sas_persist_operation
Type_annoter: not finding type for scsi_device_reprobe
Type_annoter: not finding type for starget_for_each_device
Type_annoter: not finding type for memset
Type_annoter: not finding type for mpt_config
Type_annoter: not finding type for pci_alloc_consistent
Type_annoter: not finding type for mpt_raid_phys_disk_pg0
Type_annoter: not finding type for kzalloc
Type_annoter: not finding type for printk
Type_annoter: not finding type for schedule_work
Type_annoter: not finding type for pci_free_consistent
Type_annoter: not finding type for container_of
Type_annoter: not finding type for mutex_lock
Type_annoter: not finding type for dfailprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for dev_printk
Type_annoter: not finding type for sas_port_delete
Type_annoter: not finding type for mpt_findImVolumes
Type_annoter: not finding type for memcpy
Type_annoter: not finding type for sas_end_device_alloc
Type_annoter: not finding type for sas_rphy_add
Type_annoter: not finding type for sas_rphy_free
Type_annoter: not finding type for scsi_device_lookup
Type_annoter: not finding type for scsi_device_put
Type_annoter: not finding type for scsi_add_device
Type_annoter: not finding type for scsi_remove_device
Type_annoter: not finding type for mutex_unlock
Type_annoter: not finding type for kfree
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for kzalloc
Type_annoter: not finding type for printk
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for memcpy
Type_annoter: not finding type for le64_to_cpu
Type_annoter: not finding type for schedule_work
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for kzalloc
Type_annoter: not finding type for printk
Type_annoter: not finding type for schedule_work
Type_annoter: not finding type for kzalloc
Type_annoter: not finding type for schedule_work
Type_annoter: not finding type for kzalloc
Type_annoter: not finding type for schedule_work
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for mptscsih_event_process
Type_annoter: not finding type for schedule_work
Type_annoter: not finding type for mpt_attach
Type_annoter: not finding type for pci_get_drvdata
Type_annoter: not finding type for printk
Type_annoter: not finding type for scsi_host_alloc
Type_annoter: not finding type for spin_lock_irqsave
Type_annoter: not finding type for mutex_init
Type_annoter: not finding type for init_completion
Type_annoter: not finding type for dprintk
Type_annoter: not finding type for kcalloc
Type_annoter: not finding type for init_timer
Type_annoter: not finding type for mptscsih_timer_expired
Type_annoter: not finding type for init_waitqueue_head
Type_annoter: not finding type for spin_unlock_irqrestore
Type_annoter: not finding type for mptbase_sas_persist_operation
Type_annoter: not finding type for scsi_add_host
Type_annoter: not finding type for mptscsih_remove
Type_annoter: not finding type for pci
Type_annoter: not finding type for mptsas_remove
Type_annoter: not finding type for mptscsih_shutdown
Type_annoter: not finding type for mptscsih_suspend
Type_annoter: not finding type for mptscsih_resume
Type_annoter: not finding type for mptsas_init
Type_annoter: not finding type for mptsas_exit
PB MAYBE: dangerous typedef inference, maybe not a typedef: VirtDevice
PB MAYBE: dangerous typedef inference, maybe not a typedef: MPT_FRAME_HDR
PB MAYBE: dangerous typedef inference, maybe not a typedef: SCSITaskMgmt_t
PB MAYBE: dangerous typedef inference, maybe not a typedef: SasEnclosurePage0_t
PB MAYBE: dangerous typedef inference, maybe not a typedef: SasIoUnitControlRequest_t
PB MAYBE: dangerous typedef inference, maybe not a typedef: SasIoUnitControlReply_t
PB MAYBE: dangerous typedef inference, maybe not a typedef: MPIHeader_t
PB MAYBE: dangerous typedef inference, maybe not a typedef: SmpPassthroughRequest_t
PB MAYBE: dangerous typedef inference, maybe not a typedef: SmpPassthroughReply_t
PB MAYBE: dangerous typedef inference, maybe not a typedef: SasIOUnitPage0_t
PB MAYBE: dangerous typedef inference, maybe not a typedef: SasIOUnitPage1_t
PB MAYBE: dangerous typedef inference, maybe not a typedef: SasExpanderPage0_t
semantic error two or more data types
 =File "mptsas.c.new", line 3285, column 22,  charpos = 87068
    around = 'mptsas_remove', whole content = static void __devexit mptsas_remove(struct pci_dev *pdev)
ERROR-RECOV: found sync '}' at line 3305
badcount: 22
bad: }
bad: 
BAD:!!!!! static void __devexit mptsas_remove(struct pci_dev *pdev)
bad: {
bad: 	MPT_ADAPTER *ioc = pci_get_drvdata(pdev);
bad: 	struct mptsas_portinfo *p, *n;
bad: 	int i;
bad: 
bad: 	ioc->sas_discovery_ignore_events = 1;
bad: 	sas_remove_host(ioc->sh);
bad: 
bad: 	mutex_lock(&ioc->sas_topology_mutex);
bad: 	list_for_each_entry_safe(p, n, &ioc->sas_topology, list) {
bad: 		list_del(&p->list);
bad: 		for (i = 0 ; i < p->num_phys ; i++)
bad: 			mptsas_port_delete(ioc, p->phy_info[i].port_details);
bad: 		kfree(p->phy_info);
bad: 		kfree(p);
bad: 	}
bad: 	mutex_unlock(&ioc->sas_topology_mutex);
bad: 
bad: 	mptscsih_remove(pdev);
bad: }
semantic error two or more data types
 =File "mptsas.c.new", line 3336, column 0,  charpos = 88446
    around = 'mptsas_init', whole content = mptsas_init(void)
ERROR-RECOV: found sync '}' at line 3361
badcount: 28
bad: };
bad: 
bad: static int __init
BAD:!!!!! mptsas_init(void)
bad: {
bad: 	int error;
bad: 
bad: 	show_mptmod_ver(my_NAME, my_VERSION);
bad: 
bad: 	mptsas_transport_template =
bad: 	    sas_attach_transport(&mptsas_transport_functions);
bad: 	if (!mptsas_transport_template)
bad: 		return -ENODEV;
bad: 
bad: 	mptsasDoneCtx = mpt_register(mptscsih_io_done, MPTSAS_DRIVER);
bad: 	mptsasTaskCtx = mpt_register(mptsas_taskmgmt_complete, MPTSAS_DRIVER);
bad: 	mptsasInternalCtx =
bad: 		mpt_register(mptscsih_scandv_complete, MPTSAS_DRIVER);
bad: 	mptsasMgmtCtx = mpt_register(mptsas_mgmt_done, MPTSAS_DRIVER);
bad: 
bad: 	mpt_event_register(mptsasDoneCtx, mptsas_event_process);
bad: 	mpt_reset_register(mptsasDoneCtx, mptsas_ioc_reset);
bad: 
bad: 	error = pci_register_driver(&mptsas_driver);
bad: 	if (error)
bad: 		sas_release_transport(mptsas_transport_template);
bad: 
bad: 	return error;
bad: }
semantic error two or more data types
 =File "mptsas.c.new", line 3364, column 0,  charpos = 89196
    around = 'mptsas_exit', whole content = mptsas_exit(void)
ERROR-RECOV: found sync '}' at line 3376
badcount: 15
bad: }
bad: 
bad: static void __exit
BAD:!!!!! mptsas_exit(void)
bad: {
bad: 	pci_unregister_driver(&mptsas_driver);
bad: 	sas_release_transport(mptsas_transport_template);
bad: 
bad: 	mpt_reset_deregister(mptsasDoneCtx);
bad: 	mpt_event_deregister(mptsasDoneCtx);
bad: 
bad: 	mpt_deregister(mptsasMgmtCtx);
bad: 	mpt_deregister(mptsasInternalCtx);
bad: 	mpt_deregister(mptsasTaskCtx);
bad: 	mpt_deregister(mptsasDoneCtx);
bad: }
Type_annoter: not finding type for my_NAME
Type_annoter: not finding type for my_VERSION
Type_annoter: not finding type for dsasprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for memcpy
Type_annoter: not finding type for dsasprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for le64_to_cpu
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for dsasprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for memcpy
Type_annoter: not finding type for dsasprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for le64_to_cpu
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for dsasprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for dev_to_shost
Type_annoter: not finding type for dev_to_shost
Type_annoter: not finding type for list
Type_annoter: not finding type for dsaswideprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for memset
Type_annoter: not finding type for kfree
Type_annoter: not finding type for dsaswideprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for dev_printk
Type_annoter: not finding type for dsaswideprintk
Type_annoter: not finding type for dev_printk
Type_annoter: not finding type for printk
Type_annoter: not finding type for mutex_lock
Type_annoter: not finding type for dsaswideprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for memset
Type_annoter: not finding type for sas_port_delete_phy
Type_annoter: not finding type for kzalloc
Type_annoter: not finding type for kfree
Type_annoter: not finding type for mutex_unlock
Type_annoter: not finding type for mpt_get_msg_frame
Type_annoter: not finding type for dfailprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for memset
Type_annoter: not finding type for mpt_put_msg_frame_hi_pri
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for kzalloc
Type_annoter: not finding type for dfailprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for memcpy
Type_annoter: not finding type for list_add_tail
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for list_empty
Type_annoter: not finding type for list_entry
Type_annoter: not finding type for list
Type_annoter: not finding type for list_del
Type_annoter: not finding type for kzalloc
Type_annoter: not finding type for dfailprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for memcpy
Type_annoter: not finding type for le64_to_cpu
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for schedule_work
Type_annoter: not finding type for kfree
Type_annoter: not finding type for mptscsih_taskmgmt_complete
Type_annoter: not finding type for mptscsih_ioc_reset
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for list_empty
Type_annoter: not finding type for list
Type_annoter: not finding type for list_del
Type_annoter: not finding type for kfree
Type_annoter: not finding type for memset
Type_annoter: not finding type for mpt_config
Type_annoter: not finding type for pci_alloc_consistent
Type_annoter: not finding type for memcpy
Type_annoter: not finding type for le64_to_cpu
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for pci_free_consistent
Type_annoter: not finding type for sas_read_port_mode_page
Type_annoter: not finding type for mptscsih_slave_configure
Type_annoter: not finding type for dev_to_shost
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for kzalloc
Type_annoter: not finding type for dev_to_rphy
Type_annoter: not finding type for mutex_lock
Type_annoter: not finding type for list
Type_annoter: not finding type for mptscsih_is_phys_disk
Type_annoter: not finding type for mptscsih_raid_id_to_num
Type_annoter: not finding type for mutex_unlock
Type_annoter: not finding type for kfree
Type_annoter: not finding type for dev_to_shost
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for dev_to_rphy
Type_annoter: not finding type for list
Type_annoter: not finding type for kfree
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for kzalloc
Type_annoter: not finding type for printk
Type_annoter: not finding type for scsi_target
Type_annoter: not finding type for dev_to_rphy
Type_annoter: not finding type for mutex_lock
Type_annoter: not finding type for list
Type_annoter: not finding type for mptscsih_is_phys_disk
Type_annoter: not finding type for mutex_unlock
Type_annoter: not finding type for kfree
Type_annoter: not finding type for mptscsih_qcmd
Type_annoter: not finding type for mptscsih_proc_info
Type_annoter: not finding type for mptscsih_info
Type_annoter: not finding type for mptscsih_slave_destroy
Type_annoter: not finding type for mptscsih_change_queue_depth
Type_annoter: not finding type for mptscsih_abort
Type_annoter: not finding type for mptscsih_dev_reset
Type_annoter: not finding type for mptscsih_bus_reset
Type_annoter: not finding type for mptscsih_host_reset
Type_annoter: not finding type for mptscsih_bios_param
Type_annoter: not finding type for mptscsih_host_attrs
Type_annoter: not finding type for scsi_is_sas_phy_local
Type_annoter: not finding type for mpt_config
Type_annoter: not finding type for pci_alloc_consistent
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for pci_free_consistent
Type_annoter: not finding type for memcpy
Type_annoter: not finding type for min
Type_annoter: not finding type for complete
Type_annoter: not finding type for scsi_is_sas_phy_local
Type_annoter: not finding type for mutex_lock_interruptible
Type_annoter: not finding type for mpt_get_msg_frame
Type_annoter: not finding type for memset
Type_annoter: not finding type for mpt_put_msg_frame
Type_annoter: not finding type for wait_for_completion_timeout
Type_annoter: not finding type for mpt_free_msg_frame
Type_annoter: not finding type for mpt_HardResetHandler
Type_annoter: not finding type for printk
Type_annoter: not finding type for mutex_unlock
Type_annoter: not finding type for mutex_lock
Type_annoter: not finding type for list
Type_annoter: not finding type for mutex_unlock
Type_annoter: not finding type for memset
Type_annoter: not finding type for mutex_lock
Type_annoter: not finding type for list
Type_annoter: not finding type for mutex_unlock
Type_annoter: not finding type for printk
Type_annoter: not finding type for mutex_lock_interruptible
Type_annoter: not finding type for mpt_get_msg_frame
Type_annoter: not finding type for memset
Type_annoter: not finding type for cpu_to_le16
Type_annoter: not finding type for mutex_lock
Type_annoter: not finding type for mutex_unlock
Type_annoter: not finding type for cpu_to_le64
Type_annoter: not finding type for offsetof
Type_annoter: not finding type for mpt_addr_size
Type_annoter: not finding type for pci_map_single
Type_annoter: not finding type for bio_data
Type_annoter: not finding type for mpt_add_sge
Type_annoter: not finding type for mpt_put_msg_frame
Type_annoter: not finding type for wait_for_completion_timeout
Type_annoter: not finding type for mpt_HardResetHandler
Type_annoter: not finding type for memcpy
Type_annoter: not finding type for pci_unmap_single
Type_annoter: not finding type for mpt_free_msg_frame
Type_annoter: not finding type for mpt_config
Type_annoter: not finding type for pci_alloc_consistent
Type_annoter: not finding type for kcalloc
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for pci_free_consistent
Type_annoter: not finding type for memset
Type_annoter: not finding type for mpt_config
Type_annoter: not finding type for pci_alloc_consistent
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for pci_free_consistent
Type_annoter: not finding type for mpt_config
Type_annoter: not finding type for pci_alloc_consistent
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for pci_free_consistent
Type_annoter: not finding type for memset
Type_annoter: not finding type for mpt_config
Type_annoter: not finding type for pci_alloc_consistent
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for memcpy
Type_annoter: not finding type for le64_to_cpu
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for pci_free_consistent
Type_annoter: not finding type for memset
Type_annoter: not finding type for mpt_config
Type_annoter: not finding type for pci_alloc_consistent
Type_annoter: not finding type for kcalloc
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for pci_free_consistent
Type_annoter: not finding type for mpt_config
Type_annoter: not finding type for pci_alloc_consistent
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for pci_free_consistent
Type_annoter: not finding type for sas_phy_alloc
Type_annoter: not finding type for sas_phy_add
Type_annoter: not finding type for sas_phy_free
Type_annoter: not finding type for sas_port_alloc_num
Type_annoter: not finding type for sas_port_add
Type_annoter: not finding type for dfailprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for dsaswideprintk
Type_annoter: not finding type for sas_port_add_phy
Type_annoter: not finding type for scsi_is_host_device
Type_annoter: not finding type for mutex_lock
Type_annoter: not finding type for mutex_unlock
Type_annoter: not finding type for sas_port_mark_backlink
Type_annoter: not finding type for scsi_is_sas_rphy
Type_annoter: not finding type for dev_to_rphy
Type_annoter: not finding type for sas_end_device_alloc
Type_annoter: not finding type for sas_expander_alloc
Type_annoter: not finding type for sas_rphy_add
Type_annoter: not finding type for sas_rphy_free
Type_annoter: not finding type for kzalloc
Type_annoter: not finding type for mutex_lock
Type_annoter: not finding type for list_add_tail
Type_annoter: not finding type for kfree
Type_annoter: not finding type for mutex_unlock
Type_annoter: not finding type for kzalloc
Type_annoter: not finding type for mutex_lock
Type_annoter: not finding type for list_add_tail
Type_annoter: not finding type for kfree
Type_annoter: not finding type for mutex_unlock
Type_annoter: not finding type for list
Type_annoter: not finding type for mutex_lock
Type_annoter: not finding type for list
Type_annoter: not finding type for dsaswideprintk
Type_annoter: not finding type for dev_printk
Type_annoter: not finding type for sas_port_delete
Type_annoter: not finding type for list_del
Type_annoter: not finding type for kfree
Type_annoter: not finding type for mutex_unlock
Type_annoter: not finding type for mutex_lock
Type_annoter: not finding type for scsi_add_device
Type_annoter: not finding type for mutex_unlock
Type_annoter: not finding type for container_of
Type_annoter: not finding type for mutex_lock
Type_annoter: not finding type for mutex_unlock
Type_annoter: not finding type for kfree
Type_annoter: not finding type for mutex_lock
Type_annoter: not finding type for list
Type_annoter: not finding type for mutex_unlock
Type_annoter: not finding type for mutex_lock
Type_annoter: not finding type for list
Type_annoter: not finding type for mutex_unlock
Type_annoter: not finding type for mutex_lock
Type_annoter: not finding type for list
Type_annoter: not finding type for mutex_unlock
Type_annoter: not finding type for container_of
Type_annoter: not finding type for sas_persist_task
Type_annoter: not finding type for mptbase_sas_persist_operation
Type_annoter: not finding type for scsi_device_reprobe
Type_annoter: not finding type for starget_for_each_device
Type_annoter: not finding type for memset
Type_annoter: not finding type for mpt_config
Type_annoter: not finding type for pci_alloc_consistent
Type_annoter: not finding type for mpt_raid_phys_disk_pg0
Type_annoter: not finding type for kzalloc
Type_annoter: not finding type for printk
Type_annoter: not finding type for schedule_work
Type_annoter: not finding type for pci_free_consistent
Type_annoter: not finding type for container_of
Type_annoter: not finding type for mutex_lock
Type_annoter: not finding type for dfailprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for dev_printk
Type_annoter: not finding type for sas_port_delete
Type_annoter: not finding type for mpt_findImVolumes
Type_annoter: not finding type for memcpy
Type_annoter: not finding type for sas_end_device_alloc
Type_annoter: not finding type for sas_rphy_add
Type_annoter: not finding type for sas_rphy_free
Type_annoter: not finding type for scsi_device_lookup
Type_annoter: not finding type for scsi_device_put
Type_annoter: not finding type for scsi_add_device
Type_annoter: not finding type for scsi_remove_device
Type_annoter: not finding type for mutex_unlock
Type_annoter: not finding type for kfree
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for kzalloc
Type_annoter: not finding type for printk
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for memcpy
Type_annoter: not finding type for le64_to_cpu
Type_annoter: not finding type for schedule_work
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for kzalloc
Type_annoter: not finding type for printk
Type_annoter: not finding type for schedule_work
Type_annoter: not finding type for kzalloc
Type_annoter: not finding type for schedule_work
Type_annoter: not finding type for kzalloc
Type_annoter: not finding type for schedule_work
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for mptscsih_event_process
Type_annoter: not finding type for schedule_work
Type_annoter: not finding type for mpt_attach
Type_annoter: not finding type for pci_get_drvdata
Type_annoter: not finding type for printk
Type_annoter: not finding type for scsi_host_alloc
Type_annoter: not finding type for spin_lock_irqsave
Type_annoter: not finding type for mutex_init
Type_annoter: not finding type for init_completion
Type_annoter: not finding type for dprintk
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for kcalloc
Type_annoter: not finding type for init_timer
Type_annoter: not finding type for mptscsih_timer_expired
Type_annoter: not finding type for init_waitqueue_head
Type_annoter: not finding type for spin_unlock_irqrestore
Type_annoter: not finding type for mptbase_sas_persist_operation
Type_annoter: not finding type for scsi_add_host
Type_annoter: not finding type for mptscsih_remove
Type_annoter: not finding type for pci
Type_annoter: not finding type for mptsas_remove
Type_annoter: not finding type for mptscsih_shutdown
Type_annoter: not finding type for mptscsih_suspend
Type_annoter: not finding type for mptscsih_resume
Type_annoter: not finding type for mptsas_init
Type_annoter: not finding type for mptsas_exit
semantic error two or more data types
 =File "mptctl.c.orig", line 124, column 76,  charpos = 4656
    around = '*', whole content = static int mptctl_do_mpt_command(struct mpt_ioctl_command karg, void __user *mfPtr);
ERROR-RECOV: found sync col 0 at line 125
badcount: 5
bad: static long compat_mpctl_ioctl(struct file *f, unsigned cmd, unsigned long arg);
bad: #endif
bad: /*
bad:  * Private function calls.
bad:  */
BAD:!!!!! static int mptctl_do_mpt_command(struct mpt_ioctl_command karg, void __user *mfPtr);
semantic error two or more data types
 =File "mptctl.c.orig", line 125, column 54,  charpos = 4719
    around = '*', whole content = static int mptctl_do_fw_download(int ioc, char __user *ufwbuf, size_t fwlen);
ERROR-RECOV: found sync col 0 at line 126
badcount: 1
bad: static int mptctl_do_mpt_command(struct mpt_ioctl_command karg, void __user *mfPtr);
BAD:!!!!! static int mptctl_do_fw_download(int ioc, char __user *ufwbuf, size_t fwlen);
PB MAYBE: dangerous typedef inference, maybe not a typedef: SCSITaskMgmt_t
semantic error two or more data types
 =File "mptctl.c.orig", line 573, column 25,  charpos = 16860
    around = '*', whole content = 	mpt_ioctl_header __user *uhdr = (void __user *) arg;
ERROR-RECOV: found sync '}' at line 649
badcount: 87
bad: }
bad: 
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
bad: /*
bad:  *  MPT ioctl handler
bad:  *  cmd - specify the particular IOCTL command to be issued
bad:  *  arg - data specific to the command. Must not be null.
bad:  */
bad: static long
bad: __mptctl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
bad: {
BAD:!!!!! 	mpt_ioctl_header __user *uhdr = (void __user *) arg;
bad: 	mpt_ioctl_header	 khdr;
bad: 	int iocnum;
bad: 	unsigned iocnumX;
bad: 	int nonblock = (file->f_flags & O_NONBLOCK);
bad: 	int ret;
bad: 	MPT_ADAPTER *iocp = NULL;
bad: 
bad: 	if (copy_from_user(&khdr, uhdr, sizeof(khdr))) {
bad: 		printk(KERN_ERR MYNAM "%s::mptctl_ioctl() @%d - "
bad: 				"Unable to copy mpt_ioctl_header data @ %p\n",
bad: 				__FILE__, __LINE__, uhdr);
bad: 		return -EFAULT;
bad: 	}
bad: 	ret = -ENXIO;				/* (-6) No such device or address */
bad: 
bad: 	/* Verify intended MPT adapter - set iocnum and the adapter
bad: 	 * pointer (iocp)
bad: 	 */
bad: 	iocnumX = khdr.iocnum & 0xFF;
bad: 	if (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||
bad: 	    (iocp == NULL)) {
bad: 		printk(KERN_DEBUG MYNAM "%s::mptctl_ioctl() @%d - ioc%d not found!\n",
bad: 				__FILE__, __LINE__, iocnumX);
bad: 		return -ENODEV;
bad: 	}
bad: 
bad: 	if (!iocp->active) {
bad: 		printk(KERN_DEBUG MYNAM "%s::mptctl_ioctl() @%d - Controller disabled.\n",
bad: 				__FILE__, __LINE__);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	/* Handle those commands that are just returning
bad: 	 * information stored in the driver.
bad: 	 * These commands should never time out and are unaffected
bad: 	 * by TM and FW reloads.
bad: 	 */
bad: 	if ((cmd & ~IOCSIZE_MASK) == (MPTIOCINFO & ~IOCSIZE_MASK)) {
bad: 		return mptctl_getiocinfo(arg, _IOC_SIZE(cmd));
bad: 	} else if (cmd == MPTTARGETINFO) {
bad: 		return mptctl_gettargetinfo(arg);
bad: 	} else if (cmd == MPTTEST) {
bad: 		return mptctl_readtest(arg);
bad: 	} else if (cmd == MPTEVENTQUERY) {
bad: 		return mptctl_eventquery(arg);
bad: 	} else if (cmd == MPTEVENTENABLE) {
bad: 		return mptctl_eventenable(arg);
bad: 	} else if (cmd == MPTEVENTREPORT) {
bad: 		return mptctl_eventreport(arg);
bad: 	} else if (cmd == MPTFWREPLACE) {
bad: 		return mptctl_replace_fw(arg);
bad: 	}
bad: 
bad: 	/* All of these commands require an interrupt or
bad: 	 * are unknown/illegal.
bad: 	 */
bad: 	if ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)
bad: 		return ret;
bad: 
bad: 	if (cmd == MPTFWDOWNLOAD)
bad: 		ret = mptctl_fw_download(arg);
bad: 	else if (cmd == MPTCOMMAND)
bad: 		ret = mptctl_mpt_command(arg);
bad: 	else if (cmd == MPTHARDRESET)
bad: 		ret = mptctl_do_reset(arg);
bad: 	else if ((cmd & ~IOCSIZE_MASK) == (HP_GETHOSTINFO & ~IOCSIZE_MASK))
bad: 		ret = mptctl_hp_hostinfo(arg, _IOC_SIZE(cmd));
bad: 	else if (cmd == HP_GETTARGETINFO)
bad: 		ret = mptctl_hp_targetinfo(arg);
bad: 	else
bad: 		ret = -EINVAL;
bad: 
bad: 	mutex_unlock(&iocp->ioctl->ioctl_mutex);
bad: 
bad: 	return ret;
bad: }
semantic error two or more data types
 =File "mptctl.c.orig", line 663, column 36,  charpos = 19342
    around = '*', whole content = 	struct mpt_ioctl_diag_reset __user *urinfo = (void __user *) arg;
ERROR-RECOV: found sync '}' at line 690
badcount: 31
bad: }
bad: 
bad: static int mptctl_do_reset(unsigned long arg)
bad: {
BAD:!!!!! 	struct mpt_ioctl_diag_reset __user *urinfo = (void __user *) arg;
bad: 	struct mpt_ioctl_diag_reset krinfo;
bad: 	MPT_ADAPTER		*iocp;
bad: 
bad: 	if (copy_from_user(&krinfo, urinfo, sizeof(struct mpt_ioctl_diag_reset))) {
bad: 		printk(KERN_ERR MYNAM "%s@%d::mptctl_do_reset - "
bad: 				"Unable to copy mpt_ioctl_diag_reset struct @ %p\n",
bad: 				__FILE__, __LINE__, urinfo);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	if (mpt_verify_adapter(krinfo.hdr.iocnum, &iocp) < 0) {
bad: 		printk(KERN_DEBUG MYNAM "%s@%d::mptctl_do_reset - ioc%d not found!\n",
bad: 				__FILE__, __LINE__, krinfo.hdr.iocnum);
bad: 		return -ENODEV; /* (-6) No such device or address */
bad: 	}
bad: 
bad: 	dctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT "mptctl_do_reset called.\n",
bad: 	    iocp->name));
bad: 
bad: 	if (mpt_HardResetHandler(iocp, CAN_SLEEP) != 0) {
bad: 		printk (MYIOC_s_ERR_FMT "%s@%d::mptctl_do_reset - reset failed.\n",
bad: 			iocp->name, __FILE__, __LINE__);
bad: 		return -1;
bad: 	}
bad: 
bad: 	return 0;
bad: }
semantic error two or more data types
 =File "mptctl.c.orig", line 712, column 27,  charpos = 20904
    around = '*', whole content = 	struct mpt_fw_xfer __user *ufwdl = (void __user *) arg;
ERROR-RECOV: found sync '}' at line 723
badcount: 33
bad: }
bad: 
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
bad: /*
bad:  * MPT FW download function.  Cast the arg into the mpt_fw_xfer structure.
bad:  * This structure contains: iocnum, firmware length (bytes),
bad:  *      pointer to user space memory where the fw image is stored.
bad:  *
bad:  * Outputs:	None.
bad:  * Return:	0 if successful
bad:  *		-EFAULT if data unavailable
bad:  *		-ENXIO  if no such device
bad:  *		-EAGAIN if resource problem
bad:  *		-ENOMEM if no memory for SGE
bad:  *		-EMLINK if too many chain buffers required
bad:  *		-EBADRQC if adapter does not support FW download
bad:  *		-EBUSY if adapter is busy
bad:  *		-ENOMSG if FW upload returned bad status
bad:  */
bad: static int
bad: mptctl_fw_download(unsigned long arg)
bad: {
BAD:!!!!! 	struct mpt_fw_xfer __user *ufwdl = (void __user *) arg;
bad: 	struct mpt_fw_xfer	 kfwdl;
bad: 
bad: 	if (copy_from_user(&kfwdl, ufwdl, sizeof(struct mpt_fw_xfer))) {
bad: 		printk(KERN_ERR MYNAM "%s@%d::_ioctl_fwdl - "
bad: 				"Unable to copy mpt_fw_xfer struct @ %p\n",
bad: 				__FILE__, __LINE__, ufwdl);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	return mptctl_do_fw_download(kfwdl.iocnum, kfwdl.bufp, kfwdl.fwlen);
bad: }
semantic error two or more data types
 =File "mptctl.c.orig", line 740, column 43,  charpos = 21763
    around = '*', whole content = mptctl_do_fw_download(int ioc, char __user *ufwbuf, size_t fwlen)
ERROR-RECOV: found sync '}' at line 938
badcount: 215
bad: }
bad: 
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
bad: /*
bad:  * FW Download engine.
bad:  * Outputs:	None.
bad:  * Return:	0 if successful
bad:  *		-EFAULT if data unavailable
bad:  *		-ENXIO  if no such device
bad:  *		-EAGAIN if resource problem
bad:  *		-ENOMEM if no memory for SGE
bad:  *		-EMLINK if too many chain buffers required
bad:  *		-EBADRQC if adapter does not support FW download
bad:  *		-EBUSY if adapter is busy
bad:  *		-ENOMSG if FW upload returned bad status
bad:  */
bad: static int
BAD:!!!!! mptctl_do_fw_download(int ioc, char __user *ufwbuf, size_t fwlen)
bad: {
bad: 	FWDownload_t		*dlmsg;
bad: 	MPT_FRAME_HDR		*mf;
bad: 	MPT_ADAPTER		*iocp;
bad: 	FWDownloadTCSGE_t	*ptsge;
bad: 	MptSge_t		*sgl, *sgIn;
bad: 	char			*sgOut;
bad: 	struct buflist		*buflist;
bad: 	struct buflist		*bl;
bad: 	dma_addr_t		 sgl_dma;
bad: 	int			 ret;
bad: 	int			 numfrags = 0;
bad: 	int			 maxfrags;
bad: 	int			 n = 0;
bad: 	u32			 sgdir;
bad: 	u32			 nib;
bad: 	int			 fw_bytes_copied = 0;
bad: 	int			 i;
bad: 	int			 sge_offset = 0;
bad: 	u16			 iocstat;
bad: 	pFWDownloadReply_t	 ReplyMsg = NULL;
bad: 
bad: 	if (mpt_verify_adapter(ioc, &iocp) < 0) {
bad: 		printk(KERN_DEBUG MYNAM "ioctl_fwdl - ioc%d not found!\n",
bad: 				 ioc);
bad: 		return -ENODEV; /* (-6) No such device or address */
bad: 	} else {
bad: 
bad: 		/*  Valid device. Get a message frame and construct the FW download message.
bad: 	 	*/
bad: 		if ((mf = mpt_get_msg_frame(mptctl_id, iocp)) == NULL)
bad: 			return -EAGAIN;
bad: 	}
bad: 
bad: 	dctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT
bad: 	    "mptctl_do_fwdl called. mptctl_id = %xh.\n", iocp->name, mptctl_id));
bad: 	dctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT "DbG: kfwdl.bufp  = %p\n",
bad: 	    iocp->name, ufwbuf));
bad: 	dctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT "DbG: kfwdl.fwlen = %d\n",
bad: 	    iocp->name, (int)fwlen));
bad: 	dctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT "DbG: kfwdl.ioc   = %04xh\n",
bad: 	    iocp->name, ioc));
bad: 
bad: 	dlmsg = (FWDownload_t*) mf;
bad: 	ptsge = (FWDownloadTCSGE_t *) &dlmsg->SGL;
bad: 	sgOut = (char *) (ptsge + 1);
bad: 
bad: 	/*
bad: 	 * Construct f/w download request
bad: 	 */
bad: 	dlmsg->ImageType = MPI_FW_DOWNLOAD_ITYPE_FW;
bad: 	dlmsg->Reserved = 0;
bad: 	dlmsg->ChainOffset = 0;
bad: 	dlmsg->Function = MPI_FUNCTION_FW_DOWNLOAD;
bad: 	dlmsg->Reserved1[0] = dlmsg->Reserved1[1] = dlmsg->Reserved1[2] = 0;
bad: 	if (iocp->facts.MsgVersion >= MPI_VERSION_01_05)
bad: 		dlmsg->MsgFlags = MPI_FW_DOWNLOAD_MSGFLGS_LAST_SEGMENT;
bad: 	else
bad: 		dlmsg->MsgFlags = 0;
bad: 
bad: 
bad: 	/* Set up the Transaction SGE.
bad: 	 */
bad: 	ptsge->Reserved = 0;
bad: 	ptsge->ContextSize = 0;
bad: 	ptsge->DetailsLength = 12;
bad: 	ptsge->Flags = MPI_SGE_FLAGS_TRANSACTION_ELEMENT;
bad: 	ptsge->Reserved_0100_Checksum = 0;
bad: 	ptsge->ImageOffset = 0;
bad: 	ptsge->ImageSize = cpu_to_le32(fwlen);
bad: 
bad: 	/* Add the SGL
bad: 	 */
bad: 
bad: 	/*
bad: 	 * Need to kmalloc area(s) for holding firmware image bytes.
bad: 	 * But we need to do it piece meal, using a proper
bad: 	 * scatter gather list (with 128kB MAX hunks).
bad: 	 *
bad: 	 * A practical limit here might be # of sg hunks that fit into
bad: 	 * a single IOC request frame; 12 or 8 (see below), so:
bad: 	 * For FC9xx: 12 x 128kB == 1.5 mB (max)
bad: 	 * For C1030:  8 x 128kB == 1   mB (max)
bad: 	 * We could support chaining, but things get ugly(ier:)
bad: 	 *
bad: 	 * Set the sge_offset to the start of the sgl (bytes).
bad: 	 */
bad: 	sgdir = 0x04000000;		/* IOC will READ from sys mem */
bad: 	sge_offset = sizeof(MPIHeader_t) + sizeof(FWDownloadTCSGE_t);
bad: 	if ((sgl = kbuf_alloc_2_sgl(fwlen, sgdir, sge_offset,
bad: 				    &numfrags, &buflist, &sgl_dma, iocp)) == NULL)
bad: 		return -ENOMEM;
bad: 
bad: 	/*
bad: 	 * We should only need SGL with 2 simple_32bit entries (up to 256 kB)
bad: 	 * for FC9xx f/w image, but calculate max number of sge hunks
bad: 	 * we can fit into a request frame, and limit ourselves to that.
bad: 	 * (currently no chain support)
bad: 	 * maxfrags = (Request Size - FWdownload Size ) / Size of 32 bit SGE
bad: 	 *	Request		maxfrags
bad: 	 *	128		12
bad: 	 *	96		8
bad: 	 *	64		4
bad: 	 */
bad: 	maxfrags = (iocp->req_sz - sizeof(MPIHeader_t) - sizeof(FWDownloadTCSGE_t))
bad: 			/ (sizeof(dma_addr_t) + sizeof(u32));
bad: 	if (numfrags > maxfrags) {
bad: 		ret = -EMLINK;
bad: 		goto fwdl_out;
bad: 	}
bad: 
bad: 	dctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT "DbG: sgl buffer = %p, sgfrags = %d\n",
bad: 	    iocp->name, sgl, numfrags));
bad: 
bad: 	/*
bad: 	 * Parse SG list, copying sgl itself,
bad: 	 * plus f/w image hunks from user space as we go...
bad: 	 */
bad: 	ret = -EFAULT;
bad: 	sgIn = sgl;
bad: 	bl = buflist;
bad: 	for (i=0; i < numfrags; i++) {
bad: 
bad: 		/* Get the SGE type: 0 - TCSGE, 3 - Chain, 1 - Simple SGE
bad: 		 * Skip everything but Simple. If simple, copy from
bad: 		 *	user space into kernel space.
bad: 		 * Note: we should not have anything but Simple as
bad: 		 *	Chain SGE are illegal.
bad: 		 */
bad: 		nib = (sgIn->FlagsLength & 0x30000000) >> 28;
bad: 		if (nib == 0 || nib == 3) {
bad: 			;
bad: 		} else if (sgIn->Address) {
bad: 			mpt_add_sge(sgOut, sgIn->FlagsLength, sgIn->Address);
bad: 			n++;
bad: 			if (copy_from_user(bl->kptr, ufwbuf+fw_bytes_copied, bl->len)) {
bad: 				printk(MYIOC_s_ERR_FMT "%s@%d::_ioctl_fwdl - "
bad: 					"Unable to copy f/w buffer hunk#%d @ %p\n",
bad: 					iocp->name, __FILE__, __LINE__, n, ufwbuf);
bad: 				goto fwdl_out;
bad: 			}
bad: 			fw_bytes_copied += bl->len;
bad: 		}
bad: 		sgIn++;
bad: 		bl++;
bad: 		sgOut += (sizeof(dma_addr_t) + sizeof(u32));
bad: 	}
bad: 
bad: 	DBG_DUMP_FW_DOWNLOAD(iocp, (u32 *)mf, numfrags);
bad: 
bad: 	/*
bad: 	 * Finally, perform firmware download.
bad: 	 */
bad: 	ReplyMsg = NULL;
bad: 	mpt_put_msg_frame(mptctl_id, iocp, mf);
bad: 
bad: 	/* Now wait for the command to complete */
bad: 	ret = wait_event_timeout(mptctl_wait,
bad: 	     iocp->ioctl->wait_done == 1,
bad: 	     HZ*60);
bad: 
bad: 	if(ret <=0 && (iocp->ioctl->wait_done != 1 )) {
bad: 	/* Now we need to reset the board */
bad: 		mptctl_timeout_expired(iocp->ioctl);
bad: 		ret = -ENODATA;
bad: 		goto fwdl_out;
bad: 	}
bad: 
bad: 	if (sgl)
bad: 		kfree_sgl(sgl, sgl_dma, buflist, iocp);
bad: 
bad: 	ReplyMsg = (pFWDownloadReply_t)iocp->ioctl->ReplyFrame;
bad: 	iocstat = le16_to_cpu(ReplyMsg->IOCStatus) & MPI_IOCSTATUS_MASK;
bad: 	if (iocstat == MPI_IOCSTATUS_SUCCESS) {
bad: 		printk(MYIOC_s_INFO_FMT "F/W update successfull!\n", iocp->name);
bad: 		return 0;
bad: 	} else if (iocstat == MPI_IOCSTATUS_INVALID_FUNCTION) {
bad: 		printk(MYIOC_s_WARN_FMT "Hmmm...  F/W download not supported!?!\n",
bad: 			iocp->name);
bad: 		printk(MYIOC_s_WARN_FMT "(time to go bang on somebodies door)\n",
bad: 			iocp->name);
bad: 		return -EBADRQC;
bad: 	} else if (iocstat == MPI_IOCSTATUS_BUSY) {
bad: 		printk(MYIOC_s_WARN_FMT "IOC_BUSY!\n", iocp->name);
bad: 		printk(MYIOC_s_WARN_FMT "(try again later?)\n", iocp->name);
bad: 		return -EBUSY;
bad: 	} else {
bad: 		printk(MYIOC_s_WARN_FMT "ioctl_fwdl() returned [bad] status = %04xh\n",
bad: 			iocp->name, iocstat);
bad: 		printk(MYIOC_s_WARN_FMT "(bad VooDoo)\n", iocp->name);
bad: 		return -ENOMSG;
bad: 	}
bad: 	return 0;
bad: 
bad: fwdl_out:
bad:         kfree_sgl(sgl, sgl_dma, buflist, iocp);
bad: 	return ret;
bad: }
semantic error two or more data types
 =File "mptctl.c.orig", line 1169, column 33,  charpos = 33680
    around = '*', whole content = 	struct mpt_ioctl_iocinfo __user *uarg = (void __user *) arg;
ERROR-RECOV: found sync '}' at line 1307
badcount: 153
bad: }
bad: 
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
bad: /*
bad:  *	mptctl_getiocinfo - Query the host adapter for IOC information.
bad:  *	@arg: User space argument
bad:  *
bad:  * Outputs:	None.
bad:  * Return:	0 if successful
bad:  *		-EFAULT if data unavailable
bad:  *		-ENODEV  if no such device/adapter
bad:  */
bad: static int
bad: mptctl_getiocinfo (unsigned long arg, unsigned int data_size)
bad: {
BAD:!!!!! 	struct mpt_ioctl_iocinfo __user *uarg = (void __user *) arg;
bad: 	struct mpt_ioctl_iocinfo *karg;
bad: 	MPT_ADAPTER		*ioc;
bad: 	struct pci_dev		*pdev;
bad: 	int			iocnum;
bad: 	unsigned int		port;
bad: 	int			cim_rev;
bad: 	u8			revision;
bad: 	struct scsi_device 	*sdev;
bad: 	VirtDevice		*vdevice;
bad: 
bad: 	/* Add of PCI INFO results in unaligned access for
bad: 	 * IA64 and Sparc. Reset long to int. Return no PCI
bad: 	 * data for obsolete format.
bad: 	 */
bad: 	if (data_size == sizeof(struct mpt_ioctl_iocinfo_rev0))
bad: 		cim_rev = 0;
bad: 	else if (data_size == sizeof(struct mpt_ioctl_iocinfo_rev1))
bad: 		cim_rev = 1;
bad: 	else if (data_size == sizeof(struct mpt_ioctl_iocinfo))
bad: 		cim_rev = 2;
bad: 	else if (data_size == (sizeof(struct mpt_ioctl_iocinfo_rev0)+12))
bad: 		cim_rev = 0;	/* obsolete */
bad: 	else
bad: 		return -EFAULT;
bad: 
bad: 	karg = kmalloc(data_size, GFP_KERNEL);
bad: 	if (karg == NULL) {
bad: 		printk(KERN_ERR MYNAM "%s::mpt_ioctl_iocinfo() @%d - no memory available!\n",
bad: 				__FILE__, __LINE__);
bad: 		return -ENOMEM;
bad: 	}
bad: 
bad: 	if (copy_from_user(karg, uarg, data_size)) {
bad: 		printk(KERN_ERR MYNAM "%s@%d::mptctl_getiocinfo - "
bad: 			"Unable to read in mpt_ioctl_iocinfo struct @ %p\n",
bad: 				__FILE__, __LINE__, uarg);
bad: 		kfree(karg);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	if (((iocnum = mpt_verify_adapter(karg->hdr.iocnum, &ioc)) < 0) ||
bad: 	    (ioc == NULL)) {
bad: 		printk(KERN_DEBUG MYNAM "%s::mptctl_getiocinfo() @%d - ioc%d not found!\n",
bad: 				__FILE__, __LINE__, iocnum);
bad: 		kfree(karg);
bad: 		return -ENODEV;
bad: 	}
bad: 
bad: 	/* Verify the data transfer size is correct. */
bad: 	if (karg->hdr.maxDataSize != data_size) {
bad: 		printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_getiocinfo - "
bad: 			"Structure size mismatch. Command not completed.\n",
bad: 			ioc->name, __FILE__, __LINE__);
bad: 		kfree(karg);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "mptctl_getiocinfo called.\n",
bad: 	    ioc->name));
bad: 
bad: 	/* Fill in the data and return the structure to the calling
bad: 	 * program
bad: 	 */
bad: 	if (ioc->bus_type == SAS)
bad: 		karg->adapterType = MPT_IOCTL_INTERFACE_SAS;
bad: 	else if (ioc->bus_type == FC)
bad: 		karg->adapterType = MPT_IOCTL_INTERFACE_FC;
bad: 	else
bad: 		karg->adapterType = MPT_IOCTL_INTERFACE_SCSI;
bad: 
bad: 	if (karg->hdr.port > 1)
bad: 		return -EINVAL;
bad: 	port = karg->hdr.port;
bad: 
bad: 	karg->port = port;
bad: 	pdev = (struct pci_dev *) ioc->pcidev;
bad: 
bad: 	karg->pciId = pdev->device;
bad: 	pci_read_config_byte(pdev, PCI_CLASS_REVISION, &revision);
bad: 	karg->hwRev = revision;
bad: 	karg->subSystemDevice = pdev->subsystem_device;
bad: 	karg->subSystemVendor = pdev->subsystem_vendor;
bad: 
bad: 	if (cim_rev == 1) {
bad: 		/* Get the PCI bus, device, and function numbers for the IOC
bad: 		 */
bad: 		karg->pciInfo.u.bits.busNumber = pdev->bus->number;
bad: 		karg->pciInfo.u.bits.deviceNumber = PCI_SLOT( pdev->devfn );
bad: 		karg->pciInfo.u.bits.functionNumber = PCI_FUNC( pdev->devfn );
bad: 	} else if (cim_rev == 2) {
bad: 		/* Get the PCI bus, device, function and segment ID numbers
bad: 		   for the IOC */
bad: 		karg->pciInfo.u.bits.busNumber = pdev->bus->number;
bad: 		karg->pciInfo.u.bits.deviceNumber = PCI_SLOT( pdev->devfn );
bad: 		karg->pciInfo.u.bits.functionNumber = PCI_FUNC( pdev->devfn );
bad: 		karg->pciInfo.segmentID = pci_domain_nr(pdev->bus);
bad: 	}
bad: 
bad: 	/* Get number of devices
bad:          */
bad: 	karg->numDevices = 0;
bad: 	if (ioc->sh) {
bad: 		shost_for_each_device(sdev, ioc->sh) {
bad: 			vdevice = sdev->hostdata;
bad: 			if (vdevice->vtarget->tflags &
bad: 			    MPT_TARGET_FLAGS_RAID_COMPONENT)
bad: 				continue;
bad: 			karg->numDevices++;
bad: 		}
bad: 	}
bad: 
bad: 	/* Set the BIOS and FW Version
bad: 	 */
bad: 	karg->FWVersion = ioc->facts.FWVersion.Word;
bad: 	karg->BIOSVersion = ioc->biosVersion;
bad: 
bad: 	/* Set the Version Strings.
bad: 	 */
bad: 	strncpy (karg->driverVersion, MPT_LINUX_PACKAGE_NAME, MPT_IOCTL_VERSION_LENGTH);
bad: 	karg->driverVersion[MPT_IOCTL_VERSION_LENGTH-1]='\0';
bad: 
bad: 	karg->busChangeEvent = 0;
bad: 	karg->hostId = ioc->pfacts[port].PortSCSIID;
bad: 	karg->rsvd[0] = karg->rsvd[1] = 0;
bad: 
bad: 	/* Copy the data from kernel memory to user memory
bad: 	 */
bad: 	if (copy_to_user((char __user *)arg, karg, data_size)) {
bad: 		printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_getiocinfo - "
bad: 			"Unable to write out mpt_ioctl_iocinfo struct @ %p\n",
bad: 			ioc->name, __FILE__, __LINE__, uarg);
bad: 		kfree(karg);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	kfree(karg);
bad: 	return 0;
bad: }
semantic error two or more data types
 =File "mptctl.c.orig", line 1322, column 36,  charpos = 38057
    around = '*', whole content = 	struct mpt_ioctl_targetinfo __user *uarg = (void __user *) arg;
ERROR-RECOV: found sync '}' at line 1432
badcount: 125
bad: }
bad: 
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
bad: /*
bad:  *	mptctl_gettargetinfo - Query the host adapter for target information.
bad:  *	@arg: User space argument
bad:  *
bad:  * Outputs:	None.
bad:  * Return:	0 if successful
bad:  *		-EFAULT if data unavailable
bad:  *		-ENODEV  if no such device/adapter
bad:  */
bad: static int
bad: mptctl_gettargetinfo (unsigned long arg)
bad: {
BAD:!!!!! 	struct mpt_ioctl_targetinfo __user *uarg = (void __user *) arg;
bad: 	struct mpt_ioctl_targetinfo karg;
bad: 	MPT_ADAPTER		*ioc;
bad: 	VirtDevice		*vdevice;
bad: 	char			*pmem;
bad: 	int			*pdata;
bad: 	int			iocnum;
bad: 	int			numDevices = 0;
bad: 	int			lun;
bad: 	int			maxWordsLeft;
bad: 	int			numBytes;
bad: 	u8			port;
bad: 	struct scsi_device 	*sdev;
bad: 
bad: 	if (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_targetinfo))) {
bad: 		printk(KERN_ERR MYNAM "%s@%d::mptctl_gettargetinfo - "
bad: 			"Unable to read in mpt_ioctl_targetinfo struct @ %p\n",
bad: 				__FILE__, __LINE__, uarg);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
bad: 	    (ioc == NULL)) {
bad: 		printk(KERN_DEBUG MYNAM "%s::mptctl_gettargetinfo() @%d - ioc%d not found!\n",
bad: 				__FILE__, __LINE__, iocnum);
bad: 		return -ENODEV;
bad: 	}
bad: 
bad: 	dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "mptctl_gettargetinfo called.\n",
bad: 	    ioc->name));
bad: 	/* Get the port number and set the maximum number of bytes
bad: 	 * in the returned structure.
bad: 	 * Ignore the port setting.
bad: 	 */
bad: 	numBytes = karg.hdr.maxDataSize - sizeof(mpt_ioctl_header);
bad: 	maxWordsLeft = numBytes/sizeof(int);
bad: 	port = karg.hdr.port;
bad: 
bad: 	if (maxWordsLeft <= 0) {
bad: 		printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_gettargetinfo() - no memory available!\n",
bad: 			ioc->name, __FILE__, __LINE__);
bad: 		return -ENOMEM;
bad: 	}
bad: 
bad: 	/* Fill in the data and return the structure to the calling
bad: 	 * program
bad: 	 */
bad: 
bad: 	/* struct mpt_ioctl_targetinfo does not contain sufficient space
bad: 	 * for the target structures so when the IOCTL is called, there is
bad: 	 * not sufficient stack space for the structure. Allocate memory,
bad: 	 * populate the memory, copy back to the user, then free memory.
bad: 	 * targetInfo format:
bad: 	 * bits 31-24: reserved
bad: 	 *      23-16: LUN
bad: 	 *      15- 8: Bus Number
bad: 	 *       7- 0: Target ID
bad: 	 */
bad: 	pmem = kzalloc(numBytes, GFP_KERNEL);
bad: 	if (!pmem) {
bad: 		printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_gettargetinfo() - no memory available!\n",
bad: 			ioc->name, __FILE__, __LINE__);
bad: 		return -ENOMEM;
bad: 	}
bad: 	pdata =  (int *) pmem;
bad: 
bad: 	/* Get number of devices
bad:          */
bad: 	if (ioc->sh){
bad: 		shost_for_each_device(sdev, ioc->sh) {
bad: 			if (!maxWordsLeft)
bad: 				continue;
bad: 			vdevice = sdev->hostdata;
bad: 			if (vdevice->vtarget->tflags &
bad: 			    MPT_TARGET_FLAGS_RAID_COMPONENT)
bad: 				continue;
bad: 			lun = (vdevice->vtarget->raidVolume) ? 0x80 : vdevice->lun;
bad: 			*pdata = (((u8)lun << 16) + (vdevice->vtarget->channel << 8) +
bad: 			    (vdevice->vtarget->id ));
bad: 			pdata++;
bad: 			numDevices++;
bad: 			--maxWordsLeft;
bad: 		}
bad: 	}
bad: 	karg.numDevices = numDevices;
bad: 
bad: 	/* Copy part of the data from kernel memory to user memory
bad: 	 */
bad: 	if (copy_to_user((char __user *)arg, &karg,
bad: 				sizeof(struct mpt_ioctl_targetinfo))) {
bad: 		printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_gettargetinfo - "
bad: 			"Unable to write out mpt_ioctl_targetinfo struct @ %p\n",
bad: 			ioc->name, __FILE__, __LINE__, uarg);
bad: 		kfree(pmem);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	/* Copy the remaining data from kernel memory to user memory
bad: 	 */
bad: 	if (copy_to_user(uarg->targetInfo, pmem, numBytes)) {
bad: 		printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_gettargetinfo - "
bad: 			"Unable to write out mpt_ioctl_targetinfo struct @ %p\n",
bad: 			ioc->name, __FILE__, __LINE__, pdata);
bad: 		kfree(pmem);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	kfree(pmem);
bad: 
bad: 	return 0;
bad: }
semantic error two or more data types
 =File "mptctl.c.orig", line 1445, column 30,  charpos = 41493
    around = '*', whole content = 	struct mpt_ioctl_test __user *uarg = (void __user *) arg;
ERROR-RECOV: found sync '}' at line 1490
badcount: 58
bad: }
bad: 
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
bad: /* MPT IOCTL Test function.
bad:  *
bad:  * Outputs:	None.
bad:  * Return:	0 if successful
bad:  *		-EFAULT if data unavailable
bad:  *		-ENODEV  if no such device/adapter
bad:  */
bad: static int
bad: mptctl_readtest (unsigned long arg)
bad: {
BAD:!!!!! 	struct mpt_ioctl_test __user *uarg = (void __user *) arg;
bad: 	struct mpt_ioctl_test	 karg;
bad: 	MPT_ADAPTER *ioc;
bad: 	int iocnum;
bad: 
bad: 	if (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_test))) {
bad: 		printk(KERN_ERR MYNAM "%s@%d::mptctl_readtest - "
bad: 			"Unable to read in mpt_ioctl_test struct @ %p\n",
bad: 				__FILE__, __LINE__, uarg);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
bad: 	    (ioc == NULL)) {
bad: 		printk(KERN_DEBUG MYNAM "%s::mptctl_readtest() @%d - ioc%d not found!\n",
bad: 				__FILE__, __LINE__, iocnum);
bad: 		return -ENODEV;
bad: 	}
bad: 
bad: 	dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "mptctl_readtest called.\n",
bad: 	    ioc->name));
bad: 	/* Fill in the data and return the structure to the calling
bad: 	 * program
bad: 	 */
bad: 
bad: #ifdef MFCNT
bad: 	karg.chip_type = ioc->mfcnt;
bad: #else
bad: 	karg.chip_type = ioc->pcidev->device;
bad: #endif
bad: 	strncpy (karg.name, ioc->name, MPT_MAX_NAME);
bad: 	karg.name[MPT_MAX_NAME-1]='\0';
bad: 	strncpy (karg.product, ioc->prod_name, MPT_PRODUCT_LENGTH);
bad: 	karg.product[MPT_PRODUCT_LENGTH-1]='\0';
bad: 
bad: 	/* Copy the data from kernel memory to user memory
bad: 	 */
bad: 	if (copy_to_user((char __user *)arg, &karg, sizeof(struct mpt_ioctl_test))) {
bad: 		printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_readtest - "
bad: 			"Unable to write out mpt_ioctl_test struct @ %p\n",
bad: 			ioc->name, __FILE__, __LINE__, uarg);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	return 0;
bad: }
semantic error two or more data types
 =File "mptctl.c.orig", line 1506, column 36,  charpos = 43212
    around = '*', whole content = 	struct mpt_ioctl_eventquery __user *uarg = (void __user *) arg;
ERROR-RECOV: found sync '}' at line 1539
badcount: 49
bad: }
bad: 
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
bad: /*
bad:  *	mptctl_eventquery - Query the host adapter for the event types
bad:  *	that are being logged.
bad:  *	@arg: User space argument
bad:  *
bad:  * Outputs:	None.
bad:  * Return:	0 if successful
bad:  *		-EFAULT if data unavailable
bad:  *		-ENODEV  if no such device/adapter
bad:  */
bad: static int
bad: mptctl_eventquery (unsigned long arg)
bad: {
BAD:!!!!! 	struct mpt_ioctl_eventquery __user *uarg = (void __user *) arg;
bad: 	struct mpt_ioctl_eventquery	 karg;
bad: 	MPT_ADAPTER *ioc;
bad: 	int iocnum;
bad: 
bad: 	if (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventquery))) {
bad: 		printk(KERN_ERR MYNAM "%s@%d::mptctl_eventquery - "
bad: 			"Unable to read in mpt_ioctl_eventquery struct @ %p\n",
bad: 				__FILE__, __LINE__, uarg);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
bad: 	    (ioc == NULL)) {
bad: 		printk(KERN_DEBUG MYNAM "%s::mptctl_eventquery() @%d - ioc%d not found!\n",
bad: 				__FILE__, __LINE__, iocnum);
bad: 		return -ENODEV;
bad: 	}
bad: 
bad: 	dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "mptctl_eventquery called.\n",
bad: 	    ioc->name));
bad: 	karg.eventEntries = MPTCTL_EVENT_LOG_SIZE;
bad: 	karg.eventTypes = ioc->eventTypes;
bad: 
bad: 	/* Copy the data from kernel memory to user memory
bad: 	 */
bad: 	if (copy_to_user((char __user *)arg, &karg, sizeof(struct mpt_ioctl_eventquery))) {
bad: 		printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_eventquery - "
bad: 			"Unable to write out mpt_ioctl_eventquery struct @ %p\n",
bad: 			ioc->name, __FILE__, __LINE__, uarg);
bad: 		return -EFAULT;
bad: 	}
bad: 	return 0;
bad: }
semantic error two or more data types
 =File "mptctl.c.orig", line 1545, column 37,  charpos = 44446
    around = '*', whole content = 	struct mpt_ioctl_eventenable __user *uarg = (void __user *) arg;
ERROR-RECOV: found sync '}' at line 1587
badcount: 48
bad: }
bad: 
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
bad: static int
bad: mptctl_eventenable (unsigned long arg)
bad: {
BAD:!!!!! 	struct mpt_ioctl_eventenable __user *uarg = (void __user *) arg;
bad: 	struct mpt_ioctl_eventenable	 karg;
bad: 	MPT_ADAPTER *ioc;
bad: 	int iocnum;
bad: 
bad: 	if (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventenable))) {
bad: 		printk(KERN_ERR MYNAM "%s@%d::mptctl_eventenable - "
bad: 			"Unable to read in mpt_ioctl_eventenable struct @ %p\n",
bad: 				__FILE__, __LINE__, uarg);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
bad: 	    (ioc == NULL)) {
bad: 		printk(KERN_DEBUG MYNAM "%s::mptctl_eventenable() @%d - ioc%d not found!\n",
bad: 				__FILE__, __LINE__, iocnum);
bad: 		return -ENODEV;
bad: 	}
bad: 
bad: 	dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "mptctl_eventenable called.\n",
bad: 	    ioc->name));
bad: 	if (ioc->events == NULL) {
bad: 		/* Have not yet allocated memory - do so now.
bad: 		 */
bad: 		int sz = MPTCTL_EVENT_LOG_SIZE * sizeof(MPT_IOCTL_EVENTS);
bad: 		ioc->events = kzalloc(sz, GFP_KERNEL);
bad: 		if (!ioc->events) {
bad: 			printk(MYIOC_s_ERR_FMT
bad: 			    ": ERROR - Insufficient memory to add adapter!\n",
bad: 			    ioc->name);
bad: 			return -ENOMEM;
bad: 		}
bad: 		ioc->alloc_total += sz;
bad: 
bad: 		ioc->eventContext = 0;
bad:         }
bad: 
bad: 	/* Update the IOC event logging flag.
bad: 	 */
bad: 	ioc->eventTypes = karg.eventTypes;
bad: 
bad: 	return 0;
bad: }
semantic error two or more data types
 =File "mptctl.c.orig", line 1593, column 37,  charpos = 45761
    around = '*', whole content = 	struct mpt_ioctl_eventreport __user *uarg = (void __user *) arg;
ERROR-RECOV: found sync '}' at line 1641
badcount: 54
bad: }
bad: 
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
bad: static int
bad: mptctl_eventreport (unsigned long arg)
bad: {
BAD:!!!!! 	struct mpt_ioctl_eventreport __user *uarg = (void __user *) arg;
bad: 	struct mpt_ioctl_eventreport	 karg;
bad: 	MPT_ADAPTER		 *ioc;
bad: 	int			 iocnum;
bad: 	int			 numBytes, maxEvents, max;
bad: 
bad: 	if (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventreport))) {
bad: 		printk(KERN_ERR MYNAM "%s@%d::mptctl_eventreport - "
bad: 			"Unable to read in mpt_ioctl_eventreport struct @ %p\n",
bad: 				__FILE__, __LINE__, uarg);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
bad: 	    (ioc == NULL)) {
bad: 		printk(KERN_DEBUG MYNAM "%s::mptctl_eventreport() @%d - ioc%d not found!\n",
bad: 				__FILE__, __LINE__, iocnum);
bad: 		return -ENODEV;
bad: 	}
bad: 	dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "mptctl_eventreport called.\n",
bad: 	    ioc->name));
bad: 
bad: 	numBytes = karg.hdr.maxDataSize - sizeof(mpt_ioctl_header);
bad: 	maxEvents = numBytes/sizeof(MPT_IOCTL_EVENTS);
bad: 
bad: 
bad: 	max = MPTCTL_EVENT_LOG_SIZE < maxEvents ? MPTCTL_EVENT_LOG_SIZE : maxEvents;
bad: 
bad: 	/* If fewer than 1 event is requested, there must have
bad: 	 * been some type of error.
bad: 	 */
bad: 	if ((max < 1) || !ioc->events)
bad: 		return -ENODATA;
bad: 
bad: 	/* reset this flag so SIGIO can restart */
bad: 	ioc->aen_event_read_flag=0;
bad: 
bad: 	/* Copy the data from kernel memory to user memory
bad: 	 */
bad: 	numBytes = max * sizeof(MPT_IOCTL_EVENTS);
bad: 	if (copy_to_user(uarg->eventData, ioc->events, numBytes)) {
bad: 		printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_eventreport - "
bad: 			"Unable to write out mpt_ioctl_eventreport struct @ %p\n",
bad: 			ioc->name, __FILE__, __LINE__, ioc->events);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	return 0;
bad: }
semantic error two or more data types
 =File "mptctl.c.orig", line 1647, column 36,  charpos = 47393
    around = '*', whole content = 	struct mpt_ioctl_replace_fw __user *uarg = (void __user *) arg;
ERROR-RECOV: found sync '}' at line 1703
badcount: 62
bad: }
bad: 
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
bad: static int
bad: mptctl_replace_fw (unsigned long arg)
bad: {
BAD:!!!!! 	struct mpt_ioctl_replace_fw __user *uarg = (void __user *) arg;
bad: 	struct mpt_ioctl_replace_fw	 karg;
bad: 	MPT_ADAPTER		 *ioc;
bad: 	int			 iocnum;
bad: 	int			 newFwSize;
bad: 
bad: 	if (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_replace_fw))) {
bad: 		printk(KERN_ERR MYNAM "%s@%d::mptctl_replace_fw - "
bad: 			"Unable to read in mpt_ioctl_replace_fw struct @ %p\n",
bad: 				__FILE__, __LINE__, uarg);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
bad: 	    (ioc == NULL)) {
bad: 		printk(KERN_DEBUG MYNAM "%s::mptctl_replace_fw() @%d - ioc%d not found!\n",
bad: 				__FILE__, __LINE__, iocnum);
bad: 		return -ENODEV;
bad: 	}
bad: 
bad: 	dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "mptctl_replace_fw called.\n",
bad: 	    ioc->name));
bad: 	/* If caching FW, Free the old FW image
bad: 	 */
bad: 	if (ioc->cached_fw == NULL)
bad: 		return 0;
bad: 
bad: 	mpt_free_fw_memory(ioc);
bad: 
bad: 	/* Allocate memory for the new FW image
bad: 	 */
bad: 	newFwSize = karg.newImageSize;
bad: 
bad: 	if (newFwSize & 0x01)
bad: 		newFwSize += 1;
bad: 	if (newFwSize & 0x02)
bad: 		newFwSize += 2;
bad: 
bad: 	mpt_alloc_fw_memory(ioc, newFwSize);
bad: 	if (ioc->cached_fw == NULL)
bad: 		return -ENOMEM;
bad: 
bad: 	/* Copy the data from user memory to kernel space
bad: 	 */
bad: 	if (copy_from_user(ioc->cached_fw, uarg->newImage, newFwSize)) {
bad: 		printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_replace_fw - "
bad: 				"Unable to read in mpt_ioctl_replace_fw image "
bad: 				"@ %p\n", ioc->name, __FILE__, __LINE__, uarg);
bad: 		mpt_free_fw_memory(ioc);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	/* Update IOCFactsReply
bad: 	 */
bad: 	ioc->facts.FWImageSize = newFwSize;
bad: 	return 0;
bad: }
semantic error two or more data types
 =File "mptctl.c.orig", line 1720, column 33,  charpos = 49357
    around = '*', whole content = 	struct mpt_ioctl_command __user *uarg = (void __user *) arg;
ERROR-RECOV: found sync '}' at line 1744
badcount: 41
bad: }
bad: 
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
bad: /* MPT IOCTL MPTCOMMAND function.
bad:  * Cast the arg into the mpt_ioctl_mpt_command structure.
bad:  *
bad:  * Outputs:	None.
bad:  * Return:	0 if successful
bad:  *		-EBUSY  if previous command timout and IOC reset is not complete.
bad:  *		-EFAULT if data unavailable
bad:  *		-ENODEV if no such device/adapter
bad:  *		-ETIME	if timer expires
bad:  *		-ENOMEM if memory allocation error
bad:  */
bad: static int
bad: mptctl_mpt_command (unsigned long arg)
bad: {
BAD:!!!!! 	struct mpt_ioctl_command __user *uarg = (void __user *) arg;
bad: 	struct mpt_ioctl_command  karg;
bad: 	MPT_ADAPTER	*ioc;
bad: 	int		iocnum;
bad: 	int		rc;
bad: 
bad: 
bad: 	if (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_command))) {
bad: 		printk(KERN_ERR MYNAM "%s@%d::mptctl_mpt_command - "
bad: 			"Unable to read in mpt_ioctl_command struct @ %p\n",
bad: 				__FILE__, __LINE__, uarg);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
bad: 	    (ioc == NULL)) {
bad: 		printk(KERN_DEBUG MYNAM "%s::mptctl_mpt_command() @%d - ioc%d not found!\n",
bad: 				__FILE__, __LINE__, iocnum);
bad: 		return -ENODEV;
bad: 	}
bad: 
bad: 	rc = mptctl_do_mpt_command (karg, &uarg->MF);
bad: 
bad: 	return rc;
bad: }
semantic error two or more data types
 =File "mptctl.c.orig", line 1759, column 66,  charpos = 50524
    around = '*', whole content = mptctl_do_mpt_command (struct mpt_ioctl_command karg, void __user *mfPtr)
ERROR-RECOV: found sync '}' at line 2313
badcount: 569
bad: }
bad: 
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
bad: /* Worker routine for the IOCTL MPTCOMMAND and MPTCOMMAND32 (sparc) commands.
bad:  *
bad:  * Outputs:	None.
bad:  * Return:	0 if successful
bad:  *		-EBUSY  if previous command timout and IOC reset is not complete.
bad:  *		-EFAULT if data unavailable
bad:  *		-ENODEV if no such device/adapter
bad:  *		-ETIME	if timer expires
bad:  *		-ENOMEM if memory allocation error
bad:  *		-EPERM if SCSI I/O and target is untagged
bad:  */
bad: static int
BAD:!!!!! mptctl_do_mpt_command (struct mpt_ioctl_command karg, void __user *mfPtr)
bad: {
bad: 	MPT_ADAPTER	*ioc;
bad: 	MPT_FRAME_HDR	*mf = NULL;
bad: 	MPIHeader_t	*hdr;
bad: 	char		*psge;
bad: 	struct buflist	bufIn;	/* data In buffer */
bad: 	struct buflist	bufOut; /* data Out buffer */
bad: 	dma_addr_t	dma_addr_in;
bad: 	dma_addr_t	dma_addr_out;
bad: 	int		sgSize = 0;	/* Num SG elements */
bad: 	int		iocnum, flagsLength;
bad: 	int		sz, rc = 0;
bad: 	int		msgContext;
bad: 	u16		req_idx;
bad: 	ulong 		timeout;
bad: 	struct scsi_device *sdev;
bad: 
bad: 	bufIn.kptr = bufOut.kptr = NULL;
bad: 
bad: 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
bad: 	    (ioc == NULL)) {
bad: 		printk(KERN_DEBUG MYNAM "%s::mptctl_do_mpt_command() @%d - ioc%d not found!\n",
bad: 				__FILE__, __LINE__, iocnum);
bad: 		return -ENODEV;
bad: 	}
bad: 	if (!ioc->ioctl) {
bad: 		printk(KERN_ERR MYNAM "%s@%d::mptctl_do_mpt_command - "
bad: 			"No memory available during driver init.\n",
bad: 				__FILE__, __LINE__);
bad: 		return -ENOMEM;
bad: 	} else if (ioc->ioctl->status & MPT_IOCTL_STATUS_DID_IOCRESET) {
bad: 		printk(KERN_ERR MYNAM "%s@%d::mptctl_do_mpt_command - "
bad: 			"Busy with IOC Reset \n", __FILE__, __LINE__);
bad: 		return -EBUSY;
bad: 	}
bad: 
bad: 	/* Verify that the final request frame will not be too large.
bad: 	 */
bad: 	sz = karg.dataSgeOffset * 4;
bad: 	if (karg.dataInSize > 0)
bad: 		sz += sizeof(dma_addr_t) + sizeof(u32);
bad: 	if (karg.dataOutSize > 0)
bad: 		sz += sizeof(dma_addr_t) + sizeof(u32);
bad: 
bad: 	if (sz > ioc->req_sz) {
bad: 		printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_do_mpt_command - "
bad: 			"Request frame too large (%d) maximum (%d)\n",
bad: 			ioc->name, __FILE__, __LINE__, sz, ioc->req_sz);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	/* Get a free request frame and save the message context.
bad: 	 */
bad:         if ((mf = mpt_get_msg_frame(mptctl_id, ioc)) == NULL)
bad:                 return -EAGAIN;
bad: 
bad: 	hdr = (MPIHeader_t *) mf;
bad: 	msgContext = le32_to_cpu(hdr->MsgContext);
bad: 	req_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
bad: 
bad: 	/* Copy the request frame
bad: 	 * Reset the saved message context.
bad: 	 * Request frame in user space
bad: 	 */
bad: 	if (copy_from_user(mf, mfPtr, karg.dataSgeOffset * 4)) {
bad: 		printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_do_mpt_command - "
bad: 			"Unable to read MF from mpt_ioctl_command struct @ %p\n",
bad: 			ioc->name, __FILE__, __LINE__, mfPtr);
bad: 		rc = -EFAULT;
bad: 		goto done_free_mem;
bad: 	}
bad: 	hdr->MsgContext = cpu_to_le32(msgContext);
bad: 
bad: 
bad: 	/* Verify that this request is allowed.
bad: 	 */
bad: 	dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "sending mpi function (0x%02X), req=%p\n",
bad: 	    ioc->name, hdr->Function, mf));
bad: 
bad: 	switch (hdr->Function) {
bad: 	case MPI_FUNCTION_IOC_FACTS:
bad: 	case MPI_FUNCTION_PORT_FACTS:
bad: 		karg.dataOutSize  = karg.dataInSize = 0;
bad: 		break;
bad: 
bad: 	case MPI_FUNCTION_CONFIG:
bad: 	{
bad: 		Config_t *config_frame;
bad: 		config_frame = (Config_t *)mf;
bad: 		dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "\ttype=0x%02x ext_type=0x%02x "
bad: 		    "number=0x%02x action=0x%02x\n", ioc->name,
bad: 		    config_frame->Header.PageType,
bad: 		    config_frame->ExtPageType,
bad: 		    config_frame->Header.PageNumber,
bad: 		    config_frame->Action));
bad: 		break;
bad: 	}
bad: 
bad: 	case MPI_FUNCTION_FC_COMMON_TRANSPORT_SEND:
bad: 	case MPI_FUNCTION_FC_EX_LINK_SRVC_SEND:
bad: 	case MPI_FUNCTION_FW_UPLOAD:
bad: 	case MPI_FUNCTION_SCSI_ENCLOSURE_PROCESSOR:
bad: 	case MPI_FUNCTION_FW_DOWNLOAD:
bad: 	case MPI_FUNCTION_FC_PRIMITIVE_SEND:
bad: 	case MPI_FUNCTION_TOOLBOX:
bad: 	case MPI_FUNCTION_SAS_IO_UNIT_CONTROL:
bad: 		break;
bad: 
bad: 	case MPI_FUNCTION_SCSI_IO_REQUEST:
bad: 		if (ioc->sh) {
bad: 			SCSIIORequest_t *pScsiReq = (SCSIIORequest_t *) mf;
bad: 			int qtag = MPI_SCSIIO_CONTROL_UNTAGGED;
bad: 			int scsidir = 0;
bad: 			int dataSize;
bad: 			u32 id;
bad: 
bad: 			id = (ioc->devices_per_bus == 0) ? 256 : ioc->devices_per_bus;
bad: 			if (pScsiReq->TargetID > id) {
bad: 				printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_do_mpt_command - "
bad: 					"Target ID out of bounds. \n",
bad: 					ioc->name, __FILE__, __LINE__);
bad: 				rc = -ENODEV;
bad: 				goto done_free_mem;
bad: 			}
bad: 
bad: 			if (pScsiReq->Bus >= ioc->number_of_buses) {
bad: 				printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_do_mpt_command - "
bad: 					"Target Bus out of bounds. \n",
bad: 					ioc->name, __FILE__, __LINE__);
bad: 				rc = -ENODEV;
bad: 				goto done_free_mem;
bad: 			}
bad: 
bad: 			pScsiReq->MsgFlags &= ~MPI_SCSIIO_MSGFLGS_SENSE_WIDTH;
bad: 			pScsiReq->MsgFlags |= mpt_msg_flags();
bad: 
bad: 
bad: 			/* verify that app has not requested
bad: 			 *	more sense data than driver
bad: 			 *	can provide, if so, reset this parameter
bad: 			 * set the sense buffer pointer low address
bad: 			 * update the control field to specify Q type
bad: 			 */
bad: 			if (karg.maxSenseBytes > MPT_SENSE_BUFFER_SIZE)
bad: 				pScsiReq->SenseBufferLength = MPT_SENSE_BUFFER_SIZE;
bad: 			else
bad: 				pScsiReq->SenseBufferLength = karg.maxSenseBytes;
bad: 
bad: 			pScsiReq->SenseBufferLowAddr =
bad: 				cpu_to_le32(ioc->sense_buf_low_dma
bad: 				   + (req_idx * MPT_SENSE_BUFFER_ALLOC));
bad: 
bad: 			shost_for_each_device(sdev, ioc->sh) {
bad: 				struct scsi_target *starget = scsi_target(sdev);
bad: 				VirtTarget *vtarget = starget->hostdata;
bad: 
bad: 				if ((pScsiReq->TargetID == vtarget->id) &&
bad: 				    (pScsiReq->Bus == vtarget->channel) &&
bad: 				    (vtarget->tflags & MPT_TARGET_FLAGS_Q_YES))
bad: 					qtag = MPI_SCSIIO_CONTROL_SIMPLEQ;
bad: 			}
bad: 
bad: 			/* Have the IOCTL driver set the direction based
bad: 			 * on the dataOutSize (ordering issue with Sparc).
bad: 			 */
bad: 			if (karg.dataOutSize > 0) {
bad: 				scsidir = MPI_SCSIIO_CONTROL_WRITE;
bad: 				dataSize = karg.dataOutSize;
bad: 			} else {
bad: 				scsidir = MPI_SCSIIO_CONTROL_READ;
bad: 				dataSize = karg.dataInSize;
bad: 			}
bad: 
bad: 			pScsiReq->Control = cpu_to_le32(scsidir | qtag);
bad: 			pScsiReq->DataLength = cpu_to_le32(dataSize);
bad: 
bad: 			ioc->ioctl->reset = MPTCTL_RESET_OK;
bad: 			ioc->ioctl->id = pScsiReq->TargetID;
bad: 
bad: 		} else {
bad: 			printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_do_mpt_command - "
bad: 				"SCSI driver is not loaded. \n",
bad: 				ioc->name, __FILE__, __LINE__);
bad: 			rc = -EFAULT;
bad: 			goto done_free_mem;
bad: 		}
bad: 		break;
bad: 
bad: 	case MPI_FUNCTION_SMP_PASSTHROUGH:
bad: 		/* Check mf->PassthruFlags to determine if
bad: 		 * transfer is ImmediateMode or not.
bad: 		 * Immediate mode returns data in the ReplyFrame.
bad: 		 * Else, we are sending request and response data
bad: 		 * in two SGLs at the end of the mf.
bad: 		 */
bad: 		break;
bad: 
bad: 	case MPI_FUNCTION_SATA_PASSTHROUGH:
bad: 		if (!ioc->sh) {
bad: 			printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_do_mpt_command - "
bad: 				"SCSI driver is not loaded. \n",
bad: 				ioc->name, __FILE__, __LINE__);
bad: 			rc = -EFAULT;
bad: 			goto done_free_mem;
bad: 		}
bad: 		break;
bad: 
bad: 	case MPI_FUNCTION_RAID_ACTION:
bad: 		/* Just add a SGE
bad: 		 */
bad: 		break;
bad: 
bad: 	case MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH:
bad: 		if (ioc->sh) {
bad: 			SCSIIORequest_t *pScsiReq = (SCSIIORequest_t *) mf;
bad: 			int qtag = MPI_SCSIIO_CONTROL_SIMPLEQ;
bad: 			int scsidir = MPI_SCSIIO_CONTROL_READ;
bad: 			int dataSize;
bad: 
bad: 			pScsiReq->MsgFlags &= ~MPI_SCSIIO_MSGFLGS_SENSE_WIDTH;
bad: 			pScsiReq->MsgFlags |= mpt_msg_flags();
bad: 
bad: 
bad: 			/* verify that app has not requested
bad: 			 *	more sense data than driver
bad: 			 *	can provide, if so, reset this parameter
bad: 			 * set the sense buffer pointer low address
bad: 			 * update the control field to specify Q type
bad: 			 */
bad: 			if (karg.maxSenseBytes > MPT_SENSE_BUFFER_SIZE)
bad: 				pScsiReq->SenseBufferLength = MPT_SENSE_BUFFER_SIZE;
bad: 			else
bad: 				pScsiReq->SenseBufferLength = karg.maxSenseBytes;
bad: 
bad: 			pScsiReq->SenseBufferLowAddr =
bad: 				cpu_to_le32(ioc->sense_buf_low_dma
bad: 				   + (req_idx * MPT_SENSE_BUFFER_ALLOC));
bad: 
bad: 			/* All commands to physical devices are tagged
bad: 			 */
bad: 
bad: 			/* Have the IOCTL driver set the direction based
bad: 			 * on the dataOutSize (ordering issue with Sparc).
bad: 			 */
bad: 			if (karg.dataOutSize > 0) {
bad: 				scsidir = MPI_SCSIIO_CONTROL_WRITE;
bad: 				dataSize = karg.dataOutSize;
bad: 			} else {
bad: 				scsidir = MPI_SCSIIO_CONTROL_READ;
bad: 				dataSize = karg.dataInSize;
bad: 			}
bad: 
bad: 			pScsiReq->Control = cpu_to_le32(scsidir | qtag);
bad: 			pScsiReq->DataLength = cpu_to_le32(dataSize);
bad: 
bad: 			ioc->ioctl->reset = MPTCTL_RESET_OK;
bad: 			ioc->ioctl->id = pScsiReq->TargetID;
bad: 		} else {
bad: 			printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_do_mpt_command - "
bad: 				"SCSI driver is not loaded. \n",
bad: 				ioc->name, __FILE__, __LINE__);
bad: 			rc = -EFAULT;
bad: 			goto done_free_mem;
bad: 		}
bad: 		break;
bad: 
bad: 	case MPI_FUNCTION_SCSI_TASK_MGMT:
bad: 		{
bad: 			MPT_SCSI_HOST *hd = NULL;
bad: 			if ((ioc->sh == NULL) || ((hd = (MPT_SCSI_HOST *)ioc->sh->hostdata) == NULL)) {
bad: 				printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_do_mpt_command - "
bad: 					"SCSI driver not loaded or SCSI host not found. \n",
bad: 					ioc->name, __FILE__, __LINE__);
bad: 				rc = -EFAULT;
bad: 				goto done_free_mem;
bad: 			} else if (mptctl_set_tm_flags(hd) != 0) {
bad: 				rc = -EPERM;
bad: 				goto done_free_mem;
bad: 			}
bad: 		}
bad: 		break;
bad: 
bad: 	case MPI_FUNCTION_IOC_INIT:
bad: 		{
bad: 			IOCInit_t	*pInit = (IOCInit_t *) mf;
bad: 			u32		high_addr, sense_high;
bad: 
bad: 			/* Verify that all entries in the IOC INIT match
bad: 			 * existing setup (and in LE format).
bad: 			 */
bad: 			if (sizeof(dma_addr_t) == sizeof(u64)) {
bad: 				high_addr = cpu_to_le32((u32)((u64)ioc->req_frames_dma >> 32));
bad: 				sense_high= cpu_to_le32((u32)((u64)ioc->sense_buf_pool_dma >> 32));
bad: 			} else {
bad: 				high_addr = 0;
bad: 				sense_high= 0;
bad: 			}
bad: 
bad: 			if ((pInit->Flags != 0) || (pInit->MaxDevices != ioc->facts.MaxDevices) ||
bad: 				(pInit->MaxBuses != ioc->facts.MaxBuses) ||
bad: 				(pInit->ReplyFrameSize != cpu_to_le16(ioc->reply_sz)) ||
bad: 				(pInit->HostMfaHighAddr != high_addr) ||
bad: 				(pInit->SenseBufferHighAddr != sense_high)) {
bad: 				printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_do_mpt_command - "
bad: 					"IOC_INIT issued with 1 or more incorrect parameters. Rejected.\n",
bad: 					ioc->name, __FILE__, __LINE__);
bad: 				rc = -EFAULT;
bad: 				goto done_free_mem;
bad: 			}
bad: 		}
bad: 		break;
bad: 	default:
bad: 		/*
bad: 		 * MPI_FUNCTION_PORT_ENABLE
bad: 		 * MPI_FUNCTION_TARGET_CMD_BUFFER_POST
bad: 		 * MPI_FUNCTION_TARGET_ASSIST
bad: 		 * MPI_FUNCTION_TARGET_STATUS_SEND
bad: 		 * MPI_FUNCTION_TARGET_MODE_ABORT
bad: 		 * MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET
bad: 		 * MPI_FUNCTION_IO_UNIT_RESET
bad: 		 * MPI_FUNCTION_HANDSHAKE
bad: 		 * MPI_FUNCTION_REPLY_FRAME_REMOVAL
bad: 		 * MPI_FUNCTION_EVENT_NOTIFICATION
bad: 		 *  (driver handles event notification)
bad: 		 * MPI_FUNCTION_EVENT_ACK
bad: 		 */
bad: 
bad: 		/*  What to do with these???  CHECK ME!!!
bad: 			MPI_FUNCTION_FC_LINK_SRVC_BUF_POST
bad: 			MPI_FUNCTION_FC_LINK_SRVC_RSP
bad: 			MPI_FUNCTION_FC_ABORT
bad: 			MPI_FUNCTION_LAN_SEND
bad: 			MPI_FUNCTION_LAN_RECEIVE
bad: 		 	MPI_FUNCTION_LAN_RESET
bad: 		*/
bad: 
bad: 		printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_do_mpt_command - "
bad: 			"Illegal request (function 0x%x) \n",
bad: 			ioc->name, __FILE__, __LINE__, hdr->Function);
bad: 		rc = -EFAULT;
bad: 		goto done_free_mem;
bad: 	}
bad: 
bad: 	/* Add the SGL ( at most one data in SGE and one data out SGE )
bad: 	 * In the case of two SGE's - the data out (write) will always
bad: 	 * preceede the data in (read) SGE. psgList is used to free the
bad: 	 * allocated memory.
bad: 	 */
bad: 	psge = (char *) (((int *) mf) + karg.dataSgeOffset);
bad: 	flagsLength = 0;
bad: 
bad: 	/* bufIn and bufOut are used for user to kernel space transfers
bad: 	 */
bad: 	bufIn.kptr = bufOut.kptr = NULL;
bad: 	bufIn.len = bufOut.len = 0;
bad: 
bad: 	if (karg.dataOutSize > 0)
bad: 		sgSize ++;
bad: 
bad: 	if (karg.dataInSize > 0)
bad: 		sgSize ++;
bad: 
bad: 	if (sgSize > 0) {
bad: 
bad: 		/* Set up the dataOut memory allocation */
bad: 		if (karg.dataOutSize > 0) {
bad: 			if (karg.dataInSize > 0) {
bad: 				flagsLength = ( MPI_SGE_FLAGS_SIMPLE_ELEMENT |
bad: 						MPI_SGE_FLAGS_END_OF_BUFFER |
bad: 						MPI_SGE_FLAGS_DIRECTION |
bad: 						mpt_addr_size() )
bad: 						<< MPI_SGE_FLAGS_SHIFT;
bad: 			} else {
bad: 				flagsLength = MPT_SGE_FLAGS_SSIMPLE_WRITE;
bad: 			}
bad: 			flagsLength |= karg.dataOutSize;
bad: 			bufOut.len = karg.dataOutSize;
bad: 			bufOut.kptr = pci_alloc_consistent(
bad: 					ioc->pcidev, bufOut.len, &dma_addr_out);
bad: 
bad: 			if (bufOut.kptr == NULL) {
bad: 				rc = -ENOMEM;
bad: 				goto done_free_mem;
bad: 			} else {
bad: 				/* Set up this SGE.
bad: 				 * Copy to MF and to sglbuf
bad: 				 */
bad: 				mpt_add_sge(psge, flagsLength, dma_addr_out);
bad: 				psge += (sizeof(u32) + sizeof(dma_addr_t));
bad: 
bad: 				/* Copy user data to kernel space.
bad: 				 */
bad: 				if (copy_from_user(bufOut.kptr,
bad: 						karg.dataOutBufPtr,
bad: 						bufOut.len)) {
bad: 					printk(MYIOC_s_ERR_FMT
bad: 						"%s@%d::mptctl_do_mpt_command - Unable "
bad: 						"to read user data "
bad: 						"struct @ %p\n",
bad: 						ioc->name, __FILE__, __LINE__,karg.dataOutBufPtr);
bad: 					rc =  -EFAULT;
bad: 					goto done_free_mem;
bad: 				}
bad: 			}
bad: 		}
bad: 
bad: 		if (karg.dataInSize > 0) {
bad: 			flagsLength = MPT_SGE_FLAGS_SSIMPLE_READ;
bad: 			flagsLength |= karg.dataInSize;
bad: 
bad: 			bufIn.len = karg.dataInSize;
bad: 			bufIn.kptr = pci_alloc_consistent(ioc->pcidev,
bad: 					bufIn.len, &dma_addr_in);
bad: 
bad: 			if (bufIn.kptr == NULL) {
bad: 				rc = -ENOMEM;
bad: 				goto done_free_mem;
bad: 			} else {
bad: 				/* Set up this SGE
bad: 				 * Copy to MF and to sglbuf
bad: 				 */
bad: 				mpt_add_sge(psge, flagsLength, dma_addr_in);
bad: 			}
bad: 		}
bad: 	} else  {
bad: 		/* Add a NULL SGE
bad: 		 */
bad: 		mpt_add_sge(psge, flagsLength, (dma_addr_t) -1);
bad: 	}
bad: 
bad: 	ioc->ioctl->wait_done = 0;
bad: 	if (hdr->Function == MPI_FUNCTION_SCSI_TASK_MGMT) {
bad: 
bad: 		DBG_DUMP_TM_REQUEST_FRAME(ioc, (u32 *)mf);
bad: 
bad: 		if ((ioc->facts.IOCCapabilities & MPI_IOCFACTS_CAPABILITY_HIGH_PRI_Q) &&
bad: 		    (ioc->facts.MsgVersion >= MPI_VERSION_01_05))
bad: 			mpt_put_msg_frame_hi_pri(mptctl_id, ioc, mf);
bad: 		else {
bad: 			rc =mpt_send_handshake_request(mptctl_id, ioc,
bad: 				sizeof(SCSITaskMgmt_t), (u32*)mf, CAN_SLEEP);
bad: 			if (rc != 0) {
bad: 				dfailprintk(ioc, printk(MYIOC_s_ERR_FMT
bad: 				    "_send_handshake FAILED! (ioc %p, mf %p)\n",
bad: 				    ioc->name, ioc, mf));
bad: 				mptctl_free_tm_flags(ioc);
bad: 				rc = -ENODATA;
bad: 				goto done_free_mem;
bad: 			}
bad: 		}
bad: 
bad: 	} else
bad: 		mpt_put_msg_frame(mptctl_id, ioc, mf);
bad: 
bad: 	/* Now wait for the command to complete */
bad: 	timeout = (karg.timeout > 0) ? karg.timeout : MPT_IOCTL_DEFAULT_TIMEOUT;
bad: 	timeout = wait_event_timeout(mptctl_wait,
bad: 	     ioc->ioctl->wait_done == 1,
bad: 	     HZ*timeout);
bad: 
bad: 	if(timeout <=0 && (ioc->ioctl->wait_done != 1 )) {
bad: 	/* Now we need to reset the board */
bad: 
bad: 		if (hdr->Function == MPI_FUNCTION_SCSI_TASK_MGMT)
bad: 			mptctl_free_tm_flags(ioc);
bad: 
bad: 		mptctl_timeout_expired(ioc->ioctl);
bad: 		rc = -ENODATA;
bad: 		goto done_free_mem;
bad: 	}
bad: 
bad: 	mf = NULL;
bad: 
bad: 	/* If a valid reply frame, copy to the user.
bad: 	 * Offset 2: reply length in U32's
bad: 	 */
bad: 	if (ioc->ioctl->status & MPT_IOCTL_STATUS_RF_VALID) {
bad: 		if (karg.maxReplyBytes < ioc->reply_sz) {
bad: 			 sz = min(karg.maxReplyBytes, 4*ioc->ioctl->ReplyFrame[2]);
bad: 		} else {
bad: 			 sz = min(ioc->reply_sz, 4*ioc->ioctl->ReplyFrame[2]);
bad: 		}
bad: 
bad: 		if (sz > 0) {
bad: 			if (copy_to_user(karg.replyFrameBufPtr,
bad: 				 &ioc->ioctl->ReplyFrame, sz)){
bad: 				 printk(MYIOC_s_ERR_FMT
bad: 				     "%s@%d::mptctl_do_mpt_command - "
bad: 				 "Unable to write out reply frame %p\n",
bad: 				 ioc->name, __FILE__, __LINE__, karg.replyFrameBufPtr);
bad: 				 rc =  -ENODATA;
bad: 				 goto done_free_mem;
bad: 			}
bad: 		}
bad: 	}
bad: 
bad: 	/* If valid sense data, copy to user.
bad: 	 */
bad: 	if (ioc->ioctl->status & MPT_IOCTL_STATUS_SENSE_VALID) {
bad: 		sz = min(karg.maxSenseBytes, MPT_SENSE_BUFFER_SIZE);
bad: 		if (sz > 0) {
bad: 			if (copy_to_user(karg.senseDataPtr, ioc->ioctl->sense, sz)) {
bad: 				printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_do_mpt_command - "
bad: 				"Unable to write sense data to user %p\n",
bad: 				ioc->name, __FILE__, __LINE__,
bad: 				karg.senseDataPtr);
bad: 				rc =  -ENODATA;
bad: 				goto done_free_mem;
bad: 			}
bad: 		}
bad: 	}
bad: 
bad: 	/* If the overall status is _GOOD and data in, copy data
bad: 	 * to user.
bad: 	 */
bad: 	if ((ioc->ioctl->status & MPT_IOCTL_STATUS_COMMAND_GOOD) &&
bad: 				(karg.dataInSize > 0) && (bufIn.kptr)) {
bad: 
bad: 		if (copy_to_user(karg.dataInBufPtr,
bad: 				 bufIn.kptr, karg.dataInSize)) {
bad: 			printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_do_mpt_command - "
bad: 				"Unable to write data to user %p\n",
bad: 				ioc->name, __FILE__, __LINE__,
bad: 				karg.dataInBufPtr);
bad: 			rc =  -ENODATA;
bad: 		}
bad: 	}
bad: 
bad: done_free_mem:
bad: 
bad: 	ioc->ioctl->status &= ~(MPT_IOCTL_STATUS_COMMAND_GOOD |
bad: 		MPT_IOCTL_STATUS_SENSE_VALID |
bad: 		MPT_IOCTL_STATUS_RF_VALID );
bad: 
bad: 	/* Free the allocated memory.
bad: 	 */
bad: 	if (bufOut.kptr != NULL) {
bad: 		pci_free_consistent(ioc->pcidev,
bad: 			bufOut.len, (void *) bufOut.kptr, dma_addr_out);
bad: 	}
bad: 
bad: 	if (bufIn.kptr != NULL) {
bad: 		pci_free_consistent(ioc->pcidev,
bad: 			bufIn.len, (void *) bufIn.kptr, dma_addr_in);
bad: 	}
bad: 
bad: 	/* mf is null if command issued successfully
bad: 	 * otherwise, failure occured after mf acquired.
bad: 	 */
bad: 	if (mf)
bad: 		mpt_free_msg_frame(ioc, mf);
bad: 
bad: 	return rc;
bad: }
semantic error two or more data types
 =File "mptctl.c.orig", line 2329, column 23,  charpos = 66419
    around = '*', whole content = 	hp_host_info_t	__user *uarg = (void __user *) arg;
ERROR-RECOV: found sync '}' at line 2550
badcount: 237
bad: }
bad: 
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
bad: /* Prototype Routine for the HOST INFO command.
bad:  *
bad:  * Outputs:	None.
bad:  * Return:	0 if successful
bad:  *		-EFAULT if data unavailable
bad:  *		-EBUSY  if previous command timout and IOC reset is not complete.
bad:  *		-ENODEV if no such device/adapter
bad:  *		-ETIME	if timer expires
bad:  *		-ENOMEM if memory allocation error
bad:  */
bad: static int
bad: mptctl_hp_hostinfo(unsigned long arg, unsigned int data_size)
bad: {
BAD:!!!!! 	hp_host_info_t	__user *uarg = (void __user *) arg;
bad: 	MPT_ADAPTER		*ioc;
bad: 	struct pci_dev		*pdev;
bad: 	char                    *pbuf=NULL;
bad: 	dma_addr_t		buf_dma;
bad: 	hp_host_info_t		karg;
bad: 	CONFIGPARMS		cfg;
bad: 	ConfigPageHeader_t	hdr;
bad: 	int			iocnum;
bad: 	int			rc, cim_rev;
bad: 	ToolboxIstwiReadWriteRequest_t	*IstwiRWRequest;
bad: 	MPT_FRAME_HDR		*mf = NULL;
bad: 	MPIHeader_t		*mpi_hdr;
bad: 
bad: 	/* Reset long to int. Should affect IA64 and SPARC only
bad: 	 */
bad: 	if (data_size == sizeof(hp_host_info_t))
bad: 		cim_rev = 1;
bad: 	else if (data_size == sizeof(hp_host_info_rev0_t))
bad: 		cim_rev = 0;	/* obsolete */
bad: 	else
bad: 		return -EFAULT;
bad: 
bad: 	if (copy_from_user(&karg, uarg, sizeof(hp_host_info_t))) {
bad: 		printk(KERN_ERR MYNAM "%s@%d::mptctl_hp_host_info - "
bad: 			"Unable to read in hp_host_info struct @ %p\n",
bad: 				__FILE__, __LINE__, uarg);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
bad: 	    (ioc == NULL)) {
bad: 		printk(KERN_DEBUG MYNAM "%s::mptctl_hp_hostinfo() @%d - ioc%d not found!\n",
bad: 				__FILE__, __LINE__, iocnum);
bad: 		return -ENODEV;
bad: 	}
bad: 	dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT ": mptctl_hp_hostinfo called.\n",
bad: 	    ioc->name));
bad: 
bad: 	/* Fill in the data and return the structure to the calling
bad: 	 * program
bad: 	 */
bad: 	pdev = (struct pci_dev *) ioc->pcidev;
bad: 
bad: 	karg.vendor = pdev->vendor;
bad: 	karg.device = pdev->device;
bad: 	karg.subsystem_id = pdev->subsystem_device;
bad: 	karg.subsystem_vendor = pdev->subsystem_vendor;
bad: 	karg.devfn = pdev->devfn;
bad: 	karg.bus = pdev->bus->number;
bad: 
bad: 	/* Save the SCSI host no. if
bad: 	 * SCSI driver loaded
bad: 	 */
bad: 	if (ioc->sh != NULL)
bad: 		karg.host_no = ioc->sh->host_no;
bad: 	else
bad: 		karg.host_no =  -1;
bad: 
bad: 	/* Reformat the fw_version into a string
bad: 	 */
bad: 	karg.fw_version[0] = ioc->facts.FWVersion.Struct.Major >= 10 ?
bad: 		((ioc->facts.FWVersion.Struct.Major / 10) + '0') : '0';
bad: 	karg.fw_version[1] = (ioc->facts.FWVersion.Struct.Major % 10 ) + '0';
bad: 	karg.fw_version[2] = '.';
bad: 	karg.fw_version[3] = ioc->facts.FWVersion.Struct.Minor >= 10 ?
bad: 		((ioc->facts.FWVersion.Struct.Minor / 10) + '0') : '0';
bad: 	karg.fw_version[4] = (ioc->facts.FWVersion.Struct.Minor % 10 ) + '0';
bad: 	karg.fw_version[5] = '.';
bad: 	karg.fw_version[6] = ioc->facts.FWVersion.Struct.Unit >= 10 ?
bad: 		((ioc->facts.FWVersion.Struct.Unit / 10) + '0') : '0';
bad: 	karg.fw_version[7] = (ioc->facts.FWVersion.Struct.Unit % 10 ) + '0';
bad: 	karg.fw_version[8] = '.';
bad: 	karg.fw_version[9] = ioc->facts.FWVersion.Struct.Dev >= 10 ?
bad: 		((ioc->facts.FWVersion.Struct.Dev / 10) + '0') : '0';
bad: 	karg.fw_version[10] = (ioc->facts.FWVersion.Struct.Dev % 10 ) + '0';
bad: 	karg.fw_version[11] = '\0';
bad: 
bad: 	/* Issue a config request to get the device serial number
bad: 	 */
bad: 	hdr.PageVersion = 0;
bad: 	hdr.PageLength = 0;
bad: 	hdr.PageNumber = 0;
bad: 	hdr.PageType = MPI_CONFIG_PAGETYPE_MANUFACTURING;
bad: 	cfg.cfghdr.hdr = &hdr;
bad: 	cfg.physAddr = -1;
bad: 	cfg.pageAddr = 0;
bad: 	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
bad: 	cfg.dir = 0;	/* read */
bad: 	cfg.timeout = 10;
bad: 
bad: 	strncpy(karg.serial_number, " ", 24);
bad: 	if (mpt_config(ioc, &cfg) == 0) {
bad: 		if (cfg.cfghdr.hdr->PageLength > 0) {
bad: 			/* Issue the second config page request */
bad: 			cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
bad: 
bad: 			pbuf = pci_alloc_consistent(ioc->pcidev, hdr.PageLength * 4, &buf_dma);
bad: 			if (pbuf) {
bad: 				cfg.physAddr = buf_dma;
bad: 				if (mpt_config(ioc, &cfg) == 0) {
bad: 					ManufacturingPage0_t *pdata = (ManufacturingPage0_t *) pbuf;
bad: 					if (strlen(pdata->BoardTracerNumber) > 1) {
bad: 						strncpy(karg.serial_number, 									    pdata->BoardTracerNumber, 24);
bad: 						karg.serial_number[24-1]='\0';
bad: 					}
bad: 				}
bad: 				pci_free_consistent(ioc->pcidev, hdr.PageLength * 4, pbuf, buf_dma);
bad: 				pbuf = NULL;
bad: 			}
bad: 		}
bad: 	}
bad: 	rc = mpt_GetIocState(ioc, 1);
bad: 	switch (rc) {
bad: 	case MPI_IOC_STATE_OPERATIONAL:
bad: 		karg.ioc_status =  HP_STATUS_OK;
bad: 		break;
bad: 
bad: 	case MPI_IOC_STATE_FAULT:
bad: 		karg.ioc_status =  HP_STATUS_FAILED;
bad: 		break;
bad: 
bad: 	case MPI_IOC_STATE_RESET:
bad: 	case MPI_IOC_STATE_READY:
bad: 	default:
bad: 		karg.ioc_status =  HP_STATUS_OTHER;
bad: 		break;
bad: 	}
bad: 
bad: 	karg.base_io_addr = pci_resource_start(pdev, 0);
bad: 
bad: 	if ((ioc->bus_type == SAS) || (ioc->bus_type == FC))
bad: 		karg.bus_phys_width = HP_BUS_WIDTH_UNK;
bad: 	else
bad: 		karg.bus_phys_width = HP_BUS_WIDTH_16;
bad: 
bad: 	karg.hard_resets = 0;
bad: 	karg.soft_resets = 0;
bad: 	karg.timeouts = 0;
bad: 	if (ioc->sh != NULL) {
bad: 		MPT_SCSI_HOST *hd =  (MPT_SCSI_HOST *)ioc->sh->hostdata;
bad: 
bad: 		if (hd && (cim_rev == 1)) {
bad: 			karg.hard_resets = hd->hard_resets;
bad: 			karg.soft_resets = hd->soft_resets;
bad: 			karg.timeouts = hd->timeouts;
bad: 		}
bad: 	}
bad: 
bad: 	/* 
bad: 	 * Gather ISTWI(Industry Standard Two Wire Interface) Data
bad: 	 */
bad: 	if ((mf = mpt_get_msg_frame(mptctl_id, ioc)) == NULL) {
bad: 		dfailprintk(ioc, printk(MYIOC_s_WARN_FMT "%s, no msg frames!!\n",
bad: 		    ioc->name,__FUNCTION__));
bad: 		goto out;
bad: 	}
bad: 
bad: 	IstwiRWRequest = (ToolboxIstwiReadWriteRequest_t *)mf;
bad: 	mpi_hdr = (MPIHeader_t *) mf;
bad: 	memset(IstwiRWRequest,0,sizeof(ToolboxIstwiReadWriteRequest_t));
bad: 	IstwiRWRequest->Function = MPI_FUNCTION_TOOLBOX;
bad: 	IstwiRWRequest->Tool = MPI_TOOLBOX_ISTWI_READ_WRITE_TOOL;
bad: 	IstwiRWRequest->MsgContext = mpi_hdr->MsgContext;
bad: 	IstwiRWRequest->Flags = MPI_TB_ISTWI_FLAGS_READ;
bad: 	IstwiRWRequest->NumAddressBytes = 0x01;
bad: 	IstwiRWRequest->DataLength = cpu_to_le16(0x04);
bad: 	if (pdev->devfn & 1)
bad: 		IstwiRWRequest->DeviceAddr = 0xB2;
bad: 	else
bad: 		IstwiRWRequest->DeviceAddr = 0xB0;
bad: 
bad: 	pbuf = pci_alloc_consistent(ioc->pcidev, 4, &buf_dma);
bad: 	if (!pbuf)
bad: 		goto out;
bad: 	mpt_add_sge((char *)&IstwiRWRequest->SGL,
bad: 	    (MPT_SGE_FLAGS_SSIMPLE_READ|4), buf_dma);
bad: 
bad: 	ioc->ioctl->wait_done = 0;
bad: 	mpt_put_msg_frame(mptctl_id, ioc, mf);
bad: 
bad: 	rc = wait_event_timeout(mptctl_wait,
bad: 	     ioc->ioctl->wait_done == 1,
bad: 	     HZ*MPT_IOCTL_DEFAULT_TIMEOUT /* 10 sec */);
bad: 
bad: 	if(rc <=0 && (ioc->ioctl->wait_done != 1 )) {
bad: 		/*
bad: 		 * Now we need to reset the board
bad: 		 */
bad: 		mpt_free_msg_frame(ioc, mf);
bad: 		mptctl_timeout_expired(ioc->ioctl);
bad: 		goto out;
bad: 	}
bad: 
bad: 	/*
bad: 	 *ISTWI Data Definition
bad: 	 * pbuf[0] = FW_VERSION = 0x4
bad: 	 * pbuf[1] = Bay Count = 6 or 4 or 2, depending on
bad: 	 *  the config, you should be seeing one out of these three values
bad: 	 * pbuf[2] = Drive Installed Map = bit pattern depend on which
bad: 	 *   bays have drives in them
bad: 	 * pbuf[3] = Checksum (0x100 = (byte0 + byte2 + byte3)
bad: 	 */
bad: 	if (ioc->ioctl->status & MPT_IOCTL_STATUS_RF_VALID)
bad: 		karg.rsvd = *(u32 *)pbuf;
bad: 
bad:  out:
bad: 	if (pbuf)
bad: 		pci_free_consistent(ioc->pcidev, 4, pbuf, buf_dma);
bad: 
bad: 	/* Copy the data from kernel memory to user memory
bad: 	 */
bad: 	if (copy_to_user((char __user *)arg, &karg, sizeof(hp_host_info_t))) {
bad: 		printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_hpgethostinfo - "
bad: 			"Unable to write out hp_host_info @ %p\n",
bad: 			ioc->name, __FILE__, __LINE__, uarg);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	return 0;
bad: 
bad: }
semantic error two or more data types
 =File "mptctl.c.orig", line 2566, column 25,  charpos = 73379
    around = '*', whole content = 	hp_target_info_t __user *uarg = (void __user *) arg;
ERROR-RECOV: found sync '}' at line 2700
badcount: 150
bad: }
bad: 
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
bad: /* Prototype Routine for the TARGET INFO command.
bad:  *
bad:  * Outputs:	None.
bad:  * Return:	0 if successful
bad:  *		-EFAULT if data unavailable
bad:  *		-EBUSY  if previous command timout and IOC reset is not complete.
bad:  *		-ENODEV if no such device/adapter
bad:  *		-ETIME	if timer expires
bad:  *		-ENOMEM if memory allocation error
bad:  */
bad: static int
bad: mptctl_hp_targetinfo(unsigned long arg)
bad: {
BAD:!!!!! 	hp_target_info_t __user *uarg = (void __user *) arg;
bad: 	SCSIDevicePage0_t	*pg0_alloc;
bad: 	SCSIDevicePage3_t	*pg3_alloc;
bad: 	MPT_ADAPTER		*ioc;
bad: 	MPT_SCSI_HOST 		*hd = NULL;
bad: 	hp_target_info_t	karg;
bad: 	int			iocnum;
bad: 	int			data_sz;
bad: 	dma_addr_t		page_dma;
bad: 	CONFIGPARMS	 	cfg;
bad: 	ConfigPageHeader_t	hdr;
bad: 	int			tmp, np, rc = 0;
bad: 
bad: 	if (copy_from_user(&karg, uarg, sizeof(hp_target_info_t))) {
bad: 		printk(KERN_ERR MYNAM "%s@%d::mptctl_hp_targetinfo - "
bad: 			"Unable to read in hp_host_targetinfo struct @ %p\n",
bad: 				__FILE__, __LINE__, uarg);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
bad: 		(ioc == NULL)) {
bad: 		printk(KERN_DEBUG MYNAM "%s::mptctl_hp_targetinfo() @%d - ioc%d not found!\n",
bad: 				__FILE__, __LINE__, iocnum);
bad: 		return -ENODEV;
bad: 	}
bad: 	dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "mptctl_hp_targetinfo called.\n",
bad: 	    ioc->name));
bad: 
bad: 	/*  There is nothing to do for FCP parts.
bad: 	 */
bad: 	if ((ioc->bus_type == SAS) || (ioc->bus_type == FC))
bad: 		return 0;
bad: 
bad: 	if ((ioc->spi_data.sdp0length == 0) || (ioc->sh == NULL))
bad: 		return 0;
bad: 
bad: 	if (ioc->sh->host_no != karg.hdr.host)
bad: 		return -ENODEV;
bad: 
bad:        /* Get the data transfer speeds
bad:         */
bad: 	data_sz = ioc->spi_data.sdp0length * 4;
bad: 	pg0_alloc = (SCSIDevicePage0_t *) pci_alloc_consistent(ioc->pcidev, data_sz, &page_dma);
bad: 	if (pg0_alloc) {
bad: 		hdr.PageVersion = ioc->spi_data.sdp0version;
bad: 		hdr.PageLength = data_sz;
bad: 		hdr.PageNumber = 0;
bad: 		hdr.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;
bad: 
bad: 		cfg.cfghdr.hdr = &hdr;
bad: 		cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
bad: 		cfg.dir = 0;
bad: 		cfg.timeout = 0;
bad: 		cfg.physAddr = page_dma;
bad: 
bad: 		cfg.pageAddr = (karg.hdr.channel << 8) | karg.hdr.id;
bad: 
bad: 		if ((rc = mpt_config(ioc, &cfg)) == 0) {
bad: 			np = le32_to_cpu(pg0_alloc->NegotiatedParameters);
bad: 			karg.negotiated_width = np & MPI_SCSIDEVPAGE0_NP_WIDE ?
bad: 					HP_BUS_WIDTH_16 : HP_BUS_WIDTH_8;
bad: 
bad: 			if (np & MPI_SCSIDEVPAGE0_NP_NEG_SYNC_OFFSET_MASK) {
bad: 				tmp = (np & MPI_SCSIDEVPAGE0_NP_NEG_SYNC_PERIOD_MASK) >> 8;
bad: 				if (tmp < 0x09)
bad: 					karg.negotiated_speed = HP_DEV_SPEED_ULTRA320;
bad: 				else if (tmp <= 0x09)
bad: 					karg.negotiated_speed = HP_DEV_SPEED_ULTRA160;
bad: 				else if (tmp <= 0x0A)
bad: 					karg.negotiated_speed = HP_DEV_SPEED_ULTRA2;
bad: 				else if (tmp <= 0x0C)
bad: 					karg.negotiated_speed = HP_DEV_SPEED_ULTRA;
bad: 				else if (tmp <= 0x25)
bad: 					karg.negotiated_speed = HP_DEV_SPEED_FAST;
bad: 				else
bad: 					karg.negotiated_speed = HP_DEV_SPEED_ASYNC;
bad: 			} else
bad: 				karg.negotiated_speed = HP_DEV_SPEED_ASYNC;
bad: 		}
bad: 
bad: 		pci_free_consistent(ioc->pcidev, data_sz, (u8 *) pg0_alloc, page_dma);
bad: 	}
bad: 
bad: 	/* Set defaults
bad: 	 */
bad: 	karg.message_rejects = -1;
bad: 	karg.phase_errors = -1;
bad: 	karg.parity_errors = -1;
bad: 	karg.select_timeouts = -1;
bad: 
bad: 	/* Get the target error parameters
bad: 	 */
bad: 	hdr.PageVersion = 0;
bad: 	hdr.PageLength = 0;
bad: 	hdr.PageNumber = 3;
bad: 	hdr.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;
bad: 
bad: 	cfg.cfghdr.hdr = &hdr;
bad: 	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
bad: 	cfg.dir = 0;
bad: 	cfg.timeout = 0;
bad: 	cfg.physAddr = -1;
bad: 	if ((mpt_config(ioc, &cfg) == 0) && (cfg.cfghdr.hdr->PageLength > 0)) {
bad: 		/* Issue the second config page request */
bad: 		cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
bad: 		data_sz = (int) cfg.cfghdr.hdr->PageLength * 4;
bad: 		pg3_alloc = (SCSIDevicePage3_t *) pci_alloc_consistent(
bad: 							ioc->pcidev, data_sz, &page_dma);
bad: 		if (pg3_alloc) {
bad: 			cfg.physAddr = page_dma;
bad: 			cfg.pageAddr = (karg.hdr.channel << 8) | karg.hdr.id;
bad: 			if ((rc = mpt_config(ioc, &cfg)) == 0) {
bad: 				karg.message_rejects = (u32) le16_to_cpu(pg3_alloc->MsgRejectCount);
bad: 				karg.phase_errors = (u32) le16_to_cpu(pg3_alloc->PhaseErrorCount);
bad: 				karg.parity_errors = (u32) le16_to_cpu(pg3_alloc->ParityErrorCount);
bad: 			}
bad: 			pci_free_consistent(ioc->pcidev, data_sz, (u8 *) pg3_alloc, page_dma);
bad: 		}
bad: 	}
bad: 	hd = (MPT_SCSI_HOST *) ioc->sh->hostdata;
bad: 	if (hd != NULL)
bad: 		karg.select_timeouts = hd->sel_timeout[karg.hdr.id];
bad: 
bad: 	/* Copy the data from kernel memory to user memory
bad: 	 */
bad: 	if (copy_to_user((char __user *)arg, &karg, sizeof(hp_target_info_t))) {
bad: 		printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_hp_target_info - "
bad: 			"Unable to write out mpt_ioctl_targetinfo struct @ %p\n",
bad: 			ioc->name, __FILE__, __LINE__, uarg);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	return 0;
bad: }
semantic error two or more data types
 =File "mptctl.c.orig", line 2737, column 41,  charpos = 78327
    around = '*', whole content = 	if (copy_from_user(&kfw32, (char __user *)arg, sizeof(kfw32)))
ERROR-RECOV: found sync '}' at line 2763
badcount: 44
bad: };
bad: 
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
bad: 
bad: #ifdef CONFIG_COMPAT
bad: 
bad: static int
bad: compat_mptfwxfer_ioctl(struct file *filp, unsigned int cmd,
bad: 			unsigned long arg)
bad: {
bad: 	struct mpt_fw_xfer32 kfw32;
bad: 	struct mpt_fw_xfer kfw;
bad: 	MPT_ADAPTER *iocp = NULL;
bad: 	int iocnum, iocnumX;
bad: 	int nonblock = (filp->f_flags & O_NONBLOCK);
bad: 	int ret;
bad: 
bad: 
BAD:!!!!! 	if (copy_from_user(&kfw32, (char __user *)arg, sizeof(kfw32)))
bad: 		return -EFAULT;
bad: 
bad: 	/* Verify intended MPT adapter */
bad: 	iocnumX = kfw32.iocnum & 0xFF;
bad: 	if (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||
bad: 	    (iocp == NULL)) {
bad: 		printk(KERN_DEBUG MYNAM "::compat_mptfwxfer_ioctl @%d - ioc%d not found!\n",
bad: 			__LINE__, iocnumX);
bad: 		return -ENODEV;
bad: 	}
bad: 
bad: 	if ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)
bad: 		return ret;
bad: 
bad: 	dctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT "compat_mptfwxfer_ioctl() called\n",
bad: 	    iocp->name));
bad: 	kfw.iocnum = iocnum;
bad: 	kfw.fwlen = kfw32.fwlen;
bad: 	kfw.bufp = compat_ptr(kfw32.bufp);
bad: 
bad: 	ret = mptctl_do_fw_download(kfw.iocnum, kfw.bufp, kfw.fwlen);
bad: 
bad: 	mutex_unlock(&iocp->ioctl->ioctl_mutex);
bad: 
bad: 	return ret;
bad: }
semantic error two or more data types
 =File "mptctl.c.orig", line 2770, column 35,  charpos = 79182
    around = '*', whole content = 	struct mpt_ioctl_command32 __user *uarg = (struct mpt_ioctl_command32 __user *) arg;
ERROR-RECOV: found sync '}' at line 2817
badcount: 54
bad: }
bad: 
bad: static int
bad: compat_mpt_command(struct file *filp, unsigned int cmd,
bad: 			unsigned long arg)
bad: {
bad: 	struct mpt_ioctl_command32 karg32;
BAD:!!!!! 	struct mpt_ioctl_command32 __user *uarg = (struct mpt_ioctl_command32 __user *) arg;
bad: 	struct mpt_ioctl_command karg;
bad: 	MPT_ADAPTER *iocp = NULL;
bad: 	int iocnum, iocnumX;
bad: 	int nonblock = (filp->f_flags & O_NONBLOCK);
bad: 	int ret;
bad: 
bad: 	if (copy_from_user(&karg32, (char __user *)arg, sizeof(karg32)))
bad: 		return -EFAULT;
bad: 
bad: 	/* Verify intended MPT adapter */
bad: 	iocnumX = karg32.hdr.iocnum & 0xFF;
bad: 	if (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||
bad: 	    (iocp == NULL)) {
bad: 		printk(KERN_DEBUG MYNAM "::compat_mpt_command @%d - ioc%d not found!\n",
bad: 			__LINE__, iocnumX);
bad: 		return -ENODEV;
bad: 	}
bad: 
bad: 	if ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)
bad: 		return ret;
bad: 
bad: 	dctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT "compat_mpt_command() called\n",
bad: 	    iocp->name));
bad: 	/* Copy data to karg */
bad: 	karg.hdr.iocnum = karg32.hdr.iocnum;
bad: 	karg.hdr.port = karg32.hdr.port;
bad: 	karg.timeout = karg32.timeout;
bad: 	karg.maxReplyBytes = karg32.maxReplyBytes;
bad: 
bad: 	karg.dataInSize = karg32.dataInSize;
bad: 	karg.dataOutSize = karg32.dataOutSize;
bad: 	karg.maxSenseBytes = karg32.maxSenseBytes;
bad: 	karg.dataSgeOffset = karg32.dataSgeOffset;
bad: 
bad: 	karg.replyFrameBufPtr = (char __user *)(unsigned long)karg32.replyFrameBufPtr;
bad: 	karg.dataInBufPtr = (char __user *)(unsigned long)karg32.dataInBufPtr;
bad: 	karg.dataOutBufPtr = (char __user *)(unsigned long)karg32.dataOutBufPtr;
bad: 	karg.senseDataPtr = (char __user *)(unsigned long)karg32.senseDataPtr;
bad: 
bad: 	/* Pass new structure to do_mpt_command
bad: 	 */
bad: 	ret = mptctl_do_mpt_command (karg, &uarg->MF);
bad: 
bad: 	mutex_unlock(&iocp->ioctl->ioctl_mutex);
bad: 
bad: 	return ret;
bad: }
semantic error two or more data types
 =File "mptctl.c.orig", line 2905, column 18,  charpos = 82444
    around = 'mptctl_init', whole content = static int __init mptctl_init(void)
ERROR-RECOV: found sync '}' at line 2946
badcount: 44
bad: };
bad: 
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
BAD:!!!!! static int __init mptctl_init(void)
bad: {
bad: 	int err;
bad: 	int where = 1;
bad: 
bad: 	show_mptmod_ver(my_NAME, my_VERSION);
bad: 
bad: 	mpt_device_driver_register(&mptctl_driver, MPTCTL_DRIVER);
bad: 
bad: 	/* Register this device */
bad: 	err = misc_register(&mptctl_miscdev);
bad: 	if (err < 0) {
bad: 		printk(KERN_ERR MYNAM ": Can't register misc device [minor=%d].\n", MPT_MINOR);
bad: 		goto out_fail;
bad: 	}
bad: 	printk(KERN_INFO MYNAM ": Registered with Fusion MPT base driver\n");
bad: 	printk(KERN_INFO MYNAM ": /dev/%s @ (major,minor=%d,%d)\n",
bad: 			 mptctl_miscdev.name, MISC_MAJOR, mptctl_miscdev.minor);
bad: 
bad: 	/*
bad: 	 *  Install our handler
bad: 	 */
bad: 	++where;
bad: 	mptctl_id = mpt_register(mptctl_reply, MPTCTL_DRIVER);
bad: 	if (!mptctl_id || mptctl_id >= MPT_MAX_PROTOCOL_DRIVERS) {
bad: 		printk(KERN_ERR MYNAM ": ERROR: Failed to register with Fusion MPT base driver\n");
bad: 		misc_deregister(&mptctl_miscdev);
bad: 		err = -EBUSY;
bad: 		goto out_fail;
bad: 	}
bad: 
bad: 	mpt_reset_register(mptctl_id, mptctl_ioc_reset);
bad: 	mpt_event_register(mptctl_id, mptctl_event_process);
bad: 
bad: 	return 0;
bad: 
bad: out_fail:
bad: 
bad: 	mpt_device_driver_deregister(MPTCTL_DRIVER);
bad: 
bad: 	return err;
bad: }
Type_annoter: not finding type for my_NAME
Type_annoter: not finding type for my_VERSION
Type_annoter: not finding type for mptctl_wait
Type_annoter: not finding type for mutex_trylock
Type_annoter: not finding type for mutex_lock_interruptible
Type_annoter: not finding type for dctlprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for wake_up
Type_annoter: not finding type for mptctl_wait
Type_annoter: not finding type for memcpy
Type_annoter: not finding type for min
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for dctlprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for mpt_HardResetHandler
Type_annoter: not finding type for mpt_get_msg_frame
Type_annoter: not finding type for dtmprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for mpt_put_msg_frame_hi_pri
Type_annoter: not finding type for mpt_send_handshake_request
Type_annoter: not finding type for dfailprintk
Type_annoter: not finding type for wait_event_timeout
Type_annoter: not finding type for mptctl_wait
Type_annoter: not finding type for mpt_free_msg_frame
Type_annoter: not finding type for spin_lock_irqsave
Type_annoter: not finding type for spin_unlock_irqrestore
Type_annoter: not finding type for spin_lock_irqsave
Type_annoter: not finding type for spin_unlock_irqrestore
Type_annoter: not finding type for dctlprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for dctlprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for devtverboseprintk
Type_annoter: not finding type for kill_fasync
Type_annoter: not finding type for ioc_list
Type_annoter: not finding type for list
Type_annoter: not finding type for fasync_helper
Type_annoter: not finding type for fasync_helper
Type_annoter: not finding type for lock_kernel
Type_annoter: not finding type for unlock_kernel
Type_annoter: not finding type for min
Type_annoter: not finding type for kzalloc
Type_annoter: not finding type for pci_alloc_consistent
Type_annoter: not finding type for printk
Type_annoter: not finding type for pci_map_single
Type_annoter: not finding type for dctlprintk
Type_annoter: not finding type for pci_free_consistent
Type_annoter: not finding type for kfree
Type_annoter: not finding type for pci_unmap_single
Type_annoter: not finding type for pci_free_consistent
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for kfree
Type_annoter: not finding type for dctlprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for no_llseek
Type_annoter: not finding type for lock_kernel
Type_annoter: not finding type for compat_mpt_command
Type_annoter: not finding type for compat_mptfwxfer_ioctl
Type_annoter: not finding type for unlock_kernel
Type_annoter: not finding type for pci_get_drvdata
Type_annoter: not finding type for kzalloc
Type_annoter: not finding type for mutex_init
Type_annoter: not finding type for pci_get_drvdata
Type_annoter: not finding type for kfree
no type, certainly because Void type ?
Type_annoter: not finding type for misc_deregister
Type_annoter: not finding type for printk
Type_annoter: not finding type for mpt_reset_deregister
Type_annoter: not finding type for mpt_deregister
Type_annoter: not finding type for mpt_device_driver_deregister
Type_annoter: not finding type for mptctl_init
semantic error two or more data types
 =File "mptctl.c.new", line 124, column 76,  charpos = 4656
    around = '*', whole content = static int mptctl_do_mpt_command(struct mpt_ioctl_command karg, void __user *mfPtr);
ERROR-RECOV: found sync col 0 at line 125
badcount: 5
bad: static long compat_mpctl_ioctl(struct file *f, unsigned cmd, unsigned long arg);
bad: #endif
bad: /*
bad:  * Private function calls.
bad:  */
BAD:!!!!! static int mptctl_do_mpt_command(struct mpt_ioctl_command karg, void __user *mfPtr);
semantic error two or more data types
 =File "mptctl.c.new", line 125, column 54,  charpos = 4719
    around = '*', whole content = static int mptctl_do_fw_download(int ioc, char __user *ufwbuf, size_t fwlen);
ERROR-RECOV: found sync col 0 at line 126
badcount: 1
bad: static int mptctl_do_mpt_command(struct mpt_ioctl_command karg, void __user *mfPtr);
BAD:!!!!! static int mptctl_do_fw_download(int ioc, char __user *ufwbuf, size_t fwlen);
PB MAYBE: dangerous typedef inference, maybe not a typedef: SCSITaskMgmt_t
semantic error two or more data types
 =File "mptctl.c.new", line 573, column 25,  charpos = 16828
    around = '*', whole content = 	mpt_ioctl_header __user *uhdr = (void __user *) arg;
ERROR-RECOV: found sync '}' at line 649
badcount: 87
bad: }
bad: 
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
bad: /*
bad:  *  MPT ioctl handler
bad:  *  cmd - specify the particular IOCTL command to be issued
bad:  *  arg - data specific to the command. Must not be null.
bad:  */
bad: static long
bad: __mptctl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
bad: {
BAD:!!!!! 	mpt_ioctl_header __user *uhdr = (void __user *) arg;
bad: 	mpt_ioctl_header	 khdr;
bad: 	int iocnum;
bad: 	unsigned iocnumX;
bad: 	int nonblock = (file->f_flags & O_NONBLOCK);
bad: 	int ret;
bad: 	MPT_ADAPTER *iocp = NULL;
bad: 
bad: 	if (copy_from_user(&khdr, uhdr, sizeof(khdr))) {
bad: 		printk(KERN_ERR MYNAM "%s::mptctl_ioctl() @%d - "
bad: 				"Unable to copy mpt_ioctl_header data @ %p\n",
bad: 				__FILE__, __LINE__, uhdr);
bad: 		return -EFAULT;
bad: 	}
bad: 	ret = -ENXIO;				/* (-6) No such device or address */
bad: 
bad: 	/* Verify intended MPT adapter - set iocnum and the adapter
bad: 	 * pointer (iocp)
bad: 	 */
bad: 	iocnumX = khdr.iocnum & 0xFF;
bad: 	if (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||
bad: 	    (iocp == NULL)) {
bad: 		printk(KERN_DEBUG MYNAM "%s::mptctl_ioctl() @%d - ioc%d not found!\n",
bad: 				__FILE__, __LINE__, iocnumX);
bad: 		return -ENODEV;
bad: 	}
bad: 
bad: 	if (!iocp->active) {
bad: 		printk(KERN_DEBUG MYNAM "%s::mptctl_ioctl() @%d - Controller disabled.\n",
bad: 				__FILE__, __LINE__);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	/* Handle those commands that are just returning
bad: 	 * information stored in the driver.
bad: 	 * These commands should never time out and are unaffected
bad: 	 * by TM and FW reloads.
bad: 	 */
bad: 	if ((cmd & ~IOCSIZE_MASK) == (MPTIOCINFO & ~IOCSIZE_MASK)) {
bad: 		return mptctl_getiocinfo(arg, _IOC_SIZE(cmd));
bad: 	} else if (cmd == MPTTARGETINFO) {
bad: 		return mptctl_gettargetinfo(arg);
bad: 	} else if (cmd == MPTTEST) {
bad: 		return mptctl_readtest(arg);
bad: 	} else if (cmd == MPTEVENTQUERY) {
bad: 		return mptctl_eventquery(arg);
bad: 	} else if (cmd == MPTEVENTENABLE) {
bad: 		return mptctl_eventenable(arg);
bad: 	} else if (cmd == MPTEVENTREPORT) {
bad: 		return mptctl_eventreport(arg);
bad: 	} else if (cmd == MPTFWREPLACE) {
bad: 		return mptctl_replace_fw(arg);
bad: 	}
bad: 
bad: 	/* All of these commands require an interrupt or
bad: 	 * are unknown/illegal.
bad: 	 */
bad: 	if ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)
bad: 		return ret;
bad: 
bad: 	if (cmd == MPTFWDOWNLOAD)
bad: 		ret = mptctl_fw_download(arg);
bad: 	else if (cmd == MPTCOMMAND)
bad: 		ret = mptctl_mpt_command(arg);
bad: 	else if (cmd == MPTHARDRESET)
bad: 		ret = mptctl_do_reset(arg);
bad: 	else if ((cmd & ~IOCSIZE_MASK) == (HP_GETHOSTINFO & ~IOCSIZE_MASK))
bad: 		ret = mptctl_hp_hostinfo(arg, _IOC_SIZE(cmd));
bad: 	else if (cmd == HP_GETTARGETINFO)
bad: 		ret = mptctl_hp_targetinfo(arg);
bad: 	else
bad: 		ret = -EINVAL;
bad: 
bad: 	mutex_unlock(&iocp->ioctl->ioctl_mutex);
bad: 
bad: 	return ret;
bad: }
semantic error two or more data types
 =File "mptctl.c.new", line 663, column 36,  charpos = 19310
    around = '*', whole content = 	struct mpt_ioctl_diag_reset __user *urinfo = (void __user *) arg;
ERROR-RECOV: found sync '}' at line 690
badcount: 31
bad: }
bad: 
bad: static int mptctl_do_reset(unsigned long arg)
bad: {
BAD:!!!!! 	struct mpt_ioctl_diag_reset __user *urinfo = (void __user *) arg;
bad: 	struct mpt_ioctl_diag_reset krinfo;
bad: 	MPT_ADAPTER		*iocp;
bad: 
bad: 	if (copy_from_user(&krinfo, urinfo, sizeof(struct mpt_ioctl_diag_reset))) {
bad: 		printk(KERN_ERR MYNAM "%s@%d::mptctl_do_reset - "
bad: 				"Unable to copy mpt_ioctl_diag_reset struct @ %p\n",
bad: 				__FILE__, __LINE__, urinfo);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	if (mpt_verify_adapter(krinfo.hdr.iocnum, &iocp) < 0) {
bad: 		printk(KERN_DEBUG MYNAM "%s@%d::mptctl_do_reset - ioc%d not found!\n",
bad: 				__FILE__, __LINE__, krinfo.hdr.iocnum);
bad: 		return -ENODEV; /* (-6) No such device or address */
bad: 	}
bad: 
bad: 	dctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT "mptctl_do_reset called.\n",
bad: 	    iocp->name));
bad: 
bad: 	if (mpt_HardResetHandler(iocp, CAN_SLEEP) != 0) {
bad: 		printk (MYIOC_s_ERR_FMT "%s@%d::mptctl_do_reset - reset failed.\n",
bad: 			iocp->name, __FILE__, __LINE__);
bad: 		return -1;
bad: 	}
bad: 
bad: 	return 0;
bad: }
semantic error two or more data types
 =File "mptctl.c.new", line 712, column 27,  charpos = 20872
    around = '*', whole content = 	struct mpt_fw_xfer __user *ufwdl = (void __user *) arg;
ERROR-RECOV: found sync '}' at line 723
badcount: 33
bad: }
bad: 
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
bad: /*
bad:  * MPT FW download function.  Cast the arg into the mpt_fw_xfer structure.
bad:  * This structure contains: iocnum, firmware length (bytes),
bad:  *      pointer to user space memory where the fw image is stored.
bad:  *
bad:  * Outputs:	None.
bad:  * Return:	0 if successful
bad:  *		-EFAULT if data unavailable
bad:  *		-ENXIO  if no such device
bad:  *		-EAGAIN if resource problem
bad:  *		-ENOMEM if no memory for SGE
bad:  *		-EMLINK if too many chain buffers required
bad:  *		-EBADRQC if adapter does not support FW download
bad:  *		-EBUSY if adapter is busy
bad:  *		-ENOMSG if FW upload returned bad status
bad:  */
bad: static int
bad: mptctl_fw_download(unsigned long arg)
bad: {
BAD:!!!!! 	struct mpt_fw_xfer __user *ufwdl = (void __user *) arg;
bad: 	struct mpt_fw_xfer	 kfwdl;
bad: 
bad: 	if (copy_from_user(&kfwdl, ufwdl, sizeof(struct mpt_fw_xfer))) {
bad: 		printk(KERN_ERR MYNAM "%s@%d::_ioctl_fwdl - "
bad: 				"Unable to copy mpt_fw_xfer struct @ %p\n",
bad: 				__FILE__, __LINE__, ufwdl);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	return mptctl_do_fw_download(kfwdl.iocnum, kfwdl.bufp, kfwdl.fwlen);
bad: }
semantic error two or more data types
 =File "mptctl.c.new", line 740, column 43,  charpos = 21731
    around = '*', whole content = mptctl_do_fw_download(int ioc, char __user *ufwbuf, size_t fwlen)
ERROR-RECOV: found sync '}' at line 938
badcount: 215
bad: }
bad: 
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
bad: /*
bad:  * FW Download engine.
bad:  * Outputs:	None.
bad:  * Return:	0 if successful
bad:  *		-EFAULT if data unavailable
bad:  *		-ENXIO  if no such device
bad:  *		-EAGAIN if resource problem
bad:  *		-ENOMEM if no memory for SGE
bad:  *		-EMLINK if too many chain buffers required
bad:  *		-EBADRQC if adapter does not support FW download
bad:  *		-EBUSY if adapter is busy
bad:  *		-ENOMSG if FW upload returned bad status
bad:  */
bad: static int
BAD:!!!!! mptctl_do_fw_download(int ioc, char __user *ufwbuf, size_t fwlen)
bad: {
bad: 	FWDownload_t		*dlmsg;
bad: 	MPT_FRAME_HDR		*mf;
bad: 	MPT_ADAPTER		*iocp;
bad: 	FWDownloadTCSGE_t	*ptsge;
bad: 	MptSge_t		*sgl, *sgIn;
bad: 	char			*sgOut;
bad: 	struct buflist		*buflist;
bad: 	struct buflist		*bl;
bad: 	dma_addr_t		 sgl_dma;
bad: 	int			 ret;
bad: 	int			 numfrags = 0;
bad: 	int			 maxfrags;
bad: 	int			 n = 0;
bad: 	u32			 sgdir;
bad: 	u32			 nib;
bad: 	int			 fw_bytes_copied = 0;
bad: 	int			 i;
bad: 	int			 sge_offset = 0;
bad: 	u16			 iocstat;
bad: 	pFWDownloadReply_t	 ReplyMsg = NULL;
bad: 
bad: 	if (mpt_verify_adapter(ioc, &iocp) < 0) {
bad: 		printk(KERN_DEBUG MYNAM "ioctl_fwdl - ioc%d not found!\n",
bad: 				 ioc);
bad: 		return -ENODEV; /* (-6) No such device or address */
bad: 	} else {
bad: 
bad: 		/*  Valid device. Get a message frame and construct the FW download message.
bad: 	 	*/
bad: 		if ((mf = mpt_get_msg_frame(mptctl_id, iocp)) == NULL)
bad: 			return -EAGAIN;
bad: 	}
bad: 
bad: 	dctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT
bad: 	    "mptctl_do_fwdl called. mptctl_id = %xh.\n", iocp->name, mptctl_id));
bad: 	dctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT "DbG: kfwdl.bufp  = %p\n",
bad: 	    iocp->name, ufwbuf));
bad: 	dctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT "DbG: kfwdl.fwlen = %d\n",
bad: 	    iocp->name, (int)fwlen));
bad: 	dctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT "DbG: kfwdl.ioc   = %04xh\n",
bad: 	    iocp->name, ioc));
bad: 
bad: 	dlmsg = (FWDownload_t*) mf;
bad: 	ptsge = (FWDownloadTCSGE_t *) &dlmsg->SGL;
bad: 	sgOut = (char *) (ptsge + 1);
bad: 
bad: 	/*
bad: 	 * Construct f/w download request
bad: 	 */
bad: 	dlmsg->ImageType = MPI_FW_DOWNLOAD_ITYPE_FW;
bad: 	dlmsg->Reserved = 0;
bad: 	dlmsg->ChainOffset = 0;
bad: 	dlmsg->Function = MPI_FUNCTION_FW_DOWNLOAD;
bad: 	dlmsg->Reserved1[0] = dlmsg->Reserved1[1] = dlmsg->Reserved1[2] = 0;
bad: 	if (iocp->facts.MsgVersion >= MPI_VERSION_01_05)
bad: 		dlmsg->MsgFlags = MPI_FW_DOWNLOAD_MSGFLGS_LAST_SEGMENT;
bad: 	else
bad: 		dlmsg->MsgFlags = 0;
bad: 
bad: 
bad: 	/* Set up the Transaction SGE.
bad: 	 */
bad: 	ptsge->Reserved = 0;
bad: 	ptsge->ContextSize = 0;
bad: 	ptsge->DetailsLength = 12;
bad: 	ptsge->Flags = MPI_SGE_FLAGS_TRANSACTION_ELEMENT;
bad: 	ptsge->Reserved_0100_Checksum = 0;
bad: 	ptsge->ImageOffset = 0;
bad: 	ptsge->ImageSize = cpu_to_le32(fwlen);
bad: 
bad: 	/* Add the SGL
bad: 	 */
bad: 
bad: 	/*
bad: 	 * Need to kmalloc area(s) for holding firmware image bytes.
bad: 	 * But we need to do it piece meal, using a proper
bad: 	 * scatter gather list (with 128kB MAX hunks).
bad: 	 *
bad: 	 * A practical limit here might be # of sg hunks that fit into
bad: 	 * a single IOC request frame; 12 or 8 (see below), so:
bad: 	 * For FC9xx: 12 x 128kB == 1.5 mB (max)
bad: 	 * For C1030:  8 x 128kB == 1   mB (max)
bad: 	 * We could support chaining, but things get ugly(ier:)
bad: 	 *
bad: 	 * Set the sge_offset to the start of the sgl (bytes).
bad: 	 */
bad: 	sgdir = 0x04000000;		/* IOC will READ from sys mem */
bad: 	sge_offset = sizeof(MPIHeader_t) + sizeof(FWDownloadTCSGE_t);
bad: 	if ((sgl = kbuf_alloc_2_sgl(fwlen, sgdir, sge_offset,
bad: 				    &numfrags, &buflist, &sgl_dma, iocp)) == NULL)
bad: 		return -ENOMEM;
bad: 
bad: 	/*
bad: 	 * We should only need SGL with 2 simple_32bit entries (up to 256 kB)
bad: 	 * for FC9xx f/w image, but calculate max number of sge hunks
bad: 	 * we can fit into a request frame, and limit ourselves to that.
bad: 	 * (currently no chain support)
bad: 	 * maxfrags = (Request Size - FWdownload Size ) / Size of 32 bit SGE
bad: 	 *	Request		maxfrags
bad: 	 *	128		12
bad: 	 *	96		8
bad: 	 *	64		4
bad: 	 */
bad: 	maxfrags = (iocp->req_sz - sizeof(MPIHeader_t) - sizeof(FWDownloadTCSGE_t))
bad: 			/ (sizeof(dma_addr_t) + sizeof(u32));
bad: 	if (numfrags > maxfrags) {
bad: 		ret = -EMLINK;
bad: 		goto fwdl_out;
bad: 	}
bad: 
bad: 	dctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT "DbG: sgl buffer = %p, sgfrags = %d\n",
bad: 	    iocp->name, sgl, numfrags));
bad: 
bad: 	/*
bad: 	 * Parse SG list, copying sgl itself,
bad: 	 * plus f/w image hunks from user space as we go...
bad: 	 */
bad: 	ret = -EFAULT;
bad: 	sgIn = sgl;
bad: 	bl = buflist;
bad: 	for (i=0; i < numfrags; i++) {
bad: 
bad: 		/* Get the SGE type: 0 - TCSGE, 3 - Chain, 1 - Simple SGE
bad: 		 * Skip everything but Simple. If simple, copy from
bad: 		 *	user space into kernel space.
bad: 		 * Note: we should not have anything but Simple as
bad: 		 *	Chain SGE are illegal.
bad: 		 */
bad: 		nib = (sgIn->FlagsLength & 0x30000000) >> 28;
bad: 		if (nib == 0 || nib == 3) {
bad: 			;
bad: 		} else if (sgIn->Address) {
bad: 			mpt_add_sge(sgOut, sgIn->FlagsLength, sgIn->Address);
bad: 			n++;
bad: 			if (copy_from_user(bl->kptr, ufwbuf+fw_bytes_copied, bl->len)) {
bad: 				printk(MYIOC_s_ERR_FMT "%s@%d::_ioctl_fwdl - "
bad: 					"Unable to copy f/w buffer hunk#%d @ %p\n",
bad: 					iocp->name, __FILE__, __LINE__, n, ufwbuf);
bad: 				goto fwdl_out;
bad: 			}
bad: 			fw_bytes_copied += bl->len;
bad: 		}
bad: 		sgIn++;
bad: 		bl++;
bad: 		sgOut += (sizeof(dma_addr_t) + sizeof(u32));
bad: 	}
bad: 
bad: 	DBG_DUMP_FW_DOWNLOAD(iocp, (u32 *)mf, numfrags);
bad: 
bad: 	/*
bad: 	 * Finally, perform firmware download.
bad: 	 */
bad: 	ReplyMsg = NULL;
bad: 	mpt_put_msg_frame(mptctl_id, iocp, mf);
bad: 
bad: 	/* Now wait for the command to complete */
bad: 	ret = wait_event_timeout(mptctl_wait,
bad: 	     iocp->ioctl->wait_done == 1,
bad: 	     HZ*60);
bad: 
bad: 	if(ret <=0 && (iocp->ioctl->wait_done != 1 )) {
bad: 	/* Now we need to reset the board */
bad: 		mptctl_timeout_expired(iocp->ioctl);
bad: 		ret = -ENODATA;
bad: 		goto fwdl_out;
bad: 	}
bad: 
bad: 	if (sgl)
bad: 		kfree_sgl(sgl, sgl_dma, buflist, iocp);
bad: 
bad: 	ReplyMsg = (pFWDownloadReply_t)iocp->ioctl->ReplyFrame;
bad: 	iocstat = le16_to_cpu(ReplyMsg->IOCStatus) & MPI_IOCSTATUS_MASK;
bad: 	if (iocstat == MPI_IOCSTATUS_SUCCESS) {
bad: 		printk(MYIOC_s_INFO_FMT "F/W update successfull!\n", iocp->name);
bad: 		return 0;
bad: 	} else if (iocstat == MPI_IOCSTATUS_INVALID_FUNCTION) {
bad: 		printk(MYIOC_s_WARN_FMT "Hmmm...  F/W download not supported!?!\n",
bad: 			iocp->name);
bad: 		printk(MYIOC_s_WARN_FMT "(time to go bang on somebodies door)\n",
bad: 			iocp->name);
bad: 		return -EBADRQC;
bad: 	} else if (iocstat == MPI_IOCSTATUS_BUSY) {
bad: 		printk(MYIOC_s_WARN_FMT "IOC_BUSY!\n", iocp->name);
bad: 		printk(MYIOC_s_WARN_FMT "(try again later?)\n", iocp->name);
bad: 		return -EBUSY;
bad: 	} else {
bad: 		printk(MYIOC_s_WARN_FMT "ioctl_fwdl() returned [bad] status = %04xh\n",
bad: 			iocp->name, iocstat);
bad: 		printk(MYIOC_s_WARN_FMT "(bad VooDoo)\n", iocp->name);
bad: 		return -ENOMSG;
bad: 	}
bad: 	return 0;
bad: 
bad: fwdl_out:
bad:         kfree_sgl(sgl, sgl_dma, buflist, iocp);
bad: 	return ret;
bad: }
semantic error two or more data types
 =File "mptctl.c.new", line 1169, column 33,  charpos = 33648
    around = '*', whole content = 	struct mpt_ioctl_iocinfo __user *uarg = (void __user *) arg;
ERROR-RECOV: found sync '}' at line 1307
badcount: 153
bad: }
bad: 
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
bad: /*
bad:  *	mptctl_getiocinfo - Query the host adapter for IOC information.
bad:  *	@arg: User space argument
bad:  *
bad:  * Outputs:	None.
bad:  * Return:	0 if successful
bad:  *		-EFAULT if data unavailable
bad:  *		-ENODEV  if no such device/adapter
bad:  */
bad: static int
bad: mptctl_getiocinfo (unsigned long arg, unsigned int data_size)
bad: {
BAD:!!!!! 	struct mpt_ioctl_iocinfo __user *uarg = (void __user *) arg;
bad: 	struct mpt_ioctl_iocinfo *karg;
bad: 	MPT_ADAPTER		*ioc;
bad: 	struct pci_dev		*pdev;
bad: 	int			iocnum;
bad: 	unsigned int		port;
bad: 	int			cim_rev;
bad: 	u8			revision;
bad: 	struct scsi_device 	*sdev;
bad: 	VirtDevice		*vdevice;
bad: 
bad: 	/* Add of PCI INFO results in unaligned access for
bad: 	 * IA64 and Sparc. Reset long to int. Return no PCI
bad: 	 * data for obsolete format.
bad: 	 */
bad: 	if (data_size == sizeof(struct mpt_ioctl_iocinfo_rev0))
bad: 		cim_rev = 0;
bad: 	else if (data_size == sizeof(struct mpt_ioctl_iocinfo_rev1))
bad: 		cim_rev = 1;
bad: 	else if (data_size == sizeof(struct mpt_ioctl_iocinfo))
bad: 		cim_rev = 2;
bad: 	else if (data_size == (sizeof(struct mpt_ioctl_iocinfo_rev0)+12))
bad: 		cim_rev = 0;	/* obsolete */
bad: 	else
bad: 		return -EFAULT;
bad: 
bad: 	karg = kmalloc(data_size, GFP_KERNEL);
bad: 	if (karg == NULL) {
bad: 		printk(KERN_ERR MYNAM "%s::mpt_ioctl_iocinfo() @%d - no memory available!\n",
bad: 				__FILE__, __LINE__);
bad: 		return -ENOMEM;
bad: 	}
bad: 
bad: 	if (copy_from_user(karg, uarg, data_size)) {
bad: 		printk(KERN_ERR MYNAM "%s@%d::mptctl_getiocinfo - "
bad: 			"Unable to read in mpt_ioctl_iocinfo struct @ %p\n",
bad: 				__FILE__, __LINE__, uarg);
bad: 		kfree(karg);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	if (((iocnum = mpt_verify_adapter(karg->hdr.iocnum, &ioc)) < 0) ||
bad: 	    (ioc == NULL)) {
bad: 		printk(KERN_DEBUG MYNAM "%s::mptctl_getiocinfo() @%d - ioc%d not found!\n",
bad: 				__FILE__, __LINE__, iocnum);
bad: 		kfree(karg);
bad: 		return -ENODEV;
bad: 	}
bad: 
bad: 	/* Verify the data transfer size is correct. */
bad: 	if (karg->hdr.maxDataSize != data_size) {
bad: 		printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_getiocinfo - "
bad: 			"Structure size mismatch. Command not completed.\n",
bad: 			ioc->name, __FILE__, __LINE__);
bad: 		kfree(karg);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "mptctl_getiocinfo called.\n",
bad: 	    ioc->name));
bad: 
bad: 	/* Fill in the data and return the structure to the calling
bad: 	 * program
bad: 	 */
bad: 	if (ioc->bus_type == SAS)
bad: 		karg->adapterType = MPT_IOCTL_INTERFACE_SAS;
bad: 	else if (ioc->bus_type == FC)
bad: 		karg->adapterType = MPT_IOCTL_INTERFACE_FC;
bad: 	else
bad: 		karg->adapterType = MPT_IOCTL_INTERFACE_SCSI;
bad: 
bad: 	if (karg->hdr.port > 1)
bad: 		return -EINVAL;
bad: 	port = karg->hdr.port;
bad: 
bad: 	karg->port = port;
bad: 	pdev = (struct pci_dev *) ioc->pcidev;
bad: 
bad: 	karg->pciId = pdev->device;
bad: 	pci_read_config_byte(pdev, PCI_CLASS_REVISION, &revision);
bad: 	karg->hwRev = revision;
bad: 	karg->subSystemDevice = pdev->subsystem_device;
bad: 	karg->subSystemVendor = pdev->subsystem_vendor;
bad: 
bad: 	if (cim_rev == 1) {
bad: 		/* Get the PCI bus, device, and function numbers for the IOC
bad: 		 */
bad: 		karg->pciInfo.u.bits.busNumber = pdev->bus->number;
bad: 		karg->pciInfo.u.bits.deviceNumber = PCI_SLOT( pdev->devfn );
bad: 		karg->pciInfo.u.bits.functionNumber = PCI_FUNC( pdev->devfn );
bad: 	} else if (cim_rev == 2) {
bad: 		/* Get the PCI bus, device, function and segment ID numbers
bad: 		   for the IOC */
bad: 		karg->pciInfo.u.bits.busNumber = pdev->bus->number;
bad: 		karg->pciInfo.u.bits.deviceNumber = PCI_SLOT( pdev->devfn );
bad: 		karg->pciInfo.u.bits.functionNumber = PCI_FUNC( pdev->devfn );
bad: 		karg->pciInfo.segmentID = pci_domain_nr(pdev->bus);
bad: 	}
bad: 
bad: 	/* Get number of devices
bad:          */
bad: 	karg->numDevices = 0;
bad: 	if (ioc->sh) {
bad: 		shost_for_each_device(sdev, ioc->sh) {
bad: 			vdevice = sdev->hostdata;
bad: 			if (vdevice->vtarget->tflags &
bad: 			    MPT_TARGET_FLAGS_RAID_COMPONENT)
bad: 				continue;
bad: 			karg->numDevices++;
bad: 		}
bad: 	}
bad: 
bad: 	/* Set the BIOS and FW Version
bad: 	 */
bad: 	karg->FWVersion = ioc->facts.FWVersion.Word;
bad: 	karg->BIOSVersion = ioc->biosVersion;
bad: 
bad: 	/* Set the Version Strings.
bad: 	 */
bad: 	strncpy (karg->driverVersion, MPT_LINUX_PACKAGE_NAME, MPT_IOCTL_VERSION_LENGTH);
bad: 	karg->driverVersion[MPT_IOCTL_VERSION_LENGTH-1]='\0';
bad: 
bad: 	karg->busChangeEvent = 0;
bad: 	karg->hostId = ioc->pfacts[port].PortSCSIID;
bad: 	karg->rsvd[0] = karg->rsvd[1] = 0;
bad: 
bad: 	/* Copy the data from kernel memory to user memory
bad: 	 */
bad: 	if (copy_to_user((char __user *)arg, karg, data_size)) {
bad: 		printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_getiocinfo - "
bad: 			"Unable to write out mpt_ioctl_iocinfo struct @ %p\n",
bad: 			ioc->name, __FILE__, __LINE__, uarg);
bad: 		kfree(karg);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	kfree(karg);
bad: 	return 0;
bad: }
semantic error two or more data types
 =File "mptctl.c.new", line 1322, column 36,  charpos = 38025
    around = '*', whole content = 	struct mpt_ioctl_targetinfo __user *uarg = (void __user *) arg;
ERROR-RECOV: found sync '}' at line 1432
badcount: 125
bad: }
bad: 
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
bad: /*
bad:  *	mptctl_gettargetinfo - Query the host adapter for target information.
bad:  *	@arg: User space argument
bad:  *
bad:  * Outputs:	None.
bad:  * Return:	0 if successful
bad:  *		-EFAULT if data unavailable
bad:  *		-ENODEV  if no such device/adapter
bad:  */
bad: static int
bad: mptctl_gettargetinfo (unsigned long arg)
bad: {
BAD:!!!!! 	struct mpt_ioctl_targetinfo __user *uarg = (void __user *) arg;
bad: 	struct mpt_ioctl_targetinfo karg;
bad: 	MPT_ADAPTER		*ioc;
bad: 	VirtDevice		*vdevice;
bad: 	char			*pmem;
bad: 	int			*pdata;
bad: 	int			iocnum;
bad: 	int			numDevices = 0;
bad: 	int			lun;
bad: 	int			maxWordsLeft;
bad: 	int			numBytes;
bad: 	u8			port;
bad: 	struct scsi_device 	*sdev;
bad: 
bad: 	if (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_targetinfo))) {
bad: 		printk(KERN_ERR MYNAM "%s@%d::mptctl_gettargetinfo - "
bad: 			"Unable to read in mpt_ioctl_targetinfo struct @ %p\n",
bad: 				__FILE__, __LINE__, uarg);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
bad: 	    (ioc == NULL)) {
bad: 		printk(KERN_DEBUG MYNAM "%s::mptctl_gettargetinfo() @%d - ioc%d not found!\n",
bad: 				__FILE__, __LINE__, iocnum);
bad: 		return -ENODEV;
bad: 	}
bad: 
bad: 	dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "mptctl_gettargetinfo called.\n",
bad: 	    ioc->name));
bad: 	/* Get the port number and set the maximum number of bytes
bad: 	 * in the returned structure.
bad: 	 * Ignore the port setting.
bad: 	 */
bad: 	numBytes = karg.hdr.maxDataSize - sizeof(mpt_ioctl_header);
bad: 	maxWordsLeft = numBytes/sizeof(int);
bad: 	port = karg.hdr.port;
bad: 
bad: 	if (maxWordsLeft <= 0) {
bad: 		printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_gettargetinfo() - no memory available!\n",
bad: 			ioc->name, __FILE__, __LINE__);
bad: 		return -ENOMEM;
bad: 	}
bad: 
bad: 	/* Fill in the data and return the structure to the calling
bad: 	 * program
bad: 	 */
bad: 
bad: 	/* struct mpt_ioctl_targetinfo does not contain sufficient space
bad: 	 * for the target structures so when the IOCTL is called, there is
bad: 	 * not sufficient stack space for the structure. Allocate memory,
bad: 	 * populate the memory, copy back to the user, then free memory.
bad: 	 * targetInfo format:
bad: 	 * bits 31-24: reserved
bad: 	 *      23-16: LUN
bad: 	 *      15- 8: Bus Number
bad: 	 *       7- 0: Target ID
bad: 	 */
bad: 	pmem = kzalloc(numBytes, GFP_KERNEL);
bad: 	if (!pmem) {
bad: 		printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_gettargetinfo() - no memory available!\n",
bad: 			ioc->name, __FILE__, __LINE__);
bad: 		return -ENOMEM;
bad: 	}
bad: 	pdata =  (int *) pmem;
bad: 
bad: 	/* Get number of devices
bad:          */
bad: 	if (ioc->sh){
bad: 		shost_for_each_device(sdev, ioc->sh) {
bad: 			if (!maxWordsLeft)
bad: 				continue;
bad: 			vdevice = sdev->hostdata;
bad: 			if (vdevice->vtarget->tflags &
bad: 			    MPT_TARGET_FLAGS_RAID_COMPONENT)
bad: 				continue;
bad: 			lun = (vdevice->vtarget->raidVolume) ? 0x80 : vdevice->lun;
bad: 			*pdata = (((u8)lun << 16) + (vdevice->vtarget->channel << 8) +
bad: 			    (vdevice->vtarget->id ));
bad: 			pdata++;
bad: 			numDevices++;
bad: 			--maxWordsLeft;
bad: 		}
bad: 	}
bad: 	karg.numDevices = numDevices;
bad: 
bad: 	/* Copy part of the data from kernel memory to user memory
bad: 	 */
bad: 	if (copy_to_user((char __user *)arg, &karg,
bad: 				sizeof(struct mpt_ioctl_targetinfo))) {
bad: 		printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_gettargetinfo - "
bad: 			"Unable to write out mpt_ioctl_targetinfo struct @ %p\n",
bad: 			ioc->name, __FILE__, __LINE__, uarg);
bad: 		kfree(pmem);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	/* Copy the remaining data from kernel memory to user memory
bad: 	 */
bad: 	if (copy_to_user(uarg->targetInfo, pmem, numBytes)) {
bad: 		printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_gettargetinfo - "
bad: 			"Unable to write out mpt_ioctl_targetinfo struct @ %p\n",
bad: 			ioc->name, __FILE__, __LINE__, pdata);
bad: 		kfree(pmem);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	kfree(pmem);
bad: 
bad: 	return 0;
bad: }
semantic error two or more data types
 =File "mptctl.c.new", line 1445, column 30,  charpos = 41461
    around = '*', whole content = 	struct mpt_ioctl_test __user *uarg = (void __user *) arg;
ERROR-RECOV: found sync '}' at line 1490
badcount: 58
bad: }
bad: 
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
bad: /* MPT IOCTL Test function.
bad:  *
bad:  * Outputs:	None.
bad:  * Return:	0 if successful
bad:  *		-EFAULT if data unavailable
bad:  *		-ENODEV  if no such device/adapter
bad:  */
bad: static int
bad: mptctl_readtest (unsigned long arg)
bad: {
BAD:!!!!! 	struct mpt_ioctl_test __user *uarg = (void __user *) arg;
bad: 	struct mpt_ioctl_test	 karg;
bad: 	MPT_ADAPTER *ioc;
bad: 	int iocnum;
bad: 
bad: 	if (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_test))) {
bad: 		printk(KERN_ERR MYNAM "%s@%d::mptctl_readtest - "
bad: 			"Unable to read in mpt_ioctl_test struct @ %p\n",
bad: 				__FILE__, __LINE__, uarg);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
bad: 	    (ioc == NULL)) {
bad: 		printk(KERN_DEBUG MYNAM "%s::mptctl_readtest() @%d - ioc%d not found!\n",
bad: 				__FILE__, __LINE__, iocnum);
bad: 		return -ENODEV;
bad: 	}
bad: 
bad: 	dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "mptctl_readtest called.\n",
bad: 	    ioc->name));
bad: 	/* Fill in the data and return the structure to the calling
bad: 	 * program
bad: 	 */
bad: 
bad: #ifdef MFCNT
bad: 	karg.chip_type = ioc->mfcnt;
bad: #else
bad: 	karg.chip_type = ioc->pcidev->device;
bad: #endif
bad: 	strncpy (karg.name, ioc->name, MPT_MAX_NAME);
bad: 	karg.name[MPT_MAX_NAME-1]='\0';
bad: 	strncpy (karg.product, ioc->prod_name, MPT_PRODUCT_LENGTH);
bad: 	karg.product[MPT_PRODUCT_LENGTH-1]='\0';
bad: 
bad: 	/* Copy the data from kernel memory to user memory
bad: 	 */
bad: 	if (copy_to_user((char __user *)arg, &karg, sizeof(struct mpt_ioctl_test))) {
bad: 		printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_readtest - "
bad: 			"Unable to write out mpt_ioctl_test struct @ %p\n",
bad: 			ioc->name, __FILE__, __LINE__, uarg);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	return 0;
bad: }
semantic error two or more data types
 =File "mptctl.c.new", line 1506, column 36,  charpos = 43180
    around = '*', whole content = 	struct mpt_ioctl_eventquery __user *uarg = (void __user *) arg;
ERROR-RECOV: found sync '}' at line 1539
badcount: 49
bad: }
bad: 
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
bad: /*
bad:  *	mptctl_eventquery - Query the host adapter for the event types
bad:  *	that are being logged.
bad:  *	@arg: User space argument
bad:  *
bad:  * Outputs:	None.
bad:  * Return:	0 if successful
bad:  *		-EFAULT if data unavailable
bad:  *		-ENODEV  if no such device/adapter
bad:  */
bad: static int
bad: mptctl_eventquery (unsigned long arg)
bad: {
BAD:!!!!! 	struct mpt_ioctl_eventquery __user *uarg = (void __user *) arg;
bad: 	struct mpt_ioctl_eventquery	 karg;
bad: 	MPT_ADAPTER *ioc;
bad: 	int iocnum;
bad: 
bad: 	if (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventquery))) {
bad: 		printk(KERN_ERR MYNAM "%s@%d::mptctl_eventquery - "
bad: 			"Unable to read in mpt_ioctl_eventquery struct @ %p\n",
bad: 				__FILE__, __LINE__, uarg);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
bad: 	    (ioc == NULL)) {
bad: 		printk(KERN_DEBUG MYNAM "%s::mptctl_eventquery() @%d - ioc%d not found!\n",
bad: 				__FILE__, __LINE__, iocnum);
bad: 		return -ENODEV;
bad: 	}
bad: 
bad: 	dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "mptctl_eventquery called.\n",
bad: 	    ioc->name));
bad: 	karg.eventEntries = MPTCTL_EVENT_LOG_SIZE;
bad: 	karg.eventTypes = ioc->eventTypes;
bad: 
bad: 	/* Copy the data from kernel memory to user memory
bad: 	 */
bad: 	if (copy_to_user((char __user *)arg, &karg, sizeof(struct mpt_ioctl_eventquery))) {
bad: 		printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_eventquery - "
bad: 			"Unable to write out mpt_ioctl_eventquery struct @ %p\n",
bad: 			ioc->name, __FILE__, __LINE__, uarg);
bad: 		return -EFAULT;
bad: 	}
bad: 	return 0;
bad: }
semantic error two or more data types
 =File "mptctl.c.new", line 1545, column 37,  charpos = 44414
    around = '*', whole content = 	struct mpt_ioctl_eventenable __user *uarg = (void __user *) arg;
ERROR-RECOV: found sync '}' at line 1587
badcount: 48
bad: }
bad: 
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
bad: static int
bad: mptctl_eventenable (unsigned long arg)
bad: {
BAD:!!!!! 	struct mpt_ioctl_eventenable __user *uarg = (void __user *) arg;
bad: 	struct mpt_ioctl_eventenable	 karg;
bad: 	MPT_ADAPTER *ioc;
bad: 	int iocnum;
bad: 
bad: 	if (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventenable))) {
bad: 		printk(KERN_ERR MYNAM "%s@%d::mptctl_eventenable - "
bad: 			"Unable to read in mpt_ioctl_eventenable struct @ %p\n",
bad: 				__FILE__, __LINE__, uarg);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
bad: 	    (ioc == NULL)) {
bad: 		printk(KERN_DEBUG MYNAM "%s::mptctl_eventenable() @%d - ioc%d not found!\n",
bad: 				__FILE__, __LINE__, iocnum);
bad: 		return -ENODEV;
bad: 	}
bad: 
bad: 	dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "mptctl_eventenable called.\n",
bad: 	    ioc->name));
bad: 	if (ioc->events == NULL) {
bad: 		/* Have not yet allocated memory - do so now.
bad: 		 */
bad: 		int sz = MPTCTL_EVENT_LOG_SIZE * sizeof(MPT_IOCTL_EVENTS);
bad: 		ioc->events = kzalloc(sz, GFP_KERNEL);
bad: 		if (!ioc->events) {
bad: 			printk(MYIOC_s_ERR_FMT
bad: 			    ": ERROR - Insufficient memory to add adapter!\n",
bad: 			    ioc->name);
bad: 			return -ENOMEM;
bad: 		}
bad: 		ioc->alloc_total += sz;
bad: 
bad: 		ioc->eventContext = 0;
bad:         }
bad: 
bad: 	/* Update the IOC event logging flag.
bad: 	 */
bad: 	ioc->eventTypes = karg.eventTypes;
bad: 
bad: 	return 0;
bad: }
semantic error two or more data types
 =File "mptctl.c.new", line 1593, column 37,  charpos = 45729
    around = '*', whole content = 	struct mpt_ioctl_eventreport __user *uarg = (void __user *) arg;
ERROR-RECOV: found sync '}' at line 1641
badcount: 54
bad: }
bad: 
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
bad: static int
bad: mptctl_eventreport (unsigned long arg)
bad: {
BAD:!!!!! 	struct mpt_ioctl_eventreport __user *uarg = (void __user *) arg;
bad: 	struct mpt_ioctl_eventreport	 karg;
bad: 	MPT_ADAPTER		 *ioc;
bad: 	int			 iocnum;
bad: 	int			 numBytes, maxEvents, max;
bad: 
bad: 	if (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventreport))) {
bad: 		printk(KERN_ERR MYNAM "%s@%d::mptctl_eventreport - "
bad: 			"Unable to read in mpt_ioctl_eventreport struct @ %p\n",
bad: 				__FILE__, __LINE__, uarg);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
bad: 	    (ioc == NULL)) {
bad: 		printk(KERN_DEBUG MYNAM "%s::mptctl_eventreport() @%d - ioc%d not found!\n",
bad: 				__FILE__, __LINE__, iocnum);
bad: 		return -ENODEV;
bad: 	}
bad: 	dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "mptctl_eventreport called.\n",
bad: 	    ioc->name));
bad: 
bad: 	numBytes = karg.hdr.maxDataSize - sizeof(mpt_ioctl_header);
bad: 	maxEvents = numBytes/sizeof(MPT_IOCTL_EVENTS);
bad: 
bad: 
bad: 	max = MPTCTL_EVENT_LOG_SIZE < maxEvents ? MPTCTL_EVENT_LOG_SIZE : maxEvents;
bad: 
bad: 	/* If fewer than 1 event is requested, there must have
bad: 	 * been some type of error.
bad: 	 */
bad: 	if ((max < 1) || !ioc->events)
bad: 		return -ENODATA;
bad: 
bad: 	/* reset this flag so SIGIO can restart */
bad: 	ioc->aen_event_read_flag=0;
bad: 
bad: 	/* Copy the data from kernel memory to user memory
bad: 	 */
bad: 	numBytes = max * sizeof(MPT_IOCTL_EVENTS);
bad: 	if (copy_to_user(uarg->eventData, ioc->events, numBytes)) {
bad: 		printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_eventreport - "
bad: 			"Unable to write out mpt_ioctl_eventreport struct @ %p\n",
bad: 			ioc->name, __FILE__, __LINE__, ioc->events);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	return 0;
bad: }
semantic error two or more data types
 =File "mptctl.c.new", line 1647, column 36,  charpos = 47361
    around = '*', whole content = 	struct mpt_ioctl_replace_fw __user *uarg = (void __user *) arg;
ERROR-RECOV: found sync '}' at line 1703
badcount: 62
bad: }
bad: 
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
bad: static int
bad: mptctl_replace_fw (unsigned long arg)
bad: {
BAD:!!!!! 	struct mpt_ioctl_replace_fw __user *uarg = (void __user *) arg;
bad: 	struct mpt_ioctl_replace_fw	 karg;
bad: 	MPT_ADAPTER		 *ioc;
bad: 	int			 iocnum;
bad: 	int			 newFwSize;
bad: 
bad: 	if (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_replace_fw))) {
bad: 		printk(KERN_ERR MYNAM "%s@%d::mptctl_replace_fw - "
bad: 			"Unable to read in mpt_ioctl_replace_fw struct @ %p\n",
bad: 				__FILE__, __LINE__, uarg);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
bad: 	    (ioc == NULL)) {
bad: 		printk(KERN_DEBUG MYNAM "%s::mptctl_replace_fw() @%d - ioc%d not found!\n",
bad: 				__FILE__, __LINE__, iocnum);
bad: 		return -ENODEV;
bad: 	}
bad: 
bad: 	dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "mptctl_replace_fw called.\n",
bad: 	    ioc->name));
bad: 	/* If caching FW, Free the old FW image
bad: 	 */
bad: 	if (ioc->cached_fw == NULL)
bad: 		return 0;
bad: 
bad: 	mpt_free_fw_memory(ioc);
bad: 
bad: 	/* Allocate memory for the new FW image
bad: 	 */
bad: 	newFwSize = karg.newImageSize;
bad: 
bad: 	if (newFwSize & 0x01)
bad: 		newFwSize += 1;
bad: 	if (newFwSize & 0x02)
bad: 		newFwSize += 2;
bad: 
bad: 	mpt_alloc_fw_memory(ioc, newFwSize);
bad: 	if (ioc->cached_fw == NULL)
bad: 		return -ENOMEM;
bad: 
bad: 	/* Copy the data from user memory to kernel space
bad: 	 */
bad: 	if (copy_from_user(ioc->cached_fw, uarg->newImage, newFwSize)) {
bad: 		printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_replace_fw - "
bad: 				"Unable to read in mpt_ioctl_replace_fw image "
bad: 				"@ %p\n", ioc->name, __FILE__, __LINE__, uarg);
bad: 		mpt_free_fw_memory(ioc);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	/* Update IOCFactsReply
bad: 	 */
bad: 	ioc->facts.FWImageSize = newFwSize;
bad: 	return 0;
bad: }
semantic error two or more data types
 =File "mptctl.c.new", line 1720, column 33,  charpos = 49325
    around = '*', whole content = 	struct mpt_ioctl_command __user *uarg = (void __user *) arg;
ERROR-RECOV: found sync '}' at line 1744
badcount: 41
bad: }
bad: 
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
bad: /* MPT IOCTL MPTCOMMAND function.
bad:  * Cast the arg into the mpt_ioctl_mpt_command structure.
bad:  *
bad:  * Outputs:	None.
bad:  * Return:	0 if successful
bad:  *		-EBUSY  if previous command timout and IOC reset is not complete.
bad:  *		-EFAULT if data unavailable
bad:  *		-ENODEV if no such device/adapter
bad:  *		-ETIME	if timer expires
bad:  *		-ENOMEM if memory allocation error
bad:  */
bad: static int
bad: mptctl_mpt_command (unsigned long arg)
bad: {
BAD:!!!!! 	struct mpt_ioctl_command __user *uarg = (void __user *) arg;
bad: 	struct mpt_ioctl_command  karg;
bad: 	MPT_ADAPTER	*ioc;
bad: 	int		iocnum;
bad: 	int		rc;
bad: 
bad: 
bad: 	if (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_command))) {
bad: 		printk(KERN_ERR MYNAM "%s@%d::mptctl_mpt_command - "
bad: 			"Unable to read in mpt_ioctl_command struct @ %p\n",
bad: 				__FILE__, __LINE__, uarg);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
bad: 	    (ioc == NULL)) {
bad: 		printk(KERN_DEBUG MYNAM "%s::mptctl_mpt_command() @%d - ioc%d not found!\n",
bad: 				__FILE__, __LINE__, iocnum);
bad: 		return -ENODEV;
bad: 	}
bad: 
bad: 	rc = mptctl_do_mpt_command (karg, &uarg->MF);
bad: 
bad: 	return rc;
bad: }
semantic error two or more data types
 =File "mptctl.c.new", line 1759, column 66,  charpos = 50492
    around = '*', whole content = mptctl_do_mpt_command (struct mpt_ioctl_command karg, void __user *mfPtr)
ERROR-RECOV: found sync '}' at line 2313
badcount: 569
bad: }
bad: 
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
bad: /* Worker routine for the IOCTL MPTCOMMAND and MPTCOMMAND32 (sparc) commands.
bad:  *
bad:  * Outputs:	None.
bad:  * Return:	0 if successful
bad:  *		-EBUSY  if previous command timout and IOC reset is not complete.
bad:  *		-EFAULT if data unavailable
bad:  *		-ENODEV if no such device/adapter
bad:  *		-ETIME	if timer expires
bad:  *		-ENOMEM if memory allocation error
bad:  *		-EPERM if SCSI I/O and target is untagged
bad:  */
bad: static int
BAD:!!!!! mptctl_do_mpt_command (struct mpt_ioctl_command karg, void __user *mfPtr)
bad: {
bad: 	MPT_ADAPTER	*ioc;
bad: 	MPT_FRAME_HDR	*mf = NULL;
bad: 	MPIHeader_t	*hdr;
bad: 	char		*psge;
bad: 	struct buflist	bufIn;	/* data In buffer */
bad: 	struct buflist	bufOut; /* data Out buffer */
bad: 	dma_addr_t	dma_addr_in;
bad: 	dma_addr_t	dma_addr_out;
bad: 	int		sgSize = 0;	/* Num SG elements */
bad: 	int		iocnum, flagsLength;
bad: 	int		sz, rc = 0;
bad: 	int		msgContext;
bad: 	u16		req_idx;
bad: 	ulong 		timeout;
bad: 	struct scsi_device *sdev;
bad: 
bad: 	bufIn.kptr = bufOut.kptr = NULL;
bad: 
bad: 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
bad: 	    (ioc == NULL)) {
bad: 		printk(KERN_DEBUG MYNAM "%s::mptctl_do_mpt_command() @%d - ioc%d not found!\n",
bad: 				__FILE__, __LINE__, iocnum);
bad: 		return -ENODEV;
bad: 	}
bad: 	if (!ioc->ioctl) {
bad: 		printk(KERN_ERR MYNAM "%s@%d::mptctl_do_mpt_command - "
bad: 			"No memory available during driver init.\n",
bad: 				__FILE__, __LINE__);
bad: 		return -ENOMEM;
bad: 	} else if (ioc->ioctl->status & MPT_IOCTL_STATUS_DID_IOCRESET) {
bad: 		printk(KERN_ERR MYNAM "%s@%d::mptctl_do_mpt_command - "
bad: 			"Busy with IOC Reset \n", __FILE__, __LINE__);
bad: 		return -EBUSY;
bad: 	}
bad: 
bad: 	/* Verify that the final request frame will not be too large.
bad: 	 */
bad: 	sz = karg.dataSgeOffset * 4;
bad: 	if (karg.dataInSize > 0)
bad: 		sz += sizeof(dma_addr_t) + sizeof(u32);
bad: 	if (karg.dataOutSize > 0)
bad: 		sz += sizeof(dma_addr_t) + sizeof(u32);
bad: 
bad: 	if (sz > ioc->req_sz) {
bad: 		printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_do_mpt_command - "
bad: 			"Request frame too large (%d) maximum (%d)\n",
bad: 			ioc->name, __FILE__, __LINE__, sz, ioc->req_sz);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	/* Get a free request frame and save the message context.
bad: 	 */
bad:         if ((mf = mpt_get_msg_frame(mptctl_id, ioc)) == NULL)
bad:                 return -EAGAIN;
bad: 
bad: 	hdr = (MPIHeader_t *) mf;
bad: 	msgContext = le32_to_cpu(hdr->MsgContext);
bad: 	req_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);
bad: 
bad: 	/* Copy the request frame
bad: 	 * Reset the saved message context.
bad: 	 * Request frame in user space
bad: 	 */
bad: 	if (copy_from_user(mf, mfPtr, karg.dataSgeOffset * 4)) {
bad: 		printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_do_mpt_command - "
bad: 			"Unable to read MF from mpt_ioctl_command struct @ %p\n",
bad: 			ioc->name, __FILE__, __LINE__, mfPtr);
bad: 		rc = -EFAULT;
bad: 		goto done_free_mem;
bad: 	}
bad: 	hdr->MsgContext = cpu_to_le32(msgContext);
bad: 
bad: 
bad: 	/* Verify that this request is allowed.
bad: 	 */
bad: 	dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "sending mpi function (0x%02X), req=%p\n",
bad: 	    ioc->name, hdr->Function, mf));
bad: 
bad: 	switch (hdr->Function) {
bad: 	case MPI_FUNCTION_IOC_FACTS:
bad: 	case MPI_FUNCTION_PORT_FACTS:
bad: 		karg.dataOutSize  = karg.dataInSize = 0;
bad: 		break;
bad: 
bad: 	case MPI_FUNCTION_CONFIG:
bad: 	{
bad: 		Config_t *config_frame;
bad: 		config_frame = (Config_t *)mf;
bad: 		dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "\ttype=0x%02x ext_type=0x%02x "
bad: 		    "number=0x%02x action=0x%02x\n", ioc->name,
bad: 		    config_frame->Header.PageType,
bad: 		    config_frame->ExtPageType,
bad: 		    config_frame->Header.PageNumber,
bad: 		    config_frame->Action));
bad: 		break;
bad: 	}
bad: 
bad: 	case MPI_FUNCTION_FC_COMMON_TRANSPORT_SEND:
bad: 	case MPI_FUNCTION_FC_EX_LINK_SRVC_SEND:
bad: 	case MPI_FUNCTION_FW_UPLOAD:
bad: 	case MPI_FUNCTION_SCSI_ENCLOSURE_PROCESSOR:
bad: 	case MPI_FUNCTION_FW_DOWNLOAD:
bad: 	case MPI_FUNCTION_FC_PRIMITIVE_SEND:
bad: 	case MPI_FUNCTION_TOOLBOX:
bad: 	case MPI_FUNCTION_SAS_IO_UNIT_CONTROL:
bad: 		break;
bad: 
bad: 	case MPI_FUNCTION_SCSI_IO_REQUEST:
bad: 		if (ioc->sh) {
bad: 			SCSIIORequest_t *pScsiReq = (SCSIIORequest_t *) mf;
bad: 			int qtag = MPI_SCSIIO_CONTROL_UNTAGGED;
bad: 			int scsidir = 0;
bad: 			int dataSize;
bad: 			u32 id;
bad: 
bad: 			id = (ioc->devices_per_bus == 0) ? 256 : ioc->devices_per_bus;
bad: 			if (pScsiReq->TargetID > id) {
bad: 				printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_do_mpt_command - "
bad: 					"Target ID out of bounds. \n",
bad: 					ioc->name, __FILE__, __LINE__);
bad: 				rc = -ENODEV;
bad: 				goto done_free_mem;
bad: 			}
bad: 
bad: 			if (pScsiReq->Bus >= ioc->number_of_buses) {
bad: 				printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_do_mpt_command - "
bad: 					"Target Bus out of bounds. \n",
bad: 					ioc->name, __FILE__, __LINE__);
bad: 				rc = -ENODEV;
bad: 				goto done_free_mem;
bad: 			}
bad: 
bad: 			pScsiReq->MsgFlags &= ~MPI_SCSIIO_MSGFLGS_SENSE_WIDTH;
bad: 			pScsiReq->MsgFlags |= mpt_msg_flags();
bad: 
bad: 
bad: 			/* verify that app has not requested
bad: 			 *	more sense data than driver
bad: 			 *	can provide, if so, reset this parameter
bad: 			 * set the sense buffer pointer low address
bad: 			 * update the control field to specify Q type
bad: 			 */
bad: 			if (karg.maxSenseBytes > MPT_SENSE_BUFFER_SIZE)
bad: 				pScsiReq->SenseBufferLength = MPT_SENSE_BUFFER_SIZE;
bad: 			else
bad: 				pScsiReq->SenseBufferLength = karg.maxSenseBytes;
bad: 
bad: 			pScsiReq->SenseBufferLowAddr =
bad: 				cpu_to_le32(ioc->sense_buf_low_dma
bad: 				   + (req_idx * MPT_SENSE_BUFFER_ALLOC));
bad: 
bad: 			shost_for_each_device(sdev, ioc->sh) {
bad: 				struct scsi_target *starget = scsi_target(sdev);
bad: 				VirtTarget *vtarget = starget->hostdata;
bad: 
bad: 				if ((pScsiReq->TargetID == vtarget->id) &&
bad: 				    (pScsiReq->Bus == vtarget->channel) &&
bad: 				    (vtarget->tflags & MPT_TARGET_FLAGS_Q_YES))
bad: 					qtag = MPI_SCSIIO_CONTROL_SIMPLEQ;
bad: 			}
bad: 
bad: 			/* Have the IOCTL driver set the direction based
bad: 			 * on the dataOutSize (ordering issue with Sparc).
bad: 			 */
bad: 			if (karg.dataOutSize > 0) {
bad: 				scsidir = MPI_SCSIIO_CONTROL_WRITE;
bad: 				dataSize = karg.dataOutSize;
bad: 			} else {
bad: 				scsidir = MPI_SCSIIO_CONTROL_READ;
bad: 				dataSize = karg.dataInSize;
bad: 			}
bad: 
bad: 			pScsiReq->Control = cpu_to_le32(scsidir | qtag);
bad: 			pScsiReq->DataLength = cpu_to_le32(dataSize);
bad: 
bad: 			ioc->ioctl->reset = MPTCTL_RESET_OK;
bad: 			ioc->ioctl->id = pScsiReq->TargetID;
bad: 
bad: 		} else {
bad: 			printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_do_mpt_command - "
bad: 				"SCSI driver is not loaded. \n",
bad: 				ioc->name, __FILE__, __LINE__);
bad: 			rc = -EFAULT;
bad: 			goto done_free_mem;
bad: 		}
bad: 		break;
bad: 
bad: 	case MPI_FUNCTION_SMP_PASSTHROUGH:
bad: 		/* Check mf->PassthruFlags to determine if
bad: 		 * transfer is ImmediateMode or not.
bad: 		 * Immediate mode returns data in the ReplyFrame.
bad: 		 * Else, we are sending request and response data
bad: 		 * in two SGLs at the end of the mf.
bad: 		 */
bad: 		break;
bad: 
bad: 	case MPI_FUNCTION_SATA_PASSTHROUGH:
bad: 		if (!ioc->sh) {
bad: 			printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_do_mpt_command - "
bad: 				"SCSI driver is not loaded. \n",
bad: 				ioc->name, __FILE__, __LINE__);
bad: 			rc = -EFAULT;
bad: 			goto done_free_mem;
bad: 		}
bad: 		break;
bad: 
bad: 	case MPI_FUNCTION_RAID_ACTION:
bad: 		/* Just add a SGE
bad: 		 */
bad: 		break;
bad: 
bad: 	case MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH:
bad: 		if (ioc->sh) {
bad: 			SCSIIORequest_t *pScsiReq = (SCSIIORequest_t *) mf;
bad: 			int qtag = MPI_SCSIIO_CONTROL_SIMPLEQ;
bad: 			int scsidir = MPI_SCSIIO_CONTROL_READ;
bad: 			int dataSize;
bad: 
bad: 			pScsiReq->MsgFlags &= ~MPI_SCSIIO_MSGFLGS_SENSE_WIDTH;
bad: 			pScsiReq->MsgFlags |= mpt_msg_flags();
bad: 
bad: 
bad: 			/* verify that app has not requested
bad: 			 *	more sense data than driver
bad: 			 *	can provide, if so, reset this parameter
bad: 			 * set the sense buffer pointer low address
bad: 			 * update the control field to specify Q type
bad: 			 */
bad: 			if (karg.maxSenseBytes > MPT_SENSE_BUFFER_SIZE)
bad: 				pScsiReq->SenseBufferLength = MPT_SENSE_BUFFER_SIZE;
bad: 			else
bad: 				pScsiReq->SenseBufferLength = karg.maxSenseBytes;
bad: 
bad: 			pScsiReq->SenseBufferLowAddr =
bad: 				cpu_to_le32(ioc->sense_buf_low_dma
bad: 				   + (req_idx * MPT_SENSE_BUFFER_ALLOC));
bad: 
bad: 			/* All commands to physical devices are tagged
bad: 			 */
bad: 
bad: 			/* Have the IOCTL driver set the direction based
bad: 			 * on the dataOutSize (ordering issue with Sparc).
bad: 			 */
bad: 			if (karg.dataOutSize > 0) {
bad: 				scsidir = MPI_SCSIIO_CONTROL_WRITE;
bad: 				dataSize = karg.dataOutSize;
bad: 			} else {
bad: 				scsidir = MPI_SCSIIO_CONTROL_READ;
bad: 				dataSize = karg.dataInSize;
bad: 			}
bad: 
bad: 			pScsiReq->Control = cpu_to_le32(scsidir | qtag);
bad: 			pScsiReq->DataLength = cpu_to_le32(dataSize);
bad: 
bad: 			ioc->ioctl->reset = MPTCTL_RESET_OK;
bad: 			ioc->ioctl->id = pScsiReq->TargetID;
bad: 		} else {
bad: 			printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_do_mpt_command - "
bad: 				"SCSI driver is not loaded. \n",
bad: 				ioc->name, __FILE__, __LINE__);
bad: 			rc = -EFAULT;
bad: 			goto done_free_mem;
bad: 		}
bad: 		break;
bad: 
bad: 	case MPI_FUNCTION_SCSI_TASK_MGMT:
bad: 		{
bad: 			MPT_SCSI_HOST *hd = NULL;
bad: 			if ((ioc->sh == NULL) || ((hd = shost_priv(ioc->sh)) == NULL)) {
bad: 				printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_do_mpt_command - "
bad: 					"SCSI driver not loaded or SCSI host not found. \n",
bad: 					ioc->name, __FILE__, __LINE__);
bad: 				rc = -EFAULT;
bad: 				goto done_free_mem;
bad: 			} else if (mptctl_set_tm_flags(hd) != 0) {
bad: 				rc = -EPERM;
bad: 				goto done_free_mem;
bad: 			}
bad: 		}
bad: 		break;
bad: 
bad: 	case MPI_FUNCTION_IOC_INIT:
bad: 		{
bad: 			IOCInit_t	*pInit = (IOCInit_t *) mf;
bad: 			u32		high_addr, sense_high;
bad: 
bad: 			/* Verify that all entries in the IOC INIT match
bad: 			 * existing setup (and in LE format).
bad: 			 */
bad: 			if (sizeof(dma_addr_t) == sizeof(u64)) {
bad: 				high_addr = cpu_to_le32((u32)((u64)ioc->req_frames_dma >> 32));
bad: 				sense_high= cpu_to_le32((u32)((u64)ioc->sense_buf_pool_dma >> 32));
bad: 			} else {
bad: 				high_addr = 0;
bad: 				sense_high= 0;
bad: 			}
bad: 
bad: 			if ((pInit->Flags != 0) || (pInit->MaxDevices != ioc->facts.MaxDevices) ||
bad: 				(pInit->MaxBuses != ioc->facts.MaxBuses) ||
bad: 				(pInit->ReplyFrameSize != cpu_to_le16(ioc->reply_sz)) ||
bad: 				(pInit->HostMfaHighAddr != high_addr) ||
bad: 				(pInit->SenseBufferHighAddr != sense_high)) {
bad: 				printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_do_mpt_command - "
bad: 					"IOC_INIT issued with 1 or more incorrect parameters. Rejected.\n",
bad: 					ioc->name, __FILE__, __LINE__);
bad: 				rc = -EFAULT;
bad: 				goto done_free_mem;
bad: 			}
bad: 		}
bad: 		break;
bad: 	default:
bad: 		/*
bad: 		 * MPI_FUNCTION_PORT_ENABLE
bad: 		 * MPI_FUNCTION_TARGET_CMD_BUFFER_POST
bad: 		 * MPI_FUNCTION_TARGET_ASSIST
bad: 		 * MPI_FUNCTION_TARGET_STATUS_SEND
bad: 		 * MPI_FUNCTION_TARGET_MODE_ABORT
bad: 		 * MPI_FUNCTION_IOC_MESSAGE_UNIT_RESET
bad: 		 * MPI_FUNCTION_IO_UNIT_RESET
bad: 		 * MPI_FUNCTION_HANDSHAKE
bad: 		 * MPI_FUNCTION_REPLY_FRAME_REMOVAL
bad: 		 * MPI_FUNCTION_EVENT_NOTIFICATION
bad: 		 *  (driver handles event notification)
bad: 		 * MPI_FUNCTION_EVENT_ACK
bad: 		 */
bad: 
bad: 		/*  What to do with these???  CHECK ME!!!
bad: 			MPI_FUNCTION_FC_LINK_SRVC_BUF_POST
bad: 			MPI_FUNCTION_FC_LINK_SRVC_RSP
bad: 			MPI_FUNCTION_FC_ABORT
bad: 			MPI_FUNCTION_LAN_SEND
bad: 			MPI_FUNCTION_LAN_RECEIVE
bad: 		 	MPI_FUNCTION_LAN_RESET
bad: 		*/
bad: 
bad: 		printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_do_mpt_command - "
bad: 			"Illegal request (function 0x%x) \n",
bad: 			ioc->name, __FILE__, __LINE__, hdr->Function);
bad: 		rc = -EFAULT;
bad: 		goto done_free_mem;
bad: 	}
bad: 
bad: 	/* Add the SGL ( at most one data in SGE and one data out SGE )
bad: 	 * In the case of two SGE's - the data out (write) will always
bad: 	 * preceede the data in (read) SGE. psgList is used to free the
bad: 	 * allocated memory.
bad: 	 */
bad: 	psge = (char *) (((int *) mf) + karg.dataSgeOffset);
bad: 	flagsLength = 0;
bad: 
bad: 	/* bufIn and bufOut are used for user to kernel space transfers
bad: 	 */
bad: 	bufIn.kptr = bufOut.kptr = NULL;
bad: 	bufIn.len = bufOut.len = 0;
bad: 
bad: 	if (karg.dataOutSize > 0)
bad: 		sgSize ++;
bad: 
bad: 	if (karg.dataInSize > 0)
bad: 		sgSize ++;
bad: 
bad: 	if (sgSize > 0) {
bad: 
bad: 		/* Set up the dataOut memory allocation */
bad: 		if (karg.dataOutSize > 0) {
bad: 			if (karg.dataInSize > 0) {
bad: 				flagsLength = ( MPI_SGE_FLAGS_SIMPLE_ELEMENT |
bad: 						MPI_SGE_FLAGS_END_OF_BUFFER |
bad: 						MPI_SGE_FLAGS_DIRECTION |
bad: 						mpt_addr_size() )
bad: 						<< MPI_SGE_FLAGS_SHIFT;
bad: 			} else {
bad: 				flagsLength = MPT_SGE_FLAGS_SSIMPLE_WRITE;
bad: 			}
bad: 			flagsLength |= karg.dataOutSize;
bad: 			bufOut.len = karg.dataOutSize;
bad: 			bufOut.kptr = pci_alloc_consistent(
bad: 					ioc->pcidev, bufOut.len, &dma_addr_out);
bad: 
bad: 			if (bufOut.kptr == NULL) {
bad: 				rc = -ENOMEM;
bad: 				goto done_free_mem;
bad: 			} else {
bad: 				/* Set up this SGE.
bad: 				 * Copy to MF and to sglbuf
bad: 				 */
bad: 				mpt_add_sge(psge, flagsLength, dma_addr_out);
bad: 				psge += (sizeof(u32) + sizeof(dma_addr_t));
bad: 
bad: 				/* Copy user data to kernel space.
bad: 				 */
bad: 				if (copy_from_user(bufOut.kptr,
bad: 						karg.dataOutBufPtr,
bad: 						bufOut.len)) {
bad: 					printk(MYIOC_s_ERR_FMT
bad: 						"%s@%d::mptctl_do_mpt_command - Unable "
bad: 						"to read user data "
bad: 						"struct @ %p\n",
bad: 						ioc->name, __FILE__, __LINE__,karg.dataOutBufPtr);
bad: 					rc =  -EFAULT;
bad: 					goto done_free_mem;
bad: 				}
bad: 			}
bad: 		}
bad: 
bad: 		if (karg.dataInSize > 0) {
bad: 			flagsLength = MPT_SGE_FLAGS_SSIMPLE_READ;
bad: 			flagsLength |= karg.dataInSize;
bad: 
bad: 			bufIn.len = karg.dataInSize;
bad: 			bufIn.kptr = pci_alloc_consistent(ioc->pcidev,
bad: 					bufIn.len, &dma_addr_in);
bad: 
bad: 			if (bufIn.kptr == NULL) {
bad: 				rc = -ENOMEM;
bad: 				goto done_free_mem;
bad: 			} else {
bad: 				/* Set up this SGE
bad: 				 * Copy to MF and to sglbuf
bad: 				 */
bad: 				mpt_add_sge(psge, flagsLength, dma_addr_in);
bad: 			}
bad: 		}
bad: 	} else  {
bad: 		/* Add a NULL SGE
bad: 		 */
bad: 		mpt_add_sge(psge, flagsLength, (dma_addr_t) -1);
bad: 	}
bad: 
bad: 	ioc->ioctl->wait_done = 0;
bad: 	if (hdr->Function == MPI_FUNCTION_SCSI_TASK_MGMT) {
bad: 
bad: 		DBG_DUMP_TM_REQUEST_FRAME(ioc, (u32 *)mf);
bad: 
bad: 		if ((ioc->facts.IOCCapabilities & MPI_IOCFACTS_CAPABILITY_HIGH_PRI_Q) &&
bad: 		    (ioc->facts.MsgVersion >= MPI_VERSION_01_05))
bad: 			mpt_put_msg_frame_hi_pri(mptctl_id, ioc, mf);
bad: 		else {
bad: 			rc =mpt_send_handshake_request(mptctl_id, ioc,
bad: 				sizeof(SCSITaskMgmt_t), (u32*)mf, CAN_SLEEP);
bad: 			if (rc != 0) {
bad: 				dfailprintk(ioc, printk(MYIOC_s_ERR_FMT
bad: 				    "_send_handshake FAILED! (ioc %p, mf %p)\n",
bad: 				    ioc->name, ioc, mf));
bad: 				mptctl_free_tm_flags(ioc);
bad: 				rc = -ENODATA;
bad: 				goto done_free_mem;
bad: 			}
bad: 		}
bad: 
bad: 	} else
bad: 		mpt_put_msg_frame(mptctl_id, ioc, mf);
bad: 
bad: 	/* Now wait for the command to complete */
bad: 	timeout = (karg.timeout > 0) ? karg.timeout : MPT_IOCTL_DEFAULT_TIMEOUT;
bad: 	timeout = wait_event_timeout(mptctl_wait,
bad: 	     ioc->ioctl->wait_done == 1,
bad: 	     HZ*timeout);
bad: 
bad: 	if(timeout <=0 && (ioc->ioctl->wait_done != 1 )) {
bad: 	/* Now we need to reset the board */
bad: 
bad: 		if (hdr->Function == MPI_FUNCTION_SCSI_TASK_MGMT)
bad: 			mptctl_free_tm_flags(ioc);
bad: 
bad: 		mptctl_timeout_expired(ioc->ioctl);
bad: 		rc = -ENODATA;
bad: 		goto done_free_mem;
bad: 	}
bad: 
bad: 	mf = NULL;
bad: 
bad: 	/* If a valid reply frame, copy to the user.
bad: 	 * Offset 2: reply length in U32's
bad: 	 */
bad: 	if (ioc->ioctl->status & MPT_IOCTL_STATUS_RF_VALID) {
bad: 		if (karg.maxReplyBytes < ioc->reply_sz) {
bad: 			 sz = min(karg.maxReplyBytes, 4*ioc->ioctl->ReplyFrame[2]);
bad: 		} else {
bad: 			 sz = min(ioc->reply_sz, 4*ioc->ioctl->ReplyFrame[2]);
bad: 		}
bad: 
bad: 		if (sz > 0) {
bad: 			if (copy_to_user(karg.replyFrameBufPtr,
bad: 				 &ioc->ioctl->ReplyFrame, sz)){
bad: 				 printk(MYIOC_s_ERR_FMT
bad: 				     "%s@%d::mptctl_do_mpt_command - "
bad: 				 "Unable to write out reply frame %p\n",
bad: 				 ioc->name, __FILE__, __LINE__, karg.replyFrameBufPtr);
bad: 				 rc =  -ENODATA;
bad: 				 goto done_free_mem;
bad: 			}
bad: 		}
bad: 	}
bad: 
bad: 	/* If valid sense data, copy to user.
bad: 	 */
bad: 	if (ioc->ioctl->status & MPT_IOCTL_STATUS_SENSE_VALID) {
bad: 		sz = min(karg.maxSenseBytes, MPT_SENSE_BUFFER_SIZE);
bad: 		if (sz > 0) {
bad: 			if (copy_to_user(karg.senseDataPtr, ioc->ioctl->sense, sz)) {
bad: 				printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_do_mpt_command - "
bad: 				"Unable to write sense data to user %p\n",
bad: 				ioc->name, __FILE__, __LINE__,
bad: 				karg.senseDataPtr);
bad: 				rc =  -ENODATA;
bad: 				goto done_free_mem;
bad: 			}
bad: 		}
bad: 	}
bad: 
bad: 	/* If the overall status is _GOOD and data in, copy data
bad: 	 * to user.
bad: 	 */
bad: 	if ((ioc->ioctl->status & MPT_IOCTL_STATUS_COMMAND_GOOD) &&
bad: 				(karg.dataInSize > 0) && (bufIn.kptr)) {
bad: 
bad: 		if (copy_to_user(karg.dataInBufPtr,
bad: 				 bufIn.kptr, karg.dataInSize)) {
bad: 			printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_do_mpt_command - "
bad: 				"Unable to write data to user %p\n",
bad: 				ioc->name, __FILE__, __LINE__,
bad: 				karg.dataInBufPtr);
bad: 			rc =  -ENODATA;
bad: 		}
bad: 	}
bad: 
bad: done_free_mem:
bad: 
bad: 	ioc->ioctl->status &= ~(MPT_IOCTL_STATUS_COMMAND_GOOD |
bad: 		MPT_IOCTL_STATUS_SENSE_VALID |
bad: 		MPT_IOCTL_STATUS_RF_VALID );
bad: 
bad: 	/* Free the allocated memory.
bad: 	 */
bad: 	if (bufOut.kptr != NULL) {
bad: 		pci_free_consistent(ioc->pcidev,
bad: 			bufOut.len, (void *) bufOut.kptr, dma_addr_out);
bad: 	}
bad: 
bad: 	if (bufIn.kptr != NULL) {
bad: 		pci_free_consistent(ioc->pcidev,
bad: 			bufIn.len, (void *) bufIn.kptr, dma_addr_in);
bad: 	}
bad: 
bad: 	/* mf is null if command issued successfully
bad: 	 * otherwise, failure occured after mf acquired.
bad: 	 */
bad: 	if (mf)
bad: 		mpt_free_msg_frame(ioc, mf);
bad: 
bad: 	return rc;
bad: }
semantic error two or more data types
 =File "mptctl.c.new", line 2329, column 23,  charpos = 66372
    around = '*', whole content = 	hp_host_info_t	__user *uarg = (void __user *) arg;
ERROR-RECOV: found sync '}' at line 2550
badcount: 237
bad: }
bad: 
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
bad: /* Prototype Routine for the HOST INFO command.
bad:  *
bad:  * Outputs:	None.
bad:  * Return:	0 if successful
bad:  *		-EFAULT if data unavailable
bad:  *		-EBUSY  if previous command timout and IOC reset is not complete.
bad:  *		-ENODEV if no such device/adapter
bad:  *		-ETIME	if timer expires
bad:  *		-ENOMEM if memory allocation error
bad:  */
bad: static int
bad: mptctl_hp_hostinfo(unsigned long arg, unsigned int data_size)
bad: {
BAD:!!!!! 	hp_host_info_t	__user *uarg = (void __user *) arg;
bad: 	MPT_ADAPTER		*ioc;
bad: 	struct pci_dev		*pdev;
bad: 	char                    *pbuf=NULL;
bad: 	dma_addr_t		buf_dma;
bad: 	hp_host_info_t		karg;
bad: 	CONFIGPARMS		cfg;
bad: 	ConfigPageHeader_t	hdr;
bad: 	int			iocnum;
bad: 	int			rc, cim_rev;
bad: 	ToolboxIstwiReadWriteRequest_t	*IstwiRWRequest;
bad: 	MPT_FRAME_HDR		*mf = NULL;
bad: 	MPIHeader_t		*mpi_hdr;
bad: 
bad: 	/* Reset long to int. Should affect IA64 and SPARC only
bad: 	 */
bad: 	if (data_size == sizeof(hp_host_info_t))
bad: 		cim_rev = 1;
bad: 	else if (data_size == sizeof(hp_host_info_rev0_t))
bad: 		cim_rev = 0;	/* obsolete */
bad: 	else
bad: 		return -EFAULT;
bad: 
bad: 	if (copy_from_user(&karg, uarg, sizeof(hp_host_info_t))) {
bad: 		printk(KERN_ERR MYNAM "%s@%d::mptctl_hp_host_info - "
bad: 			"Unable to read in hp_host_info struct @ %p\n",
bad: 				__FILE__, __LINE__, uarg);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
bad: 	    (ioc == NULL)) {
bad: 		printk(KERN_DEBUG MYNAM "%s::mptctl_hp_hostinfo() @%d - ioc%d not found!\n",
bad: 				__FILE__, __LINE__, iocnum);
bad: 		return -ENODEV;
bad: 	}
bad: 	dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT ": mptctl_hp_hostinfo called.\n",
bad: 	    ioc->name));
bad: 
bad: 	/* Fill in the data and return the structure to the calling
bad: 	 * program
bad: 	 */
bad: 	pdev = (struct pci_dev *) ioc->pcidev;
bad: 
bad: 	karg.vendor = pdev->vendor;
bad: 	karg.device = pdev->device;
bad: 	karg.subsystem_id = pdev->subsystem_device;
bad: 	karg.subsystem_vendor = pdev->subsystem_vendor;
bad: 	karg.devfn = pdev->devfn;
bad: 	karg.bus = pdev->bus->number;
bad: 
bad: 	/* Save the SCSI host no. if
bad: 	 * SCSI driver loaded
bad: 	 */
bad: 	if (ioc->sh != NULL)
bad: 		karg.host_no = ioc->sh->host_no;
bad: 	else
bad: 		karg.host_no =  -1;
bad: 
bad: 	/* Reformat the fw_version into a string
bad: 	 */
bad: 	karg.fw_version[0] = ioc->facts.FWVersion.Struct.Major >= 10 ?
bad: 		((ioc->facts.FWVersion.Struct.Major / 10) + '0') : '0';
bad: 	karg.fw_version[1] = (ioc->facts.FWVersion.Struct.Major % 10 ) + '0';
bad: 	karg.fw_version[2] = '.';
bad: 	karg.fw_version[3] = ioc->facts.FWVersion.Struct.Minor >= 10 ?
bad: 		((ioc->facts.FWVersion.Struct.Minor / 10) + '0') : '0';
bad: 	karg.fw_version[4] = (ioc->facts.FWVersion.Struct.Minor % 10 ) + '0';
bad: 	karg.fw_version[5] = '.';
bad: 	karg.fw_version[6] = ioc->facts.FWVersion.Struct.Unit >= 10 ?
bad: 		((ioc->facts.FWVersion.Struct.Unit / 10) + '0') : '0';
bad: 	karg.fw_version[7] = (ioc->facts.FWVersion.Struct.Unit % 10 ) + '0';
bad: 	karg.fw_version[8] = '.';
bad: 	karg.fw_version[9] = ioc->facts.FWVersion.Struct.Dev >= 10 ?
bad: 		((ioc->facts.FWVersion.Struct.Dev / 10) + '0') : '0';
bad: 	karg.fw_version[10] = (ioc->facts.FWVersion.Struct.Dev % 10 ) + '0';
bad: 	karg.fw_version[11] = '\0';
bad: 
bad: 	/* Issue a config request to get the device serial number
bad: 	 */
bad: 	hdr.PageVersion = 0;
bad: 	hdr.PageLength = 0;
bad: 	hdr.PageNumber = 0;
bad: 	hdr.PageType = MPI_CONFIG_PAGETYPE_MANUFACTURING;
bad: 	cfg.cfghdr.hdr = &hdr;
bad: 	cfg.physAddr = -1;
bad: 	cfg.pageAddr = 0;
bad: 	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
bad: 	cfg.dir = 0;	/* read */
bad: 	cfg.timeout = 10;
bad: 
bad: 	strncpy(karg.serial_number, " ", 24);
bad: 	if (mpt_config(ioc, &cfg) == 0) {
bad: 		if (cfg.cfghdr.hdr->PageLength > 0) {
bad: 			/* Issue the second config page request */
bad: 			cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
bad: 
bad: 			pbuf = pci_alloc_consistent(ioc->pcidev, hdr.PageLength * 4, &buf_dma);
bad: 			if (pbuf) {
bad: 				cfg.physAddr = buf_dma;
bad: 				if (mpt_config(ioc, &cfg) == 0) {
bad: 					ManufacturingPage0_t *pdata = (ManufacturingPage0_t *) pbuf;
bad: 					if (strlen(pdata->BoardTracerNumber) > 1) {
bad: 						strncpy(karg.serial_number, 									    pdata->BoardTracerNumber, 24);
bad: 						karg.serial_number[24-1]='\0';
bad: 					}
bad: 				}
bad: 				pci_free_consistent(ioc->pcidev, hdr.PageLength * 4, pbuf, buf_dma);
bad: 				pbuf = NULL;
bad: 			}
bad: 		}
bad: 	}
bad: 	rc = mpt_GetIocState(ioc, 1);
bad: 	switch (rc) {
bad: 	case MPI_IOC_STATE_OPERATIONAL:
bad: 		karg.ioc_status =  HP_STATUS_OK;
bad: 		break;
bad: 
bad: 	case MPI_IOC_STATE_FAULT:
bad: 		karg.ioc_status =  HP_STATUS_FAILED;
bad: 		break;
bad: 
bad: 	case MPI_IOC_STATE_RESET:
bad: 	case MPI_IOC_STATE_READY:
bad: 	default:
bad: 		karg.ioc_status =  HP_STATUS_OTHER;
bad: 		break;
bad: 	}
bad: 
bad: 	karg.base_io_addr = pci_resource_start(pdev, 0);
bad: 
bad: 	if ((ioc->bus_type == SAS) || (ioc->bus_type == FC))
bad: 		karg.bus_phys_width = HP_BUS_WIDTH_UNK;
bad: 	else
bad: 		karg.bus_phys_width = HP_BUS_WIDTH_16;
bad: 
bad: 	karg.hard_resets = 0;
bad: 	karg.soft_resets = 0;
bad: 	karg.timeouts = 0;
bad: 	if (ioc->sh != NULL) {
bad: 		MPT_SCSI_HOST *hd =  shost_priv(ioc->sh);
bad: 
bad: 		if (hd && (cim_rev == 1)) {
bad: 			karg.hard_resets = hd->hard_resets;
bad: 			karg.soft_resets = hd->soft_resets;
bad: 			karg.timeouts = hd->timeouts;
bad: 		}
bad: 	}
bad: 
bad: 	/* 
bad: 	 * Gather ISTWI(Industry Standard Two Wire Interface) Data
bad: 	 */
bad: 	if ((mf = mpt_get_msg_frame(mptctl_id, ioc)) == NULL) {
bad: 		dfailprintk(ioc, printk(MYIOC_s_WARN_FMT "%s, no msg frames!!\n",
bad: 		    ioc->name,__FUNCTION__));
bad: 		goto out;
bad: 	}
bad: 
bad: 	IstwiRWRequest = (ToolboxIstwiReadWriteRequest_t *)mf;
bad: 	mpi_hdr = (MPIHeader_t *) mf;
bad: 	memset(IstwiRWRequest,0,sizeof(ToolboxIstwiReadWriteRequest_t));
bad: 	IstwiRWRequest->Function = MPI_FUNCTION_TOOLBOX;
bad: 	IstwiRWRequest->Tool = MPI_TOOLBOX_ISTWI_READ_WRITE_TOOL;
bad: 	IstwiRWRequest->MsgContext = mpi_hdr->MsgContext;
bad: 	IstwiRWRequest->Flags = MPI_TB_ISTWI_FLAGS_READ;
bad: 	IstwiRWRequest->NumAddressBytes = 0x01;
bad: 	IstwiRWRequest->DataLength = cpu_to_le16(0x04);
bad: 	if (pdev->devfn & 1)
bad: 		IstwiRWRequest->DeviceAddr = 0xB2;
bad: 	else
bad: 		IstwiRWRequest->DeviceAddr = 0xB0;
bad: 
bad: 	pbuf = pci_alloc_consistent(ioc->pcidev, 4, &buf_dma);
bad: 	if (!pbuf)
bad: 		goto out;
bad: 	mpt_add_sge((char *)&IstwiRWRequest->SGL,
bad: 	    (MPT_SGE_FLAGS_SSIMPLE_READ|4), buf_dma);
bad: 
bad: 	ioc->ioctl->wait_done = 0;
bad: 	mpt_put_msg_frame(mptctl_id, ioc, mf);
bad: 
bad: 	rc = wait_event_timeout(mptctl_wait,
bad: 	     ioc->ioctl->wait_done == 1,
bad: 	     HZ*MPT_IOCTL_DEFAULT_TIMEOUT /* 10 sec */);
bad: 
bad: 	if(rc <=0 && (ioc->ioctl->wait_done != 1 )) {
bad: 		/*
bad: 		 * Now we need to reset the board
bad: 		 */
bad: 		mpt_free_msg_frame(ioc, mf);
bad: 		mptctl_timeout_expired(ioc->ioctl);
bad: 		goto out;
bad: 	}
bad: 
bad: 	/*
bad: 	 *ISTWI Data Definition
bad: 	 * pbuf[0] = FW_VERSION = 0x4
bad: 	 * pbuf[1] = Bay Count = 6 or 4 or 2, depending on
bad: 	 *  the config, you should be seeing one out of these three values
bad: 	 * pbuf[2] = Drive Installed Map = bit pattern depend on which
bad: 	 *   bays have drives in them
bad: 	 * pbuf[3] = Checksum (0x100 = (byte0 + byte2 + byte3)
bad: 	 */
bad: 	if (ioc->ioctl->status & MPT_IOCTL_STATUS_RF_VALID)
bad: 		karg.rsvd = *(u32 *)pbuf;
bad: 
bad:  out:
bad: 	if (pbuf)
bad: 		pci_free_consistent(ioc->pcidev, 4, pbuf, buf_dma);
bad: 
bad: 	/* Copy the data from kernel memory to user memory
bad: 	 */
bad: 	if (copy_to_user((char __user *)arg, &karg, sizeof(hp_host_info_t))) {
bad: 		printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_hpgethostinfo - "
bad: 			"Unable to write out hp_host_info @ %p\n",
bad: 			ioc->name, __FILE__, __LINE__, uarg);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	return 0;
bad: 
bad: }
semantic error two or more data types
 =File "mptctl.c.new", line 2566, column 25,  charpos = 73317
    around = '*', whole content = 	hp_target_info_t __user *uarg = (void __user *) arg;
ERROR-RECOV: found sync '}' at line 2700
badcount: 150
bad: }
bad: 
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
bad: /* Prototype Routine for the TARGET INFO command.
bad:  *
bad:  * Outputs:	None.
bad:  * Return:	0 if successful
bad:  *		-EFAULT if data unavailable
bad:  *		-EBUSY  if previous command timout and IOC reset is not complete.
bad:  *		-ENODEV if no such device/adapter
bad:  *		-ETIME	if timer expires
bad:  *		-ENOMEM if memory allocation error
bad:  */
bad: static int
bad: mptctl_hp_targetinfo(unsigned long arg)
bad: {
BAD:!!!!! 	hp_target_info_t __user *uarg = (void __user *) arg;
bad: 	SCSIDevicePage0_t	*pg0_alloc;
bad: 	SCSIDevicePage3_t	*pg3_alloc;
bad: 	MPT_ADAPTER		*ioc;
bad: 	MPT_SCSI_HOST 		*hd = NULL;
bad: 	hp_target_info_t	karg;
bad: 	int			iocnum;
bad: 	int			data_sz;
bad: 	dma_addr_t		page_dma;
bad: 	CONFIGPARMS	 	cfg;
bad: 	ConfigPageHeader_t	hdr;
bad: 	int			tmp, np, rc = 0;
bad: 
bad: 	if (copy_from_user(&karg, uarg, sizeof(hp_target_info_t))) {
bad: 		printk(KERN_ERR MYNAM "%s@%d::mptctl_hp_targetinfo - "
bad: 			"Unable to read in hp_host_targetinfo struct @ %p\n",
bad: 				__FILE__, __LINE__, uarg);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
bad: 		(ioc == NULL)) {
bad: 		printk(KERN_DEBUG MYNAM "%s::mptctl_hp_targetinfo() @%d - ioc%d not found!\n",
bad: 				__FILE__, __LINE__, iocnum);
bad: 		return -ENODEV;
bad: 	}
bad: 	dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT "mptctl_hp_targetinfo called.\n",
bad: 	    ioc->name));
bad: 
bad: 	/*  There is nothing to do for FCP parts.
bad: 	 */
bad: 	if ((ioc->bus_type == SAS) || (ioc->bus_type == FC))
bad: 		return 0;
bad: 
bad: 	if ((ioc->spi_data.sdp0length == 0) || (ioc->sh == NULL))
bad: 		return 0;
bad: 
bad: 	if (ioc->sh->host_no != karg.hdr.host)
bad: 		return -ENODEV;
bad: 
bad:        /* Get the data transfer speeds
bad:         */
bad: 	data_sz = ioc->spi_data.sdp0length * 4;
bad: 	pg0_alloc = (SCSIDevicePage0_t *) pci_alloc_consistent(ioc->pcidev, data_sz, &page_dma);
bad: 	if (pg0_alloc) {
bad: 		hdr.PageVersion = ioc->spi_data.sdp0version;
bad: 		hdr.PageLength = data_sz;
bad: 		hdr.PageNumber = 0;
bad: 		hdr.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;
bad: 
bad: 		cfg.cfghdr.hdr = &hdr;
bad: 		cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
bad: 		cfg.dir = 0;
bad: 		cfg.timeout = 0;
bad: 		cfg.physAddr = page_dma;
bad: 
bad: 		cfg.pageAddr = (karg.hdr.channel << 8) | karg.hdr.id;
bad: 
bad: 		if ((rc = mpt_config(ioc, &cfg)) == 0) {
bad: 			np = le32_to_cpu(pg0_alloc->NegotiatedParameters);
bad: 			karg.negotiated_width = np & MPI_SCSIDEVPAGE0_NP_WIDE ?
bad: 					HP_BUS_WIDTH_16 : HP_BUS_WIDTH_8;
bad: 
bad: 			if (np & MPI_SCSIDEVPAGE0_NP_NEG_SYNC_OFFSET_MASK) {
bad: 				tmp = (np & MPI_SCSIDEVPAGE0_NP_NEG_SYNC_PERIOD_MASK) >> 8;
bad: 				if (tmp < 0x09)
bad: 					karg.negotiated_speed = HP_DEV_SPEED_ULTRA320;
bad: 				else if (tmp <= 0x09)
bad: 					karg.negotiated_speed = HP_DEV_SPEED_ULTRA160;
bad: 				else if (tmp <= 0x0A)
bad: 					karg.negotiated_speed = HP_DEV_SPEED_ULTRA2;
bad: 				else if (tmp <= 0x0C)
bad: 					karg.negotiated_speed = HP_DEV_SPEED_ULTRA;
bad: 				else if (tmp <= 0x25)
bad: 					karg.negotiated_speed = HP_DEV_SPEED_FAST;
bad: 				else
bad: 					karg.negotiated_speed = HP_DEV_SPEED_ASYNC;
bad: 			} else
bad: 				karg.negotiated_speed = HP_DEV_SPEED_ASYNC;
bad: 		}
bad: 
bad: 		pci_free_consistent(ioc->pcidev, data_sz, (u8 *) pg0_alloc, page_dma);
bad: 	}
bad: 
bad: 	/* Set defaults
bad: 	 */
bad: 	karg.message_rejects = -1;
bad: 	karg.phase_errors = -1;
bad: 	karg.parity_errors = -1;
bad: 	karg.select_timeouts = -1;
bad: 
bad: 	/* Get the target error parameters
bad: 	 */
bad: 	hdr.PageVersion = 0;
bad: 	hdr.PageLength = 0;
bad: 	hdr.PageNumber = 3;
bad: 	hdr.PageType = MPI_CONFIG_PAGETYPE_SCSI_DEVICE;
bad: 
bad: 	cfg.cfghdr.hdr = &hdr;
bad: 	cfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;
bad: 	cfg.dir = 0;
bad: 	cfg.timeout = 0;
bad: 	cfg.physAddr = -1;
bad: 	if ((mpt_config(ioc, &cfg) == 0) && (cfg.cfghdr.hdr->PageLength > 0)) {
bad: 		/* Issue the second config page request */
bad: 		cfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;
bad: 		data_sz = (int) cfg.cfghdr.hdr->PageLength * 4;
bad: 		pg3_alloc = (SCSIDevicePage3_t *) pci_alloc_consistent(
bad: 							ioc->pcidev, data_sz, &page_dma);
bad: 		if (pg3_alloc) {
bad: 			cfg.physAddr = page_dma;
bad: 			cfg.pageAddr = (karg.hdr.channel << 8) | karg.hdr.id;
bad: 			if ((rc = mpt_config(ioc, &cfg)) == 0) {
bad: 				karg.message_rejects = (u32) le16_to_cpu(pg3_alloc->MsgRejectCount);
bad: 				karg.phase_errors = (u32) le16_to_cpu(pg3_alloc->PhaseErrorCount);
bad: 				karg.parity_errors = (u32) le16_to_cpu(pg3_alloc->ParityErrorCount);
bad: 			}
bad: 			pci_free_consistent(ioc->pcidev, data_sz, (u8 *) pg3_alloc, page_dma);
bad: 		}
bad: 	}
bad: 	hd = shost_priv(ioc->sh);
bad: 	if (hd != NULL)
bad: 		karg.select_timeouts = hd->sel_timeout[karg.hdr.id];
bad: 
bad: 	/* Copy the data from kernel memory to user memory
bad: 	 */
bad: 	if (copy_to_user((char __user *)arg, &karg, sizeof(hp_target_info_t))) {
bad: 		printk(MYIOC_s_ERR_FMT "%s@%d::mptctl_hp_target_info - "
bad: 			"Unable to write out mpt_ioctl_targetinfo struct @ %p\n",
bad: 			ioc->name, __FILE__, __LINE__, uarg);
bad: 		return -EFAULT;
bad: 	}
bad: 
bad: 	return 0;
bad: }
semantic error two or more data types
 =File "mptctl.c.new", line 2737, column 41,  charpos = 78249
    around = '*', whole content = 	if (copy_from_user(&kfw32, (char __user *)arg, sizeof(kfw32)))
ERROR-RECOV: found sync '}' at line 2763
badcount: 44
bad: };
bad: 
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
bad: 
bad: #ifdef CONFIG_COMPAT
bad: 
bad: static int
bad: compat_mptfwxfer_ioctl(struct file *filp, unsigned int cmd,
bad: 			unsigned long arg)
bad: {
bad: 	struct mpt_fw_xfer32 kfw32;
bad: 	struct mpt_fw_xfer kfw;
bad: 	MPT_ADAPTER *iocp = NULL;
bad: 	int iocnum, iocnumX;
bad: 	int nonblock = (filp->f_flags & O_NONBLOCK);
bad: 	int ret;
bad: 
bad: 
BAD:!!!!! 	if (copy_from_user(&kfw32, (char __user *)arg, sizeof(kfw32)))
bad: 		return -EFAULT;
bad: 
bad: 	/* Verify intended MPT adapter */
bad: 	iocnumX = kfw32.iocnum & 0xFF;
bad: 	if (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||
bad: 	    (iocp == NULL)) {
bad: 		printk(KERN_DEBUG MYNAM "::compat_mptfwxfer_ioctl @%d - ioc%d not found!\n",
bad: 			__LINE__, iocnumX);
bad: 		return -ENODEV;
bad: 	}
bad: 
bad: 	if ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)
bad: 		return ret;
bad: 
bad: 	dctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT "compat_mptfwxfer_ioctl() called\n",
bad: 	    iocp->name));
bad: 	kfw.iocnum = iocnum;
bad: 	kfw.fwlen = kfw32.fwlen;
bad: 	kfw.bufp = compat_ptr(kfw32.bufp);
bad: 
bad: 	ret = mptctl_do_fw_download(kfw.iocnum, kfw.bufp, kfw.fwlen);
bad: 
bad: 	mutex_unlock(&iocp->ioctl->ioctl_mutex);
bad: 
bad: 	return ret;
bad: }
semantic error two or more data types
 =File "mptctl.c.new", line 2770, column 35,  charpos = 79104
    around = '*', whole content = 	struct mpt_ioctl_command32 __user *uarg = (struct mpt_ioctl_command32 __user *) arg;
ERROR-RECOV: found sync '}' at line 2817
badcount: 54
bad: }
bad: 
bad: static int
bad: compat_mpt_command(struct file *filp, unsigned int cmd,
bad: 			unsigned long arg)
bad: {
bad: 	struct mpt_ioctl_command32 karg32;
BAD:!!!!! 	struct mpt_ioctl_command32 __user *uarg = (struct mpt_ioctl_command32 __user *) arg;
bad: 	struct mpt_ioctl_command karg;
bad: 	MPT_ADAPTER *iocp = NULL;
bad: 	int iocnum, iocnumX;
bad: 	int nonblock = (filp->f_flags & O_NONBLOCK);
bad: 	int ret;
bad: 
bad: 	if (copy_from_user(&karg32, (char __user *)arg, sizeof(karg32)))
bad: 		return -EFAULT;
bad: 
bad: 	/* Verify intended MPT adapter */
bad: 	iocnumX = karg32.hdr.iocnum & 0xFF;
bad: 	if (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||
bad: 	    (iocp == NULL)) {
bad: 		printk(KERN_DEBUG MYNAM "::compat_mpt_command @%d - ioc%d not found!\n",
bad: 			__LINE__, iocnumX);
bad: 		return -ENODEV;
bad: 	}
bad: 
bad: 	if ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)
bad: 		return ret;
bad: 
bad: 	dctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT "compat_mpt_command() called\n",
bad: 	    iocp->name));
bad: 	/* Copy data to karg */
bad: 	karg.hdr.iocnum = karg32.hdr.iocnum;
bad: 	karg.hdr.port = karg32.hdr.port;
bad: 	karg.timeout = karg32.timeout;
bad: 	karg.maxReplyBytes = karg32.maxReplyBytes;
bad: 
bad: 	karg.dataInSize = karg32.dataInSize;
bad: 	karg.dataOutSize = karg32.dataOutSize;
bad: 	karg.maxSenseBytes = karg32.maxSenseBytes;
bad: 	karg.dataSgeOffset = karg32.dataSgeOffset;
bad: 
bad: 	karg.replyFrameBufPtr = (char __user *)(unsigned long)karg32.replyFrameBufPtr;
bad: 	karg.dataInBufPtr = (char __user *)(unsigned long)karg32.dataInBufPtr;
bad: 	karg.dataOutBufPtr = (char __user *)(unsigned long)karg32.dataOutBufPtr;
bad: 	karg.senseDataPtr = (char __user *)(unsigned long)karg32.senseDataPtr;
bad: 
bad: 	/* Pass new structure to do_mpt_command
bad: 	 */
bad: 	ret = mptctl_do_mpt_command (karg, &uarg->MF);
bad: 
bad: 	mutex_unlock(&iocp->ioctl->ioctl_mutex);
bad: 
bad: 	return ret;
bad: }
semantic error two or more data types
 =File "mptctl.c.new", line 2905, column 18,  charpos = 82366
    around = 'mptctl_init', whole content = static int __init mptctl_init(void)
ERROR-RECOV: found sync '}' at line 2946
badcount: 44
bad: };
bad: 
bad: /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
BAD:!!!!! static int __init mptctl_init(void)
bad: {
bad: 	int err;
bad: 	int where = 1;
bad: 
bad: 	show_mptmod_ver(my_NAME, my_VERSION);
bad: 
bad: 	mpt_device_driver_register(&mptctl_driver, MPTCTL_DRIVER);
bad: 
bad: 	/* Register this device */
bad: 	err = misc_register(&mptctl_miscdev);
bad: 	if (err < 0) {
bad: 		printk(KERN_ERR MYNAM ": Can't register misc device [minor=%d].\n", MPT_MINOR);
bad: 		goto out_fail;
bad: 	}
bad: 	printk(KERN_INFO MYNAM ": Registered with Fusion MPT base driver\n");
bad: 	printk(KERN_INFO MYNAM ": /dev/%s @ (major,minor=%d,%d)\n",
bad: 			 mptctl_miscdev.name, MISC_MAJOR, mptctl_miscdev.minor);
bad: 
bad: 	/*
bad: 	 *  Install our handler
bad: 	 */
bad: 	++where;
bad: 	mptctl_id = mpt_register(mptctl_reply, MPTCTL_DRIVER);
bad: 	if (!mptctl_id || mptctl_id >= MPT_MAX_PROTOCOL_DRIVERS) {
bad: 		printk(KERN_ERR MYNAM ": ERROR: Failed to register with Fusion MPT base driver\n");
bad: 		misc_deregister(&mptctl_miscdev);
bad: 		err = -EBUSY;
bad: 		goto out_fail;
bad: 	}
bad: 
bad: 	mpt_reset_register(mptctl_id, mptctl_ioc_reset);
bad: 	mpt_event_register(mptctl_id, mptctl_event_process);
bad: 
bad: 	return 0;
bad: 
bad: out_fail:
bad: 
bad: 	mpt_device_driver_deregister(MPTCTL_DRIVER);
bad: 
bad: 	return err;
bad: }
Type_annoter: not finding type for my_NAME
Type_annoter: not finding type for my_VERSION
Type_annoter: not finding type for mptctl_wait
Type_annoter: not finding type for mutex_trylock
Type_annoter: not finding type for mutex_lock_interruptible
Type_annoter: not finding type for dctlprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for wake_up
Type_annoter: not finding type for mptctl_wait
Type_annoter: not finding type for memcpy
Type_annoter: not finding type for min
Type_annoter: not finding type for le16_to_cpu
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for dctlprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for mpt_HardResetHandler
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for mpt_get_msg_frame
Type_annoter: not finding type for dtmprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for mpt_put_msg_frame_hi_pri
Type_annoter: not finding type for mpt_send_handshake_request
Type_annoter: not finding type for dfailprintk
Type_annoter: not finding type for wait_event_timeout
Type_annoter: not finding type for mptctl_wait
Type_annoter: not finding type for mpt_free_msg_frame
Type_annoter: not finding type for spin_lock_irqsave
Type_annoter: not finding type for spin_unlock_irqrestore
Type_annoter: not finding type for shost_priv
Type_annoter: not finding type for spin_lock_irqsave
Type_annoter: not finding type for spin_unlock_irqrestore
Type_annoter: not finding type for dctlprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for dctlprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for devtverboseprintk
Type_annoter: not finding type for kill_fasync
Type_annoter: not finding type for ioc_list
Type_annoter: not finding type for list
Type_annoter: not finding type for fasync_helper
Type_annoter: not finding type for fasync_helper
Type_annoter: not finding type for lock_kernel
Type_annoter: not finding type for unlock_kernel
Type_annoter: not finding type for min
Type_annoter: not finding type for kzalloc
Type_annoter: not finding type for pci_alloc_consistent
Type_annoter: not finding type for printk
Type_annoter: not finding type for pci_map_single
Type_annoter: not finding type for dctlprintk
Type_annoter: not finding type for pci_free_consistent
Type_annoter: not finding type for kfree
Type_annoter: not finding type for pci_unmap_single
Type_annoter: not finding type for pci_free_consistent
Type_annoter: not finding type for le32_to_cpu
Type_annoter: not finding type for kfree
Type_annoter: not finding type for dctlprintk
Type_annoter: not finding type for printk
Type_annoter: not finding type for no_llseek
Type_annoter: not finding type for lock_kernel
Type_annoter: not finding type for compat_mpt_command
Type_annoter: not finding type for compat_mptfwxfer_ioctl
Type_annoter: not finding type for unlock_kernel
Type_annoter: not finding type for pci_get_drvdata
Type_annoter: not finding type for kzalloc
Type_annoter: not finding type for mutex_init
Type_annoter: not finding type for pci_get_drvdata
Type_annoter: not finding type for kfree
no type, certainly because Void type ?
Type_annoter: not finding type for misc_deregister
Type_annoter: not finding type for printk
Type_annoter: not finding type for mpt_reset_deregister
Type_annoter: not finding type for mpt_deregister
Type_annoter: not finding type for mpt_device_driver_deregister
Type_annoter: not finding type for mptctl_init
Fatal error: exception Diff.Fail("whhaaattt")
